// Code generated by Fern. DO NOT EDIT.

package link

import (
	context "context"
	vital "github.com/tryVital/vital-go"
	core "github.com/tryVital/vital-go/core"
	internal "github.com/tryVital/vital-go/internal"
	option "github.com/tryVital/vital-go/option"
	http "net/http"
)

type Client struct {
	WithRawResponse *RawClient

	baseURL string
	caller  *internal.Caller
	header  http.Header
}

func NewClient(opts ...option.RequestOption) *Client {
	options := core.NewRequestOptions(opts...)
	return &Client{
		WithRawResponse: NewRawClient(options),
		baseURL:         options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
		header: options.ToHeader(),
	}
}

func (c *Client) ListBulkOps(
	ctx context.Context,
	request *vital.LinkListBulkOpsRequest,
	opts ...option.RequestOption,
) (*vital.BulkOpsResponse, error) {
	response, err := c.WithRawResponse.ListBulkOps(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) BulkImport(
	ctx context.Context,
	request *vital.BulkImportConnectionsBody,
	opts ...option.RequestOption,
) (*vital.BulkImportConnectionsResponse, error) {
	response, err := c.WithRawResponse.BulkImport(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) BulkTriggerHistoricalPull(
	ctx context.Context,
	request *vital.BulkTriggerHistoricalPullBody,
	opts ...option.RequestOption,
) (any, error) {
	response, err := c.WithRawResponse.BulkTriggerHistoricalPull(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) BulkExport(
	ctx context.Context,
	request *vital.BulkExportConnectionsBody,
	opts ...option.RequestOption,
) (*vital.BulkExportConnectionsResponse, error) {
	response, err := c.WithRawResponse.BulkExport(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) BulkPause(
	ctx context.Context,
	request *vital.BulkPauseConnectionsBody,
	opts ...option.RequestOption,
) (any, error) {
	response, err := c.WithRawResponse.BulkPause(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Endpoint to generate a user link token, to be used throughout the vital
// link process. The vital link token is a one time use token, that
// expires after 10 minutes. If you would like vital-link widget to launch
// with a specific provider, pass in a provider in the body. If you would
// like to redirect to a custom url after successful or error connection,
// pass in your own custom redirect_url parameter.
func (c *Client) Token(
	ctx context.Context,
	request *vital.LinkTokenExchange,
	opts ...option.RequestOption,
) (*vital.LinkTokenExchangeResponse, error) {
	response, err := c.WithRawResponse.Token(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) IsTokenValid(
	ctx context.Context,
	request *vital.LinkTokenValidationRequest,
	opts ...option.RequestOption,
) (map[string]any, error) {
	response, err := c.WithRawResponse.IsTokenValid(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Generate a token to invite a user of Vital mobile app to your team
func (c *Client) CodeCreate(
	ctx context.Context,
	request *vital.LinkCodeCreateRequest,
	opts ...option.RequestOption,
) (*vital.VitalTokenCreatedResponse, error) {
	response, err := c.WithRawResponse.CodeCreate(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// REQUEST_SOURCE: VITAL-LINK
// Start link token process
func (c *Client) StartConnect(
	ctx context.Context,
	request *vital.BeginLinkTokenRequest,
	opts ...option.RequestOption,
) (map[string]any, error) {
	response, err := c.WithRawResponse.StartConnect(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// REQUEST_SOURCE: VITAL-LINK
// Check link token state - can be hit continuously used as heartbeat
func (c *Client) TokenState(
	ctx context.Context,
	request *vital.LinkTokenStateRequest,
	opts ...option.RequestOption,
) (map[string]any, error) {
	response, err := c.WithRawResponse.TokenState(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Deprecated. Use `POST /v2/link/provider/email/{provider}` instead.
func (c *Client) EmailAuth(
	ctx context.Context,
	request *vital.EmailAuthLink,
	opts ...option.RequestOption,
) (any, error) {
	response, err := c.WithRawResponse.EmailAuth(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Deprecated. Use `POST /v2/link/provider/password/{provider}` instead.
func (c *Client) PasswordAuth(
	ctx context.Context,
	request *vital.PasswordAuthLink,
	opts ...option.RequestOption,
) (any, error) {
	response, err := c.WithRawResponse.PasswordAuth(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// This endpoint generates an OAuth link for oauth provider
func (c *Client) GenerateOauthLink(
	ctx context.Context,
	oauthProvider *vital.OAuthProviders,
	request *vital.LinkGenerateOauthLinkRequest,
	opts ...option.RequestOption,
) (*vital.Source, error) {
	response, err := c.WithRawResponse.GenerateOauthLink(
		ctx,
		oauthProvider,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// This connects auth providers that are password based.
func (c *Client) ConnectPasswordProvider(
	ctx context.Context,
	provider *vital.PasswordProviders,
	request *vital.IndividualProviderData,
	opts ...option.RequestOption,
) (*vital.ProviderLinkResponse, error) {
	response, err := c.WithRawResponse.ConnectPasswordProvider(
		ctx,
		provider,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// This connects auth providers that are password based.
func (c *Client) CompletePasswordProviderMfa(
	ctx context.Context,
	provider *vital.PasswordProviders,
	request *vital.CompletePasswordProviderMfaBody,
	opts ...option.RequestOption,
) (*vital.ProviderLinkResponse, error) {
	response, err := c.WithRawResponse.CompletePasswordProviderMfa(
		ctx,
		provider,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// This connects auth providers that are email based.
func (c *Client) ConnectEmailAuthProvider(
	ctx context.Context,
	provider vital.EmailProviders,
	request *vital.EmailProviderAuthLink,
	opts ...option.RequestOption,
) (any, error) {
	response, err := c.WithRawResponse.ConnectEmailAuthProvider(
		ctx,
		provider,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// GET List of all available providers given the generated link token.
func (c *Client) GetAllProviders(
	ctx context.Context,
	request *vital.LinkGetAllProvidersRequest,
	opts ...option.RequestOption,
) ([]*vital.SourceLink, error) {
	response, err := c.WithRawResponse.GetAllProviders(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) ConnectManualProvider(
	ctx context.Context,
	provider *vital.ManualProviders,
	request *vital.ManualConnectionData,
	opts ...option.RequestOption,
) (map[string]bool, error) {
	response, err := c.WithRawResponse.ConnectManualProvider(
		ctx,
		provider,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// POST Connect the given Vital user to a demo provider.
func (c *Client) ConnectDemoProvider(
	ctx context.Context,
	request *vital.DemoConnectionCreationPayload,
	opts ...option.RequestOption,
) (*vital.DemoConnectionStatus, error) {
	response, err := c.WithRawResponse.ConnectDemoProvider(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}
