// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/tryVital/vital-go/core"
	time "time"
)

type ActivityV2InDb struct {
	Timestamp  time.Time             `json:"timestamp"`
	Data       *string               `json:"data,omitempty"`
	ProviderId string                `json:"provider_id"`
	UserId     string                `json:"user_id"`
	SourceId   int                   `json:"source_id"`
	PriorityId int                   `json:"priority_id"`
	Id         string                `json:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActivityV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivityV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivityV2InDb(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityV2InDb) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Address struct {
	FirstLine  string  `json:"first_line"`
	SecondLine *string `json:"second_line,omitempty"`
	Country    string  `json:"country"`
	Zip        string  `json:"zip"`
	City       string  `json:"city"`
	State      string  `json:"state"`

	_rawJSON json.RawMessage
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentAvailabilitySlots struct {
	Slots    []*DaySlots `json:"slots,omitempty"`
	Timezone *string     `json:"timezone,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AppointmentAvailabilitySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentAvailabilitySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentAvailabilitySlots(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentAvailabilitySlots) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// An enumeration.
type AppointmentEventStatus string

const (
	AppointmentEventStatusScheduled  AppointmentEventStatus = "scheduled"
	AppointmentEventStatusCompleted  AppointmentEventStatus = "completed"
	AppointmentEventStatusCancelled  AppointmentEventStatus = "cancelled"
	AppointmentEventStatusInProgress AppointmentEventStatus = "in_progress"
)

func NewAppointmentEventStatusFromString(s string) (AppointmentEventStatus, error) {
	switch s {
	case "scheduled":
		return AppointmentEventStatusScheduled, nil
	case "completed":
		return AppointmentEventStatusCompleted, nil
	case "cancelled":
		return AppointmentEventStatusCancelled, nil
	case "in_progress":
		return AppointmentEventStatusInProgress, nil
	}
	var t AppointmentEventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentEventStatus) Ptr() *AppointmentEventStatus {
	return &a
}

// An enumeration.
type AppointmentProvider string

const (
	AppointmentProviderGetlabs    AppointmentProvider = "getlabs"
	AppointmentProviderAxlehealth AppointmentProvider = "axlehealth"
)

func NewAppointmentProviderFromString(s string) (AppointmentProvider, error) {
	switch s {
	case "getlabs":
		return AppointmentProviderGetlabs, nil
	case "axlehealth":
		return AppointmentProviderAxlehealth, nil
	}
	var t AppointmentProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentProvider) Ptr() *AppointmentProvider {
	return &a
}

// An enumeration.
type AppointmentStatus string

const (
	AppointmentStatusConfirmed  AppointmentStatus = "confirmed"
	AppointmentStatusPending    AppointmentStatus = "pending"
	AppointmentStatusInProgress AppointmentStatus = "in_progress"
	AppointmentStatusCompleted  AppointmentStatus = "completed"
	AppointmentStatusCancelled  AppointmentStatus = "cancelled"
)

func NewAppointmentStatusFromString(s string) (AppointmentStatus, error) {
	switch s {
	case "confirmed":
		return AppointmentStatusConfirmed, nil
	case "pending":
		return AppointmentStatusPending, nil
	case "in_progress":
		return AppointmentStatusInProgress, nil
	case "completed":
		return AppointmentStatusCompleted, nil
	case "cancelled":
		return AppointmentStatusCancelled, nil
	}
	var t AppointmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentStatus) Ptr() *AppointmentStatus {
	return &a
}

type AppointmentType = string

type AreaInfo struct {
	ZipCode    string              `json:"zip_code"`
	Phlebotomy *PhlebotomyAreaInfo `json:"phlebotomy,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler AreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AreaInfo(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AreaInfo) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// An enumeration.
type AuthType string

const (
	AuthTypePassword AuthType = "password"
	AuthTypeOauth    AuthType = "oauth"
	AuthTypeEmail    AuthType = "email"
)

func NewAuthTypeFromString(s string) (AuthType, error) {
	switch s {
	case "password":
		return AuthTypePassword, nil
	case "oauth":
		return AuthTypeOauth, nil
	case "email":
		return AuthTypeEmail, nil
	}
	var t AuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthType) Ptr() *AuthType {
	return &a
}

// Represent the schema for an individual biomarker result.
type BiomarkerResult struct {
	Name            string     `json:"name"`
	Slug            *string    `json:"slug,omitempty"`
	Value           float64    `json:"value"`
	Result          string     `json:"result"`
	Type            ResultType `json:"type,omitempty"`
	Unit            *string    `json:"unit,omitempty"`
	Timestamp       *time.Time `json:"timestamp,omitempty"`
	Notes           *string    `json:"notes,omitempty"`
	MinRangeValue   *float64   `json:"min_range_value,omitempty"`
	MaxRangeValue   *float64   `json:"max_range_value,omitempty"`
	IsAboveMaxRange *bool      `json:"is_above_max_range,omitempty"`
	IsBelowMinRange *bool      `json:"is_below_min_range,omitempty"`
	Interpretation  *string    `json:"interpretation,omitempty"`
	Loinc           *string    `json:"loinc,omitempty"`
	LoincSlug       *string    `json:"loinc_slug,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BiomarkerResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BiomarkerResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BiomarkerResult(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BiomarkerResult) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BodyV2InDb struct {
	Timestamp  time.Time             `json:"timestamp"`
	Data       *string               `json:"data,omitempty"`
	ProviderId string                `json:"provider_id"`
	UserId     string                `json:"user_id"`
	SourceId   int                   `json:"source_id"`
	PriorityId *int                  `json:"priority_id,omitempty"`
	Id         string                `json:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty"`
	Priority   *int                  `json:"priority,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BodyV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyV2InDb(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyV2InDb) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ClientActivityResponse struct {
	Activity []*ClientFacingActivity `json:"activity,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientActivityResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientActivityResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientBodyResponse struct {
	Body []*ClientFacingBody `json:"body,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientBodyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientBodyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientBodyResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientBodyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingActivity struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date"`
	// Total energy consumption during the day including Basal Metabolic Rate in kilocalories::kilocalories
	CaloriesTotal *float64 `json:"calories_total,omitempty"`
	// Energy consumption caused by the physical activity of the day in kilocalories::kilocalories
	CaloriesActive *float64 `json:"calories_active,omitempty"`
	// Total number of steps registered during the day::steps
	Steps *int `json:"steps,omitempty"`
	// Deprecated. Daily physical activity as equal meters i.e. amount of walking needed to get the same amount of activity::meters
	DailyMovement *float64 `json:"daily_movement,omitempty"`
	// Distance traveled during activities throughout the day::meters
	Distance *float64 `json:"distance,omitempty"`
	// Number of minutes during the day with low intensity activity (e.g. household work)::minutes
	Low *float64 `json:"low,omitempty"`
	// Number of minutes during the day with medium intensity activity (e.g. walking)::minutes
	Medium *float64 `json:"medium,omitempty"`
	// Number of minutes during the day with high intensity activity (e.g. running)::minutes
	High *float64 `json:"high,omitempty"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty"`
	// Number of floors climbed by the user::count
	FloorsClimbed *int `json:"floors_climbed,omitempty"`
	// [DEPRECATED] The time zone full identifier for the data. Example: 'Europe/London'.
	TimeZone *string `json:"time_zone,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Heart rate daily summary.
	HeartRate *ClientFacingHeartRate `json:"heart_rate,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingActivity(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingActivity) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingApiKey struct {
	Label     string     `json:"label"`
	Value     string     `json:"value"`
	TeamId    *string    `json:"team_id,omitempty"`
	Id        string     `json:"id"`
	CreatedAt time.Time  `json:"created_at"`
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingApiKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingApiKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingApiKey(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingApiKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointment struct {
	Id       string     `json:"id"`
	UserId   string     `json:"user_id"`
	OrderId  string     `json:"order_id"`
	Address  *UsAddress `json:"address,omitempty"`
	Location *LngLat    `json:"location,omitempty"`
	// Time is in UTC
	StartAt time.Time `json:"start_at"`
	// Time is in UTC
	EndAt         time.Time                       `json:"end_at"`
	IanaTimezone  string                          `json:"iana_timezone"`
	Type          AppointmentType                 `json:"type,omitempty"`
	Provider      AppointmentProvider             `json:"provider,omitempty"`
	Status        AppointmentStatus               `json:"status,omitempty"`
	ProviderId    string                          `json:"provider_id"`
	CanReschedule bool                            `json:"can_reschedule"`
	EventStatus   AppointmentEventStatus          `json:"event_status,omitempty"`
	EventData     map[string]interface{}          `json:"event_data,omitempty"`
	Events        []*ClientFacingAppointmentEvent `json:"events,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAppointment) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointment(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentCancellationReason struct {
	Id           string `json:"id"`
	Name         string `json:"name"`
	IsRefundable bool   `json:"is_refundable"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAppointmentCancellationReason) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentCancellationReason
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentCancellationReason(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentCancellationReason) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentEvent struct {
	CreatedAt time.Time              `json:"created_at"`
	Status    AppointmentEventStatus `json:"status,omitempty"`
	Data      map[string]interface{} `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAppointmentEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a at-home-phlebotomy test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingAtHomePhlebotomyOrder struct {
	// The Vital at-home phlebotomy Order ID
	Id            string    `json:"id"`
	AppointmentId *string   `json:"appointment_id,omitempty"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAtHomePhlebotomyOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAtHomePhlebotomyOrderDetails struct {
	Data *ClientFacingAtHomePhlebotomyOrder `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAtHomePhlebotomyOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrderDetails(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodOxygenTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in percentage (spo2).
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBloodOxygenTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodOxygenTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodPressureTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// The unit of the value. We use SI units where possible, e.g. mmol/L for glucose/cholesterol, bpm for heart rate, etc.
	Unit      string    `json:"unit"`
	Timestamp time.Time `json:"timestamp"`
	Systolic  float64   `json:"systolic"`
	Diastolic float64   `json:"diastolic"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBloodPressureTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodPressureTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBody struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date"`
	// Weight in kg::kg
	Weight *float64 `json:"weight,omitempty"`
	// Body fat percentage::perc
	Fat    *float64            `json:"fat,omitempty"`
	Source *ClientFacingSource `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBody(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBody) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaffeineTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Quantity of caffeine consumed during the time period.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingCaffeineTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaffeineTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaffeineTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesActiveTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Energy consumption caused by the physical activity at the time or interval::kilocalories
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingCaloriesActiveTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesActiveTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesActiveTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveTimeseries(value)
	c.unit = "kcal"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesActiveTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesBasalTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Basal Metabolic Rate at the time or interval::kilocalories
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingCaloriesBasalTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesBasalTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesBasalTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalTimeseries(value)
	c.unit = "kcal"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesBasalTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCholesterolTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingCholesterolTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCholesterolTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCholesterolTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDiagnosisInformation struct {
	// Diagnosis code for insurance information required by Labcorp.
	DiagnosisCode string `json:"diagnosis_code"`
	// Diagnosis description insurance information required by Labcorp.
	Description string `json:"description"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingDiagnosisInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDiagnosisInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDiagnosisInformation(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDiagnosisInformation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDistanceTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Distance traveled during activities at the time or interval::steps
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingDistanceTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingDistanceTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDistanceTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDistanceTimeseries(value)
	c.unit = "m"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "m",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingDistanceTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramVoltageTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The lead of the measurement.
	Type string `json:"type"`
	// Measured in mV.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingElectrocardiogramVoltageTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFloorsClimbedTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Number of floors climbed at the time or interval::count
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingFloorsClimbedTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingFloorsClimbedTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFloorsClimbedTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedTimeseries(value)
	c.unit = "count"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFloorsClimbedTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFood struct {
	Energy *Energy `json:"energy,omitempty"`
	Macros *Macros `json:"macros,omitempty"`
	Micros *Micros `json:"micros,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingFood) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFood
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFood(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFood) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGlucoseTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGlucoseTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGlucoseTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGlucoseTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRate struct {
	// Average heart rate::bpm
	AvgBpm *float64 `json:"avg_bpm,omitempty"`
	// Minimum heart rate::bpm
	MinBpm *float64 `json:"min_bpm,omitempty"`
	// Maximum heart rate::bpm
	MaxBpm *float64 `json:"max_bpm,omitempty"`
	// Resting heart rate::bpm
	RestingBpm *float64 `json:"resting_bpm,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRate(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Heart rate in bpm
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHeartRateTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRateTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRateTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHrvTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in rmssd.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// HRV calculated using rmssd during sleep
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHrvTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHrvTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHrvTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHrvTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHypnogramTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// enum: 1: deep, 2: light, 3: rem, 4: awake, -1: missing_data.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Hypnogram for sleep stages {"deep": 1, "light": 2, "rem": 3, "awake": 4, "manual": 5, "missing_data": -1}
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHypnogramTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHypnogramTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHypnogramTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHypnogramTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIgeTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingIgeTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIgeTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIgeTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIggTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingIggTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIggTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIggTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLab struct {
	Id                int                       `json:"id"`
	Slug              string                    `json:"slug"`
	Name              string                    `json:"name"`
	FirstLineAddress  string                    `json:"first_line_address"`
	City              string                    `json:"city"`
	Zipcode           string                    `json:"zipcode"`
	CollectionMethods []LabTestCollectionMethod `json:"collection_methods,omitempty"`
	SampleTypes       []LabTestSampleType       `json:"sample_types,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingLab) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLab(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLab) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabTest struct {
	Id         string                  `json:"id"`
	Slug       string                  `json:"slug"`
	Name       string                  `json:"name"`
	SampleType LabTestSampleType       `json:"sample_type,omitempty"`
	Method     LabTestCollectionMethod `json:"method,omitempty"`
	Price      float64                 `json:"price"`
	IsActive   bool                    `json:"is_active"`
	// Defines whether a lab test requires fasting. Only available for Labcorp.
	Fasting *bool                 `json:"fasting,omitempty"`
	Lab     *ClientFacingLab      `json:"lab,omitempty"`
	Markers []*ClientFacingMarker `json:"markers,omitempty"`
	// Denotes whether a lab test requires using non-Vital physician networks. If it does then it's delegated - no otherwise.
	IsDelegated *bool `json:"is_delegated,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingLabTest) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLabTest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLabTest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLabTest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLoinc struct {
	Id   int     `json:"id"`
	Name string  `json:"name"`
	Slug string  `json:"slug"`
	Code string  `json:"code"`
	Unit *string `json:"unit,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingLoinc) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLoinc
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLoinc(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLoinc) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarker struct {
	Id          int         `json:"id"`
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	Description *string     `json:"description,omitempty"`
	LabId       *int        `json:"lab_id,omitempty"`
	ProviderId  *string     `json:"provider_id,omitempty"`
	Type        *MarkerType `json:"type,omitempty"`
	Unit        *string     `json:"unit,omitempty"`
	Price       *string     `json:"price,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMarker) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarker
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarker(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarker) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarkerComplete struct {
	Id              int                   `json:"id"`
	Name            string                `json:"name"`
	Slug            string                `json:"slug"`
	Description     *string               `json:"description,omitempty"`
	LabId           *int                  `json:"lab_id,omitempty"`
	ProviderId      *string               `json:"provider_id,omitempty"`
	Type            *MarkerType           `json:"type,omitempty"`
	Unit            *string               `json:"unit,omitempty"`
	Price           *string               `json:"price,omitempty"`
	ExpectedResults []*ClientFacingResult `json:"expected_results,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMarkerComplete) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarkerComplete
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarkerComplete(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarkerComplete) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMealResponse struct {
	Meals []*MealInDbBaseClientFacingSource `json:"meals,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMealResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMealResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMealResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMealResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMindfulnessMinutesTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in minutes.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Number of minutes spent in a mindful state.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMindfulnessMinutesTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingOrder struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// The Vital Order ID
	Id string `json:"id"`
	// Your team id.
	TeamId string `json:"team_id"`
	// Patient Details
	PatientDetails *ClientFacingPatientDetailsCompatible `json:"patient_details,omitempty"`
	// Patient Address
	PatientAddress *PatientAddressCompatible `json:"patient_address,omitempty"`
	// The Vital Test associated with the order
	LabTest *ClientFacingLabTest      `json:"lab_test,omitempty"`
	Details *ClientFacingOrderDetails `json:"details,omitempty"`
	// Sample ID
	SampleId *string `json:"sample_id,omitempty"`
	// Notes associated with the order
	Notes *string `json:"notes,omitempty"`
	// When your order was created
	CreatedAt time.Time `json:"created_at"`
	// When your order was last updated.
	UpdatedAt time.Time                 `json:"updated_at"`
	Events    []*ClientFacingOrderEvent `json:"events,omitempty"`
	Status    *OrderTopLevelStatus      `json:"status,omitempty"`
	Physician *PhysicianClientFacing    `json:"physician,omitempty"`
	// Vital ID of the health insurance.
	HealthInsuranceId *string `json:"health_insurance_id,omitempty"`
	// DEPRECATED. Requistion form url.
	RequisitionFormUrl *string `json:"requisition_form_url,omitempty"`
	// Defines whether order is priority or not. Only available for Labcorp. For Labcorp, this corresponds to a STAT order.
	Priority *bool `json:"priority,omitempty"`
	// Shipping Details. For unregistered testkit orders.
	ShippingDetails *ShippingAddress `json:"shipping_details,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingOrderDetails struct {
	Type             string
	WalkInTest       *ClientFacingWalkInOrderDetails
	Testkit          *ClientFacingTestKitOrderDetails
	AtHomePhlebotomy *ClientFacingAtHomePhlebotomyOrderDetails
}

func NewClientFacingOrderDetailsFromWalkInTest(value *ClientFacingWalkInOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "walk_in_test", WalkInTest: value}
}

func NewClientFacingOrderDetailsFromTestkit(value *ClientFacingTestKitOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "testkit", Testkit: value}
}

func NewClientFacingOrderDetailsFromAtHomePhlebotomy(value *ClientFacingAtHomePhlebotomyOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "at_home_phlebotomy", AtHomePhlebotomy: value}
}

func (c *ClientFacingOrderDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "walk_in_test":
		value := new(ClientFacingWalkInOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.WalkInTest = value
	case "testkit":
		value := new(ClientFacingTestKitOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Testkit = value
	case "at_home_phlebotomy":
		value := new(ClientFacingAtHomePhlebotomyOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.AtHomePhlebotomy = value
	}
	return nil
}

func (c ClientFacingOrderDetails) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingWalkInOrderDetails
		}{
			Type:                           c.Type,
			ClientFacingWalkInOrderDetails: c.WalkInTest,
		}
		return json.Marshal(marshaler)
	case "testkit":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingTestKitOrderDetails
		}{
			Type:                            c.Type,
			ClientFacingTestKitOrderDetails: c.Testkit,
		}
		return json.Marshal(marshaler)
	case "at_home_phlebotomy":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingAtHomePhlebotomyOrderDetails
		}{
			Type:                                     c.Type,
			ClientFacingAtHomePhlebotomyOrderDetails: c.AtHomePhlebotomy,
		}
		return json.Marshal(marshaler)
	}
}

type ClientFacingOrderDetailsVisitor interface {
	VisitWalkInTest(*ClientFacingWalkInOrderDetails) error
	VisitTestkit(*ClientFacingTestKitOrderDetails) error
	VisitAtHomePhlebotomy(*ClientFacingAtHomePhlebotomyOrderDetails) error
}

func (c *ClientFacingOrderDetails) Accept(visitor ClientFacingOrderDetailsVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		return visitor.VisitWalkInTest(c.WalkInTest)
	case "testkit":
		return visitor.VisitTestkit(c.Testkit)
	case "at_home_phlebotomy":
		return visitor.VisitAtHomePhlebotomy(c.AtHomePhlebotomy)
	}
}

type ClientFacingOrderEvent struct {
	Id        int         `json:"id"`
	CreatedAt time.Time   `json:"created_at"`
	Status    OrderStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingOrderEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingOrderEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingOrderEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrderEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPatientDetailsCompatible struct {
	FirstName   *string   `json:"first_name,omitempty"`
	LastName    *string   `json:"last_name,omitempty"`
	Dob         time.Time `json:"dob"`
	Gender      string    `json:"gender"`
	PhoneNumber *string   `json:"phone_number,omitempty"`
	Email       *string   `json:"email,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingPatientDetailsCompatible) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPatientDetailsCompatible
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPatientDetailsCompatible(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPatientDetailsCompatible) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPayorSearchResponse struct {
	// Payor code returned for the insurance information required by Labcorp.
	Code string `json:"code"`
	// Insurance name returned for the insurance information required by Labcorp.
	Name string `json:"name"`
	// Insurance business address returned for the insurance information required by Labcorp.
	OrgAddress *Address `json:"org_address,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingPayorSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPayorSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPayorSearchResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPayorSearchResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProfile struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string              `json:"user_id"`
	Id     string              `json:"id"`
	Height *int                `json:"height,omitempty"`
	Source *ClientFacingSource `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProfile(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProfile) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A vendor, a service, or a platform which Vital can connect with.
type ClientFacingProvider struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// URL for source logo
	Logo string `json:"logo"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProvider) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProvider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProvider(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProvider) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderDetailed struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// Description of source of information
	Description string `json:"description"`
	// URL for source logo
	Logo               *string                `json:"logo,omitempty"`
	AuthType           *SourceAuthType        `json:"auth_type,omitempty"`
	SupportedResources []ClientFacingResource `json:"supported_resources,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProviderDetailed) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProviderDetailed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProviderDetailed(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderDetailed) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderWithStatus struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// URL for source logo
	Logo string `json:"logo"`
	// Status of source, either error or connected
	Status string `json:"status"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProviderWithStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProviderWithStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProviderWithStatus(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderWithStatus) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An enumeration.
type ClientFacingResource string

const (
	ClientFacingResourceProfile                  ClientFacingResource = "profile"
	ClientFacingResourceActivity                 ClientFacingResource = "activity"
	ClientFacingResourceSleep                    ClientFacingResource = "sleep"
	ClientFacingResourceBody                     ClientFacingResource = "body"
	ClientFacingResourceWorkouts                 ClientFacingResource = "workouts"
	ClientFacingResourceWorkoutStream            ClientFacingResource = "workout_stream"
	ClientFacingResourceConnection               ClientFacingResource = "connection"
	ClientFacingResourceOrder                    ClientFacingResource = "order"
	ClientFacingResourceResult                   ClientFacingResource = "result"
	ClientFacingResourceAppointment              ClientFacingResource = "appointment"
	ClientFacingResourceGlucose                  ClientFacingResource = "glucose"
	ClientFacingResourceHeartrate                ClientFacingResource = "heartrate"
	ClientFacingResourceHrv                      ClientFacingResource = "hrv"
	ClientFacingResourceHypnogram                ClientFacingResource = "hypnogram"
	ClientFacingResourceIge                      ClientFacingResource = "ige"
	ClientFacingResourceIgg                      ClientFacingResource = "igg"
	ClientFacingResourceBloodOxygen              ClientFacingResource = "blood_oxygen"
	ClientFacingResourceBloodPressure            ClientFacingResource = "blood_pressure"
	ClientFacingResourceCholesterol              ClientFacingResource = "cholesterol"
	ClientFacingResourceDevice                   ClientFacingResource = "device"
	ClientFacingResourceWeight                   ClientFacingResource = "weight"
	ClientFacingResourceFat                      ClientFacingResource = "fat"
	ClientFacingResourceMeal                     ClientFacingResource = "meal"
	ClientFacingResourceWater                    ClientFacingResource = "water"
	ClientFacingResourceCaffeine                 ClientFacingResource = "caffeine"
	ClientFacingResourceMindfulnessMinutes       ClientFacingResource = "mindfulness_minutes"
	ClientFacingResourceSteps                    ClientFacingResource = "steps"
	ClientFacingResourceCaloriesActive           ClientFacingResource = "calories_active"
	ClientFacingResourceDistance                 ClientFacingResource = "distance"
	ClientFacingResourceFloorsClimbed            ClientFacingResource = "floors_climbed"
	ClientFacingResourceRespiratoryRate          ClientFacingResource = "respiratory_rate"
	ClientFacingResourceVo2Max                   ClientFacingResource = "vo2_max"
	ClientFacingResourceCaloriesBasal            ClientFacingResource = "calories_basal"
	ClientFacingResourceStressLevel              ClientFacingResource = "stress_level"
	ClientFacingResourceElectrocardiogramVoltage ClientFacingResource = "electrocardiogram_voltage"
	ClientFacingResourceSleepStream              ClientFacingResource = "sleep_stream"
)

func NewClientFacingResourceFromString(s string) (ClientFacingResource, error) {
	switch s {
	case "profile":
		return ClientFacingResourceProfile, nil
	case "activity":
		return ClientFacingResourceActivity, nil
	case "sleep":
		return ClientFacingResourceSleep, nil
	case "body":
		return ClientFacingResourceBody, nil
	case "workouts":
		return ClientFacingResourceWorkouts, nil
	case "workout_stream":
		return ClientFacingResourceWorkoutStream, nil
	case "connection":
		return ClientFacingResourceConnection, nil
	case "order":
		return ClientFacingResourceOrder, nil
	case "result":
		return ClientFacingResourceResult, nil
	case "appointment":
		return ClientFacingResourceAppointment, nil
	case "glucose":
		return ClientFacingResourceGlucose, nil
	case "heartrate":
		return ClientFacingResourceHeartrate, nil
	case "hrv":
		return ClientFacingResourceHrv, nil
	case "hypnogram":
		return ClientFacingResourceHypnogram, nil
	case "ige":
		return ClientFacingResourceIge, nil
	case "igg":
		return ClientFacingResourceIgg, nil
	case "blood_oxygen":
		return ClientFacingResourceBloodOxygen, nil
	case "blood_pressure":
		return ClientFacingResourceBloodPressure, nil
	case "cholesterol":
		return ClientFacingResourceCholesterol, nil
	case "device":
		return ClientFacingResourceDevice, nil
	case "weight":
		return ClientFacingResourceWeight, nil
	case "fat":
		return ClientFacingResourceFat, nil
	case "meal":
		return ClientFacingResourceMeal, nil
	case "water":
		return ClientFacingResourceWater, nil
	case "caffeine":
		return ClientFacingResourceCaffeine, nil
	case "mindfulness_minutes":
		return ClientFacingResourceMindfulnessMinutes, nil
	case "steps":
		return ClientFacingResourceSteps, nil
	case "calories_active":
		return ClientFacingResourceCaloriesActive, nil
	case "distance":
		return ClientFacingResourceDistance, nil
	case "floors_climbed":
		return ClientFacingResourceFloorsClimbed, nil
	case "respiratory_rate":
		return ClientFacingResourceRespiratoryRate, nil
	case "vo2_max":
		return ClientFacingResourceVo2Max, nil
	case "calories_basal":
		return ClientFacingResourceCaloriesBasal, nil
	case "stress_level":
		return ClientFacingResourceStressLevel, nil
	case "electrocardiogram_voltage":
		return ClientFacingResourceElectrocardiogramVoltage, nil
	case "sleep_stream":
		return ClientFacingResourceSleepStream, nil
	}
	var t ClientFacingResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingResource) Ptr() *ClientFacingResource {
	return &c
}

type ClientFacingRespiratoryRateTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Average respiratory rate::breaths per minute
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingRespiratoryRateTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingRespiratoryRateTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingRespiratoryRateTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingRespiratoryRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingResult struct {
	Id         int                `json:"id"`
	Name       string             `json:"name"`
	Slug       string             `json:"slug"`
	LabId      *int               `json:"lab_id,omitempty"`
	ProviderId *string            `json:"provider_id,omitempty"`
	Loinc      *ClientFacingLoinc `json:"loinc,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingResult(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a Shipment in the client facing API.
//
// To be used as part of a ClientFacingTestkitOrder.
type ClientFacingShipment struct {
	// The Vital Shipment ID
	Id string `json:"id"`
	// Tracking number for delivery to customer
	OutboundTrackingNumber *string `json:"outbound_tracking_number,omitempty"`
	// Tracking url for delivery to customer
	OutboundTrackingUrl *string `json:"outbound_tracking_url,omitempty"`
	// Tracking number for delivery to lab
	InboundTrackingNumber *string `json:"inbound_tracking_number,omitempty"`
	// Tracking url for delivery to lab
	InboundTrackingUrl *string `json:"inbound_tracking_url,omitempty"`
	// Courier used for delivery to customer
	OutboundCourier *string `json:"outbound_courier,omitempty"`
	// Courier used for delivery to lab
	InboundCourier *string `json:"inbound_courier,omitempty"`
	// Notes associated to the Vital shipment
	Notes *string `json:"notes,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingShipment) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingShipment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingShipment(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingShipment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleep struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the sleep summary in the YYYY-mm-dd format. This generally matches the sleep end date.
	CalendarDate string `json:"calendar_date"`
	// UTC Time when the sleep period started
	BedtimeStart time.Time `json:"bedtime_start"`
	// UTC Time when the sleep period ended
	BedtimeStop time.Time `json:"bedtime_stop"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Total duration of the sleep period (sleep.duration = sleep.bedtime_end - sleep.bedtime_start)::seconds
	Duration int `json:"duration"`
	// Total amount of sleep registered during the sleep period (sleep.total = sleep.rem + sleep.light + sleep.deep)::seconds
	Total int `json:"total"`
	// Total amount of awake time registered during the sleep period::seconds
	Awake int `json:"awake"`
	// Total amount of light sleep registered during the sleep period::seconds
	Light int `json:"light"`
	// Total amount of REM sleep registered during the sleep period, minutes::seconds
	Rem int `json:"rem"`
	// Total amount of deep (N3) sleep registered during the sleep period::seconds
	Deep int `json:"deep"`
	// A value between 1 and 100 representing how well the user slept. Currently only available for Withings, Oura, Whoop and Garmin::scalar
	Score *int `json:"score,omitempty"`
	// The lowest heart rate (5 minutes sliding average) registered during the sleep period::beats per minute
	HrLowest *int `json:"hr_lowest,omitempty"`
	// The average heart rate registered during the sleep period::beats per minute
	HrAverage *int `json:"hr_average,omitempty"`
	// Sleep efficiency is the percentage of the sleep period spent asleep (100% * sleep.total / sleep.duration)::perc
	Efficiency *float64 `json:"efficiency,omitempty"`
	// Detected latency from bedtime_start to the beginning of the first five minutes of persistent sleep::seconds
	Latency *int `json:"latency,omitempty"`
	// Skin temperature deviation from the long-term temperature average::celcius
	TemperatureDelta *float64 `json:"temperature_delta,omitempty"`
	// The skin temperature::celcius
	SkinTemperature *float64 `json:"skin_temperature,omitempty"`
	// Sleeping Heart Rate Dip is the percentage difference between your average waking heart rate and your average sleeping heart rate. In health studies, a greater "dip" is typically seen as a positive indicator of overall health. Currently only available for Garmin::perc
	HrDip *float64 `json:"hr_dip,omitempty"`
	// The average heart rate variability registered during the sleep period::rmssd
	AverageHrv *float64 `json:"average_hrv,omitempty"`
	// Average respiratory rate::breaths per minute
	RespiratoryRate *float64 `json:"respiratory_rate,omitempty"`
	// Source the data has come from.
	Source      *ClientFacingSource      `json:"source,omitempty"`
	SleepStream *ClientFacingSleepStream `json:"sleep_stream,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSleep) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleep(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleep) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepStream struct {
	Hrv             []*ClientFacingHrvTimeseries             `json:"hrv,omitempty"`
	Heartrate       []*ClientFacingHeartRateTimeseries       `json:"heartrate,omitempty"`
	Hypnogram       []*ClientFacingHypnogramTimeseries       `json:"hypnogram,omitempty"`
	RespiratoryRate []*ClientFacingRespiratoryRateTimeseries `json:"respiratory_rate,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSleepStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepStream(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Source summarizes where a sample or a summary is sourced from.
// At minimum, the source provider is always included.
type ClientFacingSource struct {
	// Provider slug. e.g., `oura`, `fitbit`, `garmin`.
	Provider string `json:"provider"`
	// The type of the data source (app or device) by which the summary or the timeseries data were recorded. This defaults to `unknown` when Vital cannot extract or infer that information
	Type *string `json:"type,omitempty"`
	// The identifier of the app which recorded this summary. This is only applicable to multi-source providers like Apple Health and Android Health Connect.
	AppId *string `json:"app_id,omitempty"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Name string `json:"name"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Slug string `json:"slug"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Logo string `json:"logo"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSource(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSource) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSport struct {
	Id int `json:"id"`
	// Sport's name
	Name string `json:"name"`
	// Slug for designated sport
	Slug string `json:"slug"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSport) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSport(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSport) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStepsTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The number of steps sampled at the time or interval::count
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingStepsTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingStepsTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStepsTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStepsTimeseries(value)
	c.unit = "count"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStepsTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStepsTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStream struct {
	Cadence []float64 `json:"cadence,omitempty"`
	// Corresponding time stamp in unix time for datapoint
	Time           []int     `json:"time,omitempty"`
	Altitude       []float64 `json:"altitude,omitempty"`
	VelocitySmooth []float64 `json:"velocity_smooth,omitempty"`
	Heartrate      []int     `json:"heartrate,omitempty"`
	Lat            []float64 `json:"lat,omitempty"`
	Lng            []float64 `json:"lng,omitempty"`
	Distance       []float64 `json:"distance,omitempty"`
	Power          []float64 `json:"power,omitempty"`
	Resistance     []float64 `json:"resistance,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStream(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTeam struct {
	Id                                       string                `json:"id"`
	Name                                     string                `json:"name"`
	SvixAppId                                *string               `json:"svix_app_id,omitempty"`
	ClientId                                 *string               `json:"client_id,omitempty"`
	ClientSecret                             *string               `json:"client_secret,omitempty"`
	AirtableApiKey                           *string               `json:"airtable_api_key,omitempty"`
	AirtableBaseId                           *string               `json:"airtable_base_id,omitempty"`
	WebhookSecret                            *string               `json:"webhook_secret,omitempty"`
	ApiKey                                   *string               `json:"api_key,omitempty"`
	ApiKeys                                  []*ClientFacingApiKey `json:"api_keys,omitempty"`
	Configuration                            *TeamConfig           `json:"configuration,omitempty"`
	TestkitsTextsEnabled                     bool                  `json:"testkits_texts_enabled"`
	LabTestsPatientCommunicationEnabled      bool                  `json:"lab_tests_patient_communication_enabled"`
	LabTestsPatientSmsCommunicationEnabled   bool                  `json:"lab_tests_patient_sms_communication_enabled"`
	LabTestsPatientEmailCommunicationEnabled bool                  `json:"lab_tests_patient_email_communication_enabled"`
	LogoUrl                                  *string               `json:"logo_url,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTeam) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTeam
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTeam(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTeam) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTestKitOrderDetails struct {
	Data *ClientFacingTestkitOrder `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTestKitOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTestKitOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTestKitOrderDetails(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestKitOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a testkit order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingTestkitOrder struct {
	// The Vital TestKit Order ID
	Id string `json:"id"`
	// Shipment object
	Shipment  *ClientFacingShipment `json:"shipment,omitempty"`
	CreatedAt time.Time             `json:"created_at"`
	UpdatedAt time.Time             `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTestkitOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTestkitOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTestkitOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestkitOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUser struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// Your team id.
	TeamId string `json:"team_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id"`
	// When your item is created
	CreatedOn time.Time `json:"created_on"`
	// A list of the users connected sources.
	ConnectedSources []*ConnectedSourceClientFacing `json:"connected_sources,omitempty"`
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	FallbackTimeZone *FallbackTimeZone `json:"fallback_time_zone,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingUser) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUser(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUser) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUserKey struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingUserKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUserKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUserKey(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUserKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWalkInOrderDetails struct {
	Data *ClientFacingWalkInTestOrder `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWalkInOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWalkInOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWalkInOrderDetails(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a walk-in test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingWalkInTestOrder struct {
	// The Vital walk-in test Order ID
	Id        string    `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWalkInTestOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWalkInTestOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWalkInTestOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInTestOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWaterTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG and IGE.
	Type *string `json:"type,omitempty"`
	// Measured in milliters.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Quantity of water drank during the time period.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWaterTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWaterTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWaterTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkout struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Title given for the workout
	Title *string `json:"title,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Average heart rate during workout::bpm
	AverageHr *int `json:"average_hr,omitempty"`
	// Max heart rate during workout::bpm
	MaxHr *int `json:"max_hr,omitempty"`
	// Distance travelled during workout::meters
	Distance *float64 `json:"distance,omitempty"`
	// Date of the workout summary in the YYYY-mm-dd format. This generally matches the workout start date.
	CalendarDate string `json:"calendar_date"`
	// Start time of the workout::time
	TimeStart time.Time `json:"time_start"`
	// End time of the workout::time
	TimeEnd time.Time `json:"time_end"`
	// Calories burned during the workout::kCal
	Calories *float64 `json:"calories,omitempty"`
	// Sport's name
	Sport *ClientFacingSport `json:"sport,omitempty"`
	// Time in seconds spent in different heart rate zones <50%, 50-60%, 60-70%, 70-80%, 80-90%, 90%+. Due to rounding errors, it's possible that summing all values is different than the total time of the workout. Not available for all providers::seconds
	HrZones []int `json:"hr_zones,omitempty"`
	// Time spent active during the workout::seconds
	MovingTime *int `json:"moving_time,omitempty"`
	// Elevation gain during the workout::meters
	TotalElevationGain *float64 `json:"total_elevation_gain,omitempty"`
	// Highest point of elevation::meters
	ElevHigh *float64 `json:"elev_high,omitempty"`
	// Lowest point of elevation::meters
	ElevLow *float64 `json:"elev_low,omitempty"`
	// Average speed during workout in m/s::meters/sec
	AverageSpeed *float64 `json:"average_speed,omitempty"`
	// Max speed during workout in m/s::meters/sec
	MaxSpeed *float64 `json:"max_speed,omitempty"`
	// Average watts burned during exercise::watts
	AverageWatts *float64 `json:"average_watts,omitempty"`
	// Watts burned during exercise::watts
	DeviceWatts *float64 `json:"device_watts,omitempty"`
	// Max watts burned during exercise::watts
	MaxWatts *float64 `json:"max_watts,omitempty"`
	// Weighted average watts burned during exercise::watts
	WeightedAverageWatts *float64 `json:"weighted_average_watts,omitempty"`
	// Map of workouts encoded as polyline
	Map map[string]interface{} `json:"map,omitempty"`
	// Provider ID given for that specific workout
	ProviderId string `json:"provider_id"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWorkout) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkout(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkout) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientSleepResponse struct {
	Sleep []*ClientFacingSleep `json:"sleep,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientSleepResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSleepResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSleepResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSleepResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientWorkoutResponse struct {
	Workouts []*ClientFacingWorkout `json:"workouts,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientWorkoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientWorkoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientWorkoutResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientWorkoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectedSourceClientFacing struct {
	// The provider of this connected source.
	Provider *ClientFacingProvider `json:"provider,omitempty"`
	// When your item is created
	CreatedOn time.Time `json:"created_on"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Source *ClientFacingProvider `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectedSourceClientFacing) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectedSourceClientFacing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectedSourceClientFacing(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectedSourceClientFacing) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionStatus struct {
	Success     bool    `json:"success"`
	RedirectUrl *string `json:"redirect_url,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionStatus(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionStatus) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Consent struct {
	ConsentType   ConsentType `json:"consentType,omitempty"`
	Version       *string     `json:"version,omitempty"`
	TimeOfConsent *time.Time  `json:"timeOfConsent,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Consent) UnmarshalJSON(data []byte) error {
	type unmarshaler Consent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Consent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Consent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An enumeration.
type ConsentType string

const (
	ConsentTypeTermsOfUse                ConsentType = "terms-of-use"
	ConsentTypeTelehealthInformedConsent ConsentType = "telehealth-informed-consent"
	ConsentTypeMobileTermsAndConditions  ConsentType = "mobile-terms-and-conditions"
	ConsentTypeNoticeOfPrivacyPractices  ConsentType = "notice-of-privacy-practices"
	ConsentTypePrivacyPolicy             ConsentType = "privacy-policy"
	ConsentTypeHipaaAuthorization        ConsentType = "hipaa-authorization"
)

func NewConsentTypeFromString(s string) (ConsentType, error) {
	switch s {
	case "terms-of-use":
		return ConsentTypeTermsOfUse, nil
	case "telehealth-informed-consent":
		return ConsentTypeTelehealthInformedConsent, nil
	case "mobile-terms-and-conditions":
		return ConsentTypeMobileTermsAndConditions, nil
	case "notice-of-privacy-practices":
		return ConsentTypeNoticeOfPrivacyPractices, nil
	case "privacy-policy":
		return ConsentTypePrivacyPolicy, nil
	case "hipaa-authorization":
		return ConsentTypeHipaaAuthorization, nil
	}
	var t ConsentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsentType) Ptr() *ConsentType {
	return &c
}

type DaySlots struct {
	Date  string      `json:"date"`
	Slots []*TimeSlot `json:"slots,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DaySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler DaySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DaySlots(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DaySlots) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DemoConnectionStatus struct {
	Success bool   `json:"success"`
	Detail  string `json:"detail"`

	_rawJSON json.RawMessage
}

func (d *DemoConnectionStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler DemoConnectionStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DemoConnectionStatus(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DemoConnectionStatus) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// An enumeration.
type DemoProviders string

const (
	DemoProvidersAppleHealthKit DemoProviders = "apple_health_kit"
	DemoProvidersFitbit         DemoProviders = "fitbit"
	DemoProvidersFreestyleLibre DemoProviders = "freestyle_libre"
	DemoProvidersOura           DemoProviders = "oura"
)

func NewDemoProvidersFromString(s string) (DemoProviders, error) {
	switch s {
	case "apple_health_kit":
		return DemoProvidersAppleHealthKit, nil
	case "fitbit":
		return DemoProvidersFitbit, nil
	case "freestyle_libre":
		return DemoProvidersFreestyleLibre, nil
	case "oura":
		return DemoProvidersOura, nil
	}
	var t DemoProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DemoProviders) Ptr() *DemoProviders {
	return &d
}

type DeviceV2InDb struct {
	Data       *string               `json:"data,omitempty"`
	ProviderId string                `json:"provider_id"`
	UserId     string                `json:"user_id"`
	SourceId   int                   `json:"source_id"`
	Id         string                `json:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeviceV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceV2InDb(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceV2InDb) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmailProviders = string

type Energy struct {
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (e *Energy) Unit() string {
	return e.unit
}

func (e *Energy) UnmarshalJSON(data []byte) error {
	type unmarshaler Energy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Energy(value)
	e.unit = "kcal"
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Energy) MarshalJSON() ([]byte, error) {
	type embed Energy
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*e),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (e *Energy) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FallbackTimeZone struct {
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	Id string `json:"id"`
	// Slug for designated source
	SourceSlug string    `json:"source_slug"`
	UpdatedAt  time.Time `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (f *FallbackTimeZone) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackTimeZone
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackTimeZone(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTimeZone) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Fats struct {
	// Amount of saturated fats in grams (g)
	Saturated *float64 `json:"saturated,omitempty"`
	// Amount of monounsaturated fats in grams (g)
	Monounsaturated *float64 `json:"monounsaturated,omitempty"`
	// Amount of polyunsaturated fats in grams (g)
	Polyunsaturated *float64 `json:"polyunsaturated,omitempty"`
	// Amount of Omega-3 fatty acids in grams (g)
	Omega3 *float64 `json:"omega3,omitempty"`
	// Amount of Omega-6 fatty acids in grams (g)
	Omega6 *float64 `json:"omega6,omitempty"`
	// Total amount of fats in grams (g)
	Total *float64 `json:"total,omitempty"`

	_rawJSON json.RawMessage
}

func (f *Fats) UnmarshalJSON(data []byte) error {
	type unmarshaler Fats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fats(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fats) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// An enumeration.
type Gender string

const (
	GenderFemale  Gender = "female"
	GenderMale    Gender = "male"
	GenderOther   Gender = "other"
	GenderUnknown Gender = "unknown"
)

func NewGenderFromString(s string) (Gender, error) {
	switch s {
	case "female":
		return GenderFemale, nil
	case "male":
		return GenderMale, nil
	case "other":
		return GenderOther, nil
	case "unknown":
		return GenderUnknown, nil
	}
	var t Gender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g Gender) Ptr() *Gender {
	return &g
}

type GetMarkersResponse struct {
	Markers []*ClientFacingMarkerComplete `json:"markers,omitempty"`
	Total   int                           `json:"total"`
	Page    int                           `json:"page"`
	Size    int                           `json:"size"`

	_rawJSON json.RawMessage
}

func (g *GetMarkersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetMarkersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetMarkersResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetMarkersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetOrdersResponse struct {
	Orders []*ClientFacingOrder `json:"orders,omitempty"`
	Total  int                  `json:"total"`
	Page   int                  `json:"page"`
	Size   int                  `json:"size"`

	_rawJSON json.RawMessage
}

func (g *GetOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrdersResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrdersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HealthInsuranceCreateRequest struct {
	// An image of the front of the patient insurance card.
	FrontImage *HealthInsuranceCreateRequestFrontImage `json:"front_image,omitempty"`
	// An image of the back of the patient insurance card.
	BackImage *HealthInsuranceCreateRequestBackImage `json:"back_image,omitempty"`
	// An image of the patient signature for health insurance billing.
	PatientSignatureImage *HealthInsuranceCreateRequestPatientSignatureImage `json:"patient_signature_image,omitempty"`
	// Textual description of what are the patient symptoms and attempted treatments.
	Subjective *string `json:"subjective,omitempty"`
	// Textual description of what are the physician assessments and testing plans.
	AssessmentPlan *string `json:"assessment_plan,omitempty"`
	// Unique identifier representing a specific Health Insurance.
	PayorCode *string `json:"payor_code,omitempty"`
	// Insurance unique number assigned to a patient, usually present on the insurance card.
	InsuranceId *string `json:"insurance_id,omitempty"`
	// Relationship between the patient and the insurance contractor. Values can be (Self, Spouse, Other Relationship).
	ResponsibleRelationship *ResponsibleRelationship `json:"responsible_relationship,omitempty"`
	// Responsible details when the value of responsible_relationship is not 'Self'.
	ResponsibleDetails *PersonDetails `json:"responsible_details,omitempty"`
	// Diagnosis codes for insurance billing.
	DiagnosisCodes []string `json:"diagnosis_codes,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HealthInsuranceCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HealthInsuranceCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HealthInsuranceCreateRequest(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HealthInsuranceCreateRequest) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// An image of the back of the patient insurance card.
type HealthInsuranceCreateRequestBackImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewHealthInsuranceCreateRequestBackImageFromImageJpeg(value *Jpeg) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewHealthInsuranceCreateRequestBackImageFromImagePng(value *Png) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{ContentType: "image/png", ImagePng: value}
}

func (h *HealthInsuranceCreateRequestBackImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImagePng = value
	}
	return nil
}

func (h HealthInsuranceCreateRequestBackImage) MarshalJSON() ([]byte, error) {
	switch h.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: h.ContentType,
			Jpeg:        h.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: h.ContentType,
			Png:         h.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type HealthInsuranceCreateRequestBackImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (h *HealthInsuranceCreateRequestBackImage) Accept(visitor HealthInsuranceCreateRequestBackImageVisitor) error {
	switch h.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		return visitor.VisitImageJpeg(h.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(h.ImagePng)
	}
}

// An image of the front of the patient insurance card.
type HealthInsuranceCreateRequestFrontImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewHealthInsuranceCreateRequestFrontImageFromImageJpeg(value *Jpeg) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewHealthInsuranceCreateRequestFrontImageFromImagePng(value *Png) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{ContentType: "image/png", ImagePng: value}
}

func (h *HealthInsuranceCreateRequestFrontImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImagePng = value
	}
	return nil
}

func (h HealthInsuranceCreateRequestFrontImage) MarshalJSON() ([]byte, error) {
	switch h.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: h.ContentType,
			Jpeg:        h.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: h.ContentType,
			Png:         h.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type HealthInsuranceCreateRequestFrontImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (h *HealthInsuranceCreateRequestFrontImage) Accept(visitor HealthInsuranceCreateRequestFrontImageVisitor) error {
	switch h.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		return visitor.VisitImageJpeg(h.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(h.ImagePng)
	}
}

// An image of the patient signature for health insurance billing.
type HealthInsuranceCreateRequestPatientSignatureImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromImageJpeg(value *Jpeg) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromImagePng(value *Png) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{ContentType: "image/png", ImagePng: value}
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImagePng = value
	}
	return nil
}

func (h HealthInsuranceCreateRequestPatientSignatureImage) MarshalJSON() ([]byte, error) {
	switch h.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: h.ContentType,
			Jpeg:        h.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: h.ContentType,
			Png:         h.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type HealthInsuranceCreateRequestPatientSignatureImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) Accept(visitor HealthInsuranceCreateRequestPatientSignatureImageVisitor) error {
	switch h.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		return visitor.VisitImageJpeg(h.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(h.ImagePng)
	}
}

type HttpValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpValidationError) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type Jpeg struct {
	Content string `json:"content"`

	_rawJSON json.RawMessage
}

func (j *Jpeg) UnmarshalJSON(data []byte) error {
	type unmarshaler Jpeg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = Jpeg(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *Jpeg) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type LabResultsMetadata struct {
	Age            string  `json:"age"`
	Dob            string  `json:"dob"`
	Clia           *string `json:"clia_#,omitempty"`
	Patient        string  `json:"patient"`
	Provider       *string `json:"provider,omitempty"`
	Laboratory     *string `json:"laboratory,omitempty"`
	DateReported   string  `json:"date_reported"`
	DateCollected  *string `json:"date_collected,omitempty"`
	SpecimenNumber string  `json:"specimen_number"`
	DateReceived   *string `json:"date_received,omitempty"`
	Status         *string `json:"status,omitempty"`
	Interpretation *string `json:"interpretation,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LabResultsMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsMetadata(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsMetadata) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRaw struct {
	Metadata *LabResultsMetadata   `json:"metadata,omitempty"`
	Results  *LabResultsRawResults `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LabResultsRaw) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsRaw
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsRaw(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsRaw) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRawResults struct {
	typeName            string
	BiomarkerResultList []*BiomarkerResult
	StringUnknownMap    map[string]interface{}
}

func NewLabResultsRawResultsFromBiomarkerResultList(value []*BiomarkerResult) *LabResultsRawResults {
	return &LabResultsRawResults{typeName: "biomarkerResultList", BiomarkerResultList: value}
}

func NewLabResultsRawResultsFromStringUnknownMap(value map[string]interface{}) *LabResultsRawResults {
	return &LabResultsRawResults{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (l *LabResultsRawResults) UnmarshalJSON(data []byte) error {
	var valueBiomarkerResultList []*BiomarkerResult
	if err := json.Unmarshal(data, &valueBiomarkerResultList); err == nil {
		l.typeName = "biomarkerResultList"
		l.BiomarkerResultList = valueBiomarkerResultList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		l.typeName = "stringUnknownMap"
		l.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LabResultsRawResults) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "biomarkerResultList":
		return json.Marshal(l.BiomarkerResultList)
	case "stringUnknownMap":
		return json.Marshal(l.StringUnknownMap)
	}
}

type LabResultsRawResultsVisitor interface {
	VisitBiomarkerResultList([]*BiomarkerResult) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (l *LabResultsRawResults) Accept(visitor LabResultsRawResultsVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "biomarkerResultList":
		return visitor.VisitBiomarkerResultList(l.BiomarkerResultList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(l.StringUnknownMap)
	}
}

// The method used to perform a lab test.
type LabTestCollectionMethod string

const (
	LabTestCollectionMethodTestkit          LabTestCollectionMethod = "testkit"
	LabTestCollectionMethodWalkInTest       LabTestCollectionMethod = "walk_in_test"
	LabTestCollectionMethodAtHomePhlebotomy LabTestCollectionMethod = "at_home_phlebotomy"
)

func NewLabTestCollectionMethodFromString(s string) (LabTestCollectionMethod, error) {
	switch s {
	case "testkit":
		return LabTestCollectionMethodTestkit, nil
	case "walk_in_test":
		return LabTestCollectionMethodWalkInTest, nil
	case "at_home_phlebotomy":
		return LabTestCollectionMethodAtHomePhlebotomy, nil
	}
	var t LabTestCollectionMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestCollectionMethod) Ptr() *LabTestCollectionMethod {
	return &l
}

// The type of sample used to perform a lab test.
type LabTestSampleType string

const (
	LabTestSampleTypeDriedBloodSpot LabTestSampleType = "dried_blood_spot"
	LabTestSampleTypeSerum          LabTestSampleType = "serum"
	LabTestSampleTypeSaliva         LabTestSampleType = "saliva"
	LabTestSampleTypeUrine          LabTestSampleType = "urine"
)

func NewLabTestSampleTypeFromString(s string) (LabTestSampleType, error) {
	switch s {
	case "dried_blood_spot":
		return LabTestSampleTypeDriedBloodSpot, nil
	case "serum":
		return LabTestSampleTypeSerum, nil
	case "saliva":
		return LabTestSampleTypeSaliva, nil
	case "urine":
		return LabTestSampleTypeUrine, nil
	}
	var t LabTestSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestSampleType) Ptr() *LabTestSampleType {
	return &l
}

type LibreConfig struct {
	PracticeId map[string]interface{} `json:"practice_id,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LibreConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LibreConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LibreConfig(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LibreConfig) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LinkTokenExchangeResponse struct {
	// Link token to use to launch link widget
	LinkToken string `json:"link_token"`

	_rawJSON json.RawMessage
}

func (l *LinkTokenExchangeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkTokenExchangeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkTokenExchangeResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkTokenExchangeResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LngLat struct {
	Lng float64 `json:"lng"`
	Lat float64 `json:"lat"`

	_rawJSON json.RawMessage
}

func (l *LngLat) UnmarshalJSON(data []byte) error {
	type unmarshaler LngLat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LngLat(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LngLat) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Macros struct {
	// Amount of carbohydrates in grams (g)
	Carbs *float64 `json:"carbs,omitempty"`
	// Amount of protein in grams (g)
	Protein *float64 `json:"protein,omitempty"`
	// Details of fat content
	Fats *Fats `json:"fats,omitempty"`
	// Amount of alcohol in grams (g)
	Alcohol *float64 `json:"alcohol,omitempty"`
	// Amount of water in grams (g)
	Water *float64 `json:"water,omitempty"`
	// Amount of dietary fiber in grams (g)
	Fibre *float64 `json:"fibre,omitempty"`
	// Amount of sugar in grams (g)
	Sugar *float64 `json:"sugar,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Macros) UnmarshalJSON(data []byte) error {
	type unmarshaler Macros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Macros(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Macros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// An enumeration.
type ManualProviders string

const (
	ManualProvidersBeurerBle         ManualProviders = "beurer_ble"
	ManualProvidersOmronBle          ManualProviders = "omron_ble"
	ManualProvidersAccuchekBle       ManualProviders = "accuchek_ble"
	ManualProvidersContourBle        ManualProviders = "contour_ble"
	ManualProvidersFreestyleLibreBle ManualProviders = "freestyle_libre_ble"
	ManualProvidersOnetouchBle       ManualProviders = "onetouch_ble"
	ManualProvidersAppleHealthKit    ManualProviders = "apple_health_kit"
	ManualProvidersManual            ManualProviders = "manual"
	ManualProvidersHealthConnect     ManualProviders = "health_connect"
)

func NewManualProvidersFromString(s string) (ManualProviders, error) {
	switch s {
	case "beurer_ble":
		return ManualProvidersBeurerBle, nil
	case "omron_ble":
		return ManualProvidersOmronBle, nil
	case "accuchek_ble":
		return ManualProvidersAccuchekBle, nil
	case "contour_ble":
		return ManualProvidersContourBle, nil
	case "freestyle_libre_ble":
		return ManualProvidersFreestyleLibreBle, nil
	case "onetouch_ble":
		return ManualProvidersOnetouchBle, nil
	case "apple_health_kit":
		return ManualProvidersAppleHealthKit, nil
	case "manual":
		return ManualProvidersManual, nil
	case "health_connect":
		return ManualProvidersHealthConnect, nil
	}
	var t ManualProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManualProviders) Ptr() *ManualProviders {
	return &m
}

// An enumeration.
type MarkerType string

const (
	MarkerTypeBiomarker MarkerType = "biomarker"
	MarkerTypePanel     MarkerType = "panel"
)

func NewMarkerTypeFromString(s string) (MarkerType, error) {
	switch s {
	case "biomarker":
		return MarkerTypeBiomarker, nil
	case "panel":
		return MarkerTypePanel, nil
	}
	var t MarkerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MarkerType) Ptr() *MarkerType {
	return &m
}

type MealInDbBaseClientFacingSource struct {
	Id         string                       `json:"id"`
	UserId     string                       `json:"user_id"`
	PriorityId int                          `json:"priority_id"`
	SourceId   int                          `json:"source_id"`
	ProviderId string                       `json:"provider_id"`
	Timestamp  time.Time                    `json:"timestamp"`
	Name       string                       `json:"name"`
	Energy     *Energy                      `json:"energy,omitempty"`
	Macros     *Macros                      `json:"macros,omitempty"`
	Micros     *Micros                      `json:"micros,omitempty"`
	Data       map[string]*ClientFacingFood `json:"data,omitempty"`
	Source     *ClientFacingSource          `json:"source,omitempty"`
	CreatedAt  time.Time                    `json:"created_at"`
	UpdatedAt  time.Time                    `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (m *MealInDbBaseClientFacingSource) UnmarshalJSON(data []byte) error {
	type unmarshaler MealInDbBaseClientFacingSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MealInDbBaseClientFacingSource(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MealInDbBaseClientFacingSource) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetricsResult struct {
	TeamId                          string                   `json:"team_id"`
	NumberOfConnectedSources        *int                     `json:"number_of_connected_sources,omitempty"`
	NumberOfUsers                   *int                     `json:"number_of_users,omitempty"`
	NumberOfErroredConnectedSources *int                     `json:"number_of_errored_connected_sources,omitempty"`
	NumberOfConnectedSourcesByWeek  []*TimeseriesMetricPoint `json:"number_of_connected_sources_by_week,omitempty"`
	NumberOfOrderedTests            *int                     `json:"number_of_ordered_tests,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MetricsResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsResult(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsResult) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Micros struct {
	// Amount of each mineral in grams (g)
	Minerals map[string]float64 `json:"minerals,omitempty"`
	// Amount of each trace element in grams (g)
	TraceElements map[string]float64 `json:"trace_elements,omitempty"`
	// Amount of each vitamin in grams (g)
	Vitamins map[string]float64 `json:"vitamins,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Micros) UnmarshalJSON(data []byte) error {
	type unmarshaler Micros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Micros(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Micros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// An enumeration.
type OAuthProviders string

const (
	OAuthProvidersOura       OAuthProviders = "oura"
	OAuthProvidersFitbit     OAuthProviders = "fitbit"
	OAuthProvidersGarmin     OAuthProviders = "garmin"
	OAuthProvidersStrava     OAuthProviders = "strava"
	OAuthProvidersWahoo      OAuthProviders = "wahoo"
	OAuthProvidersIhealth    OAuthProviders = "ihealth"
	OAuthProvidersWithings   OAuthProviders = "withings"
	OAuthProvidersGoogleFit  OAuthProviders = "google_fit"
	OAuthProvidersDexcomV3   OAuthProviders = "dexcom_v3"
	OAuthProvidersPolar      OAuthProviders = "polar"
	OAuthProvidersCronometer OAuthProviders = "cronometer"
	OAuthProvidersOmron      OAuthProviders = "omron"
)

func NewOAuthProvidersFromString(s string) (OAuthProviders, error) {
	switch s {
	case "oura":
		return OAuthProvidersOura, nil
	case "fitbit":
		return OAuthProvidersFitbit, nil
	case "garmin":
		return OAuthProvidersGarmin, nil
	case "strava":
		return OAuthProvidersStrava, nil
	case "wahoo":
		return OAuthProvidersWahoo, nil
	case "ihealth":
		return OAuthProvidersIhealth, nil
	case "withings":
		return OAuthProvidersWithings, nil
	case "google_fit":
		return OAuthProvidersGoogleFit, nil
	case "dexcom_v3":
		return OAuthProvidersDexcomV3, nil
	case "polar":
		return OAuthProvidersPolar, nil
	case "cronometer":
		return OAuthProvidersCronometer, nil
	case "omron":
		return OAuthProvidersOmron, nil
	}
	var t OAuthProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OAuthProviders) Ptr() *OAuthProviders {
	return &o
}

// An enumeration.
type OrderStatus string

const (
	OrderStatusReceivedWalkInTestOrdered                            OrderStatus = "received.walk_in_test.ordered"
	OrderStatusReceivedWalkInTestRequisitionCreated                 OrderStatus = "received.walk_in_test.requisition_created"
	OrderStatusCompletedWalkInTestCompleted                         OrderStatus = "completed.walk_in_test.completed"
	OrderStatusSampleWithLabWalkInTestPartialResults                OrderStatus = "sample_with_lab.walk_in_test.partial_results"
	OrderStatusFailedWalkInTestSampleError                          OrderStatus = "failed.walk_in_test.sample_error"
	OrderStatusCancelledWalkInTestCancelled                         OrderStatus = "cancelled.walk_in_test.cancelled"
	OrderStatusReceivedAtHomePhlebotomyOrdered                      OrderStatus = "received.at_home_phlebotomy.ordered"
	OrderStatusReceivedAtHomePhlebotomyRequisitionCreated           OrderStatus = "received.at_home_phlebotomy.requisition_created"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_scheduled"
	OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted        OrderStatus = "collecting_sample.at_home_phlebotomy.draw_completed"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_cancelled"
	OrderStatusCompletedAtHomePhlebotomyCompleted                   OrderStatus = "completed.at_home_phlebotomy.completed"
	OrderStatusSampleWithLabAtHomePhlebotomyPartialResults          OrderStatus = "sample_with_lab.at_home_phlebotomy.partial_results"
	OrderStatusCancelledAtHomePhlebotomyCancelled                   OrderStatus = "cancelled.at_home_phlebotomy.cancelled"
	OrderStatusReceivedTestkitOrdered                               OrderStatus = "received.testkit.ordered"
	OrderStatusReceivedTestkitAwaitingRegistration                  OrderStatus = "received.testkit.awaiting_registration"
	OrderStatusReceivedTestkitRequisitionCreated                    OrderStatus = "received.testkit.requisition_created"
	OrderStatusReceivedTestkitRegistered                            OrderStatus = "received.testkit.registered"
	OrderStatusCollectingSampleTestkitTransitCustomer               OrderStatus = "collecting_sample.testkit.transit_customer"
	OrderStatusCollectingSampleTestkitOutForDelivery                OrderStatus = "collecting_sample.testkit.out_for_delivery"
	OrderStatusCollectingSampleTestkitWithCustomer                  OrderStatus = "collecting_sample.testkit.with_customer"
	OrderStatusCollectingSampleTestkitTransitLab                    OrderStatus = "collecting_sample.testkit.transit_lab"
	OrderStatusSampleWithLabTestkitDeliveredToLab                   OrderStatus = "sample_with_lab.testkit.delivered_to_lab"
	OrderStatusCompletedTestkitCompleted                            OrderStatus = "completed.testkit.completed"
	OrderStatusFailedTestkitFailureToDeliverToCustomer              OrderStatus = "failed.testkit.failure_to_deliver_to_customer"
	OrderStatusFailedTestkitFailureToDeliverToLab                   OrderStatus = "failed.testkit.failure_to_deliver_to_lab"
	OrderStatusFailedTestkitSampleError                             OrderStatus = "failed.testkit.sample_error"
	OrderStatusFailedTestkitLost                                    OrderStatus = "failed.testkit.lost"
	OrderStatusCancelledTestkitCancelled                            OrderStatus = "cancelled.testkit.cancelled"
	OrderStatusCancelledTestkitDoNotProcess                         OrderStatus = "cancelled.testkit.do_not_process"
)

func NewOrderStatusFromString(s string) (OrderStatus, error) {
	switch s {
	case "received.walk_in_test.ordered":
		return OrderStatusReceivedWalkInTestOrdered, nil
	case "received.walk_in_test.requisition_created":
		return OrderStatusReceivedWalkInTestRequisitionCreated, nil
	case "completed.walk_in_test.completed":
		return OrderStatusCompletedWalkInTestCompleted, nil
	case "sample_with_lab.walk_in_test.partial_results":
		return OrderStatusSampleWithLabWalkInTestPartialResults, nil
	case "failed.walk_in_test.sample_error":
		return OrderStatusFailedWalkInTestSampleError, nil
	case "cancelled.walk_in_test.cancelled":
		return OrderStatusCancelledWalkInTestCancelled, nil
	case "received.at_home_phlebotomy.ordered":
		return OrderStatusReceivedAtHomePhlebotomyOrdered, nil
	case "received.at_home_phlebotomy.requisition_created":
		return OrderStatusReceivedAtHomePhlebotomyRequisitionCreated, nil
	case "collecting_sample.at_home_phlebotomy.appointment_scheduled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled, nil
	case "collecting_sample.at_home_phlebotomy.draw_completed":
		return OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted, nil
	case "collecting_sample.at_home_phlebotomy.appointment_cancelled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled, nil
	case "completed.at_home_phlebotomy.completed":
		return OrderStatusCompletedAtHomePhlebotomyCompleted, nil
	case "sample_with_lab.at_home_phlebotomy.partial_results":
		return OrderStatusSampleWithLabAtHomePhlebotomyPartialResults, nil
	case "cancelled.at_home_phlebotomy.cancelled":
		return OrderStatusCancelledAtHomePhlebotomyCancelled, nil
	case "received.testkit.ordered":
		return OrderStatusReceivedTestkitOrdered, nil
	case "received.testkit.awaiting_registration":
		return OrderStatusReceivedTestkitAwaitingRegistration, nil
	case "received.testkit.requisition_created":
		return OrderStatusReceivedTestkitRequisitionCreated, nil
	case "received.testkit.registered":
		return OrderStatusReceivedTestkitRegistered, nil
	case "collecting_sample.testkit.transit_customer":
		return OrderStatusCollectingSampleTestkitTransitCustomer, nil
	case "collecting_sample.testkit.out_for_delivery":
		return OrderStatusCollectingSampleTestkitOutForDelivery, nil
	case "collecting_sample.testkit.with_customer":
		return OrderStatusCollectingSampleTestkitWithCustomer, nil
	case "collecting_sample.testkit.transit_lab":
		return OrderStatusCollectingSampleTestkitTransitLab, nil
	case "sample_with_lab.testkit.delivered_to_lab":
		return OrderStatusSampleWithLabTestkitDeliveredToLab, nil
	case "completed.testkit.completed":
		return OrderStatusCompletedTestkitCompleted, nil
	case "failed.testkit.failure_to_deliver_to_customer":
		return OrderStatusFailedTestkitFailureToDeliverToCustomer, nil
	case "failed.testkit.failure_to_deliver_to_lab":
		return OrderStatusFailedTestkitFailureToDeliverToLab, nil
	case "failed.testkit.sample_error":
		return OrderStatusFailedTestkitSampleError, nil
	case "failed.testkit.lost":
		return OrderStatusFailedTestkitLost, nil
	case "cancelled.testkit.cancelled":
		return OrderStatusCancelledTestkitCancelled, nil
	case "cancelled.testkit.do_not_process":
		return OrderStatusCancelledTestkitDoNotProcess, nil
	}
	var t OrderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderStatus) Ptr() *OrderStatus {
	return &o
}

// An enumeration.
type OrderTopLevelStatus string

const (
	OrderTopLevelStatusReceived         OrderTopLevelStatus = "received"
	OrderTopLevelStatusCollectingSample OrderTopLevelStatus = "collecting_sample"
	OrderTopLevelStatusSampleWithLab    OrderTopLevelStatus = "sample_with_lab"
	OrderTopLevelStatusCompleted        OrderTopLevelStatus = "completed"
	OrderTopLevelStatusCancelled        OrderTopLevelStatus = "cancelled"
	OrderTopLevelStatusFailed           OrderTopLevelStatus = "failed"
)

func NewOrderTopLevelStatusFromString(s string) (OrderTopLevelStatus, error) {
	switch s {
	case "received":
		return OrderTopLevelStatusReceived, nil
	case "collecting_sample":
		return OrderTopLevelStatusCollectingSample, nil
	case "sample_with_lab":
		return OrderTopLevelStatusSampleWithLab, nil
	case "completed":
		return OrderTopLevelStatusCompleted, nil
	case "cancelled":
		return OrderTopLevelStatusCancelled, nil
	case "failed":
		return OrderTopLevelStatusFailed, nil
	}
	var t OrderTopLevelStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderTopLevelStatus) Ptr() *OrderTopLevelStatus {
	return &o
}

type PaginatedUsersResponse struct {
	Users  []*ClientFacingUser `json:"users,omitempty"`
	Total  int                 `json:"total"`
	Offset int                 `json:"offset"`
	Limit  int                 `json:"limit"`

	_rawJSON json.RawMessage
}

func (p *PaginatedUsersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedUsersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedUsersResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedUsersResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An enumeration.
type PasswordProviders string

const (
	PasswordProvidersWhoop        PasswordProviders = "whoop"
	PasswordProvidersRenpho       PasswordProviders = "renpho"
	PasswordProvidersPeloton      PasswordProviders = "peloton"
	PasswordProvidersZwift        PasswordProviders = "zwift"
	PasswordProvidersEightSleep   PasswordProviders = "eight_sleep"
	PasswordProvidersBeurerApi    PasswordProviders = "beurer_api"
	PasswordProvidersDexcom       PasswordProviders = "dexcom"
	PasswordProvidersHammerhead   PasswordProviders = "hammerhead"
	PasswordProvidersMyFitnessPal PasswordProviders = "my_fitness_pal"
	PasswordProvidersKardia       PasswordProviders = "kardia"
)

func NewPasswordProvidersFromString(s string) (PasswordProviders, error) {
	switch s {
	case "whoop":
		return PasswordProvidersWhoop, nil
	case "renpho":
		return PasswordProvidersRenpho, nil
	case "peloton":
		return PasswordProvidersPeloton, nil
	case "zwift":
		return PasswordProvidersZwift, nil
	case "eight_sleep":
		return PasswordProvidersEightSleep, nil
	case "beurer_api":
		return PasswordProvidersBeurerApi, nil
	case "dexcom":
		return PasswordProvidersDexcom, nil
	case "hammerhead":
		return PasswordProvidersHammerhead, nil
	case "my_fitness_pal":
		return PasswordProvidersMyFitnessPal, nil
	case "kardia":
		return PasswordProvidersKardia, nil
	}
	var t PasswordProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PasswordProviders) Ptr() *PasswordProviders {
	return &p
}

type PatientAddressCompatible struct {
	ReceiverName *string `json:"receiver_name,omitempty"`
	Street       string  `json:"street"`
	StreetNumber *string `json:"street_number,omitempty"`
	City         string  `json:"city"`
	State        string  `json:"state"`
	Zip          string  `json:"zip"`
	Country      string  `json:"country"`
	PhoneNumber  *string `json:"phone_number,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatientAddressCompatible) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientAddressCompatible
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientAddressCompatible(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientAddressCompatible) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatientDetails struct {
	FirstName   string    `json:"first_name"`
	LastName    string    `json:"last_name"`
	Dob         time.Time `json:"dob"`
	Gender      Gender    `json:"gender,omitempty"`
	PhoneNumber string    `json:"phone_number"`
	Email       string    `json:"email"`

	_rawJSON json.RawMessage
}

func (p *PatientDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientDetails(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PersonDetails struct {
	FirstName   string   `json:"first_name"`
	LastName    string   `json:"last_name"`
	Address     *Address `json:"address,omitempty"`
	PhoneNumber string   `json:"phone_number"`
	PhoneType   *string  `json:"phone_type,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PersonDetails(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PersonDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhlebotomyAreaInfo struct {
	IsServed bool `json:"is_served"`

	_rawJSON json.RawMessage
}

func (p *PhlebotomyAreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhlebotomyAreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhlebotomyAreaInfo(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhlebotomyAreaInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianClientFacing struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Npi       string `json:"npi"`

	_rawJSON json.RawMessage
}

func (p *PhysicianClientFacing) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianClientFacing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianClientFacing(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianClientFacing) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequest struct {
	FirstName      string   `json:"first_name"`
	LastName       string   `json:"last_name"`
	Email          *string  `json:"email,omitempty"`
	Npi            string   `json:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty"`
	// An image of the physician signature for health insurance billing
	SignatureImage *PhysicianCreateRequestSignatureImage `json:"signature_image,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PhysicianCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequestBase struct {
	FirstName      string   `json:"first_name"`
	LastName       string   `json:"last_name"`
	Email          *string  `json:"email,omitempty"`
	Npi            string   `json:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PhysicianCreateRequestBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequestBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequestBase(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequestBase) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An image of the physician signature for health insurance billing
type PhysicianCreateRequestSignatureImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewPhysicianCreateRequestSignatureImageFromImageJpeg(value *Jpeg) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewPhysicianCreateRequestSignatureImageFromImagePng(value *Png) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{ContentType: "image/png", ImagePng: value}
}

func (p *PhysicianCreateRequestSignatureImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ImagePng = value
	}
	return nil
}

func (p PhysicianCreateRequestSignatureImage) MarshalJSON() ([]byte, error) {
	switch p.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.ContentType, p)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: p.ContentType,
			Jpeg:        p.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: p.ContentType,
			Png:         p.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type PhysicianCreateRequestSignatureImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (p *PhysicianCreateRequestSignatureImage) Accept(visitor PhysicianCreateRequestSignatureImageVisitor) error {
	switch p.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", p.ContentType, p)
	case "image/jpeg":
		return visitor.VisitImageJpeg(p.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(p.ImagePng)
	}
}

type Png struct {
	Content string `json:"content"`

	_rawJSON json.RawMessage
}

func (p *Png) UnmarshalJSON(data []byte) error {
	type unmarshaler Png
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Png(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Png) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostOrderResponse struct {
	Order   *ClientFacingOrder `json:"order,omitempty"`
	Status  string             `json:"status"`
	Message string             `json:"message"`

	_rawJSON json.RawMessage
}

func (p *PostOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostOrderResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostOrderResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileInDb struct {
	Data       *string               `json:"data,omitempty"`
	UserId     string                `json:"user_id"`
	SourceId   int                   `json:"source_id"`
	PriorityId *int                  `json:"priority_id,omitempty"`
	Id         string                `json:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty"`
	UpdatedAt  *time.Time            `json:"updated_at,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ProfileInDb) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileInDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileInDb(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileInDb) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderLinkResponse struct {
	Provider   PasswordProviders `json:"provider,omitempty"`
	Connected  bool              `json:"connected"`
	ProviderId *string           `json:"provider_id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ProviderLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderLinkResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderLinkResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An enumeration.
type Providers string

const (
	ProvidersOura              Providers = "oura"
	ProvidersFitbit            Providers = "fitbit"
	ProvidersGarmin            Providers = "garmin"
	ProvidersWhoop             Providers = "whoop"
	ProvidersStrava            Providers = "strava"
	ProvidersRenpho            Providers = "renpho"
	ProvidersPeloton           Providers = "peloton"
	ProvidersWahoo             Providers = "wahoo"
	ProvidersZwift             Providers = "zwift"
	ProvidersFreestyleLibre    Providers = "freestyle_libre"
	ProvidersFreestyleLibreBle Providers = "freestyle_libre_ble"
	ProvidersEightSleep        Providers = "eight_sleep"
	ProvidersWithings          Providers = "withings"
	ProvidersAppleHealthKit    Providers = "apple_health_kit"
	ProvidersManual            Providers = "manual"
	ProvidersIhealth           Providers = "ihealth"
	ProvidersGoogleFit         Providers = "google_fit"
	ProvidersBeurerApi         Providers = "beurer_api"
	ProvidersBeurerBle         Providers = "beurer_ble"
	ProvidersOmron             Providers = "omron"
	ProvidersOmronBle          Providers = "omron_ble"
	ProvidersOnetouchBle       Providers = "onetouch_ble"
	ProvidersAccuchekBle       Providers = "accuchek_ble"
	ProvidersContourBle        Providers = "contour_ble"
	ProvidersDexcom            Providers = "dexcom"
	ProvidersDexcomV3          Providers = "dexcom_v3"
	ProvidersHammerhead        Providers = "hammerhead"
	ProvidersMyFitnessPal      Providers = "my_fitness_pal"
	ProvidersHealthConnect     Providers = "health_connect"
	ProvidersPolar             Providers = "polar"
	ProvidersCronometer        Providers = "cronometer"
	ProvidersKardia            Providers = "kardia"
)

func NewProvidersFromString(s string) (Providers, error) {
	switch s {
	case "oura":
		return ProvidersOura, nil
	case "fitbit":
		return ProvidersFitbit, nil
	case "garmin":
		return ProvidersGarmin, nil
	case "whoop":
		return ProvidersWhoop, nil
	case "strava":
		return ProvidersStrava, nil
	case "renpho":
		return ProvidersRenpho, nil
	case "peloton":
		return ProvidersPeloton, nil
	case "wahoo":
		return ProvidersWahoo, nil
	case "zwift":
		return ProvidersZwift, nil
	case "freestyle_libre":
		return ProvidersFreestyleLibre, nil
	case "freestyle_libre_ble":
		return ProvidersFreestyleLibreBle, nil
	case "eight_sleep":
		return ProvidersEightSleep, nil
	case "withings":
		return ProvidersWithings, nil
	case "apple_health_kit":
		return ProvidersAppleHealthKit, nil
	case "manual":
		return ProvidersManual, nil
	case "ihealth":
		return ProvidersIhealth, nil
	case "google_fit":
		return ProvidersGoogleFit, nil
	case "beurer_api":
		return ProvidersBeurerApi, nil
	case "beurer_ble":
		return ProvidersBeurerBle, nil
	case "omron":
		return ProvidersOmron, nil
	case "omron_ble":
		return ProvidersOmronBle, nil
	case "onetouch_ble":
		return ProvidersOnetouchBle, nil
	case "accuchek_ble":
		return ProvidersAccuchekBle, nil
	case "contour_ble":
		return ProvidersContourBle, nil
	case "dexcom":
		return ProvidersDexcom, nil
	case "dexcom_v3":
		return ProvidersDexcomV3, nil
	case "hammerhead":
		return ProvidersHammerhead, nil
	case "my_fitness_pal":
		return ProvidersMyFitnessPal, nil
	case "health_connect":
		return ProvidersHealthConnect, nil
	case "polar":
		return ProvidersPolar, nil
	case "cronometer":
		return ProvidersCronometer, nil
	case "kardia":
		return ProvidersKardia, nil
	}
	var t Providers
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Providers) Ptr() *Providers {
	return &p
}

type RawActivity struct {
	Activity []*ActivityV2InDb `json:"activity,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler RawActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawActivity(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawActivity) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawBody struct {
	Body []*BodyV2InDb `json:"body,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawBody) UnmarshalJSON(data []byte) error {
	type unmarshaler RawBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawBody(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawDevices struct {
	Devices []*DeviceV2InDb `json:"devices,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawDevices) UnmarshalJSON(data []byte) error {
	type unmarshaler RawDevices
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawDevices(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawDevices) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawProfile struct {
	Profile *ProfileInDb `json:"profile,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler RawProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawProfile(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawProfile) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawSleep struct {
	Sleep []*SleepV2InDb `json:"sleep,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawSleep) UnmarshalJSON(data []byte) error {
	type unmarshaler RawSleep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawSleep(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawSleep) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawWorkout struct {
	Workouts []*WorkoutV2InDb `json:"workouts,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawWorkout) UnmarshalJSON(data []byte) error {
	type unmarshaler RawWorkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawWorkout(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawWorkout) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// An enumeration.
type Region string

const (
	RegionUs Region = "us"
	RegionEu Region = "eu"
	RegionSg Region = "sg"
	RegionDe Region = "de"
	RegionAu Region = "au"
	RegionBr Region = "br"
	RegionNl Region = "nl"
	RegionFr Region = "fr"
	RegionCa Region = "ca"
)

func NewRegionFromString(s string) (Region, error) {
	switch s {
	case "us":
		return RegionUs, nil
	case "eu":
		return RegionEu, nil
	case "sg":
		return RegionSg, nil
	case "de":
		return RegionDe, nil
	case "au":
		return RegionAu, nil
	case "br":
		return RegionBr, nil
	case "nl":
		return RegionNl, nil
	case "fr":
		return RegionFr, nil
	case "ca":
		return RegionCa, nil
	}
	var t Region
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Region) Ptr() *Region {
	return &r
}

// An enumeration.
type ResponsibleRelationship string

const (
	ResponsibleRelationshipSelf              ResponsibleRelationship = "Self"
	ResponsibleRelationshipSpouse            ResponsibleRelationship = "Spouse"
	ResponsibleRelationshipOtherRelationship ResponsibleRelationship = "Other Relationship"
)

func NewResponsibleRelationshipFromString(s string) (ResponsibleRelationship, error) {
	switch s {
	case "Self":
		return ResponsibleRelationshipSelf, nil
	case "Spouse":
		return ResponsibleRelationshipSpouse, nil
	case "Other Relationship":
		return ResponsibleRelationshipOtherRelationship, nil
	}
	var t ResponsibleRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponsibleRelationship) Ptr() *ResponsibleRelationship {
	return &r
}

// An enumeration.
type ResultType string

const (
	ResultTypeNumeric ResultType = "numeric"
	ResultTypeRange   ResultType = "range"
	ResultTypeComment ResultType = "comment"
)

func NewResultTypeFromString(s string) (ResultType, error) {
	switch s {
	case "numeric":
		return ResultTypeNumeric, nil
	case "range":
		return ResultTypeRange, nil
	case "comment":
		return ResultTypeComment, nil
	}
	var t ResultType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResultType) Ptr() *ResultType {
	return &r
}

type ShippingAddress struct {
	ReceiverName string  `json:"receiver_name"`
	FirstLine    string  `json:"first_line"`
	SecondLine   *string `json:"second_line,omitempty"`
	City         string  `json:"city"`
	State        string  `json:"state"`
	Zip          string  `json:"zip"`
	Country      string  `json:"country"`
	PhoneNumber  string  `json:"phone_number"`

	_rawJSON json.RawMessage
}

func (s *ShippingAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingAddress(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingAddress) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepV2InDb struct {
	Timestamp  time.Time             `json:"timestamp"`
	Data       *string               `json:"data,omitempty"`
	ProviderId string                `json:"provider_id"`
	UserId     string                `json:"user_id"`
	SourceId   int                   `json:"source_id"`
	PriorityId *int                  `json:"priority_id,omitempty"`
	Id         string                `json:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty"`
	Priority   *int                  `json:"priority,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SleepV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler SleepV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SleepV2InDb(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepV2InDb) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Source struct {
	Name            string          `json:"name"`
	Slug            string          `json:"slug"`
	Description     string          `json:"description"`
	Logo            string          `json:"logo"`
	Group           *string         `json:"group,omitempty"`
	OauthUrl        *string         `json:"oauth_url,omitempty"`
	AuthType        *SourceAuthType `json:"auth_type,omitempty"`
	SourceType      *SourceType     `json:"source_type,omitempty"`
	IsActive        *bool           `json:"is_active,omitempty"`
	BackfillNumDays *int            `json:"backfill_num_days,omitempty"`
	Id              int             `json:"id"`

	_rawJSON json.RawMessage
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// An enumeration.
type SourceAuthType string

const (
	SourceAuthTypeOauth     SourceAuthType = "oauth"
	SourceAuthTypeTeamOauth SourceAuthType = "team_oauth"
	SourceAuthTypeSdk       SourceAuthType = "sdk"
	SourceAuthTypePassword  SourceAuthType = "password"
	SourceAuthTypeEmail     SourceAuthType = "email"
	SourceAuthTypeApp       SourceAuthType = "app"
	SourceAuthTypeEmpty     SourceAuthType = ""
)

func NewSourceAuthTypeFromString(s string) (SourceAuthType, error) {
	switch s {
	case "oauth":
		return SourceAuthTypeOauth, nil
	case "team_oauth":
		return SourceAuthTypeTeamOauth, nil
	case "sdk":
		return SourceAuthTypeSdk, nil
	case "password":
		return SourceAuthTypePassword, nil
	case "email":
		return SourceAuthTypeEmail, nil
	case "app":
		return SourceAuthTypeApp, nil
	case "":
		return SourceAuthTypeEmpty, nil
	}
	var t SourceAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAuthType) Ptr() *SourceAuthType {
	return &s
}

type SourceLink struct {
	Id             int                    `json:"id"`
	Name           string                 `json:"name"`
	Slug           string                 `json:"slug"`
	Description    string                 `json:"description"`
	Logo           string                 `json:"logo"`
	OauthUrl       *string                `json:"oauth_url,omitempty"`
	AuthType       *SourceAuthType        `json:"auth_type,omitempty"`
	FormComponents map[string]interface{} `json:"form_components,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SourceLink) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceLink(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceLink) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// An enumeration.
type SourceType string

const (
	SourceTypeApp      SourceType = "app"
	SourceTypeBle      SourceType = "ble"
	SourceTypeDevice   SourceType = "device"
	SourceTypeLab      SourceType = "lab"
	SourceTypeProvider SourceType = "provider"
)

func NewSourceTypeFromString(s string) (SourceType, error) {
	switch s {
	case "app":
		return SourceTypeApp, nil
	case "ble":
		return SourceTypeBle, nil
	case "device":
		return SourceTypeDevice, nil
	case "lab":
		return SourceTypeLab, nil
	case "provider":
		return SourceTypeProvider, nil
	}
	var t SourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceType) Ptr() *SourceType {
	return &s
}

type TeamConfig struct {
	Libreview    *LibreConfig `json:"libreview,omitempty"`
	TextsEnabled *bool        `json:"texts_enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TeamConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamConfig(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamConfig) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeSlot struct {
	BookingKey *string `json:"booking_key,omitempty"`
	// Time is in UTC
	Start time.Time `json:"start"`
	// Time is in UTC
	End                      time.Time  `json:"end"`
	ExpiresAt                *time.Time `json:"expires_at,omitempty"`
	Price                    float64    `json:"price"`
	IsPriority               bool       `json:"is_priority"`
	NumAppointmentsAvailable int        `json:"num_appointments_available"`

	_rawJSON json.RawMessage
}

func (t *TimeSlot) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeSlot
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeSlot(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeSlot) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeseriesMetricPoint struct {
	Date  time.Time `json:"date"`
	Value float64   `json:"value"`

	_rawJSON json.RawMessage
}

func (t *TimeseriesMetricPoint) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeseriesMetricPoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeseriesMetricPoint(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeseriesMetricPoint) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// An enumeration.
type TimeseriesResource string

const (
	TimeseriesResourceCaloriesActive           TimeseriesResource = "calories_active"
	TimeseriesResourceCaloriesBasal            TimeseriesResource = "calories_basal"
	TimeseriesResourceDistance                 TimeseriesResource = "distance"
	TimeseriesResourceBloodOxygen              TimeseriesResource = "blood_oxygen"
	TimeseriesResourceBloodPressure            TimeseriesResource = "blood_pressure"
	TimeseriesResourceBodyFat                  TimeseriesResource = "body/fat"
	TimeseriesResourceBodyWeight               TimeseriesResource = "body/weight"
	TimeseriesResourceCholesterol              TimeseriesResource = "cholesterol"
	TimeseriesResourceCholesterolLdl           TimeseriesResource = "cholesterol/ldl"
	TimeseriesResourceCholesterolHdl           TimeseriesResource = "cholesterol/hdl"
	TimeseriesResourceCholesterolTotal         TimeseriesResource = "cholesterol/total"
	TimeseriesResourceCholesterolTriglycerides TimeseriesResource = "cholesterol/triglycerides"
	TimeseriesResourceElectrocardiogramVoltage TimeseriesResource = "electrocardiogram_voltage"
	TimeseriesResourceFloorsClimbed            TimeseriesResource = "floors_climbed"
	TimeseriesResourceGlucose                  TimeseriesResource = "glucose"
	TimeseriesResourceHeartrate                TimeseriesResource = "heartrate"
	TimeseriesResourceHrv                      TimeseriesResource = "hrv"
	TimeseriesResourceHeartrateVariability     TimeseriesResource = "heartrate_variability"
	TimeseriesResourceHypnogram                TimeseriesResource = "hypnogram"
	TimeseriesResourceIge                      TimeseriesResource = "ige"
	TimeseriesResourceIgg                      TimeseriesResource = "igg"
	TimeseriesResourceRespiratoryRate          TimeseriesResource = "respiratory_rate"
	TimeseriesResourceSteps                    TimeseriesResource = "steps"
	TimeseriesResourceStressLevel              TimeseriesResource = "stress_level"
	TimeseriesResourceVo2Max                   TimeseriesResource = "vo2_max"
	TimeseriesResourceWater                    TimeseriesResource = "water"
	TimeseriesResourceCaffeine                 TimeseriesResource = "caffeine"
	TimeseriesResourceMindfulnessMinutes       TimeseriesResource = "mindfulness_minutes"
)

func NewTimeseriesResourceFromString(s string) (TimeseriesResource, error) {
	switch s {
	case "calories_active":
		return TimeseriesResourceCaloriesActive, nil
	case "calories_basal":
		return TimeseriesResourceCaloriesBasal, nil
	case "distance":
		return TimeseriesResourceDistance, nil
	case "blood_oxygen":
		return TimeseriesResourceBloodOxygen, nil
	case "blood_pressure":
		return TimeseriesResourceBloodPressure, nil
	case "body/fat":
		return TimeseriesResourceBodyFat, nil
	case "body/weight":
		return TimeseriesResourceBodyWeight, nil
	case "cholesterol":
		return TimeseriesResourceCholesterol, nil
	case "cholesterol/ldl":
		return TimeseriesResourceCholesterolLdl, nil
	case "cholesterol/hdl":
		return TimeseriesResourceCholesterolHdl, nil
	case "cholesterol/total":
		return TimeseriesResourceCholesterolTotal, nil
	case "cholesterol/triglycerides":
		return TimeseriesResourceCholesterolTriglycerides, nil
	case "electrocardiogram_voltage":
		return TimeseriesResourceElectrocardiogramVoltage, nil
	case "floors_climbed":
		return TimeseriesResourceFloorsClimbed, nil
	case "glucose":
		return TimeseriesResourceGlucose, nil
	case "heartrate":
		return TimeseriesResourceHeartrate, nil
	case "hrv":
		return TimeseriesResourceHrv, nil
	case "heartrate_variability":
		return TimeseriesResourceHeartrateVariability, nil
	case "hypnogram":
		return TimeseriesResourceHypnogram, nil
	case "ige":
		return TimeseriesResourceIge, nil
	case "igg":
		return TimeseriesResourceIgg, nil
	case "respiratory_rate":
		return TimeseriesResourceRespiratoryRate, nil
	case "steps":
		return TimeseriesResourceSteps, nil
	case "stress_level":
		return TimeseriesResourceStressLevel, nil
	case "vo2_max":
		return TimeseriesResourceVo2Max, nil
	case "water":
		return TimeseriesResourceWater, nil
	case "caffeine":
		return TimeseriesResourceCaffeine, nil
	case "mindfulness_minutes":
		return TimeseriesResourceMindfulnessMinutes, nil
	}
	var t TimeseriesResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeseriesResource) Ptr() *TimeseriesResource {
	return &t
}

type UsAddress struct {
	FirstLine  string  `json:"first_line"`
	SecondLine *string `json:"second_line,omitempty"`
	City       string  `json:"city"`
	State      string  `json:"state"`
	ZipCode    string  `json:"zip_code"`
	// Deprecated. Use `second_line` instead to provide the unit number. Subject to removal after 20 Nov 2023.
	Unit *string `json:"unit,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UsAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler UsAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsAddress(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsAddress) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshErrorResponse struct {
	// Whether operation was successful or not
	Success string `json:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId        string   `json:"user_id"`
	Error         string   `json:"error"`
	FailedSources []string `json:"failed_sources,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserRefreshErrorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshErrorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshErrorResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshErrorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshSuccessResponse struct {
	// Whether operation was successful or not
	Success string `json:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId           string   `json:"user_id"`
	RefreshedSources []string `json:"refreshed_sources,omitempty"`
	FailedSources    []string `json:"failed_sources,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserRefreshSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshSuccessResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSignInToken struct {
	PublicKey string `json:"public_key"`
	UserToken string `json:"user_token"`

	_rawJSON json.RawMessage
}

func (u *UserSignInToken) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSignInToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSignInToken(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSignInToken) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSignInTokenResponse struct {
	UserId      string                              `json:"user_id"`
	SignInToken *UserSignInTokenResponseSignInToken `json:"sign_in_token,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserSignInTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSignInTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSignInTokenResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSignInTokenResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSignInTokenResponseSignInToken struct {
	typeName        string
	UserSignInToken *UserSignInToken
	String          string
}

func NewUserSignInTokenResponseSignInTokenFromUserSignInToken(value *UserSignInToken) *UserSignInTokenResponseSignInToken {
	return &UserSignInTokenResponseSignInToken{typeName: "userSignInToken", UserSignInToken: value}
}

func NewUserSignInTokenResponseSignInTokenFromString(value string) *UserSignInTokenResponseSignInToken {
	return &UserSignInTokenResponseSignInToken{typeName: "string", String: value}
}

func (u *UserSignInTokenResponseSignInToken) UnmarshalJSON(data []byte) error {
	valueUserSignInToken := new(UserSignInToken)
	if err := json.Unmarshal(data, &valueUserSignInToken); err == nil {
		u.typeName = "userSignInToken"
		u.UserSignInToken = valueUserSignInToken
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserSignInTokenResponseSignInToken) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "userSignInToken":
		return json.Marshal(u.UserSignInToken)
	case "string":
		return json.Marshal(u.String)
	}
}

type UserSignInTokenResponseSignInTokenVisitor interface {
	VisitUserSignInToken(*UserSignInToken) error
	VisitString(string) error
}

func (u *UserSignInTokenResponseSignInToken) Accept(visitor UserSignInTokenResponseSignInTokenVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "userSignInToken":
		return visitor.VisitUserSignInToken(u.UserSignInToken)
	case "string":
		return visitor.VisitString(u.String)
	}
}

type UserSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success"`

	_rawJSON json.RawMessage
}

func (u *UserSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSuccessResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty"`
	Msg  string                    `json:"msg"`
	Type string                    `json:"type"`

	_rawJSON json.RawMessage
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	typeName string
	String   string
	Integer  int
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "string", String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "integer", Integer: value}
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.typeName = "integer"
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "integer":
		return json.Marshal(v.Integer)
	}
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "integer":
		return visitor.VisitInteger(v.Integer)
	}
}

type VitalTokenCreatedResponse struct {
	Code        string `json:"code"`
	ExchangeUrl string `json:"exchange_url"`

	_rawJSON json.RawMessage
}

func (v *VitalTokenCreatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalTokenCreatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalTokenCreatedResponse(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalTokenCreatedResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WorkoutV2InDb struct {
	Timestamp  time.Time             `json:"timestamp"`
	Data       *string               `json:"data,omitempty"`
	ProviderId string                `json:"provider_id"`
	UserId     string                `json:"user_id"`
	SourceId   int                   `json:"source_id"`
	PriorityId *int                  `json:"priority_id,omitempty"`
	Id         string                `json:"id"`
	SportId    int                   `json:"sport_id"`
	Source     *ClientFacingProvider `json:"source,omitempty"`
	Sport      *ClientFacingSport    `json:"sport,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WorkoutV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkoutV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkoutV2InDb(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutV2InDb) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
