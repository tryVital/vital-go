// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/tryVital/vital-go/core"
	time "time"
)

type ActivityColumnExpr struct {
	Activity ActivityColumnExprActivity `json:"activity" url:"activity"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActivityColumnExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActivityColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivityColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivityColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityColumnExpr) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActivityColumnExprActivity string

const (
	ActivityColumnExprActivityDate                     ActivityColumnExprActivity = "date"
	ActivityColumnExprActivityCaloriesTotal            ActivityColumnExprActivity = "calories_total"
	ActivityColumnExprActivityCaloriesActive           ActivityColumnExprActivity = "calories_active"
	ActivityColumnExprActivitySteps                    ActivityColumnExprActivity = "steps"
	ActivityColumnExprActivityDistanceMeter            ActivityColumnExprActivity = "distance_meter"
	ActivityColumnExprActivityFloorsClimbed            ActivityColumnExprActivity = "floors_climbed"
	ActivityColumnExprActivityDurationActiveSecond     ActivityColumnExprActivity = "duration_active_second"
	ActivityColumnExprActivityIntensitySedentarySecond ActivityColumnExprActivity = "intensity_sedentary_second"
	ActivityColumnExprActivityIntensityLowSecond       ActivityColumnExprActivity = "intensity_low_second"
	ActivityColumnExprActivityIntensityMediumSecond    ActivityColumnExprActivity = "intensity_medium_second"
	ActivityColumnExprActivityIntensityHighSecond      ActivityColumnExprActivity = "intensity_high_second"
	ActivityColumnExprActivityHeartRateMean            ActivityColumnExprActivity = "heart_rate_mean"
	ActivityColumnExprActivityHeartRateMinimum         ActivityColumnExprActivity = "heart_rate_minimum"
	ActivityColumnExprActivityHeartRateMaximum         ActivityColumnExprActivity = "heart_rate_maximum"
	ActivityColumnExprActivityHeartRateResting         ActivityColumnExprActivity = "heart_rate_resting"
	ActivityColumnExprActivitySourceType               ActivityColumnExprActivity = "source_type"
	ActivityColumnExprActivitySourceProvider           ActivityColumnExprActivity = "source_provider"
	ActivityColumnExprActivitySourceAppId              ActivityColumnExprActivity = "source_app_id"
)

func NewActivityColumnExprActivityFromString(s string) (ActivityColumnExprActivity, error) {
	switch s {
	case "date":
		return ActivityColumnExprActivityDate, nil
	case "calories_total":
		return ActivityColumnExprActivityCaloriesTotal, nil
	case "calories_active":
		return ActivityColumnExprActivityCaloriesActive, nil
	case "steps":
		return ActivityColumnExprActivitySteps, nil
	case "distance_meter":
		return ActivityColumnExprActivityDistanceMeter, nil
	case "floors_climbed":
		return ActivityColumnExprActivityFloorsClimbed, nil
	case "duration_active_second":
		return ActivityColumnExprActivityDurationActiveSecond, nil
	case "intensity_sedentary_second":
		return ActivityColumnExprActivityIntensitySedentarySecond, nil
	case "intensity_low_second":
		return ActivityColumnExprActivityIntensityLowSecond, nil
	case "intensity_medium_second":
		return ActivityColumnExprActivityIntensityMediumSecond, nil
	case "intensity_high_second":
		return ActivityColumnExprActivityIntensityHighSecond, nil
	case "heart_rate_mean":
		return ActivityColumnExprActivityHeartRateMean, nil
	case "heart_rate_minimum":
		return ActivityColumnExprActivityHeartRateMinimum, nil
	case "heart_rate_maximum":
		return ActivityColumnExprActivityHeartRateMaximum, nil
	case "heart_rate_resting":
		return ActivityColumnExprActivityHeartRateResting, nil
	case "source_type":
		return ActivityColumnExprActivitySourceType, nil
	case "source_provider":
		return ActivityColumnExprActivitySourceProvider, nil
	case "source_app_id":
		return ActivityColumnExprActivitySourceAppId, nil
	}
	var t ActivityColumnExprActivity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActivityColumnExprActivity) Ptr() *ActivityColumnExprActivity {
	return &a
}

type ActivityV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId int                    `json:"priority_id" url:"priority_id"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActivityV2InDb) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActivityV2InDb) UnmarshalJSON(data []byte) error {
	type embed ActivityV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActivityV2InDb(unmarshaler.embed)
	a.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityV2InDb) MarshalJSON() ([]byte, error) {
	type embed ActivityV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*a),
		Timestamp: core.NewDateTime(a.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (a *ActivityV2InDb) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AddOnOrder struct {
	MarkerIds   []int    `json:"marker_ids,omitempty" url:"marker_ids,omitempty"`
	ProviderIds []string `json:"provider_ids,omitempty" url:"provider_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddOnOrder) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddOnOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler AddOnOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddOnOrder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddOnOrder) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Address struct {
	FirstLine  string  `json:"first_line" url:"first_line"`
	SecondLine *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	Country    string  `json:"country" url:"country"`
	Zip        string  `json:"zip" url:"zip"`
	City       string  `json:"city" url:"city"`
	State      string  `json:"state" url:"state"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AggregateExpr struct {
	Arg  *AggregateExprArg `json:"arg,omitempty" url:"arg,omitempty"`
	Func AggregateExprFunc `json:"func" url:"func"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AggregateExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregateExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregateExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregateExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregateExpr) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AggregateExprArg struct {
	SleepColumnExpr            *SleepColumnExpr
	ActivityColumnExpr         *ActivityColumnExpr
	WorkoutColumnExpr          *WorkoutColumnExpr
	BodyColumnExpr             *BodyColumnExpr
	IndexColumnExpr            *IndexColumnExpr
	GroupKeyColumnExpr         *GroupKeyColumnExpr
	SleepScoreValueMacroExpr   *SleepScoreValueMacroExpr
	ChronotypeValueMacroExpr   *ChronotypeValueMacroExpr
	UnrecognizedValueMacroExpr *UnrecognizedValueMacroExpr
}

func NewAggregateExprArgFromSleepColumnExpr(value *SleepColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{SleepColumnExpr: value}
}

func NewAggregateExprArgFromActivityColumnExpr(value *ActivityColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{ActivityColumnExpr: value}
}

func NewAggregateExprArgFromWorkoutColumnExpr(value *WorkoutColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{WorkoutColumnExpr: value}
}

func NewAggregateExprArgFromBodyColumnExpr(value *BodyColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{BodyColumnExpr: value}
}

func NewAggregateExprArgFromIndexColumnExpr(value *IndexColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{IndexColumnExpr: value}
}

func NewAggregateExprArgFromGroupKeyColumnExpr(value *GroupKeyColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{GroupKeyColumnExpr: value}
}

func NewAggregateExprArgFromSleepScoreValueMacroExpr(value *SleepScoreValueMacroExpr) *AggregateExprArg {
	return &AggregateExprArg{SleepScoreValueMacroExpr: value}
}

func NewAggregateExprArgFromChronotypeValueMacroExpr(value *ChronotypeValueMacroExpr) *AggregateExprArg {
	return &AggregateExprArg{ChronotypeValueMacroExpr: value}
}

func NewAggregateExprArgFromUnrecognizedValueMacroExpr(value *UnrecognizedValueMacroExpr) *AggregateExprArg {
	return &AggregateExprArg{UnrecognizedValueMacroExpr: value}
}

func (a *AggregateExprArg) UnmarshalJSON(data []byte) error {
	valueSleepColumnExpr := new(SleepColumnExpr)
	if err := json.Unmarshal(data, &valueSleepColumnExpr); err == nil {
		a.SleepColumnExpr = valueSleepColumnExpr
		return nil
	}
	valueActivityColumnExpr := new(ActivityColumnExpr)
	if err := json.Unmarshal(data, &valueActivityColumnExpr); err == nil {
		a.ActivityColumnExpr = valueActivityColumnExpr
		return nil
	}
	valueWorkoutColumnExpr := new(WorkoutColumnExpr)
	if err := json.Unmarshal(data, &valueWorkoutColumnExpr); err == nil {
		a.WorkoutColumnExpr = valueWorkoutColumnExpr
		return nil
	}
	valueBodyColumnExpr := new(BodyColumnExpr)
	if err := json.Unmarshal(data, &valueBodyColumnExpr); err == nil {
		a.BodyColumnExpr = valueBodyColumnExpr
		return nil
	}
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		a.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valueGroupKeyColumnExpr := new(GroupKeyColumnExpr)
	if err := json.Unmarshal(data, &valueGroupKeyColumnExpr); err == nil {
		a.GroupKeyColumnExpr = valueGroupKeyColumnExpr
		return nil
	}
	valueSleepScoreValueMacroExpr := new(SleepScoreValueMacroExpr)
	if err := json.Unmarshal(data, &valueSleepScoreValueMacroExpr); err == nil {
		a.SleepScoreValueMacroExpr = valueSleepScoreValueMacroExpr
		return nil
	}
	valueChronotypeValueMacroExpr := new(ChronotypeValueMacroExpr)
	if err := json.Unmarshal(data, &valueChronotypeValueMacroExpr); err == nil {
		a.ChronotypeValueMacroExpr = valueChronotypeValueMacroExpr
		return nil
	}
	valueUnrecognizedValueMacroExpr := new(UnrecognizedValueMacroExpr)
	if err := json.Unmarshal(data, &valueUnrecognizedValueMacroExpr); err == nil {
		a.UnrecognizedValueMacroExpr = valueUnrecognizedValueMacroExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AggregateExprArg) MarshalJSON() ([]byte, error) {
	if a.SleepColumnExpr != nil {
		return json.Marshal(a.SleepColumnExpr)
	}
	if a.ActivityColumnExpr != nil {
		return json.Marshal(a.ActivityColumnExpr)
	}
	if a.WorkoutColumnExpr != nil {
		return json.Marshal(a.WorkoutColumnExpr)
	}
	if a.BodyColumnExpr != nil {
		return json.Marshal(a.BodyColumnExpr)
	}
	if a.IndexColumnExpr != nil {
		return json.Marshal(a.IndexColumnExpr)
	}
	if a.GroupKeyColumnExpr != nil {
		return json.Marshal(a.GroupKeyColumnExpr)
	}
	if a.SleepScoreValueMacroExpr != nil {
		return json.Marshal(a.SleepScoreValueMacroExpr)
	}
	if a.ChronotypeValueMacroExpr != nil {
		return json.Marshal(a.ChronotypeValueMacroExpr)
	}
	if a.UnrecognizedValueMacroExpr != nil {
		return json.Marshal(a.UnrecognizedValueMacroExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregateExprArgVisitor interface {
	VisitSleepColumnExpr(*SleepColumnExpr) error
	VisitActivityColumnExpr(*ActivityColumnExpr) error
	VisitWorkoutColumnExpr(*WorkoutColumnExpr) error
	VisitBodyColumnExpr(*BodyColumnExpr) error
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitGroupKeyColumnExpr(*GroupKeyColumnExpr) error
	VisitSleepScoreValueMacroExpr(*SleepScoreValueMacroExpr) error
	VisitChronotypeValueMacroExpr(*ChronotypeValueMacroExpr) error
	VisitUnrecognizedValueMacroExpr(*UnrecognizedValueMacroExpr) error
}

func (a *AggregateExprArg) Accept(visitor AggregateExprArgVisitor) error {
	if a.SleepColumnExpr != nil {
		return visitor.VisitSleepColumnExpr(a.SleepColumnExpr)
	}
	if a.ActivityColumnExpr != nil {
		return visitor.VisitActivityColumnExpr(a.ActivityColumnExpr)
	}
	if a.WorkoutColumnExpr != nil {
		return visitor.VisitWorkoutColumnExpr(a.WorkoutColumnExpr)
	}
	if a.BodyColumnExpr != nil {
		return visitor.VisitBodyColumnExpr(a.BodyColumnExpr)
	}
	if a.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(a.IndexColumnExpr)
	}
	if a.GroupKeyColumnExpr != nil {
		return visitor.VisitGroupKeyColumnExpr(a.GroupKeyColumnExpr)
	}
	if a.SleepScoreValueMacroExpr != nil {
		return visitor.VisitSleepScoreValueMacroExpr(a.SleepScoreValueMacroExpr)
	}
	if a.ChronotypeValueMacroExpr != nil {
		return visitor.VisitChronotypeValueMacroExpr(a.ChronotypeValueMacroExpr)
	}
	if a.UnrecognizedValueMacroExpr != nil {
		return visitor.VisitUnrecognizedValueMacroExpr(a.UnrecognizedValueMacroExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregateExprFunc string

const (
	AggregateExprFuncMean   AggregateExprFunc = "mean"
	AggregateExprFuncMin    AggregateExprFunc = "min"
	AggregateExprFuncMax    AggregateExprFunc = "max"
	AggregateExprFuncSum    AggregateExprFunc = "sum"
	AggregateExprFuncCount  AggregateExprFunc = "count"
	AggregateExprFuncMedian AggregateExprFunc = "median"
	AggregateExprFuncStddev AggregateExprFunc = "stddev"
	AggregateExprFuncOldest AggregateExprFunc = "oldest"
	AggregateExprFuncNewest AggregateExprFunc = "newest"
)

func NewAggregateExprFuncFromString(s string) (AggregateExprFunc, error) {
	switch s {
	case "mean":
		return AggregateExprFuncMean, nil
	case "min":
		return AggregateExprFuncMin, nil
	case "max":
		return AggregateExprFuncMax, nil
	case "sum":
		return AggregateExprFuncSum, nil
	case "count":
		return AggregateExprFuncCount, nil
	case "median":
		return AggregateExprFuncMedian, nil
	case "stddev":
		return AggregateExprFuncStddev, nil
	case "oldest":
		return AggregateExprFuncOldest, nil
	case "newest":
		return AggregateExprFuncNewest, nil
	}
	var t AggregateExprFunc
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregateExprFunc) Ptr() *AggregateExprFunc {
	return &a
}

// Maps miles to meters
type AllowedRadius string

const (
	AllowedRadiusTen        AllowedRadius = "10"
	AllowedRadiusTwenty     AllowedRadius = "20"
	AllowedRadiusTwentyFive AllowedRadius = "25"
	AllowedRadiusFifty      AllowedRadius = "50"
)

func NewAllowedRadiusFromString(s string) (AllowedRadius, error) {
	switch s {
	case "10":
		return AllowedRadiusTen, nil
	case "20":
		return AllowedRadiusTwenty, nil
	case "25":
		return AllowedRadiusTwentyFive, nil
	case "50":
		return AllowedRadiusFifty, nil
	}
	var t AllowedRadius
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AllowedRadius) Ptr() *AllowedRadius {
	return &a
}

type Answer struct {
	Id    int    `json:"id" url:"id"`
	Code  string `json:"code" url:"code"`
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Answer) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Answer) UnmarshalJSON(data []byte) error {
	type unmarshaler Answer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Answer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Answer) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AoE struct {
	Questions []*Question `json:"questions,omitempty" url:"questions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AoE) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AoE) UnmarshalJSON(data []byte) error {
	type unmarshaler AoE
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AoE(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AoE) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AoEAnswer struct {
	MarkerId   int    `json:"marker_id" url:"marker_id"`
	QuestionId int    `json:"question_id" url:"question_id"`
	Answer     string `json:"answer" url:"answer"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AoEAnswer) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AoEAnswer) UnmarshalJSON(data []byte) error {
	type unmarshaler AoEAnswer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AoEAnswer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AoEAnswer) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentAvailabilitySlots struct {
	Slots    []*DaySlots `json:"slots,omitempty" url:"slots,omitempty"`
	Timezone *string     `json:"timezone,omitempty" url:"timezone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentAvailabilitySlots) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentAvailabilitySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentAvailabilitySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentAvailabilitySlots(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentAvailabilitySlots) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentBookingRequest struct {
	BookingKey string `json:"booking_key" url:"booking_key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentBookingRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentBookingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentBookingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentBookingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentBookingRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentEventStatus string

const (
	AppointmentEventStatusPending    AppointmentEventStatus = "pending"
	AppointmentEventStatusScheduled  AppointmentEventStatus = "scheduled"
	AppointmentEventStatusCompleted  AppointmentEventStatus = "completed"
	AppointmentEventStatusCancelled  AppointmentEventStatus = "cancelled"
	AppointmentEventStatusInProgress AppointmentEventStatus = "in_progress"
)

func NewAppointmentEventStatusFromString(s string) (AppointmentEventStatus, error) {
	switch s {
	case "pending":
		return AppointmentEventStatusPending, nil
	case "scheduled":
		return AppointmentEventStatusScheduled, nil
	case "completed":
		return AppointmentEventStatusCompleted, nil
	case "cancelled":
		return AppointmentEventStatusCancelled, nil
	case "in_progress":
		return AppointmentEventStatusInProgress, nil
	}
	var t AppointmentEventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentEventStatus) Ptr() *AppointmentEventStatus {
	return &a
}

type AppointmentLocation struct {
	Location *LngLat    `json:"location,omitempty" url:"location,omitempty"`
	Address  *UsAddress `json:"address,omitempty" url:"address,omitempty"`
	Code     string     `json:"code" url:"code"`
	Name     string     `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentLocation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentLocation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentLocation) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentProvider string

const (
	AppointmentProviderGetlabs      AppointmentProvider = "getlabs"
	AppointmentProviderAxlehealth   AppointmentProvider = "axlehealth"
	AppointmentProviderPhlebfinders AppointmentProvider = "phlebfinders"
	AppointmentProviderQuest        AppointmentProvider = "quest"
)

func NewAppointmentProviderFromString(s string) (AppointmentProvider, error) {
	switch s {
	case "getlabs":
		return AppointmentProviderGetlabs, nil
	case "axlehealth":
		return AppointmentProviderAxlehealth, nil
	case "phlebfinders":
		return AppointmentProviderPhlebfinders, nil
	case "quest":
		return AppointmentProviderQuest, nil
	}
	var t AppointmentProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentProvider) Ptr() *AppointmentProvider {
	return &a
}

type AppointmentPscLabs = string

type AppointmentRescheduleRequest struct {
	BookingKey string `json:"booking_key" url:"booking_key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentRescheduleRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentRescheduleRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentRescheduleRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentRescheduleRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentRescheduleRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentServiceType string

const (
	AppointmentServiceTypeAppointmentReady   AppointmentServiceType = "appointment-ready"
	AppointmentServiceTypeAppointmentRequest AppointmentServiceType = "appointment-request"
)

func NewAppointmentServiceTypeFromString(s string) (AppointmentServiceType, error) {
	switch s {
	case "appointment-ready":
		return AppointmentServiceTypeAppointmentReady, nil
	case "appointment-request":
		return AppointmentServiceTypeAppointmentRequest, nil
	}
	var t AppointmentServiceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentServiceType) Ptr() *AppointmentServiceType {
	return &a
}

type AppointmentStatus string

const (
	AppointmentStatusConfirmed  AppointmentStatus = "confirmed"
	AppointmentStatusPending    AppointmentStatus = "pending"
	AppointmentStatusInProgress AppointmentStatus = "in_progress"
	AppointmentStatusCompleted  AppointmentStatus = "completed"
	AppointmentStatusCancelled  AppointmentStatus = "cancelled"
)

func NewAppointmentStatusFromString(s string) (AppointmentStatus, error) {
	switch s {
	case "confirmed":
		return AppointmentStatusConfirmed, nil
	case "pending":
		return AppointmentStatusPending, nil
	case "in_progress":
		return AppointmentStatusInProgress, nil
	case "completed":
		return AppointmentStatusCompleted, nil
	case "cancelled":
		return AppointmentStatusCancelled, nil
	}
	var t AppointmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentStatus) Ptr() *AppointmentStatus {
	return &a
}

type AppointmentType string

const (
	AppointmentTypePhlebotomy           AppointmentType = "phlebotomy"
	AppointmentTypePatientServiceCenter AppointmentType = "patient_service_center"
)

func NewAppointmentTypeFromString(s string) (AppointmentType, error) {
	switch s {
	case "phlebotomy":
		return AppointmentTypePhlebotomy, nil
	case "patient_service_center":
		return AppointmentTypePatientServiceCenter, nil
	}
	var t AppointmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentType) Ptr() *AppointmentType {
	return &a
}

type AreaInfo struct {
	ZipCode     string                  `json:"zip_code" url:"zip_code"`
	Phlebotomy  *PhlebotomyAreaInfo     `json:"phlebotomy,omitempty" url:"phlebotomy,omitempty"`
	CentralLabs map[string]*PscAreaInfo `json:"central_labs,omitempty" url:"central_labs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AreaInfo) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler AreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AreaInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AreaInfo) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttemptStatus string

const (
	AttemptStatusSuccess AttemptStatus = "success"
	AttemptStatusFailure AttemptStatus = "failure"
)

func NewAttemptStatusFromString(s string) (AttemptStatus, error) {
	switch s {
	case "success":
		return AttemptStatusSuccess, nil
	case "failure":
		return AttemptStatusFailure, nil
	}
	var t AttemptStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptStatus) Ptr() *AttemptStatus {
	return &a
}

type AuthType string

const (
	AuthTypePassword AuthType = "password"
	AuthTypeOauth    AuthType = "oauth"
	AuthTypeEmail    AuthType = "email"
)

func NewAuthTypeFromString(s string) (AuthType, error) {
	switch s {
	case "password":
		return AuthTypePassword, nil
	case "oauth":
		return AuthTypeOauth, nil
	case "email":
		return AuthTypeEmail, nil
	}
	var t AuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthType) Ptr() *AuthType {
	return &a
}

type Availability string

const (
	AvailabilityAvailable   Availability = "available"
	AvailabilityUnavailable Availability = "unavailable"
)

func NewAvailabilityFromString(s string) (Availability, error) {
	switch s {
	case "available":
		return AvailabilityAvailable, nil
	case "unavailable":
		return AvailabilityUnavailable, nil
	}
	var t Availability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a Availability) Ptr() *Availability {
	return &a
}

type BasalBodyTemperatureEntry struct {
	Date  string  `json:"date" url:"date"`
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasalBodyTemperatureEntry) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasalBodyTemperatureEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler BasalBodyTemperatureEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasalBodyTemperatureEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasalBodyTemperatureEntry) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Billing string

const (
	BillingClientBill             Billing = "client_bill"
	BillingCommercialInsurance    Billing = "commercial_insurance"
	BillingPatientBillPassthrough Billing = "patient_bill_passthrough"
	BillingPatientBill            Billing = "patient_bill"
)

func NewBillingFromString(s string) (Billing, error) {
	switch s {
	case "client_bill":
		return BillingClientBill, nil
	case "commercial_insurance":
		return BillingCommercialInsurance, nil
	case "patient_bill_passthrough":
		return BillingPatientBillPassthrough, nil
	case "patient_bill":
		return BillingPatientBill, nil
	}
	var t Billing
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b Billing) Ptr() *Billing {
	return &b
}

// Represent the schema for an individual biomarker result.
type BiomarkerResult struct {
	Name            string                 `json:"name" url:"name"`
	Slug            *string                `json:"slug,omitempty" url:"slug,omitempty"`
	Value           float64                `json:"value" url:"value"`
	Result          string                 `json:"result" url:"result"`
	Type            ResultType             `json:"type" url:"type"`
	Unit            *string                `json:"unit,omitempty" url:"unit,omitempty"`
	Timestamp       *string                `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	Notes           *string                `json:"notes,omitempty" url:"notes,omitempty"`
	MinRangeValue   *float64               `json:"min_range_value,omitempty" url:"min_range_value,omitempty"`
	MaxRangeValue   *float64               `json:"max_range_value,omitempty" url:"max_range_value,omitempty"`
	IsAboveMaxRange *bool                  `json:"is_above_max_range,omitempty" url:"is_above_max_range,omitempty"`
	IsBelowMinRange *bool                  `json:"is_below_min_range,omitempty" url:"is_below_min_range,omitempty"`
	Interpretation  *string                `json:"interpretation,omitempty" url:"interpretation,omitempty"`
	Loinc           *string                `json:"loinc,omitempty" url:"loinc,omitempty"`
	LoincSlug       *string                `json:"loinc_slug,omitempty" url:"loinc_slug,omitempty"`
	ProviderId      *string                `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	SourceMarkers   []*ParentBiomarkerData `json:"source_markers,omitempty" url:"source_markers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BiomarkerResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BiomarkerResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BiomarkerResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BiomarkerResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BiomarkerResult) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BodyColumnExpr struct {
	Body BodyColumnExprBody `json:"body" url:"body"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BodyColumnExpr) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyColumnExpr) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BodyColumnExprBody string

const (
	BodyColumnExprBodyMeasuredAt           BodyColumnExprBody = "measured_at"
	BodyColumnExprBodyWeightKilogram       BodyColumnExprBody = "weight_kilogram"
	BodyColumnExprBodyFatMassPercentage    BodyColumnExprBody = "fat_mass_percentage"
	BodyColumnExprBodyWaterPercentage      BodyColumnExprBody = "water_percentage"
	BodyColumnExprBodyMuscleMassPercentage BodyColumnExprBody = "muscle_mass_percentage"
	BodyColumnExprBodyVisceralFatIndex     BodyColumnExprBody = "visceral_fat_index"
	BodyColumnExprBodyBoneMassPercentage   BodyColumnExprBody = "bone_mass_percentage"
	BodyColumnExprBodySourceType           BodyColumnExprBody = "source_type"
	BodyColumnExprBodySourceProvider       BodyColumnExprBody = "source_provider"
	BodyColumnExprBodySourceAppId          BodyColumnExprBody = "source_app_id"
)

func NewBodyColumnExprBodyFromString(s string) (BodyColumnExprBody, error) {
	switch s {
	case "measured_at":
		return BodyColumnExprBodyMeasuredAt, nil
	case "weight_kilogram":
		return BodyColumnExprBodyWeightKilogram, nil
	case "fat_mass_percentage":
		return BodyColumnExprBodyFatMassPercentage, nil
	case "water_percentage":
		return BodyColumnExprBodyWaterPercentage, nil
	case "muscle_mass_percentage":
		return BodyColumnExprBodyMuscleMassPercentage, nil
	case "visceral_fat_index":
		return BodyColumnExprBodyVisceralFatIndex, nil
	case "bone_mass_percentage":
		return BodyColumnExprBodyBoneMassPercentage, nil
	case "source_type":
		return BodyColumnExprBodySourceType, nil
	case "source_provider":
		return BodyColumnExprBodySourceProvider, nil
	case "source_app_id":
		return BodyColumnExprBodySourceAppId, nil
	}
	var t BodyColumnExprBody
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BodyColumnExprBody) Ptr() *BodyColumnExprBody {
	return &b
}

type BodyV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`
	Priority   *int                   `json:"priority,omitempty" url:"priority,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BodyV2InDb) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyV2InDb) UnmarshalJSON(data []byte) error {
	type embed BodyV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BodyV2InDb(unmarshaler.embed)
	b.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyV2InDb) MarshalJSON() ([]byte, error) {
	type embed BodyV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*b),
		Timestamp: core.NewDateTime(b.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (b *BodyV2InDb) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CervicalMucusEntry struct {
	Date    string                    `json:"date" url:"date"`
	Quality CervicalMucusEntryQuality `json:"quality" url:"quality"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CervicalMucusEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CervicalMucusEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler CervicalMucusEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CervicalMucusEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CervicalMucusEntry) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CervicalMucusEntryQuality string

const (
	CervicalMucusEntryQualityDry      CervicalMucusEntryQuality = "dry"
	CervicalMucusEntryQualitySticky   CervicalMucusEntryQuality = "sticky"
	CervicalMucusEntryQualityCreamy   CervicalMucusEntryQuality = "creamy"
	CervicalMucusEntryQualityWatery   CervicalMucusEntryQuality = "watery"
	CervicalMucusEntryQualityEggWhite CervicalMucusEntryQuality = "egg_white"
)

func NewCervicalMucusEntryQualityFromString(s string) (CervicalMucusEntryQuality, error) {
	switch s {
	case "dry":
		return CervicalMucusEntryQualityDry, nil
	case "sticky":
		return CervicalMucusEntryQualitySticky, nil
	case "creamy":
		return CervicalMucusEntryQualityCreamy, nil
	case "watery":
		return CervicalMucusEntryQualityWatery, nil
	case "egg_white":
		return CervicalMucusEntryQualityEggWhite, nil
	}
	var t CervicalMucusEntryQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CervicalMucusEntryQuality) Ptr() *CervicalMucusEntryQuality {
	return &c
}

type ChronotypeValueMacroExpr struct {
	Version    *string `json:"version,omitempty" url:"version,omitempty"`
	valueMacro string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChronotypeValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChronotypeValueMacroExpr) ValueMacro() string {
	return c.valueMacro
}

func (c *ChronotypeValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed ChronotypeValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChronotypeValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "chronotype" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "chronotype", unmarshaler.ValueMacro)
	}
	c.valueMacro = unmarshaler.ValueMacro

	extraProperties, err := core.ExtractExtraProperties(data, *c, "value_macro")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChronotypeValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed ChronotypeValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*c),
		ValueMacro: "chronotype",
	}
	return json.Marshal(marshaler)
}

func (c *ChronotypeValueMacroExpr) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientActivityResponse struct {
	Activity []*ClientFacingActivity `json:"activity,omitempty" url:"activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientActivityResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientActivityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientActivityResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientBodyResponse struct {
	Body []*ClientFacingBody `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientBodyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientBodyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientBodyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientBodyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientBodyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAFibBurdenSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAFibBurdenSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAFibBurdenSample) Unit() string {
	return c.unit
}

func (c *ClientFacingAFibBurdenSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAFibBurdenSample
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAFibBurdenSample(unmarshaler.embed)
	if unmarshaler.Unit != "%" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "%", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAFibBurdenSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAFibBurdenSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "%",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingAFibBurdenSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingActivity struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date string `json:"date" url:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// Total energy consumption during the day including Basal Metabolic Rate in kilocalories::kilocalories
	CaloriesTotal *float64 `json:"calories_total,omitempty" url:"calories_total,omitempty"`
	// Energy consumption caused by the physical activity of the day in kilocalories::kilocalories
	CaloriesActive *float64 `json:"calories_active,omitempty" url:"calories_active,omitempty"`
	// Total number of steps registered during the day::steps
	Steps *int `json:"steps,omitempty" url:"steps,omitempty"`
	// Deprecated. Daily physical activity as equal meters i.e. amount of walking needed to get the same amount of activity::meters
	DailyMovement *float64 `json:"daily_movement,omitempty" url:"daily_movement,omitempty"`
	// Distance traveled during activities throughout the day::meters
	Distance *float64 `json:"distance,omitempty" url:"distance,omitempty"`
	// Number of minutes during the day with low intensity activity (e.g. household work)::minutes
	Low *float64 `json:"low,omitempty" url:"low,omitempty"`
	// Number of minutes during the day with medium intensity activity (e.g. walking)::minutes
	Medium *float64 `json:"medium,omitempty" url:"medium,omitempty"`
	// Number of minutes during the day with high intensity activity (e.g. running)::minutes
	High *float64 `json:"high,omitempty" url:"high,omitempty"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`
	// Number of floors climbed by the user::count
	FloorsClimbed *int `json:"floors_climbed,omitempty" url:"floors_climbed,omitempty"`
	// [DEPRECATED] The time zone full identifier for the data. Example: 'Europe/London'.
	TimeZone *string `json:"time_zone,omitempty" url:"time_zone,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Heart rate daily summary.
	HeartRate *ClientFacingHeartRate `json:"heart_rate,omitempty" url:"heart_rate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingActivity) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingActivity(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingActivity) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingApiKey struct {
	Label     string  `json:"label" url:"label"`
	Value     string  `json:"value" url:"value"`
	TeamId    *string `json:"team_id,omitempty" url:"team_id,omitempty"`
	Id        string  `json:"id" url:"id"`
	CreatedAt string  `json:"created_at" url:"created_at"`
	DeletedAt *string `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingApiKey) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingApiKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingApiKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingApiKey(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingApiKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointment struct {
	Id       string     `json:"id" url:"id"`
	UserId   string     `json:"user_id" url:"user_id"`
	OrderId  string     `json:"order_id" url:"order_id"`
	Address  *UsAddress `json:"address,omitempty" url:"address,omitempty"`
	Location *LngLat    `json:"location,omitempty" url:"location,omitempty"`
	// Time is in UTC
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// Time is in UTC
	EndAt         *string                         `json:"end_at,omitempty" url:"end_at,omitempty"`
	IanaTimezone  *string                         `json:"iana_timezone,omitempty" url:"iana_timezone,omitempty"`
	Type          AppointmentType                 `json:"type" url:"type"`
	Provider      AppointmentProvider             `json:"provider" url:"provider"`
	Status        AppointmentStatus               `json:"status" url:"status"`
	ProviderId    string                          `json:"provider_id" url:"provider_id"`
	CanReschedule bool                            `json:"can_reschedule" url:"can_reschedule"`
	EventStatus   AppointmentEventStatus          `json:"event_status" url:"event_status"`
	EventData     map[string]interface{}          `json:"event_data,omitempty" url:"event_data,omitempty"`
	Events        []*ClientFacingAppointmentEvent `json:"events,omitempty" url:"events,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAppointment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAppointment) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentCancellationReason struct {
	Id           string `json:"id" url:"id"`
	Name         string `json:"name" url:"name"`
	IsRefundable bool   `json:"is_refundable" url:"is_refundable"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAppointmentCancellationReason) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAppointmentCancellationReason) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentCancellationReason
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentCancellationReason(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentCancellationReason) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentEvent struct {
	CreatedAt string                 `json:"created_at" url:"created_at"`
	Status    AppointmentEventStatus `json:"status" url:"status"`
	Data      map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAppointmentEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAppointmentEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a at-home-phlebotomy test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingAtHomePhlebotomyOrder struct {
	// The Vital at-home phlebotomy Order ID
	Id            string  `json:"id" url:"id"`
	AppointmentId *string `json:"appointment_id,omitempty" url:"appointment_id,omitempty"`
	CreatedAt     string  `json:"created_at" url:"created_at"`
	UpdatedAt     string  `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAtHomePhlebotomyOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAtHomePhlebotomyOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAtHomePhlebotomyOrderDetails struct {
	Data *ClientFacingAtHomePhlebotomyOrder `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAtHomePhlebotomyOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrderDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodOxygenTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (spo2).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodOxygenTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodOxygenTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodOxygenTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodPressureTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unit of the value. We use SI units where possible, e.g. mmol/L for glucose/cholesterol, bpm for heart rate, etc.
	Unit      string  `json:"unit" url:"unit"`
	Timestamp string  `json:"timestamp" url:"timestamp"`
	Systolic  float64 `json:"systolic" url:"systolic"`
	Diastolic float64 `json:"diastolic" url:"diastolic"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodPressureTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodPressureTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodPressureTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBody struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date string `json:"date" url:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// Weight in kg::kg
	Weight *float64 `json:"weight,omitempty" url:"weight,omitempty"`
	// Total body fat percentage::perc
	Fat *float64 `json:"fat,omitempty" url:"fat,omitempty"`
	// Water percentage in the body::perc
	WaterPercentage *float64 `json:"water_percentage,omitempty" url:"water_percentage,omitempty"`
	// Muscle mass percentage in the body::perc
	MuscleMassPercentage *float64 `json:"muscle_mass_percentage,omitempty" url:"muscle_mass_percentage,omitempty"`
	// Visceral fat index::scalar
	VisceralFatIndex *float64 `json:"visceral_fat_index,omitempty" url:"visceral_fat_index,omitempty"`
	// Bone mass percentage in the body::perc
	BoneMassPercentage *float64            `json:"bone_mass_percentage,omitempty" url:"bone_mass_percentage,omitempty"`
	Source             *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBody) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyFatTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyFatTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyFatTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyFatTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyFatTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyFatTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.
	SensorLocation *ClientFacingBodyTemperatureDeltaSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`
	unit           string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureDeltaSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureDeltaSample
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureDeltaSample(unmarshaler.embed)
	if unmarshaler.Unit != "°C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "°C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureDeltaSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureDeltaSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "°C",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSampleSensorLocation string

const (
	ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationBody             ClientFacingBodyTemperatureDeltaSampleSensorLocation = "body"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEar              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureDeltaSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationToe              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum          ClientFacingBodyTemperatureDeltaSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureDeltaSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead         ClientFacingBodyTemperatureDeltaSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureDeltaSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureDeltaSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureDeltaSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureDeltaSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureDeltaSampleSensorLocation {
	return &c
}

type ClientFacingBodyTemperatureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.
	SensorLocation *ClientFacingBodyTemperatureSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`
	unit           string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureSample
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureSample(unmarshaler.embed)
	if unmarshaler.Unit != "°C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "°C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "°C",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureSampleSensorLocation string

const (
	ClientFacingBodyTemperatureSampleSensorLocationArmpit           ClientFacingBodyTemperatureSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureSampleSensorLocationBody             ClientFacingBodyTemperatureSampleSensorLocation = "body"
	ClientFacingBodyTemperatureSampleSensorLocationEar              ClientFacingBodyTemperatureSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureSampleSensorLocationFinger           ClientFacingBodyTemperatureSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureSampleSensorLocationMouth            ClientFacingBodyTemperatureSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureSampleSensorLocationRectum           ClientFacingBodyTemperatureSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureSampleSensorLocationToe              ClientFacingBodyTemperatureSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureSampleSensorLocationEardrum          ClientFacingBodyTemperatureSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureSampleSensorLocationForehead         ClientFacingBodyTemperatureSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureSampleSensorLocationWrist            ClientFacingBodyTemperatureSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureSampleSensorLocation {
	return &c
}

type ClientFacingBodyWeightTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilograms (kg).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyWeightTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyWeightTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyWeightTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyWeightTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyWeightTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaffeineTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// Quantity of caffeine consumed during the time period.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaffeineTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaffeineTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaffeineTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaffeineTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesActiveTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// Energy consumption caused by the physical activity at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesActiveTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesActiveTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesActiveTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesActiveTimeseries
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveTimeseries(unmarshaler.embed)
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesActiveTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesBasalTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// Basal Metabolic Rate at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesBasalTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesBasalTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesBasalTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesBasalTimeseries
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalTimeseries(unmarshaler.embed)
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesBasalTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCarbohydratesSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCarbohydratesSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCarbohydratesSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCarbohydratesSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCarbohydratesSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCholesterolTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCholesterolTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCholesterolTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCholesterolTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCholesterolTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDiagnosisInformation struct {
	// Diagnosis code for insurance information.
	DiagnosisCode string `json:"diagnosis_code" url:"diagnosis_code"`
	// Diagnosis description insurance information.
	Description string `json:"description" url:"description"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDiagnosisInformation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDiagnosisInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDiagnosisInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDiagnosisInformation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDiagnosisInformation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDistanceTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in meters (m)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// Distance traveled during activities at the time or interval::steps
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDistanceTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDistanceTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingDistanceTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDistanceTimeseries
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDistanceTimeseries(unmarshaler.embed)
	if unmarshaler.Unit != "m" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "m", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "m",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingDistanceTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramVoltageTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The lead of the measurement.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mV.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingElectrocardiogramVoltageTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFloorsClimbedTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// Number of floors climbed at the time or interval::count
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFloorsClimbedTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFloorsClimbedTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingFloorsClimbedTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFloorsClimbedTimeseries
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedTimeseries(unmarshaler.embed)
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFloorsClimbedTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFood struct {
	Energy *Energy `json:"energy,omitempty" url:"energy,omitempty"`
	Macros *Macros `json:"macros,omitempty" url:"macros,omitempty"`
	Micros *Micros `json:"micros,omitempty" url:"micros,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFood) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFood) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFood
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFood(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFood) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGlucoseTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGlucoseTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGlucoseTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGlucoseTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGlucoseTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingAFibBurdenSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingAFibBurdenSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingAFibBurdenSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingAFibBurdenSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingAFibBurdenSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingAFibBurdenSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingAFibBurdenSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingCarbohydratesSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingHeartRateAlertSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingHeartRateAlertSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingHeartRateAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingHeartRateAlertSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingHeartRateAlertSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingHeartRateAlertSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingHeartRateAlertSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingNoteSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingNoteSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingNoteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingNoteSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingNoteSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingNoteSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRate struct {
	// Average heart rate::bpm
	AvgBpm *float64 `json:"avg_bpm,omitempty" url:"avg_bpm,omitempty"`
	// Minimum heart rate::bpm
	MinBpm *float64 `json:"min_bpm,omitempty" url:"min_bpm,omitempty"`
	// Maximum heart rate::bpm
	MaxBpm *float64 `json:"max_bpm,omitempty" url:"max_bpm,omitempty"`
	// Resting heart rate::bpm
	RestingBpm *float64 `json:"resting_bpm,omitempty" url:"resting_bpm,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateAlertSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int                                 `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	Type           ClientFacingHeartRateAlertSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End   string `json:"end" url:"end"`
	Value int    `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRateAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateAlertSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHeartRateAlertSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateAlertSample
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateAlertSample(unmarshaler.embed)
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateAlertSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateAlertSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHeartRateAlertSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateAlertSampleType string

const (
	ClientFacingHeartRateAlertSampleTypeLowHeartRate    ClientFacingHeartRateAlertSampleType = "low_heart_rate"
	ClientFacingHeartRateAlertSampleTypeHighHeartRate   ClientFacingHeartRateAlertSampleType = "high_heart_rate"
	ClientFacingHeartRateAlertSampleTypeIrregularRhythm ClientFacingHeartRateAlertSampleType = "irregular_rhythm"
)

func NewClientFacingHeartRateAlertSampleTypeFromString(s string) (ClientFacingHeartRateAlertSampleType, error) {
	switch s {
	case "low_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeLowHeartRate, nil
	case "high_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeHighHeartRate, nil
	case "irregular_rhythm":
		return ClientFacingHeartRateAlertSampleTypeIrregularRhythm, nil
	}
	var t ClientFacingHeartRateAlertSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHeartRateAlertSampleType) Ptr() *ClientFacingHeartRateAlertSampleType {
	return &c
}

type ClientFacingHeartRateTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// Heart rate in bpm
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRateTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRateTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRateTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHrvTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in rmssd.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// HRV calculated using rmssd during sleep
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHrvTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHrvTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHrvTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHrvTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHrvTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHypnogramTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// enum: 1: deep, 2: light, 3: rem, 4: awake, -1: missing_data.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// Hypnogram for sleep stages {"deep": 1, "light": 2, "rem": 3, "awake": 4, "manual": 5, "missing_data": -1}
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHypnogramTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHypnogramTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHypnogramTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHypnogramTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHypnogramTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIgeTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIgeTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIgeTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIgeTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIgeTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIggTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIggTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIggTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIggTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIggTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInsulinInjectionSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Insulin type: rapid vs long acting
	Type ClientFacingInsulinInjectionSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInsulinInjectionSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsulinInjectionSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInsulinInjectionSample
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInsulinInjectionSample(unmarshaler.embed)
	if unmarshaler.Unit != "unit" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "unit", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsulinInjectionSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInsulinInjectionSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "unit",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingInsulinInjectionSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Insulin type: rapid vs long acting
type ClientFacingInsulinInjectionSampleType string

const (
	ClientFacingInsulinInjectionSampleTypeRapidActing ClientFacingInsulinInjectionSampleType = "rapid_acting"
	ClientFacingInsulinInjectionSampleTypeLongActing  ClientFacingInsulinInjectionSampleType = "long_acting"
)

func NewClientFacingInsulinInjectionSampleTypeFromString(s string) (ClientFacingInsulinInjectionSampleType, error) {
	switch s {
	case "rapid_acting":
		return ClientFacingInsulinInjectionSampleTypeRapidActing, nil
	case "long_acting":
		return ClientFacingInsulinInjectionSampleTypeLongActing, nil
	}
	var t ClientFacingInsulinInjectionSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingInsulinInjectionSampleType) Ptr() *ClientFacingInsulinInjectionSampleType {
	return &c
}

type ClientFacingInsurance struct {
	MemberId     string                  `json:"member_id" url:"member_id"`
	PayorCode    string                  `json:"payor_code" url:"payor_code"`
	Relationship ResponsibleRelationship `json:"relationship" url:"relationship"`
	Insured      *PersonDetailsOutput    `json:"insured,omitempty" url:"insured,omitempty"`
	Company      *CompanyDetails         `json:"company,omitempty" url:"company,omitempty"`
	GroupId      *string                 `json:"group_id,omitempty" url:"group_id,omitempty"`
	Guarantor    *GuarantorDetails       `json:"guarantor,omitempty" url:"guarantor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInsurance) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsurance) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingInsurance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingInsurance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsurance) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLab struct {
	Id                int                       `json:"id" url:"id"`
	Slug              string                    `json:"slug" url:"slug"`
	Name              string                    `json:"name" url:"name"`
	FirstLineAddress  string                    `json:"first_line_address" url:"first_line_address"`
	City              string                    `json:"city" url:"city"`
	Zipcode           string                    `json:"zipcode" url:"zipcode"`
	CollectionMethods []LabTestCollectionMethod `json:"collection_methods,omitempty" url:"collection_methods,omitempty"`
	SampleTypes       []LabTestSampleType       `json:"sample_types,omitempty" url:"sample_types,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLab) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLab) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLab(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLab) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabLocation struct {
	Metadata *LabLocationMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	Distance int                  `json:"distance" url:"distance"`
	SiteCode string               `json:"site_code" url:"site_code"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLabLocation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLabLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLabLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLabLocation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLabLocation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabTest struct {
	Id         string                  `json:"id" url:"id"`
	Slug       string                  `json:"slug" url:"slug"`
	Name       string                  `json:"name" url:"name"`
	SampleType LabTestSampleType       `json:"sample_type" url:"sample_type"`
	Method     LabTestCollectionMethod `json:"method" url:"method"`
	Price      float64                 `json:"price" url:"price"`
	// Deprecated. Use status instead.
	IsActive bool          `json:"is_active" url:"is_active"`
	Status   LabTestStatus `json:"status" url:"status"`
	// Defines whether a lab test requires fasting.
	Fasting *bool                 `json:"fasting,omitempty" url:"fasting,omitempty"`
	Lab     *ClientFacingLab      `json:"lab,omitempty" url:"lab,omitempty"`
	Markers []*ClientFacingMarker `json:"markers,omitempty" url:"markers,omitempty"`
	// Denotes whether a lab test requires using non-Vital physician networks. If it does then it's delegated - no otherwise.
	IsDelegated *bool `json:"is_delegated,omitempty" url:"is_delegated,omitempty"`
	// Whether the lab test was auto-generated by Vital
	AutoGenerated *bool `json:"auto_generated,omitempty" url:"auto_generated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLabTest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLabTest) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLabTest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLabTest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLabTest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabs string

const (
	ClientFacingLabsQuest        ClientFacingLabs = "quest"
	ClientFacingLabsLabcorp      ClientFacingLabs = "labcorp"
	ClientFacingLabsBioreference ClientFacingLabs = "bioreference"
)

func NewClientFacingLabsFromString(s string) (ClientFacingLabs, error) {
	switch s {
	case "quest":
		return ClientFacingLabsQuest, nil
	case "labcorp":
		return ClientFacingLabsLabcorp, nil
	case "bioreference":
		return ClientFacingLabsBioreference, nil
	}
	var t ClientFacingLabs
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingLabs) Ptr() *ClientFacingLabs {
	return &c
}

type ClientFacingLoinc struct {
	Id   int     `json:"id" url:"id"`
	Name string  `json:"name" url:"name"`
	Slug string  `json:"slug" url:"slug"`
	Code string  `json:"code" url:"code"`
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLoinc) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLoinc) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLoinc
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLoinc(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLoinc) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarker struct {
	Id              int         `json:"id" url:"id"`
	Name            string      `json:"name" url:"name"`
	Slug            string      `json:"slug" url:"slug"`
	Description     *string     `json:"description,omitempty" url:"description,omitempty"`
	LabId           *int        `json:"lab_id,omitempty" url:"lab_id,omitempty"`
	ProviderId      *string     `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	Type            *MarkerType `json:"type,omitempty" url:"type,omitempty"`
	Unit            *string     `json:"unit,omitempty" url:"unit,omitempty"`
	Price           *string     `json:"price,omitempty" url:"price,omitempty"`
	Aoe             *AoE        `json:"aoe,omitempty" url:"aoe,omitempty"`
	ALaCarteEnabled *bool       `json:"a_la_carte_enabled,omitempty" url:"a_la_carte_enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMarker) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMarker) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarker
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarker(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarker) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarkerComplete struct {
	Id              int                   `json:"id" url:"id"`
	Name            string                `json:"name" url:"name"`
	Slug            string                `json:"slug" url:"slug"`
	Description     *string               `json:"description,omitempty" url:"description,omitempty"`
	LabId           *int                  `json:"lab_id,omitempty" url:"lab_id,omitempty"`
	ProviderId      *string               `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	Type            *MarkerType           `json:"type,omitempty" url:"type,omitempty"`
	Unit            *string               `json:"unit,omitempty" url:"unit,omitempty"`
	Price           *string               `json:"price,omitempty" url:"price,omitempty"`
	Aoe             *AoE                  `json:"aoe,omitempty" url:"aoe,omitempty"`
	ALaCarteEnabled *bool                 `json:"a_la_carte_enabled,omitempty" url:"a_la_carte_enabled,omitempty"`
	ExpectedResults []*ClientFacingResult `json:"expected_results,omitempty" url:"expected_results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMarkerComplete) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMarkerComplete) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarkerComplete
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarkerComplete(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarkerComplete) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMealResponse struct {
	Meals []*MealInDbBaseClientFacingSource `json:"meals,omitempty" url:"meals,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMealResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMealResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMealResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMealResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMealResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMindfulnessMinutesTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in minutes.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// Number of minutes spent in a mindful state.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMindfulnessMinutesTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMindfulnessMinutesTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// User notes as text.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value string `json:"value" url:"value"`
	// What the note refers to.
	Tags []ClientFacingNoteSampleTagsItem `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingNoteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingNoteSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingNoteSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingNoteSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSampleTagsItem string

const (
	ClientFacingNoteSampleTagsItemFood             ClientFacingNoteSampleTagsItem = "food"
	ClientFacingNoteSampleTagsItemExercise         ClientFacingNoteSampleTagsItem = "exercise"
	ClientFacingNoteSampleTagsItemInsulinInjection ClientFacingNoteSampleTagsItem = "insulin_injection"
	ClientFacingNoteSampleTagsItemUnspecified      ClientFacingNoteSampleTagsItem = "unspecified"
)

func NewClientFacingNoteSampleTagsItemFromString(s string) (ClientFacingNoteSampleTagsItem, error) {
	switch s {
	case "food":
		return ClientFacingNoteSampleTagsItemFood, nil
	case "exercise":
		return ClientFacingNoteSampleTagsItemExercise, nil
	case "insulin_injection":
		return ClientFacingNoteSampleTagsItemInsulinInjection, nil
	case "unspecified":
		return ClientFacingNoteSampleTagsItemUnspecified, nil
	}
	var t ClientFacingNoteSampleTagsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingNoteSampleTagsItem) Ptr() *ClientFacingNoteSampleTagsItem {
	return &c
}

type ClientFacingOrder struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	// The Vital Order ID
	Id string `json:"id" url:"id"`
	// Your team id.
	TeamId string `json:"team_id" url:"team_id"`
	// Patient Details
	PatientDetails *ClientFacingPatientDetailsCompatible `json:"patient_details,omitempty" url:"patient_details,omitempty"`
	// Patient Address
	PatientAddress *PatientAddressCompatible `json:"patient_address,omitempty" url:"patient_address,omitempty"`
	// The Vital Test associated with the order
	LabTest *ClientFacingLabTest      `json:"lab_test,omitempty" url:"lab_test,omitempty"`
	Details *ClientFacingOrderDetails `json:"details,omitempty" url:"details,omitempty"`
	// Sample ID
	SampleId *string `json:"sample_id,omitempty" url:"sample_id,omitempty"`
	// Notes associated with the order
	Notes *string `json:"notes,omitempty" url:"notes,omitempty"`
	// When your order was created
	CreatedAt string `json:"created_at" url:"created_at"`
	// When your order was last updated.
	UpdatedAt string                    `json:"updated_at" url:"updated_at"`
	Events    []*ClientFacingOrderEvent `json:"events,omitempty" url:"events,omitempty"`
	Status    *OrderTopLevelStatus      `json:"status,omitempty" url:"status,omitempty"`
	Physician *ClientFacingPhysician    `json:"physician,omitempty" url:"physician,omitempty"`
	// Vital ID of the health insurance.
	HealthInsuranceId *string `json:"health_insurance_id,omitempty" url:"health_insurance_id,omitempty"`
	// DEPRECATED. Requistion form url.
	RequisitionFormUrl *string `json:"requisition_form_url,omitempty" url:"requisition_form_url,omitempty"`
	// Defines whether order is priority or not. For some labs, this refers to a STAT order.
	Priority *bool `json:"priority,omitempty" url:"priority,omitempty"`
	// Shipping Details. For unregistered testkit orders.
	ShippingDetails *ShippingAddress `json:"shipping_details,omitempty" url:"shipping_details,omitempty"`
	// Schedule an Order to be processed in a future date.
	ActivateBy  *string  `json:"activate_by,omitempty" url:"activate_by,omitempty"`
	Passthrough *string  `json:"passthrough,omitempty" url:"passthrough,omitempty"`
	BillingType *Billing `json:"billing_type,omitempty" url:"billing_type,omitempty"`
	IcdCodes    []string `json:"icd_codes,omitempty" url:"icd_codes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingOrder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingOrderDetails struct {
	Type             string
	WalkInTest       *ClientFacingWalkInOrderDetails
	Testkit          *ClientFacingTestKitOrderDetails
	AtHomePhlebotomy *ClientFacingAtHomePhlebotomyOrderDetails
}

func NewClientFacingOrderDetailsFromWalkInTest(value *ClientFacingWalkInOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "walk_in_test", WalkInTest: value}
}

func NewClientFacingOrderDetailsFromTestkit(value *ClientFacingTestKitOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "testkit", Testkit: value}
}

func NewClientFacingOrderDetailsFromAtHomePhlebotomy(value *ClientFacingAtHomePhlebotomyOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "at_home_phlebotomy", AtHomePhlebotomy: value}
}

func (c *ClientFacingOrderDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "walk_in_test":
		value := new(ClientFacingWalkInOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.WalkInTest = value
	case "testkit":
		value := new(ClientFacingTestKitOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Testkit = value
	case "at_home_phlebotomy":
		value := new(ClientFacingAtHomePhlebotomyOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.AtHomePhlebotomy = value
	}
	return nil
}

func (c ClientFacingOrderDetails) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		return core.MarshalJSONWithExtraProperty(c.WalkInTest, "type", "walk_in_test")
	case "testkit":
		return core.MarshalJSONWithExtraProperty(c.Testkit, "type", "testkit")
	case "at_home_phlebotomy":
		return core.MarshalJSONWithExtraProperty(c.AtHomePhlebotomy, "type", "at_home_phlebotomy")
	}
}

type ClientFacingOrderDetailsVisitor interface {
	VisitWalkInTest(*ClientFacingWalkInOrderDetails) error
	VisitTestkit(*ClientFacingTestKitOrderDetails) error
	VisitAtHomePhlebotomy(*ClientFacingAtHomePhlebotomyOrderDetails) error
}

func (c *ClientFacingOrderDetails) Accept(visitor ClientFacingOrderDetailsVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		return visitor.VisitWalkInTest(c.WalkInTest)
	case "testkit":
		return visitor.VisitTestkit(c.Testkit)
	case "at_home_phlebotomy":
		return visitor.VisitAtHomePhlebotomy(c.AtHomePhlebotomy)
	}
}

type ClientFacingOrderEvent struct {
	Id        int         `json:"id" url:"id"`
	CreatedAt string      `json:"created_at" url:"created_at"`
	Status    OrderStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingOrderEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingOrderEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingOrderEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingOrderEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrderEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPatientDetailsCompatible struct {
	FirstName   *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	LastName    *string `json:"last_name,omitempty" url:"last_name,omitempty"`
	Dob         string  `json:"dob" url:"dob"`
	Gender      string  `json:"gender" url:"gender"`
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	Email       *string `json:"email,omitempty" url:"email,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPatientDetailsCompatible) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPatientDetailsCompatible) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPatientDetailsCompatible
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPatientDetailsCompatible(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPatientDetailsCompatible) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPayorSearchResponse struct {
	// Payor code returned for the insurance information.
	Code string `json:"code" url:"code"`
	// Insurance name returned for the insurance information.
	Name string `json:"name" url:"name"`
	// Insurance name aliases returned for the insurance information.
	Aliases []string `json:"aliases,omitempty" url:"aliases,omitempty"`
	// Insurance business address returned for the insurance information.
	OrgAddress *Address `json:"org_address,omitempty" url:"org_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPayorSearchResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPayorSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPayorSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPayorSearchResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPayorSearchResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPhysician struct {
	FirstName string `json:"first_name" url:"first_name"`
	LastName  string `json:"last_name" url:"last_name"`
	Npi       string `json:"npi" url:"npi"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPhysician) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPhysician) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPhysician
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPhysician(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPhysician) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProfile struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string              `json:"user_id" url:"user_id"`
	Id     string              `json:"id" url:"id"`
	Height *int                `json:"height,omitempty" url:"height,omitempty"`
	Source *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProfile) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProfile) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A vendor, a service, or a platform which Vital can connect with.
type ClientFacingProvider struct {
	// Name of source of information
	Name string `json:"name" url:"name"`
	// Slug for designated source
	Slug string `json:"slug" url:"slug"`
	// URL for source logo
	Logo string `json:"logo" url:"logo"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProvider) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProvider) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProvider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProvider(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProvider) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderDetailed struct {
	// Name of source of information
	Name string `json:"name" url:"name"`
	// Slug for designated source
	Slug string `json:"slug" url:"slug"`
	// Description of source of information
	Description string `json:"description" url:"description"`
	// URL for source logo
	Logo               *string                `json:"logo,omitempty" url:"logo,omitempty"`
	AuthType           *SourceAuthType        `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	SupportedResources []ClientFacingResource `json:"supported_resources,omitempty" url:"supported_resources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProviderDetailed) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProviderDetailed) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProviderDetailed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProviderDetailed(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderDetailed) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderWithStatus struct {
	// Name of source of information
	Name string `json:"name" url:"name"`
	// Slug for designated source
	Slug string `json:"slug" url:"slug"`
	// URL for source logo
	Logo string `json:"logo" url:"logo"`
	// Status of source, either error or connected
	Status               string                           `json:"status" url:"status"`
	ResourceAvailability map[string]*ResourceAvailability `json:"resource_availability,omitempty" url:"resource_availability,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProviderWithStatus) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProviderWithStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProviderWithStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProviderWithStatus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderWithStatus) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingResource string

const (
	ClientFacingResourceProfile                  ClientFacingResource = "profile"
	ClientFacingResourceActivity                 ClientFacingResource = "activity"
	ClientFacingResourceSleep                    ClientFacingResource = "sleep"
	ClientFacingResourceBody                     ClientFacingResource = "body"
	ClientFacingResourceWorkouts                 ClientFacingResource = "workouts"
	ClientFacingResourceWorkoutStream            ClientFacingResource = "workout_stream"
	ClientFacingResourceConnection               ClientFacingResource = "connection"
	ClientFacingResourceOrder                    ClientFacingResource = "order"
	ClientFacingResourceResult                   ClientFacingResource = "result"
	ClientFacingResourceAppointment              ClientFacingResource = "appointment"
	ClientFacingResourceGlucose                  ClientFacingResource = "glucose"
	ClientFacingResourceHeartrate                ClientFacingResource = "heartrate"
	ClientFacingResourceHrv                      ClientFacingResource = "hrv"
	ClientFacingResourceHypnogram                ClientFacingResource = "hypnogram"
	ClientFacingResourceIge                      ClientFacingResource = "ige"
	ClientFacingResourceIgg                      ClientFacingResource = "igg"
	ClientFacingResourceBloodOxygen              ClientFacingResource = "blood_oxygen"
	ClientFacingResourceBloodPressure            ClientFacingResource = "blood_pressure"
	ClientFacingResourceCholesterol              ClientFacingResource = "cholesterol"
	ClientFacingResourceDevice                   ClientFacingResource = "device"
	ClientFacingResourceWeight                   ClientFacingResource = "weight"
	ClientFacingResourceFat                      ClientFacingResource = "fat"
	ClientFacingResourceBodyTemperature          ClientFacingResource = "body_temperature"
	ClientFacingResourceBodyTemperatureDelta     ClientFacingResource = "body_temperature_delta"
	ClientFacingResourceMeal                     ClientFacingResource = "meal"
	ClientFacingResourceWater                    ClientFacingResource = "water"
	ClientFacingResourceCaffeine                 ClientFacingResource = "caffeine"
	ClientFacingResourceMindfulnessMinutes       ClientFacingResource = "mindfulness_minutes"
	ClientFacingResourceSteps                    ClientFacingResource = "steps"
	ClientFacingResourceCaloriesActive           ClientFacingResource = "calories_active"
	ClientFacingResourceDistance                 ClientFacingResource = "distance"
	ClientFacingResourceFloorsClimbed            ClientFacingResource = "floors_climbed"
	ClientFacingResourceRespiratoryRate          ClientFacingResource = "respiratory_rate"
	ClientFacingResourceVo2Max                   ClientFacingResource = "vo2_max"
	ClientFacingResourceCaloriesBasal            ClientFacingResource = "calories_basal"
	ClientFacingResourceStressLevel              ClientFacingResource = "stress_level"
	ClientFacingResourceMenstrualCycle           ClientFacingResource = "menstrual_cycle"
	ClientFacingResourceSleepCycle               ClientFacingResource = "sleep_cycle"
	ClientFacingResourceElectrocardiogramVoltage ClientFacingResource = "electrocardiogram_voltage"
	ClientFacingResourceAfibBurden               ClientFacingResource = "afib_burden"
	ClientFacingResourceHeartRateAlert           ClientFacingResource = "heart_rate_alert"
	ClientFacingResourceWorkoutDuration          ClientFacingResource = "workout_duration"
	ClientFacingResourceInsulinInjection         ClientFacingResource = "insulin_injection"
	ClientFacingResourceCarbohydrates            ClientFacingResource = "carbohydrates"
	ClientFacingResourceNote                     ClientFacingResource = "note"
	ClientFacingResourceSleepStream              ClientFacingResource = "sleep_stream"
)

func NewClientFacingResourceFromString(s string) (ClientFacingResource, error) {
	switch s {
	case "profile":
		return ClientFacingResourceProfile, nil
	case "activity":
		return ClientFacingResourceActivity, nil
	case "sleep":
		return ClientFacingResourceSleep, nil
	case "body":
		return ClientFacingResourceBody, nil
	case "workouts":
		return ClientFacingResourceWorkouts, nil
	case "workout_stream":
		return ClientFacingResourceWorkoutStream, nil
	case "connection":
		return ClientFacingResourceConnection, nil
	case "order":
		return ClientFacingResourceOrder, nil
	case "result":
		return ClientFacingResourceResult, nil
	case "appointment":
		return ClientFacingResourceAppointment, nil
	case "glucose":
		return ClientFacingResourceGlucose, nil
	case "heartrate":
		return ClientFacingResourceHeartrate, nil
	case "hrv":
		return ClientFacingResourceHrv, nil
	case "hypnogram":
		return ClientFacingResourceHypnogram, nil
	case "ige":
		return ClientFacingResourceIge, nil
	case "igg":
		return ClientFacingResourceIgg, nil
	case "blood_oxygen":
		return ClientFacingResourceBloodOxygen, nil
	case "blood_pressure":
		return ClientFacingResourceBloodPressure, nil
	case "cholesterol":
		return ClientFacingResourceCholesterol, nil
	case "device":
		return ClientFacingResourceDevice, nil
	case "weight":
		return ClientFacingResourceWeight, nil
	case "fat":
		return ClientFacingResourceFat, nil
	case "body_temperature":
		return ClientFacingResourceBodyTemperature, nil
	case "body_temperature_delta":
		return ClientFacingResourceBodyTemperatureDelta, nil
	case "meal":
		return ClientFacingResourceMeal, nil
	case "water":
		return ClientFacingResourceWater, nil
	case "caffeine":
		return ClientFacingResourceCaffeine, nil
	case "mindfulness_minutes":
		return ClientFacingResourceMindfulnessMinutes, nil
	case "steps":
		return ClientFacingResourceSteps, nil
	case "calories_active":
		return ClientFacingResourceCaloriesActive, nil
	case "distance":
		return ClientFacingResourceDistance, nil
	case "floors_climbed":
		return ClientFacingResourceFloorsClimbed, nil
	case "respiratory_rate":
		return ClientFacingResourceRespiratoryRate, nil
	case "vo2_max":
		return ClientFacingResourceVo2Max, nil
	case "calories_basal":
		return ClientFacingResourceCaloriesBasal, nil
	case "stress_level":
		return ClientFacingResourceStressLevel, nil
	case "menstrual_cycle":
		return ClientFacingResourceMenstrualCycle, nil
	case "sleep_cycle":
		return ClientFacingResourceSleepCycle, nil
	case "electrocardiogram_voltage":
		return ClientFacingResourceElectrocardiogramVoltage, nil
	case "afib_burden":
		return ClientFacingResourceAfibBurden, nil
	case "heart_rate_alert":
		return ClientFacingResourceHeartRateAlert, nil
	case "workout_duration":
		return ClientFacingResourceWorkoutDuration, nil
	case "insulin_injection":
		return ClientFacingResourceInsulinInjection, nil
	case "carbohydrates":
		return ClientFacingResourceCarbohydrates, nil
	case "note":
		return ClientFacingResourceNote, nil
	case "sleep_stream":
		return ClientFacingResourceSleepStream, nil
	}
	var t ClientFacingResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingResource) Ptr() *ClientFacingResource {
	return &c
}

type ClientFacingRespiratoryRateTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// Average respiratory rate::breaths per minute
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingRespiratoryRateTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingRespiratoryRateTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingRespiratoryRateTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingRespiratoryRateTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingRespiratoryRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingResult struct {
	Id         int                `json:"id" url:"id"`
	Name       string             `json:"name" url:"name"`
	Slug       string             `json:"slug" url:"slug"`
	LabId      *int               `json:"lab_id,omitempty" url:"lab_id,omitempty"`
	ProviderId *string            `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	Required   bool               `json:"required" url:"required"`
	Loinc      *ClientFacingLoinc `json:"loinc,omitempty" url:"loinc,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSampleGroupingKeys = []interface{}

// Schema for a Shipment in the client facing API.
//
// To be used as part of a ClientFacingTestkitOrder.
type ClientFacingShipment struct {
	// The Vital Shipment ID
	Id string `json:"id" url:"id"`
	// Tracking number for delivery to customer
	OutboundTrackingNumber *string `json:"outbound_tracking_number,omitempty" url:"outbound_tracking_number,omitempty"`
	// Tracking url for delivery to customer
	OutboundTrackingUrl *string `json:"outbound_tracking_url,omitempty" url:"outbound_tracking_url,omitempty"`
	// Tracking number for delivery to lab
	InboundTrackingNumber *string `json:"inbound_tracking_number,omitempty" url:"inbound_tracking_number,omitempty"`
	// Tracking url for delivery to lab
	InboundTrackingUrl *string `json:"inbound_tracking_url,omitempty" url:"inbound_tracking_url,omitempty"`
	// Courier used for delivery to customer
	OutboundCourier *string `json:"outbound_courier,omitempty" url:"outbound_courier,omitempty"`
	// Courier used for delivery to lab
	InboundCourier *string `json:"inbound_courier,omitempty" url:"inbound_courier,omitempty"`
	// Notes associated to the Vital shipment
	Notes *string `json:"notes,omitempty" url:"notes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingShipment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingShipment) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingShipment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingShipment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingShipment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleep struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date string `json:"date" url:"date"`
	// Date of the sleep summary in the YYYY-mm-dd format. This generally matches the sleep end date.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// UTC Time when the sleep period started
	BedtimeStart string `json:"bedtime_start" url:"bedtime_start"`
	// UTC Time when the sleep period ended
	BedtimeStop string `json:"bedtime_stop" url:"bedtime_stop"`
	// `long_sleep`: >=3 hours of sleep;
	// `short_sleep`: <3 hours of sleep;
	// `acknowledged_nap`: User-acknowledged naps, typically under 3 hours of sleep;
	// `unknown`: The sleep session recording is ongoing.
	Type SleepType `json:"type" url:"type"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Total duration of the sleep period (sleep.duration = sleep.bedtime_end - sleep.bedtime_start)::seconds
	Duration int `json:"duration" url:"duration"`
	// Total amount of sleep registered during the sleep period (sleep.total = sleep.rem + sleep.light + sleep.deep)::seconds
	Total int `json:"total" url:"total"`
	// Total amount of awake time registered during the sleep period::seconds
	Awake int `json:"awake" url:"awake"`
	// Total amount of light sleep registered during the sleep period::seconds
	Light int `json:"light" url:"light"`
	// Total amount of REM sleep registered during the sleep period, minutes::seconds
	Rem int `json:"rem" url:"rem"`
	// Total amount of deep (N3) sleep registered during the sleep period::seconds
	Deep int `json:"deep" url:"deep"`
	// A value between 1 and 100 representing how well the user slept. Currently only available for Withings, Oura, Whoop and Garmin::scalar
	Score *int `json:"score,omitempty" url:"score,omitempty"`
	// The lowest heart rate (5 minutes sliding average) registered during the sleep period::beats per minute
	HrLowest *int `json:"hr_lowest,omitempty" url:"hr_lowest,omitempty"`
	// The average heart rate registered during the sleep period::beats per minute
	HrAverage *int `json:"hr_average,omitempty" url:"hr_average,omitempty"`
	// Sleep efficiency is the percentage of the sleep period spent asleep (100% \* sleep.total / sleep.duration)::perc
	Efficiency *float64 `json:"efficiency,omitempty" url:"efficiency,omitempty"`
	// Detected latency from bedtime_start to the beginning of the first five minutes of persistent sleep::seconds
	Latency *int `json:"latency,omitempty" url:"latency,omitempty"`
	// Skin temperature deviation from the long-term temperature average::celcius
	TemperatureDelta *float64 `json:"temperature_delta,omitempty" url:"temperature_delta,omitempty"`
	// The skin temperature::celcius
	SkinTemperature *float64 `json:"skin_temperature,omitempty" url:"skin_temperature,omitempty"`
	// Sleeping Heart Rate Dip is the percentage difference between your average waking heart rate and your average sleeping heart rate. In health studies, a greater "dip" is typically seen as a positive indicator of overall health. Currently only available for Garmin::perc
	HrDip *float64 `json:"hr_dip,omitempty" url:"hr_dip,omitempty"`
	// Some providers can provide updates to the sleep summary hours after the sleep period has ended. This field indicates the state of the sleep summary. For example, TENTATIVE means the summary is an intial prediction from the provider and can be subject to change. Currently only available for Garmin and EightSleep::str
	State *SleepSummaryState `json:"state,omitempty" url:"state,omitempty"`
	// The average heart rate variability registered during the sleep period::rmssd
	AverageHrv *float64 `json:"average_hrv,omitempty" url:"average_hrv,omitempty"`
	// Average respiratory rate::breaths per minute
	RespiratoryRate *float64 `json:"respiratory_rate,omitempty" url:"respiratory_rate,omitempty"`
	// Source the data has come from.
	Source      *ClientFacingSource      `json:"source,omitempty" url:"source,omitempty"`
	SleepStream *ClientFacingSleepStream `json:"sleep_stream,omitempty" url:"sleep_stream,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleep) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleep) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleep(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleep) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepCycle struct {
	Id                     string    `json:"id" url:"id"`
	SleepId                string    `json:"sleep_id" url:"sleep_id"`
	SessionStart           time.Time `json:"session_start" url:"session_start"`
	SessionEnd             time.Time `json:"session_end" url:"session_end"`
	StageStartOffsetSecond []int     `json:"stage_start_offset_second,omitempty" url:"stage_start_offset_second,omitempty"`
	StageEndOffsetSecond   []int     `json:"stage_end_offset_second,omitempty" url:"stage_end_offset_second,omitempty"`
	// Sleep stage classification:
	// `-1`: Unknown or unclassified sleep stage;
	// `1`: Deep sleep;
	// `2`: Light/non-REM sleep;
	// `3`: Rapid Eye Movement sleep;
	// `4`: Awake period;
	// `5`: Manually classified stage.
	StageType      []VitalSleepStage                     `json:"stage_type,omitempty" url:"stage_type,omitempty"`
	TimeZone       *string                               `json:"time_zone,omitempty" url:"time_zone,omitempty"`
	SourceProvider *ClientFacingSleepCycleSourceProvider `json:"source_provider,omitempty" url:"source_provider,omitempty"`
	SourceType     ClientFacingSleepCycleSourceType      `json:"source_type" url:"source_type"`
	SourceAppId    *string                               `json:"source_app_id,omitempty" url:"source_app_id,omitempty"`
	UserId         string                                `json:"user_id" url:"user_id"`
	Source         *ClientFacingSource                   `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepCycle) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepCycle) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepCycle
	var unmarshaler = struct {
		embed
		SessionStart *core.DateTime `json:"session_start"`
		SessionEnd   *core.DateTime `json:"session_end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepCycle(unmarshaler.embed)
	c.SessionStart = unmarshaler.SessionStart.Time()
	c.SessionEnd = unmarshaler.SessionEnd.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepCycle) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepCycle
	var marshaler = struct {
		embed
		SessionStart *core.DateTime `json:"session_start"`
		SessionEnd   *core.DateTime `json:"session_end"`
	}{
		embed:        embed(*c),
		SessionStart: core.NewDateTime(c.SessionStart),
		SessionEnd:   core.NewDateTime(c.SessionEnd),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepCycle) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepCycleSourceProvider struct {
	Providers Providers
	Labs      Labs
}

func NewClientFacingSleepCycleSourceProviderFromProviders(value Providers) *ClientFacingSleepCycleSourceProvider {
	return &ClientFacingSleepCycleSourceProvider{Providers: value}
}

func NewClientFacingSleepCycleSourceProviderFromLabs(value Labs) *ClientFacingSleepCycleSourceProvider {
	return &ClientFacingSleepCycleSourceProvider{Labs: value}
}

func (c *ClientFacingSleepCycleSourceProvider) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		c.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		c.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingSleepCycleSourceProvider) MarshalJSON() ([]byte, error) {
	if c.Providers != "" {
		return json.Marshal(c.Providers)
	}
	if c.Labs != "" {
		return json.Marshal(c.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingSleepCycleSourceProviderVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (c *ClientFacingSleepCycleSourceProvider) Accept(visitor ClientFacingSleepCycleSourceProviderVisitor) error {
	if c.Providers != "" {
		return visitor.VisitProviders(c.Providers)
	}
	if c.Labs != "" {
		return visitor.VisitLabs(c.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingSleepCycleSourceType string

const (
	ClientFacingSleepCycleSourceTypeUnknown         ClientFacingSleepCycleSourceType = "unknown"
	ClientFacingSleepCycleSourceTypePhone           ClientFacingSleepCycleSourceType = "phone"
	ClientFacingSleepCycleSourceTypeWatch           ClientFacingSleepCycleSourceType = "watch"
	ClientFacingSleepCycleSourceTypeApp             ClientFacingSleepCycleSourceType = "app"
	ClientFacingSleepCycleSourceTypeMultipleSources ClientFacingSleepCycleSourceType = "multiple_sources"
	ClientFacingSleepCycleSourceTypeFingerprick     ClientFacingSleepCycleSourceType = "fingerprick"
	ClientFacingSleepCycleSourceTypeCuff            ClientFacingSleepCycleSourceType = "cuff"
	ClientFacingSleepCycleSourceTypeManualScan      ClientFacingSleepCycleSourceType = "manual_scan"
	ClientFacingSleepCycleSourceTypeAutomatic       ClientFacingSleepCycleSourceType = "automatic"
	ClientFacingSleepCycleSourceTypeScale           ClientFacingSleepCycleSourceType = "scale"
	ClientFacingSleepCycleSourceTypeChestStrap      ClientFacingSleepCycleSourceType = "chest_strap"
	ClientFacingSleepCycleSourceTypeRing            ClientFacingSleepCycleSourceType = "ring"
	ClientFacingSleepCycleSourceTypeLab             ClientFacingSleepCycleSourceType = "lab"
)

func NewClientFacingSleepCycleSourceTypeFromString(s string) (ClientFacingSleepCycleSourceType, error) {
	switch s {
	case "unknown":
		return ClientFacingSleepCycleSourceTypeUnknown, nil
	case "phone":
		return ClientFacingSleepCycleSourceTypePhone, nil
	case "watch":
		return ClientFacingSleepCycleSourceTypeWatch, nil
	case "app":
		return ClientFacingSleepCycleSourceTypeApp, nil
	case "multiple_sources":
		return ClientFacingSleepCycleSourceTypeMultipleSources, nil
	case "fingerprick":
		return ClientFacingSleepCycleSourceTypeFingerprick, nil
	case "cuff":
		return ClientFacingSleepCycleSourceTypeCuff, nil
	case "manual_scan":
		return ClientFacingSleepCycleSourceTypeManualScan, nil
	case "automatic":
		return ClientFacingSleepCycleSourceTypeAutomatic, nil
	case "scale":
		return ClientFacingSleepCycleSourceTypeScale, nil
	case "chest_strap":
		return ClientFacingSleepCycleSourceTypeChestStrap, nil
	case "ring":
		return ClientFacingSleepCycleSourceTypeRing, nil
	case "lab":
		return ClientFacingSleepCycleSourceTypeLab, nil
	}
	var t ClientFacingSleepCycleSourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepCycleSourceType) Ptr() *ClientFacingSleepCycleSourceType {
	return &c
}

type ClientFacingSleepStream struct {
	Hrv             []*ClientFacingHrvTimeseries             `json:"hrv,omitempty" url:"hrv,omitempty"`
	Heartrate       []*ClientFacingHeartRateTimeseries       `json:"heartrate,omitempty" url:"heartrate,omitempty"`
	Hypnogram       []*ClientFacingHypnogramTimeseries       `json:"hypnogram,omitempty" url:"hypnogram,omitempty"`
	RespiratoryRate []*ClientFacingRespiratoryRateTimeseries `json:"respiratory_rate,omitempty" url:"respiratory_rate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepStream) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepStream(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Source summarizes where a sample or a summary is sourced from.
// At minimum, the source provider is always included.
type ClientFacingSource struct {
	// Provider slug. e.g., `oura`, `fitbit`, `garmin`.
	Provider string `json:"provider" url:"provider"`
	// The type of the data source (app or device) by which the summary or the timeseries data were recorded. This defaults to `unknown` when Vital cannot extract or infer that information
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The identifier of the app which recorded this summary. This is only applicable to multi-source providers like Apple Health and Android Health Connect.
	AppId *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSource) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSport struct {
	Id int `json:"id" url:"id"`
	// Sport's name
	Name string `json:"name" url:"name"`
	// Slug for designated sport
	Slug string `json:"slug" url:"slug"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSport) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSport) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSport) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStepsTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The number of steps sampled at the time or interval::count
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStepsTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStepsTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingStepsTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStepsTimeseries
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStepsTimeseries(unmarshaler.embed)
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStepsTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStepsTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStream struct {
	// RPM for cycling, Steps per minute for running
	Cadence *ClientFacingStreamCadence `json:"cadence,omitempty" url:"cadence,omitempty"`
	// Corresponding time stamp in unix time for datapoint
	Time []int `json:"time,omitempty" url:"time,omitempty"`
	// Data points for altitude
	Altitude *ClientFacingStreamAltitude `json:"altitude,omitempty" url:"altitude,omitempty"`
	// Velocity in m/s
	VelocitySmooth *ClientFacingStreamVelocitySmooth `json:"velocity_smooth,omitempty" url:"velocity_smooth,omitempty"`
	// Heart rate in bpm
	Heartrate *ClientFacingStreamHeartrate `json:"heartrate,omitempty" url:"heartrate,omitempty"`
	// Latitude for data point
	Lat *ClientFacingStreamLat `json:"lat,omitempty" url:"lat,omitempty"`
	// Longitude for data point
	Lng *ClientFacingStreamLng `json:"lng,omitempty" url:"lng,omitempty"`
	// Cumulated distance for exercise
	Distance *ClientFacingStreamDistance `json:"distance,omitempty" url:"distance,omitempty"`
	// Power in watts
	Power *ClientFacingStreamPower `json:"power,omitempty" url:"power,omitempty"`
	// Resistance on bike
	Resistance *ClientFacingStreamResistance `json:"resistance,omitempty" url:"resistance,omitempty"`
	// Temperature stream measured by device in Celsius
	Temperature *ClientFacingStreamTemperature `json:"temperature,omitempty" url:"temperature,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStream) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStream(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Data points for altitude
type ClientFacingStreamAltitude struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamAltitudeFromDoubleOptionalList(value []*float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{DoubleOptionalList: value}
}

func NewClientFacingStreamAltitudeFromDoubleList(value []float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{DoubleList: value}
}

func (c *ClientFacingStreamAltitude) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamAltitude) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamAltitudeVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamAltitude) Accept(visitor ClientFacingStreamAltitudeVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// RPM for cycling, Steps per minute for running
type ClientFacingStreamCadence struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamCadenceFromDoubleOptionalList(value []*float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{DoubleOptionalList: value}
}

func NewClientFacingStreamCadenceFromDoubleList(value []float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{DoubleList: value}
}

func (c *ClientFacingStreamCadence) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamCadence) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamCadenceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamCadence) Accept(visitor ClientFacingStreamCadenceVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Cumulated distance for exercise
type ClientFacingStreamDistance struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamDistanceFromDoubleOptionalList(value []*float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{DoubleOptionalList: value}
}

func NewClientFacingStreamDistanceFromDoubleList(value []float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{DoubleList: value}
}

func (c *ClientFacingStreamDistance) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamDistance) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamDistanceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamDistance) Accept(visitor ClientFacingStreamDistanceVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Heart rate in bpm
type ClientFacingStreamHeartrate struct {
	IntegerOptionalList []*int
	IntegerList         []int
}

func NewClientFacingStreamHeartrateFromIntegerOptionalList(value []*int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{IntegerOptionalList: value}
}

func NewClientFacingStreamHeartrateFromIntegerList(value []int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{IntegerList: value}
}

func (c *ClientFacingStreamHeartrate) UnmarshalJSON(data []byte) error {
	var valueIntegerOptionalList []*int
	if err := json.Unmarshal(data, &valueIntegerOptionalList); err == nil {
		c.IntegerOptionalList = valueIntegerOptionalList
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamHeartrate) MarshalJSON() ([]byte, error) {
	if c.IntegerOptionalList != nil {
		return json.Marshal(c.IntegerOptionalList)
	}
	if c.IntegerList != nil {
		return json.Marshal(c.IntegerList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamHeartrateVisitor interface {
	VisitIntegerOptionalList([]*int) error
	VisitIntegerList([]int) error
}

func (c *ClientFacingStreamHeartrate) Accept(visitor ClientFacingStreamHeartrateVisitor) error {
	if c.IntegerOptionalList != nil {
		return visitor.VisitIntegerOptionalList(c.IntegerOptionalList)
	}
	if c.IntegerList != nil {
		return visitor.VisitIntegerList(c.IntegerList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Latitude for data point
type ClientFacingStreamLat struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamLatFromDoubleOptionalList(value []*float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{DoubleOptionalList: value}
}

func NewClientFacingStreamLatFromDoubleList(value []float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{DoubleList: value}
}

func (c *ClientFacingStreamLat) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLat) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamLatVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLat) Accept(visitor ClientFacingStreamLatVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Longitude for data point
type ClientFacingStreamLng struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamLngFromDoubleOptionalList(value []*float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{DoubleOptionalList: value}
}

func NewClientFacingStreamLngFromDoubleList(value []float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{DoubleList: value}
}

func (c *ClientFacingStreamLng) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLng) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamLngVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLng) Accept(visitor ClientFacingStreamLngVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Power in watts
type ClientFacingStreamPower struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamPowerFromDoubleOptionalList(value []*float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{DoubleOptionalList: value}
}

func NewClientFacingStreamPowerFromDoubleList(value []float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{DoubleList: value}
}

func (c *ClientFacingStreamPower) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamPower) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamPowerVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamPower) Accept(visitor ClientFacingStreamPowerVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Resistance on bike
type ClientFacingStreamResistance struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamResistanceFromDoubleOptionalList(value []*float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{DoubleOptionalList: value}
}

func NewClientFacingStreamResistanceFromDoubleList(value []float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{DoubleList: value}
}

func (c *ClientFacingStreamResistance) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamResistance) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamResistanceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamResistance) Accept(visitor ClientFacingStreamResistanceVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Temperature stream measured by device in Celsius
type ClientFacingStreamTemperature struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamTemperatureFromDoubleOptionalList(value []*float64) *ClientFacingStreamTemperature {
	return &ClientFacingStreamTemperature{DoubleOptionalList: value}
}

func NewClientFacingStreamTemperatureFromDoubleList(value []float64) *ClientFacingStreamTemperature {
	return &ClientFacingStreamTemperature{DoubleList: value}
}

func (c *ClientFacingStreamTemperature) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamTemperature) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamTemperatureVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamTemperature) Accept(visitor ClientFacingStreamTemperatureVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Velocity in m/s
type ClientFacingStreamVelocitySmooth struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamVelocitySmoothFromDoubleOptionalList(value []*float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{DoubleOptionalList: value}
}

func NewClientFacingStreamVelocitySmoothFromDoubleList(value []float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{DoubleList: value}
}

func (c *ClientFacingStreamVelocitySmooth) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamVelocitySmooth) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamVelocitySmoothVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamVelocitySmooth) Accept(visitor ClientFacingStreamVelocitySmoothVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStressLevelTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string  `json:"timestamp" url:"timestamp"`
	Value     float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStressLevelTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStressLevelTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStressLevelTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStressLevelTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStressLevelTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// [Deprecated] GET /v2/team is in the process of being removed.
// Neither customers nor Dashboard should retrieve team settings and metadata directly.
//
// All must migrate to the Team endpoints of the Org Management API.
type ClientFacingTeam struct {
	Id                                       string                `json:"id" url:"id"`
	OrgId                                    string                `json:"org_id" url:"org_id"`
	Name                                     string                `json:"name" url:"name"`
	SvixAppId                                *string               `json:"svix_app_id,omitempty" url:"svix_app_id,omitempty"`
	ClientId                                 *string               `json:"client_id,omitempty" url:"client_id,omitempty"`
	ClientSecret                             *string               `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	AirtableApiKey                           *string               `json:"airtable_api_key,omitempty" url:"airtable_api_key,omitempty"`
	AirtableBaseId                           *string               `json:"airtable_base_id,omitempty" url:"airtable_base_id,omitempty"`
	WebhookSecret                            *string               `json:"webhook_secret,omitempty" url:"webhook_secret,omitempty"`
	ApiKey                                   *string               `json:"api_key,omitempty" url:"api_key,omitempty"`
	ApiKeys                                  []*ClientFacingApiKey `json:"api_keys,omitempty" url:"api_keys,omitempty"`
	Configuration                            *TeamConfig           `json:"configuration,omitempty" url:"configuration,omitempty"`
	TestkitsTextsEnabled                     bool                  `json:"testkits_texts_enabled" url:"testkits_texts_enabled"`
	LabTestsPatientCommunicationEnabled      bool                  `json:"lab_tests_patient_communication_enabled" url:"lab_tests_patient_communication_enabled"`
	LabTestsPatientSmsCommunicationEnabled   bool                  `json:"lab_tests_patient_sms_communication_enabled" url:"lab_tests_patient_sms_communication_enabled"`
	LabTestsPatientEmailCommunicationEnabled bool                  `json:"lab_tests_patient_email_communication_enabled" url:"lab_tests_patient_email_communication_enabled"`
	LogoUrl                                  *string               `json:"logo_url,omitempty" url:"logo_url,omitempty"`
	DelegatedFlow                            DelegatedFlowType     `json:"delegated_flow" url:"delegated_flow"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTeam) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTeam) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTeam
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTeam(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTeam) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTestKitOrderDetails struct {
	Data *ClientFacingTestkitOrder `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTestKitOrderDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTestKitOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTestKitOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTestKitOrderDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestKitOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a testkit order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingTestkitOrder struct {
	// The Vital TestKit Order ID
	Id string `json:"id" url:"id"`
	// Shipment object
	Shipment  *ClientFacingShipment `json:"shipment,omitempty" url:"shipment,omitempty"`
	CreatedAt string                `json:"created_at" url:"created_at"`
	UpdatedAt string                `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTestkitOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTestkitOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTestkitOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTestkitOrder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestkitOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingAFibBurdenSample struct {
	Source *ClientFacingSource             `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingAFibBurdenSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingAFibBurdenSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingAFibBurdenSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingAFibBurdenSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingAFibBurdenSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingAFibBurdenSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample struct {
	Source *ClientFacingSource                       `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyTemperatureDeltaSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyTemperatureSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingCarbohydratesSample struct {
	Source *ClientFacingSource                `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCarbohydratesSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingCarbohydratesSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingCarbohydratesSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingCarbohydratesSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingCarbohydratesSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingHeartRateAlertSample struct {
	Source *ClientFacingSource                 `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHeartRateAlertSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingHeartRateAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingHeartRateAlertSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingHeartRateAlertSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingHeartRateAlertSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingHeartRateAlertSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample struct {
	Source *ClientFacingSource                   `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingInsulinInjectionSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingNoteSample struct {
	Source *ClientFacingSource       `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingNoteSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingNoteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingNoteSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingNoteSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingNoteSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingWorkoutDurationSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUser struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	// Your team id.
	TeamId string `json:"team_id" url:"team_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id" url:"client_user_id"`
	// When your item is created
	CreatedOn string `json:"created_on" url:"created_on"`
	// A list of the users connected sources.
	ConnectedSources []*ConnectedSourceClientFacing `json:"connected_sources,omitempty" url:"connected_sources,omitempty"`
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	FallbackTimeZone *FallbackTimeZone `json:"fallback_time_zone,omitempty" url:"fallback_time_zone,omitempty"`
	// Fallback date of birth of the user, in YYYY-mm-dd format. Used for calculating max heartrate for providers that don not provide users' age.
	FallbackBirthDate *FallbackBirthDate `json:"fallback_birth_date,omitempty" url:"fallback_birth_date,omitempty"`
	// Starting bound for user data ingestion. Data older than this date will not be ingested.
	IngestionStart *string `json:"ingestion_start,omitempty" url:"ingestion_start,omitempty"`
	// Ending bound for user data ingestion. Data from this date or later will not be ingested and the connection will be deregistered.
	IngestionEnd *string `json:"ingestion_end,omitempty" url:"ingestion_end,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingUser) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUser) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUser(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUser) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUserKey struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id" url:"client_user_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingUserKey) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUserKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUserKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUserKey(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUserKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingVo2MaxTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mL/kg/min.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingVo2MaxTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingVo2MaxTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingVo2MaxTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingVo2MaxTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingVo2MaxTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWalkInOrderDetails struct {
	Data *ClientFacingWalkInTestOrder `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWalkInOrderDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWalkInOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWalkInOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWalkInOrderDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a walk-in test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingWalkInTestOrder struct {
	// The Vital walk-in test Order ID
	Id            string  `json:"id" url:"id"`
	CreatedAt     string  `json:"created_at" url:"created_at"`
	UpdatedAt     string  `json:"updated_at" url:"updated_at"`
	AppointmentId *string `json:"appointment_id,omitempty" url:"appointment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWalkInTestOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWalkInTestOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWalkInTestOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWalkInTestOrder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInTestOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWaterTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in milliters.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// Quantity of water drank during the time period.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWaterTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaterTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWaterTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWaterTimeseries(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkout struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Title given for the workout
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Average heart rate during workout::bpm
	AverageHr *int `json:"average_hr,omitempty" url:"average_hr,omitempty"`
	// Max heart rate during workout::bpm
	MaxHr *int `json:"max_hr,omitempty" url:"max_hr,omitempty"`
	// Distance travelled during workout::meters
	Distance *float64 `json:"distance,omitempty" url:"distance,omitempty"`
	// Date of the workout summary in the YYYY-mm-dd format. This generally matches the workout start date.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// Start time of the workout::time
	TimeStart string `json:"time_start" url:"time_start"`
	// End time of the workout::time
	TimeEnd string `json:"time_end" url:"time_end"`
	// Calories burned during the workout::kCal
	Calories *float64 `json:"calories,omitempty" url:"calories,omitempty"`
	// Sport's name
	Sport *ClientFacingSport `json:"sport,omitempty" url:"sport,omitempty"`
	// Time in seconds spent in different heart rate zones <50%, 50-60%, 60-70%, 70-80%, 80-90%, 90%+. Due to rounding errors, it's possible that summing all values is different than the total time of the workout. Not available for all providers::seconds
	HrZones []int `json:"hr_zones,omitempty" url:"hr_zones,omitempty"`
	// Time spent active during the workout::seconds
	MovingTime *int `json:"moving_time,omitempty" url:"moving_time,omitempty"`
	// Elevation gain during the workout::meters
	TotalElevationGain *float64 `json:"total_elevation_gain,omitempty" url:"total_elevation_gain,omitempty"`
	// Highest point of elevation::meters
	ElevHigh *float64 `json:"elev_high,omitempty" url:"elev_high,omitempty"`
	// Lowest point of elevation::meters
	ElevLow *float64 `json:"elev_low,omitempty" url:"elev_low,omitempty"`
	// Average speed during workout in m/s::meters/sec
	AverageSpeed *float64 `json:"average_speed,omitempty" url:"average_speed,omitempty"`
	// Max speed during workout in m/s::meters/sec
	MaxSpeed *float64 `json:"max_speed,omitempty" url:"max_speed,omitempty"`
	// Average watts burned during exercise::watts
	AverageWatts *float64 `json:"average_watts,omitempty" url:"average_watts,omitempty"`
	// Watts burned during exercise::watts
	DeviceWatts *float64 `json:"device_watts,omitempty" url:"device_watts,omitempty"`
	// Max watts burned during exercise::watts
	MaxWatts *float64 `json:"max_watts,omitempty" url:"max_watts,omitempty"`
	// Weighted average watts burned during exercise::watts
	WeightedAverageWatts *float64 `json:"weighted_average_watts,omitempty" url:"weighted_average_watts,omitempty"`
	// Number of steps accumulated during this workout::count
	Steps *int `json:"steps,omitempty" url:"steps,omitempty"`
	// Map of workouts encoded as polyline
	Map map[string]interface{} `json:"map,omitempty" url:"map,omitempty"`
	// Provider ID given for that specific workout
	ProviderId string `json:"provider_id" url:"provider_id"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkout) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkout) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkout) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp string `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start string `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End string `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Workout intensity.
	Intensity *ClientFacingWorkoutDurationSampleIntensity `json:"intensity,omitempty" url:"intensity,omitempty"`
	unit      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutDurationSample
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDurationSample(unmarshaler.embed)
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDurationSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "min",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWorkoutDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSampleIntensity string

const (
	ClientFacingWorkoutDurationSampleIntensityLow    ClientFacingWorkoutDurationSampleIntensity = "low"
	ClientFacingWorkoutDurationSampleIntensityMedium ClientFacingWorkoutDurationSampleIntensity = "medium"
	ClientFacingWorkoutDurationSampleIntensityHigh   ClientFacingWorkoutDurationSampleIntensity = "high"
)

func NewClientFacingWorkoutDurationSampleIntensityFromString(s string) (ClientFacingWorkoutDurationSampleIntensity, error) {
	switch s {
	case "low":
		return ClientFacingWorkoutDurationSampleIntensityLow, nil
	case "medium":
		return ClientFacingWorkoutDurationSampleIntensityMedium, nil
	case "high":
		return ClientFacingWorkoutDurationSampleIntensityHigh, nil
	}
	var t ClientFacingWorkoutDurationSampleIntensity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutDurationSampleIntensity) Ptr() *ClientFacingWorkoutDurationSampleIntensity {
	return &c
}

type ClientSleepCycleResponse struct {
	SleepCycle []*ClientFacingSleepCycle `json:"sleep_cycle,omitempty" url:"sleep_cycle,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientSleepCycleResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientSleepCycleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSleepCycleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSleepCycleResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSleepCycleResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientSleepResponse struct {
	Sleep []*ClientFacingSleep `json:"sleep,omitempty" url:"sleep,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientSleepResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientSleepResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSleepResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSleepResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSleepResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientUserIdConflict struct {
	ErrorType    string `json:"error_type" url:"error_type"`
	ErrorMessage string `json:"error_message" url:"error_message"`
	UserId       string `json:"user_id" url:"user_id"`
	CreatedOn    string `json:"created_on" url:"created_on"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientUserIdConflict) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientUserIdConflict) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientUserIdConflict
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientUserIdConflict(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientUserIdConflict) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientWorkoutResponse struct {
	Workouts []*ClientFacingWorkout `json:"workouts,omitempty" url:"workouts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientWorkoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientWorkoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientWorkoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientWorkoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientWorkoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompanyDetails struct {
	Name    string   `json:"name" url:"name"`
	Address *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CompanyDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompanyDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectedSourceClientFacing struct {
	// The provider of this connected source.
	Provider *ClientFacingProvider `json:"provider,omitempty" url:"provider,omitempty"`
	// When your item is created
	CreatedOn string `json:"created_on" url:"created_on"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Source *ClientFacingProvider `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConnectedSourceClientFacing) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectedSourceClientFacing) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectedSourceClientFacing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectedSourceClientFacing(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectedSourceClientFacing) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionStatus struct {
	State       ConnectionStatusState `json:"state" url:"state"`
	RedirectUrl *string               `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	ErrorType   *string               `json:"error_type,omitempty" url:"error_type,omitempty"`
	Error       *string               `json:"error,omitempty" url:"error,omitempty"`
	ProviderMfa *ProviderMfaRequest   `json:"provider_mfa,omitempty" url:"provider_mfa,omitempty"`
	Success     bool                  `json:"success" url:"success"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConnectionStatus) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionStatus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionStatus) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionStatusState string

const (
	ConnectionStatusStateSuccess            ConnectionStatusState = "success"
	ConnectionStatusStateError              ConnectionStatusState = "error"
	ConnectionStatusStatePendingProviderMfa ConnectionStatusState = "pending_provider_mfa"
)

func NewConnectionStatusStateFromString(s string) (ConnectionStatusState, error) {
	switch s {
	case "success":
		return ConnectionStatusStateSuccess, nil
	case "error":
		return ConnectionStatusStateError, nil
	case "pending_provider_mfa":
		return ConnectionStatusStatePendingProviderMfa, nil
	}
	var t ConnectionStatusState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionStatusState) Ptr() *ConnectionStatusState {
	return &c
}

type Consent struct {
	ConsentType   ConsentType `json:"consentType" url:"consentType"`
	Version       *string     `json:"version,omitempty" url:"version,omitempty"`
	TimeOfConsent *time.Time  `json:"timeOfConsent,omitempty" url:"timeOfConsent,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Consent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Consent) UnmarshalJSON(data []byte) error {
	type embed Consent
	var unmarshaler = struct {
		embed
		TimeOfConsent *core.DateTime `json:"timeOfConsent,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Consent(unmarshaler.embed)
	c.TimeOfConsent = unmarshaler.TimeOfConsent.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Consent) MarshalJSON() ([]byte, error) {
	type embed Consent
	var marshaler = struct {
		embed
		TimeOfConsent *core.DateTime `json:"timeOfConsent,omitempty"`
	}{
		embed:         embed(*c),
		TimeOfConsent: core.NewOptionalDateTime(c.TimeOfConsent),
	}
	return json.Marshal(marshaler)
}

func (c *Consent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConsentType string

const (
	ConsentTypeTermsOfUse                ConsentType = "terms-of-use"
	ConsentTypeTelehealthInformedConsent ConsentType = "telehealth-informed-consent"
	ConsentTypeMobileTermsAndConditions  ConsentType = "mobile-terms-and-conditions"
	ConsentTypeNoticeOfPrivacyPractices  ConsentType = "notice-of-privacy-practices"
	ConsentTypePrivacyPolicy             ConsentType = "privacy-policy"
	ConsentTypeHipaaAuthorization        ConsentType = "hipaa-authorization"
)

func NewConsentTypeFromString(s string) (ConsentType, error) {
	switch s {
	case "terms-of-use":
		return ConsentTypeTermsOfUse, nil
	case "telehealth-informed-consent":
		return ConsentTypeTelehealthInformedConsent, nil
	case "mobile-terms-and-conditions":
		return ConsentTypeMobileTermsAndConditions, nil
	case "notice-of-privacy-practices":
		return ConsentTypeNoticeOfPrivacyPractices, nil
	case "privacy-policy":
		return ConsentTypePrivacyPolicy, nil
	case "hipaa-authorization":
		return ConsentTypeHipaaAuthorization, nil
	}
	var t ConsentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsentType) Ptr() *ConsentType {
	return &c
}

type ContraceptiveEntry struct {
	Date string                 `json:"date" url:"date"`
	Type ContraceptiveEntryType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ContraceptiveEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContraceptiveEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ContraceptiveEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContraceptiveEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContraceptiveEntry) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContraceptiveEntryType string

const (
	ContraceptiveEntryTypeUnspecified      ContraceptiveEntryType = "unspecified"
	ContraceptiveEntryTypeImplant          ContraceptiveEntryType = "implant"
	ContraceptiveEntryTypeInjection        ContraceptiveEntryType = "injection"
	ContraceptiveEntryTypeIud              ContraceptiveEntryType = "iud"
	ContraceptiveEntryTypeIntravaginalRing ContraceptiveEntryType = "intravaginal_ring"
	ContraceptiveEntryTypeOral             ContraceptiveEntryType = "oral"
	ContraceptiveEntryTypePatch            ContraceptiveEntryType = "patch"
)

func NewContraceptiveEntryTypeFromString(s string) (ContraceptiveEntryType, error) {
	switch s {
	case "unspecified":
		return ContraceptiveEntryTypeUnspecified, nil
	case "implant":
		return ContraceptiveEntryTypeImplant, nil
	case "injection":
		return ContraceptiveEntryTypeInjection, nil
	case "iud":
		return ContraceptiveEntryTypeIud, nil
	case "intravaginal_ring":
		return ContraceptiveEntryTypeIntravaginalRing, nil
	case "oral":
		return ContraceptiveEntryTypeOral, nil
	case "patch":
		return ContraceptiveEntryTypePatch, nil
	}
	var t ContraceptiveEntryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContraceptiveEntryType) Ptr() *ContraceptiveEntryType {
	return &c
}

type DatePartExpr struct {
	Arg      *DatePartExprArg     `json:"arg,omitempty" url:"arg,omitempty"`
	DatePart DatePartExprDatePart `json:"date_part" url:"date_part"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DatePartExpr) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DatePartExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler DatePartExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatePartExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatePartExpr) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DatePartExprArg struct {
	IndexColumnExpr *IndexColumnExpr
	Placeholder     *Placeholder
}

func NewDatePartExprArgFromIndexColumnExpr(value *IndexColumnExpr) *DatePartExprArg {
	return &DatePartExprArg{IndexColumnExpr: value}
}

func NewDatePartExprArgFromPlaceholder(value *Placeholder) *DatePartExprArg {
	return &DatePartExprArg{Placeholder: value}
}

func (d *DatePartExprArg) UnmarshalJSON(data []byte) error {
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		d.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		d.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DatePartExprArg) MarshalJSON() ([]byte, error) {
	if d.IndexColumnExpr != nil {
		return json.Marshal(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return json.Marshal(d.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DatePartExprArgVisitor interface {
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitPlaceholder(*Placeholder) error
}

func (d *DatePartExprArg) Accept(visitor DatePartExprArgVisitor) error {
	if d.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return visitor.VisitPlaceholder(d.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DatePartExprDatePart string

const (
	DatePartExprDatePartMinute     DatePartExprDatePart = "minute"
	DatePartExprDatePartHour       DatePartExprDatePart = "hour"
	DatePartExprDatePartDay        DatePartExprDatePart = "day"
	DatePartExprDatePartWeek       DatePartExprDatePart = "week"
	DatePartExprDatePartMonth      DatePartExprDatePart = "month"
	DatePartExprDatePartYear       DatePartExprDatePart = "year"
	DatePartExprDatePartWeekday    DatePartExprDatePart = "weekday"
	DatePartExprDatePartWeekOfYear DatePartExprDatePart = "week_of_year"
	DatePartExprDatePartDayOfYear  DatePartExprDatePart = "day_of_year"
)

func NewDatePartExprDatePartFromString(s string) (DatePartExprDatePart, error) {
	switch s {
	case "minute":
		return DatePartExprDatePartMinute, nil
	case "hour":
		return DatePartExprDatePartHour, nil
	case "day":
		return DatePartExprDatePartDay, nil
	case "week":
		return DatePartExprDatePartWeek, nil
	case "month":
		return DatePartExprDatePartMonth, nil
	case "year":
		return DatePartExprDatePartYear, nil
	case "weekday":
		return DatePartExprDatePartWeekday, nil
	case "week_of_year":
		return DatePartExprDatePartWeekOfYear, nil
	case "day_of_year":
		return DatePartExprDatePartDayOfYear, nil
	}
	var t DatePartExprDatePart
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatePartExprDatePart) Ptr() *DatePartExprDatePart {
	return &d
}

type DateTruncExpr struct {
	DateTrunc *Period           `json:"date_trunc,omitempty" url:"date_trunc,omitempty"`
	Arg       *DateTruncExprArg `json:"arg,omitempty" url:"arg,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DateTruncExpr) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateTruncExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler DateTruncExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateTruncExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateTruncExpr) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DateTruncExprArg struct {
	IndexColumnExpr *IndexColumnExpr
	Placeholder     *Placeholder
}

func NewDateTruncExprArgFromIndexColumnExpr(value *IndexColumnExpr) *DateTruncExprArg {
	return &DateTruncExprArg{IndexColumnExpr: value}
}

func NewDateTruncExprArgFromPlaceholder(value *Placeholder) *DateTruncExprArg {
	return &DateTruncExprArg{Placeholder: value}
}

func (d *DateTruncExprArg) UnmarshalJSON(data []byte) error {
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		d.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		d.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DateTruncExprArg) MarshalJSON() ([]byte, error) {
	if d.IndexColumnExpr != nil {
		return json.Marshal(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return json.Marshal(d.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DateTruncExprArgVisitor interface {
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitPlaceholder(*Placeholder) error
}

func (d *DateTruncExprArg) Accept(visitor DateTruncExprArgVisitor) error {
	if d.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return visitor.VisitPlaceholder(d.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DaySlots struct {
	Location *AppointmentLocation `json:"location,omitempty" url:"location,omitempty"`
	Date     string               `json:"date" url:"date"`
	Slots    []*TimeSlot          `json:"slots,omitempty" url:"slots,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DaySlots) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DaySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler DaySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DaySlots(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DaySlots) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DelegatedFlowType string

const (
	DelegatedFlowTypeOrderAndResultsWithCustomerPhysicianNetwork DelegatedFlowType = "order_and_results_with_customer_physician_network"
	DelegatedFlowTypeOrderWithVitalPhysicianNetwork              DelegatedFlowType = "order_with_vital_physician_network"
	DelegatedFlowTypeOrderAndResultsWithVitalPhysicianNetwork    DelegatedFlowType = "order_and_results_with_vital_physician_network"
)

func NewDelegatedFlowTypeFromString(s string) (DelegatedFlowType, error) {
	switch s {
	case "order_and_results_with_customer_physician_network":
		return DelegatedFlowTypeOrderAndResultsWithCustomerPhysicianNetwork, nil
	case "order_with_vital_physician_network":
		return DelegatedFlowTypeOrderWithVitalPhysicianNetwork, nil
	case "order_and_results_with_vital_physician_network":
		return DelegatedFlowTypeOrderAndResultsWithVitalPhysicianNetwork, nil
	}
	var t DelegatedFlowType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DelegatedFlowType) Ptr() *DelegatedFlowType {
	return &d
}

type DemoConnectionStatus struct {
	Success bool   `json:"success" url:"success"`
	Detail  string `json:"detail" url:"detail"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DemoConnectionStatus) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DemoConnectionStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler DemoConnectionStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DemoConnectionStatus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DemoConnectionStatus) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DemoProviders string

const (
	DemoProvidersAppleHealthKit DemoProviders = "apple_health_kit"
	DemoProvidersFitbit         DemoProviders = "fitbit"
	DemoProvidersFreestyleLibre DemoProviders = "freestyle_libre"
	DemoProvidersOura           DemoProviders = "oura"
)

func NewDemoProvidersFromString(s string) (DemoProviders, error) {
	switch s {
	case "apple_health_kit":
		return DemoProvidersAppleHealthKit, nil
	case "fitbit":
		return DemoProvidersFitbit, nil
	case "freestyle_libre":
		return DemoProvidersFreestyleLibre, nil
	case "oura":
		return DemoProvidersOura, nil
	}
	var t DemoProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DemoProviders) Ptr() *DemoProviders {
	return &d
}

type DetectedDeviationEntry struct {
	Date      string                          `json:"date" url:"date"`
	Deviation DetectedDeviationEntryDeviation `json:"deviation" url:"deviation"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DetectedDeviationEntry) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetectedDeviationEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler DetectedDeviationEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetectedDeviationEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetectedDeviationEntry) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DetectedDeviationEntryDeviation string

const (
	DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding DetectedDeviationEntryDeviation = "persistent_intermenstrual_bleeding"
	DetectedDeviationEntryDeviationProlongedMenstrualPeriods        DetectedDeviationEntryDeviation = "prolonged_menstrual_periods"
	DetectedDeviationEntryDeviationIrregularMenstrualCycles         DetectedDeviationEntryDeviation = "irregular_menstrual_cycles"
	DetectedDeviationEntryDeviationInfrequentMenstrualCycles        DetectedDeviationEntryDeviation = "infrequent_menstrual_cycles"
)

func NewDetectedDeviationEntryDeviationFromString(s string) (DetectedDeviationEntryDeviation, error) {
	switch s {
	case "persistent_intermenstrual_bleeding":
		return DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding, nil
	case "prolonged_menstrual_periods":
		return DetectedDeviationEntryDeviationProlongedMenstrualPeriods, nil
	case "irregular_menstrual_cycles":
		return DetectedDeviationEntryDeviationIrregularMenstrualCycles, nil
	case "infrequent_menstrual_cycles":
		return DetectedDeviationEntryDeviationInfrequentMenstrualCycles, nil
	}
	var t DetectedDeviationEntryDeviation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DetectedDeviationEntryDeviation) Ptr() *DetectedDeviationEntryDeviation {
	return &d
}

type DeviceV2InDb struct {
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceV2InDb) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceV2InDb(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceV2InDb) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmailProviders = string

type Energy struct {
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Energy) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Energy) Unit() string {
	return e.unit
}

func (e *Energy) UnmarshalJSON(data []byte) error {
	type embed Energy
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Energy(unmarshaler.embed)
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "kcal", unmarshaler.Unit)
	}
	e.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *e, "unit")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Energy) MarshalJSON() ([]byte, error) {
	type embed Energy
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*e),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (e *Energy) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventDestinationPreferences struct {
	Preferred EventDestinationPreferencesPreferred     `json:"preferred" url:"preferred"`
	Enabled   []EventDestinationPreferencesEnabledItem `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventDestinationPreferences) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventDestinationPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler EventDestinationPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventDestinationPreferences(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventDestinationPreferences) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventDestinationPreferencesEnabledItem string

const (
	EventDestinationPreferencesEnabledItemCloudPubsub EventDestinationPreferencesEnabledItem = "cloud_pubsub"
	EventDestinationPreferencesEnabledItemRabbitmq    EventDestinationPreferencesEnabledItem = "rabbitmq"
	EventDestinationPreferencesEnabledItemSvix        EventDestinationPreferencesEnabledItem = "svix"
	EventDestinationPreferencesEnabledItemAzureAmqp   EventDestinationPreferencesEnabledItem = "azure_amqp"
)

func NewEventDestinationPreferencesEnabledItemFromString(s string) (EventDestinationPreferencesEnabledItem, error) {
	switch s {
	case "cloud_pubsub":
		return EventDestinationPreferencesEnabledItemCloudPubsub, nil
	case "rabbitmq":
		return EventDestinationPreferencesEnabledItemRabbitmq, nil
	case "svix":
		return EventDestinationPreferencesEnabledItemSvix, nil
	case "azure_amqp":
		return EventDestinationPreferencesEnabledItemAzureAmqp, nil
	}
	var t EventDestinationPreferencesEnabledItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventDestinationPreferencesEnabledItem) Ptr() *EventDestinationPreferencesEnabledItem {
	return &e
}

type EventDestinationPreferencesPreferred string

const (
	EventDestinationPreferencesPreferredCloudPubsub EventDestinationPreferencesPreferred = "cloud_pubsub"
	EventDestinationPreferencesPreferredRabbitmq    EventDestinationPreferencesPreferred = "rabbitmq"
	EventDestinationPreferencesPreferredSvix        EventDestinationPreferencesPreferred = "svix"
	EventDestinationPreferencesPreferredAzureAmqp   EventDestinationPreferencesPreferred = "azure_amqp"
)

func NewEventDestinationPreferencesPreferredFromString(s string) (EventDestinationPreferencesPreferred, error) {
	switch s {
	case "cloud_pubsub":
		return EventDestinationPreferencesPreferredCloudPubsub, nil
	case "rabbitmq":
		return EventDestinationPreferencesPreferredRabbitmq, nil
	case "svix":
		return EventDestinationPreferencesPreferredSvix, nil
	case "azure_amqp":
		return EventDestinationPreferencesPreferredAzureAmqp, nil
	}
	var t EventDestinationPreferencesPreferred
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventDestinationPreferencesPreferred) Ptr() *EventDestinationPreferencesPreferred {
	return &e
}

type FailureType string

const (
	FailureTypeQuantityNotSufficientFailure FailureType = "quantity_not_sufficient_failure"
	FailureTypeCollectionProcessFailure     FailureType = "collection_process_failure"
	FailureTypeDropOffFailure               FailureType = "drop_off_failure"
	FailureTypeInternalLabFailure           FailureType = "internal_lab_failure"
	FailureTypeOrderEntryFailure            FailureType = "order_entry_failure"
	FailureTypeNonFailure                   FailureType = "non_failure"
	FailureTypeUnknownFailure               FailureType = "unknown_failure"
	FailureTypePatientConditionFailure      FailureType = "patient_condition_failure"
	FailureTypeMissingResultCalcFailure     FailureType = "missing_result_calc_failure"
	FailureTypeMissingDemoAoeCalcFailure    FailureType = "missing_demo_aoe_calc_failure"
)

func NewFailureTypeFromString(s string) (FailureType, error) {
	switch s {
	case "quantity_not_sufficient_failure":
		return FailureTypeQuantityNotSufficientFailure, nil
	case "collection_process_failure":
		return FailureTypeCollectionProcessFailure, nil
	case "drop_off_failure":
		return FailureTypeDropOffFailure, nil
	case "internal_lab_failure":
		return FailureTypeInternalLabFailure, nil
	case "order_entry_failure":
		return FailureTypeOrderEntryFailure, nil
	case "non_failure":
		return FailureTypeNonFailure, nil
	case "unknown_failure":
		return FailureTypeUnknownFailure, nil
	case "patient_condition_failure":
		return FailureTypePatientConditionFailure, nil
	case "missing_result_calc_failure":
		return FailureTypeMissingResultCalcFailure, nil
	case "missing_demo_aoe_calc_failure":
		return FailureTypeMissingDemoAoeCalcFailure, nil
	}
	var t FailureType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FailureType) Ptr() *FailureType {
	return &f
}

type FallbackBirthDate struct {
	// Fallback date of birth of the user, in YYYY-mm-dd format. Used for calculating max heartrate for providers that don not provide users' age.
	Value string `json:"value" url:"value"`
	// Slug for designated source
	SourceSlug string `json:"source_slug" url:"source_slug"`
	UpdatedAt  string `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FallbackBirthDate) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackBirthDate) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackBirthDate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackBirthDate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackBirthDate) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackTimeZone struct {
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	Id string `json:"id" url:"id"`
	// Slug for designated source
	SourceSlug string `json:"source_slug" url:"source_slug"`
	UpdatedAt  string `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FallbackTimeZone) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackTimeZone) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackTimeZone
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackTimeZone(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTimeZone) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Fats struct {
	// Amount of saturated fats in grams (g)
	Saturated *float64 `json:"saturated,omitempty" url:"saturated,omitempty"`
	// Amount of monounsaturated fats in grams (g)
	Monounsaturated *float64 `json:"monounsaturated,omitempty" url:"monounsaturated,omitempty"`
	// Amount of polyunsaturated fats in grams (g)
	Polyunsaturated *float64 `json:"polyunsaturated,omitempty" url:"polyunsaturated,omitempty"`
	// Amount of Omega-3 fatty acids in grams (g)
	Omega3 *float64 `json:"omega3,omitempty" url:"omega3,omitempty"`
	// Amount of Omega-6 fatty acids in grams (g)
	Omega6 *float64 `json:"omega6,omitempty" url:"omega6,omitempty"`
	// Total amount of fats in grams (g)
	Total *float64 `json:"total,omitempty" url:"total,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Fats) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fats) UnmarshalJSON(data []byte) error {
	type unmarshaler Fats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fats(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fats) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Gender string

const (
	GenderFemale  Gender = "female"
	GenderMale    Gender = "male"
	GenderOther   Gender = "other"
	GenderUnknown Gender = "unknown"
)

func NewGenderFromString(s string) (Gender, error) {
	switch s {
	case "female":
		return GenderFemale, nil
	case "male":
		return GenderMale, nil
	case "other":
		return GenderOther, nil
	case "unknown":
		return GenderUnknown, nil
	}
	var t Gender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g Gender) Ptr() *Gender {
	return &g
}

type GetMarkersResponse struct {
	Markers []*ClientFacingMarkerComplete `json:"markers,omitempty" url:"markers,omitempty"`
	Total   *int                          `json:"total,omitempty" url:"total,omitempty"`
	Page    *int                          `json:"page,omitempty" url:"page,omitempty"`
	Size    *int                          `json:"size,omitempty" url:"size,omitempty"`
	Pages   *int                          `json:"pages,omitempty" url:"pages,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetMarkersResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetMarkersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetMarkersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetMarkersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetMarkersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetOrdersResponse struct {
	Orders []*ClientFacingOrder `json:"orders,omitempty" url:"orders,omitempty"`
	Total  *int                 `json:"total,omitempty" url:"total,omitempty"`
	Page   *int                 `json:"page,omitempty" url:"page,omitempty"`
	Size   *int                 `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrdersResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrdersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupKeyColumnExpr struct {
	GroupKey *GroupKeyColumnExprGroupKey `json:"group_key,omitempty" url:"group_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupKeyColumnExpr) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupKeyColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupKeyColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupKeyColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupKeyColumnExpr) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupKeyColumnExprGroupKey struct {
	Integer int
	Select  Select
}

func NewGroupKeyColumnExprGroupKeyFromInteger(value int) *GroupKeyColumnExprGroupKey {
	return &GroupKeyColumnExprGroupKey{Integer: value}
}

func NewGroupKeyColumnExprGroupKeyFromSelect(value Select) *GroupKeyColumnExprGroupKey {
	return &GroupKeyColumnExprGroupKey{Select: value}
}

func (g *GroupKeyColumnExprGroupKey) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.Integer = valueInteger
		return nil
	}
	var valueSelect Select
	if err := json.Unmarshal(data, &valueSelect); err == nil {
		g.Select = valueSelect
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroupKeyColumnExprGroupKey) MarshalJSON() ([]byte, error) {
	if g.Integer != 0 {
		return json.Marshal(g.Integer)
	}
	if g.Select != "" {
		return json.Marshal(g.Select)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroupKeyColumnExprGroupKeyVisitor interface {
	VisitInteger(int) error
	VisitSelect(Select) error
}

func (g *GroupKeyColumnExprGroupKey) Accept(visitor GroupKeyColumnExprGroupKeyVisitor) error {
	if g.Integer != 0 {
		return visitor.VisitInteger(g.Integer)
	}
	if g.Select != "" {
		return visitor.VisitSelect(g.Select)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroupedBloodOxygen struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBloodOxygenTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodOxygen) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygen) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygen(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygen) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodOxygenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodOxygen `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodOxygenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygenResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodPressure struct {
	Source *ClientFacingSource                    `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBloodPressureTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodPressure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressure(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressure) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodPressureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodPressure `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodPressureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressureResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressureResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyFat struct {
	Source *ClientFacingSource              `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyFatTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyFat) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFat) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFat(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFat) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyFatResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyFat `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyFatResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFatResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFatResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyWeight struct {
	Source *ClientFacingSource                 `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyWeightTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyWeight) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeight) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeight
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeight(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeight) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyWeightResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyWeight `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyWeightResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeightResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeightResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeightResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeightResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaffeine struct {
	Source *ClientFacingSource               `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCaffeineTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaffeine) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeine) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeine(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeine) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaffeineResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaffeine `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaffeineResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeineResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeineResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeineResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeineResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesActive struct {
	Source *ClientFacingSource                     `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCaloriesActiveTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesActive) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActive) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActive(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActive) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesActiveResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesActive `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesActiveResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActiveResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActiveResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActiveResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActiveResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesBasal struct {
	Source *ClientFacingSource                    `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCaloriesBasalTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesBasal) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasal) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasal(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasal) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesBasalResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesBasal `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesBasalResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasalResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasalResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasalResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasalResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCholesterol struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCholesterolTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCholesterol) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterol) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterol
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterol(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterol) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCholesterolResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCholesterol `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCholesterolResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterolResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterolResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterolResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterolResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDistance struct {
	Source *ClientFacingSource               `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingDistanceTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedDistance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistance) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDistanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedDistance `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedDistanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistanceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistanceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedElectrocardiogramVoltage struct {
	Source *ClientFacingSource                               `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingElectrocardiogramVoltageTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedElectrocardiogramVoltage) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltage) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedElectrocardiogramVoltageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedElectrocardiogramVoltage `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedElectrocardiogramVoltageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFloorsClimbed struct {
	Source *ClientFacingSource                    `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingFloorsClimbedTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedFloorsClimbed) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbed) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbed(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbed) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFloorsClimbedResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedFloorsClimbed `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedFloorsClimbedResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbedResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbedResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedGlucose struct {
	Source *ClientFacingSource              `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingGlucoseTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedGlucose) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucose) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucose(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucose) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedGlucoseResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedGlucose `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedGlucoseResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucoseResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucoseResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucoseResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucoseResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRate struct {
	Source *ClientFacingSource                `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHeartRateTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHeartRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRate `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHeartRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHrv struct {
	Source *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHrvTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHrv) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrv) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrv
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrv(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrv) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHrvResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHrv `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHrvResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrvResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrvResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrvResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrvResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHypnogram struct {
	Source *ClientFacingSource                `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHypnogramTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHypnogram) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogram) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogram(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogram) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHypnogramResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHypnogram `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHypnogramResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogramResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogramResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIge struct {
	Source *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingIgeTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIge) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIge) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIge) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIgeResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIge `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIgeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIgg struct {
	Source *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingIggTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIgg) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgg) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgg(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgg) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIggResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIgg `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIggResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIggResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIggResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIggResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIggResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedMindfulnessMinutes struct {
	Source *ClientFacingSource                         `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingMindfulnessMinutesTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedMindfulnessMinutes) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutes) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutes(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutes) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedMindfulnessMinutesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedMindfulnessMinutes `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedMindfulnessMinutesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedRespiratoryRate struct {
	Source *ClientFacingSource                      `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingRespiratoryRateTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedRespiratoryRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedRespiratoryRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedRespiratoryRate `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedRespiratoryRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRateResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedSteps struct {
	Source *ClientFacingSource            `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingStepsTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedSteps) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSteps) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSteps
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSteps(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSteps) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStepsResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSteps `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStepsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStepsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStepsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStepsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStepsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStressLevel struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingStressLevelTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStressLevel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevel) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevel) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStressLevelResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStressLevel `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStressLevelResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevelResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevelResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedVo2Max struct {
	Source *ClientFacingSource             `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingVo2MaxTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedVo2Max) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2Max) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2Max
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2Max(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2Max) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedVo2MaxResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedVo2Max `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedVo2MaxResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2MaxResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2MaxResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2MaxResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2MaxResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWater struct {
	Source *ClientFacingSource            `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingWaterTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWater) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWater) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWater
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWater(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWater) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWaterResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWater `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWaterResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaterResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaterResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuarantorDetails struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`
	Email       *string  `json:"email,omitempty" url:"email,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GuarantorDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuarantorDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler GuarantorDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuarantorDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuarantorDetails) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HealthInsuranceCreateRequest struct {
	// An image of the front of the patient insurance card.
	FrontImage *HealthInsuranceCreateRequestFrontImage `json:"front_image,omitempty" url:"front_image,omitempty"`
	// An image of the back of the patient insurance card.
	BackImage *HealthInsuranceCreateRequestBackImage `json:"back_image,omitempty" url:"back_image,omitempty"`
	// An image of the patient signature for health insurance billing.
	PatientSignatureImage *HealthInsuranceCreateRequestPatientSignatureImage `json:"patient_signature_image,omitempty" url:"patient_signature_image,omitempty"`
	// Textual description of what are the patient symptoms and attempted treatments.
	Subjective *string `json:"subjective,omitempty" url:"subjective,omitempty"`
	// Textual description of what are the physician assessments and testing plans.
	AssessmentPlan *string `json:"assessment_plan,omitempty" url:"assessment_plan,omitempty"`
	// Unique identifier representing a specific Health Insurance.
	PayorCode *string `json:"payor_code,omitempty" url:"payor_code,omitempty"`
	// Insurance unique number assigned to a patient, usually present on the insurance card.
	InsuranceId *string `json:"insurance_id,omitempty" url:"insurance_id,omitempty"`
	// Relationship between the patient and the insurance contractor. Values can be (Self, Spouse, Other Relationship).
	ResponsibleRelationship *ResponsibleRelationship `json:"responsible_relationship,omitempty" url:"responsible_relationship,omitempty"`
	// Responsible details when the value of responsible_relationship is not 'Self'.
	ResponsibleDetails *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails `json:"responsible_details,omitempty" url:"responsible_details,omitempty"`
	// Diagnosis codes for insurance billing.
	DiagnosisCodes []string `json:"diagnosis_codes,omitempty" url:"diagnosis_codes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HealthInsuranceCreateRequest) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HealthInsuranceCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HealthInsuranceCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HealthInsuranceCreateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HealthInsuranceCreateRequest) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// An image of the back of the patient insurance card.
type HealthInsuranceCreateRequestBackImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewHealthInsuranceCreateRequestBackImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{Jpeg: value}
}

func NewHealthInsuranceCreateRequestBackImageFromPng(value *Png) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{Png: value}
}

func (h *HealthInsuranceCreateRequestBackImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestBackImage) MarshalJSON() ([]byte, error) {
	if h.Jpeg != nil {
		return json.Marshal(h.Jpeg)
	}
	if h.Png != nil {
		return json.Marshal(h.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HealthInsuranceCreateRequestBackImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestBackImage) Accept(visitor HealthInsuranceCreateRequestBackImageVisitor) error {
	if h.Jpeg != nil {
		return visitor.VisitJpeg(h.Jpeg)
	}
	if h.Png != nil {
		return visitor.VisitPng(h.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

// An image of the front of the patient insurance card.
type HealthInsuranceCreateRequestFrontImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewHealthInsuranceCreateRequestFrontImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{Jpeg: value}
}

func NewHealthInsuranceCreateRequestFrontImageFromPng(value *Png) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{Png: value}
}

func (h *HealthInsuranceCreateRequestFrontImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestFrontImage) MarshalJSON() ([]byte, error) {
	if h.Jpeg != nil {
		return json.Marshal(h.Jpeg)
	}
	if h.Png != nil {
		return json.Marshal(h.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HealthInsuranceCreateRequestFrontImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestFrontImage) Accept(visitor HealthInsuranceCreateRequestFrontImageVisitor) error {
	if h.Jpeg != nil {
		return visitor.VisitJpeg(h.Jpeg)
	}
	if h.Png != nil {
		return visitor.VisitPng(h.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

// An image of the patient signature for health insurance billing.
type HealthInsuranceCreateRequestPatientSignatureImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{Jpeg: value}
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromPng(value *Png) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{Png: value}
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestPatientSignatureImage) MarshalJSON() ([]byte, error) {
	if h.Jpeg != nil {
		return json.Marshal(h.Jpeg)
	}
	if h.Png != nil {
		return json.Marshal(h.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HealthInsuranceCreateRequestPatientSignatureImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) Accept(visitor HealthInsuranceCreateRequestPatientSignatureImageVisitor) error {
	if h.Jpeg != nil {
		return visitor.VisitJpeg(h.Jpeg)
	}
	if h.Png != nil {
		return visitor.VisitPng(h.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HistoricalPullStatus string

const (
	HistoricalPullStatusSuccess    HistoricalPullStatus = "success"
	HistoricalPullStatusFailure    HistoricalPullStatus = "failure"
	HistoricalPullStatusInProgress HistoricalPullStatus = "in_progress"
	HistoricalPullStatusScheduled  HistoricalPullStatus = "scheduled"
)

func NewHistoricalPullStatusFromString(s string) (HistoricalPullStatus, error) {
	switch s {
	case "success":
		return HistoricalPullStatusSuccess, nil
	case "failure":
		return HistoricalPullStatusFailure, nil
	case "in_progress":
		return HistoricalPullStatusInProgress, nil
	case "scheduled":
		return HistoricalPullStatusScheduled, nil
	}
	var t HistoricalPullStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HistoricalPullStatus) Ptr() *HistoricalPullStatus {
	return &h
}

type HistoricalPullTimeline struct {
	ScheduledAt string  `json:"scheduled_at" url:"scheduled_at"`
	StartedAt   *string `json:"started_at,omitempty" url:"started_at,omitempty"`
	EndedAt     *string `json:"ended_at,omitempty" url:"ended_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HistoricalPullTimeline) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HistoricalPullTimeline) UnmarshalJSON(data []byte) error {
	type unmarshaler HistoricalPullTimeline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HistoricalPullTimeline(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HistoricalPullTimeline) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomePregnancyTestEntry struct {
	Date       string                           `json:"date" url:"date"`
	TestResult HomePregnancyTestEntryTestResult `json:"test_result" url:"test_result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HomePregnancyTestEntry) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HomePregnancyTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomePregnancyTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomePregnancyTestEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomePregnancyTestEntry) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomePregnancyTestEntryTestResult string

const (
	HomePregnancyTestEntryTestResultNegative      HomePregnancyTestEntryTestResult = "negative"
	HomePregnancyTestEntryTestResultPositive      HomePregnancyTestEntryTestResult = "positive"
	HomePregnancyTestEntryTestResultIndeterminate HomePregnancyTestEntryTestResult = "indeterminate"
)

func NewHomePregnancyTestEntryTestResultFromString(s string) (HomePregnancyTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomePregnancyTestEntryTestResultNegative, nil
	case "positive":
		return HomePregnancyTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomePregnancyTestEntryTestResultIndeterminate, nil
	}
	var t HomePregnancyTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomePregnancyTestEntryTestResult) Ptr() *HomePregnancyTestEntryTestResult {
	return &h
}

type HomeProgesteroneTestEntry struct {
	Date       string                              `json:"date" url:"date"`
	TestResult HomeProgesteroneTestEntryTestResult `json:"test_result" url:"test_result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HomeProgesteroneTestEntry) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HomeProgesteroneTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomeProgesteroneTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomeProgesteroneTestEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomeProgesteroneTestEntry) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomeProgesteroneTestEntryTestResult string

const (
	HomeProgesteroneTestEntryTestResultNegative      HomeProgesteroneTestEntryTestResult = "negative"
	HomeProgesteroneTestEntryTestResultPositive      HomeProgesteroneTestEntryTestResult = "positive"
	HomeProgesteroneTestEntryTestResultIndeterminate HomeProgesteroneTestEntryTestResult = "indeterminate"
)

func NewHomeProgesteroneTestEntryTestResultFromString(s string) (HomeProgesteroneTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomeProgesteroneTestEntryTestResultNegative, nil
	case "positive":
		return HomeProgesteroneTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomeProgesteroneTestEntryTestResultIndeterminate, nil
	}
	var t HomeProgesteroneTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomeProgesteroneTestEntryTestResult) Ptr() *HomeProgesteroneTestEntryTestResult {
	return &h
}

type HttpValidationError struct {
	Detail interface{} `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpValidationError) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpValidationError) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type IndexColumnExpr struct {
	Index IndexColumnExprIndex `json:"index" url:"index"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IndexColumnExpr) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndexColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler IndexColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndexColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndexColumnExpr) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndexColumnExprIndex string

const (
	IndexColumnExprIndexSleep    IndexColumnExprIndex = "sleep"
	IndexColumnExprIndexActivity IndexColumnExprIndex = "activity"
	IndexColumnExprIndexWorkout  IndexColumnExprIndex = "workout"
	IndexColumnExprIndexBody     IndexColumnExprIndex = "body"
)

func NewIndexColumnExprIndexFromString(s string) (IndexColumnExprIndex, error) {
	switch s {
	case "sleep":
		return IndexColumnExprIndexSleep, nil
	case "activity":
		return IndexColumnExprIndexActivity, nil
	case "workout":
		return IndexColumnExprIndexWorkout, nil
	case "body":
		return IndexColumnExprIndexBody, nil
	}
	var t IndexColumnExprIndex
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IndexColumnExprIndex) Ptr() *IndexColumnExprIndex {
	return &i
}

type IntermenstrualBleedingEntry struct {
	Date string `json:"date" url:"date"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntermenstrualBleedingEntry) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntermenstrualBleedingEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler IntermenstrualBleedingEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntermenstrualBleedingEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntermenstrualBleedingEntry) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Jpeg struct {
	Content     string `json:"content" url:"content"`
	contentType string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *Jpeg) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *Jpeg) ContentType() string {
	return j.contentType
}

func (j *Jpeg) UnmarshalJSON(data []byte) error {
	type embed Jpeg
	var unmarshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = Jpeg(unmarshaler.embed)
	if unmarshaler.ContentType != "image/jpeg" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", j, "image/jpeg", unmarshaler.ContentType)
	}
	j.contentType = unmarshaler.ContentType

	extraProperties, err := core.ExtractExtraProperties(data, *j, "content_type")
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *Jpeg) MarshalJSON() ([]byte, error) {
	type embed Jpeg
	var marshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed:       embed(*j),
		ContentType: "image/jpeg",
	}
	return json.Marshal(marshaler)
}

func (j *Jpeg) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type LabLocationMetadata struct {
	Name        string                 `json:"name" url:"name"`
	State       string                 `json:"state" url:"state"`
	City        string                 `json:"city" url:"city"`
	ZipCode     string                 `json:"zip_code" url:"zip_code"`
	FirstLine   string                 `json:"first_line" url:"first_line"`
	SecondLine  *string                `json:"second_line,omitempty" url:"second_line,omitempty"`
	PhoneNumber *string                `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	FaxNumber   *string                `json:"fax_number,omitempty" url:"fax_number,omitempty"`
	Hours       map[string]interface{} `json:"hours,omitempty" url:"hours,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabLocationMetadata) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabLocationMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LabLocationMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabLocationMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabLocationMetadata) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsMetadata struct {
	Age            string  `json:"age" url:"age"`
	Dob            string  `json:"dob" url:"dob"`
	Clia           *string `json:"clia_#,omitempty" url:"clia_#,omitempty"`
	Patient        string  `json:"patient" url:"patient"`
	Provider       *string `json:"provider,omitempty" url:"provider,omitempty"`
	Laboratory     *string `json:"laboratory,omitempty" url:"laboratory,omitempty"`
	DateReported   string  `json:"date_reported" url:"date_reported"`
	DateCollected  *string `json:"date_collected,omitempty" url:"date_collected,omitempty"`
	SpecimenNumber string  `json:"specimen_number" url:"specimen_number"`
	DateReceived   *string `json:"date_received,omitempty" url:"date_received,omitempty"`
	Status         *string `json:"status,omitempty" url:"status,omitempty"`
	Interpretation *string `json:"interpretation,omitempty" url:"interpretation,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabResultsMetadata) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabResultsMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsMetadata) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRaw struct {
	Metadata       *LabResultsMetadata       `json:"metadata,omitempty" url:"metadata,omitempty"`
	Results        *LabResultsRawResults     `json:"results,omitempty" url:"results,omitempty"`
	MissingResults []*MissingBiomarkerResult `json:"missing_results,omitempty" url:"missing_results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabResultsRaw) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabResultsRaw) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsRaw
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsRaw(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsRaw) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRawResults struct {
	BiomarkerResultList []*BiomarkerResult
	StringUnknownMap    map[string]interface{}
}

func NewLabResultsRawResultsFromBiomarkerResultList(value []*BiomarkerResult) *LabResultsRawResults {
	return &LabResultsRawResults{BiomarkerResultList: value}
}

func NewLabResultsRawResultsFromStringUnknownMap(value map[string]interface{}) *LabResultsRawResults {
	return &LabResultsRawResults{StringUnknownMap: value}
}

func (l *LabResultsRawResults) UnmarshalJSON(data []byte) error {
	var valueBiomarkerResultList []*BiomarkerResult
	if err := json.Unmarshal(data, &valueBiomarkerResultList); err == nil {
		l.BiomarkerResultList = valueBiomarkerResultList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		l.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LabResultsRawResults) MarshalJSON() ([]byte, error) {
	if l.BiomarkerResultList != nil {
		return json.Marshal(l.BiomarkerResultList)
	}
	if l.StringUnknownMap != nil {
		return json.Marshal(l.StringUnknownMap)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LabResultsRawResultsVisitor interface {
	VisitBiomarkerResultList([]*BiomarkerResult) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (l *LabResultsRawResults) Accept(visitor LabResultsRawResultsVisitor) error {
	if l.BiomarkerResultList != nil {
		return visitor.VisitBiomarkerResultList(l.BiomarkerResultList)
	}
	if l.StringUnknownMap != nil {
		return visitor.VisitStringUnknownMap(l.StringUnknownMap)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// The method used to perform a lab test.
type LabTestCollectionMethod string

const (
	LabTestCollectionMethodTestkit          LabTestCollectionMethod = "testkit"
	LabTestCollectionMethodWalkInTest       LabTestCollectionMethod = "walk_in_test"
	LabTestCollectionMethodAtHomePhlebotomy LabTestCollectionMethod = "at_home_phlebotomy"
)

func NewLabTestCollectionMethodFromString(s string) (LabTestCollectionMethod, error) {
	switch s {
	case "testkit":
		return LabTestCollectionMethodTestkit, nil
	case "walk_in_test":
		return LabTestCollectionMethodWalkInTest, nil
	case "at_home_phlebotomy":
		return LabTestCollectionMethodAtHomePhlebotomy, nil
	}
	var t LabTestCollectionMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestCollectionMethod) Ptr() *LabTestCollectionMethod {
	return &l
}

// The type of sample used to perform a lab test.
type LabTestSampleType string

const (
	LabTestSampleTypeDriedBloodSpot LabTestSampleType = "dried_blood_spot"
	LabTestSampleTypeArmCollector   LabTestSampleType = "arm_collector"
	LabTestSampleTypeSerum          LabTestSampleType = "serum"
	LabTestSampleTypeSaliva         LabTestSampleType = "saliva"
	LabTestSampleTypeUrine          LabTestSampleType = "urine"
)

func NewLabTestSampleTypeFromString(s string) (LabTestSampleType, error) {
	switch s {
	case "dried_blood_spot":
		return LabTestSampleTypeDriedBloodSpot, nil
	case "arm_collector":
		return LabTestSampleTypeArmCollector, nil
	case "serum":
		return LabTestSampleTypeSerum, nil
	case "saliva":
		return LabTestSampleTypeSaliva, nil
	case "urine":
		return LabTestSampleTypeUrine, nil
	}
	var t LabTestSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestSampleType) Ptr() *LabTestSampleType {
	return &l
}

type LabTestStatus string

const (
	LabTestStatusActive          LabTestStatus = "active"
	LabTestStatusPendingApproval LabTestStatus = "pending_approval"
	LabTestStatusInactive        LabTestStatus = "inactive"
)

func NewLabTestStatusFromString(s string) (LabTestStatus, error) {
	switch s {
	case "active":
		return LabTestStatusActive, nil
	case "pending_approval":
		return LabTestStatusPendingApproval, nil
	case "inactive":
		return LabTestStatusInactive, nil
	}
	var t LabTestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestStatus) Ptr() *LabTestStatus {
	return &l
}

type Labs string

const (
	LabsAyumetrix    Labs = "ayumetrix"
	LabsSpiriplex    Labs = "spiriplex"
	LabsUssl         Labs = "ussl"
	LabsQuest        Labs = "quest"
	LabsLabcorp      Labs = "labcorp"
	LabsBioreference Labs = "bioreference"
	LabsUsBiotek     Labs = "us_biotek"
	LabsManual       Labs = "manual"
	LabsSanocardio   Labs = "sanocardio"
	LabsIhd          Labs = "ihd"
)

func NewLabsFromString(s string) (Labs, error) {
	switch s {
	case "ayumetrix":
		return LabsAyumetrix, nil
	case "spiriplex":
		return LabsSpiriplex, nil
	case "ussl":
		return LabsUssl, nil
	case "quest":
		return LabsQuest, nil
	case "labcorp":
		return LabsLabcorp, nil
	case "bioreference":
		return LabsBioreference, nil
	case "us_biotek":
		return LabsUsBiotek, nil
	case "manual":
		return LabsManual, nil
	case "sanocardio":
		return LabsSanocardio, nil
	case "ihd":
		return LabsIhd, nil
	}
	var t Labs
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l Labs) Ptr() *Labs {
	return &l
}

type LastAttempt struct {
	Timestamp string        `json:"timestamp" url:"timestamp"`
	Status    AttemptStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LastAttempt) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LastAttempt) UnmarshalJSON(data []byte) error {
	type unmarshaler LastAttempt
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LastAttempt(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LastAttempt) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LibreConfig struct {
	PracticeId map[string]interface{} `json:"practice_id,omitempty" url:"practice_id,omitempty"`
	StripTz    *bool                  `json:"strip_tz,omitempty" url:"strip_tz,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LibreConfig) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LibreConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LibreConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LibreConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LibreConfig) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LinkTokenExchangeResponse struct {
	// A short-lived Vital Link token for your Custom Link Widget to communicate with the Vital API.
	LinkToken string `json:"link_token" url:"link_token"`
	// The web browser link to launch the default Vital Link experience. If you requested the token for one specific provider, the link would redirect directly to the provider authentication flow. Otherwise, the user would be presented with a list of providers based on your team and token configurations.
	LinkWebUrl string `json:"link_web_url" url:"link_web_url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LinkTokenExchangeResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkTokenExchangeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkTokenExchangeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkTokenExchangeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkTokenExchangeResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LngLat struct {
	Lng float64 `json:"lng" url:"lng"`
	Lat float64 `json:"lat" url:"lat"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LngLat) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LngLat) UnmarshalJSON(data []byte) error {
	type unmarshaler LngLat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LngLat(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LngLat) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Macros struct {
	// Amount of carbohydrates in grams (g)
	Carbs *float64 `json:"carbs,omitempty" url:"carbs,omitempty"`
	// Amount of protein in grams (g)
	Protein *float64 `json:"protein,omitempty" url:"protein,omitempty"`
	// Details of fat content
	Fats *Fats `json:"fats,omitempty" url:"fats,omitempty"`
	// Amount of alcohol in grams (g)
	Alcohol *float64 `json:"alcohol,omitempty" url:"alcohol,omitempty"`
	// Amount of water in grams (g)
	Water *float64 `json:"water,omitempty" url:"water,omitempty"`
	// Amount of dietary fiber in grams (g)
	Fibre *float64 `json:"fibre,omitempty" url:"fibre,omitempty"`
	// Amount of sugar in grams (g)
	Sugar *float64 `json:"sugar,omitempty" url:"sugar,omitempty"`
	// Amount of cholesterol in grams (g)
	Cholesterol *float64 `json:"cholesterol,omitempty" url:"cholesterol,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Macros) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Macros) UnmarshalJSON(data []byte) error {
	type unmarshaler Macros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Macros(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Macros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ManualProviders string

const (
	ManualProvidersBeurerBle         ManualProviders = "beurer_ble"
	ManualProvidersOmronBle          ManualProviders = "omron_ble"
	ManualProvidersAccuchekBle       ManualProviders = "accuchek_ble"
	ManualProvidersContourBle        ManualProviders = "contour_ble"
	ManualProvidersFreestyleLibreBle ManualProviders = "freestyle_libre_ble"
	ManualProvidersOnetouchBle       ManualProviders = "onetouch_ble"
	ManualProvidersAppleHealthKit    ManualProviders = "apple_health_kit"
	ManualProvidersManual            ManualProviders = "manual"
	ManualProvidersHealthConnect     ManualProviders = "health_connect"
)

func NewManualProvidersFromString(s string) (ManualProviders, error) {
	switch s {
	case "beurer_ble":
		return ManualProvidersBeurerBle, nil
	case "omron_ble":
		return ManualProvidersOmronBle, nil
	case "accuchek_ble":
		return ManualProvidersAccuchekBle, nil
	case "contour_ble":
		return ManualProvidersContourBle, nil
	case "freestyle_libre_ble":
		return ManualProvidersFreestyleLibreBle, nil
	case "onetouch_ble":
		return ManualProvidersOnetouchBle, nil
	case "apple_health_kit":
		return ManualProvidersAppleHealthKit, nil
	case "manual":
		return ManualProvidersManual, nil
	case "health_connect":
		return ManualProvidersHealthConnect, nil
	}
	var t ManualProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManualProviders) Ptr() *ManualProviders {
	return &m
}

type MarkerType string

const (
	MarkerTypeBiomarker MarkerType = "biomarker"
	MarkerTypePanel     MarkerType = "panel"
)

func NewMarkerTypeFromString(s string) (MarkerType, error) {
	switch s {
	case "biomarker":
		return MarkerTypeBiomarker, nil
	case "panel":
		return MarkerTypePanel, nil
	}
	var t MarkerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MarkerType) Ptr() *MarkerType {
	return &m
}

type MealInDbBaseClientFacingSource struct {
	Id          string                       `json:"id" url:"id"`
	UserId      string                       `json:"user_id" url:"user_id"`
	PriorityId  int                          `json:"priority_id" url:"priority_id"`
	SourceId    int                          `json:"source_id" url:"source_id"`
	ProviderId  string                       `json:"provider_id" url:"provider_id"`
	Timestamp   string                       `json:"timestamp" url:"timestamp"`
	Name        string                       `json:"name" url:"name"`
	Energy      *Energy                      `json:"energy,omitempty" url:"energy,omitempty"`
	Macros      *Macros                      `json:"macros,omitempty" url:"macros,omitempty"`
	Micros      *Micros                      `json:"micros,omitempty" url:"micros,omitempty"`
	Data        map[string]*ClientFacingFood `json:"data,omitempty" url:"data,omitempty"`
	Source      *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	CreatedAt   string                       `json:"created_at" url:"created_at"`
	UpdatedAt   string                       `json:"updated_at" url:"updated_at"`
	SourceAppId *string                      `json:"source_app_id,omitempty" url:"source_app_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MealInDbBaseClientFacingSource) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MealInDbBaseClientFacingSource) UnmarshalJSON(data []byte) error {
	type unmarshaler MealInDbBaseClientFacingSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MealInDbBaseClientFacingSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MealInDbBaseClientFacingSource) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualCycle struct {
	PeriodStart            string                         `json:"period_start" url:"period_start"`
	PeriodEnd              *string                        `json:"period_end,omitempty" url:"period_end,omitempty"`
	CycleEnd               *string                        `json:"cycle_end,omitempty" url:"cycle_end,omitempty"`
	IsPredicted            *bool                          `json:"is_predicted,omitempty" url:"is_predicted,omitempty"`
	MenstrualFlow          []*MenstrualFlowEntry          `json:"menstrual_flow,omitempty" url:"menstrual_flow,omitempty"`
	CervicalMucus          []*CervicalMucusEntry          `json:"cervical_mucus,omitempty" url:"cervical_mucus,omitempty"`
	IntermenstrualBleeding []*IntermenstrualBleedingEntry `json:"intermenstrual_bleeding,omitempty" url:"intermenstrual_bleeding,omitempty"`
	Contraceptive          []*ContraceptiveEntry          `json:"contraceptive,omitempty" url:"contraceptive,omitempty"`
	DetectedDeviations     []*DetectedDeviationEntry      `json:"detected_deviations,omitempty" url:"detected_deviations,omitempty"`
	OvulationTest          []*OvulationTestEntry          `json:"ovulation_test,omitempty" url:"ovulation_test,omitempty"`
	HomePregnancyTest      []*HomePregnancyTestEntry      `json:"home_pregnancy_test,omitempty" url:"home_pregnancy_test,omitempty"`
	HomeProgesteroneTest   []*HomeProgesteroneTestEntry   `json:"home_progesterone_test,omitempty" url:"home_progesterone_test,omitempty"`
	SexualActivity         []*SexualActivityEntry         `json:"sexual_activity,omitempty" url:"sexual_activity,omitempty"`
	BasalBodyTemperature   []*BasalBodyTemperatureEntry   `json:"basal_body_temperature,omitempty" url:"basal_body_temperature,omitempty"`
	Source                 *ClientFacingSource            `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MenstrualCycle) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MenstrualCycle) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualCycle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualCycle(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualCycle) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualCycleResponse struct {
	MenstrualCycle []*MenstrualCycle `json:"menstrual_cycle,omitempty" url:"menstrual_cycle,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MenstrualCycleResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MenstrualCycleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualCycleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualCycleResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualCycleResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualFlowEntry struct {
	Date string                 `json:"date" url:"date"`
	Flow MenstrualFlowEntryFlow `json:"flow" url:"flow"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MenstrualFlowEntry) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MenstrualFlowEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualFlowEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualFlowEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualFlowEntry) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualFlowEntryFlow string

const (
	MenstrualFlowEntryFlowUnspecified MenstrualFlowEntryFlow = "unspecified"
	MenstrualFlowEntryFlowNone        MenstrualFlowEntryFlow = "none"
	MenstrualFlowEntryFlowLight       MenstrualFlowEntryFlow = "light"
	MenstrualFlowEntryFlowMedium      MenstrualFlowEntryFlow = "medium"
	MenstrualFlowEntryFlowHeavy       MenstrualFlowEntryFlow = "heavy"
)

func NewMenstrualFlowEntryFlowFromString(s string) (MenstrualFlowEntryFlow, error) {
	switch s {
	case "unspecified":
		return MenstrualFlowEntryFlowUnspecified, nil
	case "none":
		return MenstrualFlowEntryFlowNone, nil
	case "light":
		return MenstrualFlowEntryFlowLight, nil
	case "medium":
		return MenstrualFlowEntryFlowMedium, nil
	case "heavy":
		return MenstrualFlowEntryFlowHeavy, nil
	}
	var t MenstrualFlowEntryFlow
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MenstrualFlowEntryFlow) Ptr() *MenstrualFlowEntryFlow {
	return &m
}

type MetricsResult struct {
	TeamId                          string                   `json:"team_id" url:"team_id"`
	NumberOfConnectedSources        *int                     `json:"number_of_connected_sources,omitempty" url:"number_of_connected_sources,omitempty"`
	NumberOfUsers                   *int                     `json:"number_of_users,omitempty" url:"number_of_users,omitempty"`
	NumberOfErroredConnectedSources *int                     `json:"number_of_errored_connected_sources,omitempty" url:"number_of_errored_connected_sources,omitempty"`
	NumberOfConnectedSourcesByWeek  []*TimeseriesMetricPoint `json:"number_of_connected_sources_by_week,omitempty" url:"number_of_connected_sources_by_week,omitempty"`
	NumberOfOrderedTests            *int                     `json:"number_of_ordered_tests,omitempty" url:"number_of_ordered_tests,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetricsResult) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetricsResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsResult) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Micros struct {
	// Amount of each mineral in grams (g)
	Minerals map[string]*float64 `json:"minerals,omitempty" url:"minerals,omitempty"`
	// Amount of each trace element in grams (g)
	TraceElements map[string]*float64 `json:"trace_elements,omitempty" url:"trace_elements,omitempty"`
	// Amount of each vitamin in grams (g)
	Vitamins map[string]*float64 `json:"vitamins,omitempty" url:"vitamins,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Micros) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Micros) UnmarshalJSON(data []byte) error {
	type unmarshaler Micros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Micros(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Micros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Minerals string

const (
	MineralsSodium     Minerals = "sodium"
	MineralsPotassium  Minerals = "potassium"
	MineralsCalcium    Minerals = "calcium"
	MineralsPhosphorus Minerals = "phosphorus"
	MineralsMagnesium  Minerals = "magnesium"
	MineralsIron       Minerals = "iron"
	MineralsZinc       Minerals = "zinc"
	MineralsFluoride   Minerals = "fluoride"
	MineralsChloride   Minerals = "chloride"
)

func NewMineralsFromString(s string) (Minerals, error) {
	switch s {
	case "sodium":
		return MineralsSodium, nil
	case "potassium":
		return MineralsPotassium, nil
	case "calcium":
		return MineralsCalcium, nil
	case "phosphorus":
		return MineralsPhosphorus, nil
	case "magnesium":
		return MineralsMagnesium, nil
	case "iron":
		return MineralsIron, nil
	case "zinc":
		return MineralsZinc, nil
	case "fluoride":
		return MineralsFluoride, nil
	case "chloride":
		return MineralsChloride, nil
	}
	var t Minerals
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m Minerals) Ptr() *Minerals {
	return &m
}

type MissingBiomarkerResult struct {
	Name                string                 `json:"name" url:"name"`
	Slug                string                 `json:"slug" url:"slug"`
	InferredFailureType FailureType            `json:"inferred_failure_type" url:"inferred_failure_type"`
	Note                *string                `json:"note,omitempty" url:"note,omitempty"`
	Loinc               *string                `json:"loinc,omitempty" url:"loinc,omitempty"`
	LoincSlug           *string                `json:"loinc_slug,omitempty" url:"loinc_slug,omitempty"`
	ProviderId          *string                `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	SourceMarkers       []*ParentBiomarkerData `json:"source_markers,omitempty" url:"source_markers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MissingBiomarkerResult) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MissingBiomarkerResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MissingBiomarkerResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MissingBiomarkerResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MissingBiomarkerResult) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OAuthProviders string

const (
	OAuthProvidersOura           OAuthProviders = "oura"
	OAuthProvidersFitbit         OAuthProviders = "fitbit"
	OAuthProvidersGarmin         OAuthProviders = "garmin"
	OAuthProvidersStrava         OAuthProviders = "strava"
	OAuthProvidersWahoo          OAuthProviders = "wahoo"
	OAuthProvidersIhealth        OAuthProviders = "ihealth"
	OAuthProvidersWithings       OAuthProviders = "withings"
	OAuthProvidersGoogleFit      OAuthProviders = "google_fit"
	OAuthProvidersDexcomV3       OAuthProviders = "dexcom_v3"
	OAuthProvidersPolar          OAuthProviders = "polar"
	OAuthProvidersCronometer     OAuthProviders = "cronometer"
	OAuthProvidersOmron          OAuthProviders = "omron"
	OAuthProvidersWhoopV2        OAuthProviders = "whoop_v2"
	OAuthProvidersMyFitnessPalV2 OAuthProviders = "my_fitness_pal_v2"
	OAuthProvidersUltrahuman     OAuthProviders = "ultrahuman"
)

func NewOAuthProvidersFromString(s string) (OAuthProviders, error) {
	switch s {
	case "oura":
		return OAuthProvidersOura, nil
	case "fitbit":
		return OAuthProvidersFitbit, nil
	case "garmin":
		return OAuthProvidersGarmin, nil
	case "strava":
		return OAuthProvidersStrava, nil
	case "wahoo":
		return OAuthProvidersWahoo, nil
	case "ihealth":
		return OAuthProvidersIhealth, nil
	case "withings":
		return OAuthProvidersWithings, nil
	case "google_fit":
		return OAuthProvidersGoogleFit, nil
	case "dexcom_v3":
		return OAuthProvidersDexcomV3, nil
	case "polar":
		return OAuthProvidersPolar, nil
	case "cronometer":
		return OAuthProvidersCronometer, nil
	case "omron":
		return OAuthProvidersOmron, nil
	case "whoop_v2":
		return OAuthProvidersWhoopV2, nil
	case "my_fitness_pal_v2":
		return OAuthProvidersMyFitnessPalV2, nil
	case "ultrahuman":
		return OAuthProvidersUltrahuman, nil
	}
	var t OAuthProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OAuthProviders) Ptr() *OAuthProviders {
	return &o
}

type OrderSetRequest struct {
	LabTestIds []string    `json:"lab_test_ids,omitempty" url:"lab_test_ids,omitempty"`
	AddOn      *AddOnOrder `json:"add_on,omitempty" url:"add_on,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderSetRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderSetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderSetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderSetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderSetRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderStatus string

const (
	OrderStatusReceivedWalkInTestOrdered                            OrderStatus = "received.walk_in_test.ordered"
	OrderStatusReceivedWalkInTestRequisitionCreated                 OrderStatus = "received.walk_in_test.requisition_created"
	OrderStatusCompletedWalkInTestCompleted                         OrderStatus = "completed.walk_in_test.completed"
	OrderStatusSampleWithLabWalkInTestPartialResults                OrderStatus = "sample_with_lab.walk_in_test.partial_results"
	OrderStatusFailedWalkInTestSampleError                          OrderStatus = "failed.walk_in_test.sample_error"
	OrderStatusCancelledWalkInTestCancelled                         OrderStatus = "cancelled.walk_in_test.cancelled"
	OrderStatusCollectingSampleWalkInTestAppointmentPending         OrderStatus = "collecting_sample.walk_in_test.appointment_pending"
	OrderStatusCollectingSampleWalkInTestAppointmentScheduled       OrderStatus = "collecting_sample.walk_in_test.appointment_scheduled"
	OrderStatusCollectingSampleWalkInTestAppointmentCancelled       OrderStatus = "collecting_sample.walk_in_test.appointment_cancelled"
	OrderStatusReceivedAtHomePhlebotomyOrdered                      OrderStatus = "received.at_home_phlebotomy.ordered"
	OrderStatusReceivedAtHomePhlebotomyRequisitionCreated           OrderStatus = "received.at_home_phlebotomy.requisition_created"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentPending   OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_pending"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_scheduled"
	OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted        OrderStatus = "collecting_sample.at_home_phlebotomy.draw_completed"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_cancelled"
	OrderStatusCompletedAtHomePhlebotomyCompleted                   OrderStatus = "completed.at_home_phlebotomy.completed"
	OrderStatusSampleWithLabAtHomePhlebotomyPartialResults          OrderStatus = "sample_with_lab.at_home_phlebotomy.partial_results"
	OrderStatusCancelledAtHomePhlebotomyCancelled                   OrderStatus = "cancelled.at_home_phlebotomy.cancelled"
	OrderStatusFailedAtHomePhlebotomySampleError                    OrderStatus = "failed.at_home_phlebotomy.sample_error"
	OrderStatusReceivedTestkitOrdered                               OrderStatus = "received.testkit.ordered"
	OrderStatusReceivedTestkitAwaitingRegistration                  OrderStatus = "received.testkit.awaiting_registration"
	OrderStatusReceivedTestkitRequisitionCreated                    OrderStatus = "received.testkit.requisition_created"
	OrderStatusReceivedTestkitRegistered                            OrderStatus = "received.testkit.registered"
	OrderStatusCollectingSampleTestkitTransitCustomer               OrderStatus = "collecting_sample.testkit.transit_customer"
	OrderStatusCollectingSampleTestkitOutForDelivery                OrderStatus = "collecting_sample.testkit.out_for_delivery"
	OrderStatusCollectingSampleTestkitWithCustomer                  OrderStatus = "collecting_sample.testkit.with_customer"
	OrderStatusCollectingSampleTestkitTransitLab                    OrderStatus = "collecting_sample.testkit.transit_lab"
	OrderStatusSampleWithLabTestkitDeliveredToLab                   OrderStatus = "sample_with_lab.testkit.delivered_to_lab"
	OrderStatusCompletedTestkitCompleted                            OrderStatus = "completed.testkit.completed"
	OrderStatusFailedTestkitFailureToDeliverToCustomer              OrderStatus = "failed.testkit.failure_to_deliver_to_customer"
	OrderStatusFailedTestkitFailureToDeliverToLab                   OrderStatus = "failed.testkit.failure_to_deliver_to_lab"
	OrderStatusFailedTestkitSampleError                             OrderStatus = "failed.testkit.sample_error"
	OrderStatusFailedTestkitLost                                    OrderStatus = "failed.testkit.lost"
	OrderStatusCancelledTestkitCancelled                            OrderStatus = "cancelled.testkit.cancelled"
	OrderStatusCancelledTestkitDoNotProcess                         OrderStatus = "cancelled.testkit.do_not_process"
)

func NewOrderStatusFromString(s string) (OrderStatus, error) {
	switch s {
	case "received.walk_in_test.ordered":
		return OrderStatusReceivedWalkInTestOrdered, nil
	case "received.walk_in_test.requisition_created":
		return OrderStatusReceivedWalkInTestRequisitionCreated, nil
	case "completed.walk_in_test.completed":
		return OrderStatusCompletedWalkInTestCompleted, nil
	case "sample_with_lab.walk_in_test.partial_results":
		return OrderStatusSampleWithLabWalkInTestPartialResults, nil
	case "failed.walk_in_test.sample_error":
		return OrderStatusFailedWalkInTestSampleError, nil
	case "cancelled.walk_in_test.cancelled":
		return OrderStatusCancelledWalkInTestCancelled, nil
	case "collecting_sample.walk_in_test.appointment_pending":
		return OrderStatusCollectingSampleWalkInTestAppointmentPending, nil
	case "collecting_sample.walk_in_test.appointment_scheduled":
		return OrderStatusCollectingSampleWalkInTestAppointmentScheduled, nil
	case "collecting_sample.walk_in_test.appointment_cancelled":
		return OrderStatusCollectingSampleWalkInTestAppointmentCancelled, nil
	case "received.at_home_phlebotomy.ordered":
		return OrderStatusReceivedAtHomePhlebotomyOrdered, nil
	case "received.at_home_phlebotomy.requisition_created":
		return OrderStatusReceivedAtHomePhlebotomyRequisitionCreated, nil
	case "collecting_sample.at_home_phlebotomy.appointment_pending":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentPending, nil
	case "collecting_sample.at_home_phlebotomy.appointment_scheduled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled, nil
	case "collecting_sample.at_home_phlebotomy.draw_completed":
		return OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted, nil
	case "collecting_sample.at_home_phlebotomy.appointment_cancelled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled, nil
	case "completed.at_home_phlebotomy.completed":
		return OrderStatusCompletedAtHomePhlebotomyCompleted, nil
	case "sample_with_lab.at_home_phlebotomy.partial_results":
		return OrderStatusSampleWithLabAtHomePhlebotomyPartialResults, nil
	case "cancelled.at_home_phlebotomy.cancelled":
		return OrderStatusCancelledAtHomePhlebotomyCancelled, nil
	case "failed.at_home_phlebotomy.sample_error":
		return OrderStatusFailedAtHomePhlebotomySampleError, nil
	case "received.testkit.ordered":
		return OrderStatusReceivedTestkitOrdered, nil
	case "received.testkit.awaiting_registration":
		return OrderStatusReceivedTestkitAwaitingRegistration, nil
	case "received.testkit.requisition_created":
		return OrderStatusReceivedTestkitRequisitionCreated, nil
	case "received.testkit.registered":
		return OrderStatusReceivedTestkitRegistered, nil
	case "collecting_sample.testkit.transit_customer":
		return OrderStatusCollectingSampleTestkitTransitCustomer, nil
	case "collecting_sample.testkit.out_for_delivery":
		return OrderStatusCollectingSampleTestkitOutForDelivery, nil
	case "collecting_sample.testkit.with_customer":
		return OrderStatusCollectingSampleTestkitWithCustomer, nil
	case "collecting_sample.testkit.transit_lab":
		return OrderStatusCollectingSampleTestkitTransitLab, nil
	case "sample_with_lab.testkit.delivered_to_lab":
		return OrderStatusSampleWithLabTestkitDeliveredToLab, nil
	case "completed.testkit.completed":
		return OrderStatusCompletedTestkitCompleted, nil
	case "failed.testkit.failure_to_deliver_to_customer":
		return OrderStatusFailedTestkitFailureToDeliverToCustomer, nil
	case "failed.testkit.failure_to_deliver_to_lab":
		return OrderStatusFailedTestkitFailureToDeliverToLab, nil
	case "failed.testkit.sample_error":
		return OrderStatusFailedTestkitSampleError, nil
	case "failed.testkit.lost":
		return OrderStatusFailedTestkitLost, nil
	case "cancelled.testkit.cancelled":
		return OrderStatusCancelledTestkitCancelled, nil
	case "cancelled.testkit.do_not_process":
		return OrderStatusCancelledTestkitDoNotProcess, nil
	}
	var t OrderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderStatus) Ptr() *OrderStatus {
	return &o
}

type OrderTopLevelStatus string

const (
	OrderTopLevelStatusReceived         OrderTopLevelStatus = "received"
	OrderTopLevelStatusCollectingSample OrderTopLevelStatus = "collecting_sample"
	OrderTopLevelStatusSampleWithLab    OrderTopLevelStatus = "sample_with_lab"
	OrderTopLevelStatusCompleted        OrderTopLevelStatus = "completed"
	OrderTopLevelStatusCancelled        OrderTopLevelStatus = "cancelled"
	OrderTopLevelStatusFailed           OrderTopLevelStatus = "failed"
)

func NewOrderTopLevelStatusFromString(s string) (OrderTopLevelStatus, error) {
	switch s {
	case "received":
		return OrderTopLevelStatusReceived, nil
	case "collecting_sample":
		return OrderTopLevelStatusCollectingSample, nil
	case "sample_with_lab":
		return OrderTopLevelStatusSampleWithLab, nil
	case "completed":
		return OrderTopLevelStatusCompleted, nil
	case "cancelled":
		return OrderTopLevelStatusCancelled, nil
	case "failed":
		return OrderTopLevelStatusFailed, nil
	}
	var t OrderTopLevelStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderTopLevelStatus) Ptr() *OrderTopLevelStatus {
	return &o
}

type OvulationTestEntry struct {
	Date       string                       `json:"date" url:"date"`
	TestResult OvulationTestEntryTestResult `json:"test_result" url:"test_result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OvulationTestEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OvulationTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OvulationTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OvulationTestEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OvulationTestEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OvulationTestEntryTestResult string

const (
	OvulationTestEntryTestResultNegative                OvulationTestEntryTestResult = "negative"
	OvulationTestEntryTestResultPositive                OvulationTestEntryTestResult = "positive"
	OvulationTestEntryTestResultLuteinizingHormoneSurge OvulationTestEntryTestResult = "luteinizing_hormone_surge"
	OvulationTestEntryTestResultEstrogenSurge           OvulationTestEntryTestResult = "estrogen_surge"
	OvulationTestEntryTestResultIndeterminate           OvulationTestEntryTestResult = "indeterminate"
)

func NewOvulationTestEntryTestResultFromString(s string) (OvulationTestEntryTestResult, error) {
	switch s {
	case "negative":
		return OvulationTestEntryTestResultNegative, nil
	case "positive":
		return OvulationTestEntryTestResultPositive, nil
	case "luteinizing_hormone_surge":
		return OvulationTestEntryTestResultLuteinizingHormoneSurge, nil
	case "estrogen_surge":
		return OvulationTestEntryTestResultEstrogenSurge, nil
	case "indeterminate":
		return OvulationTestEntryTestResultIndeterminate, nil
	}
	var t OvulationTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OvulationTestEntryTestResult) Ptr() *OvulationTestEntryTestResult {
	return &o
}

type PaginatedUsersResponse struct {
	Users  []*ClientFacingUser `json:"users,omitempty" url:"users,omitempty"`
	Total  int                 `json:"total" url:"total"`
	Offset int                 `json:"offset" url:"offset"`
	Limit  int                 `json:"limit" url:"limit"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginatedUsersResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedUsersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedUsersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedUsersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedUsersResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ParentBiomarkerData struct {
	MarkerId   int     `json:"marker_id" url:"marker_id"`
	Name       string  `json:"name" url:"name"`
	Slug       string  `json:"slug" url:"slug"`
	ProviderId *string `json:"provider_id,omitempty" url:"provider_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ParentBiomarkerData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ParentBiomarkerData) UnmarshalJSON(data []byte) error {
	type unmarshaler ParentBiomarkerData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParentBiomarkerData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParentBiomarkerData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PasswordProviders string

const (
	PasswordProvidersWhoop           PasswordProviders = "whoop"
	PasswordProvidersRenpho          PasswordProviders = "renpho"
	PasswordProvidersPeloton         PasswordProviders = "peloton"
	PasswordProvidersZwift           PasswordProviders = "zwift"
	PasswordProvidersEightSleep      PasswordProviders = "eight_sleep"
	PasswordProvidersBeurerApi       PasswordProviders = "beurer_api"
	PasswordProvidersDexcom          PasswordProviders = "dexcom"
	PasswordProvidersHammerhead      PasswordProviders = "hammerhead"
	PasswordProvidersMyFitnessPal    PasswordProviders = "my_fitness_pal"
	PasswordProvidersKardia          PasswordProviders = "kardia"
	PasswordProvidersAbbottLibreview PasswordProviders = "abbott_libreview"
)

func NewPasswordProvidersFromString(s string) (PasswordProviders, error) {
	switch s {
	case "whoop":
		return PasswordProvidersWhoop, nil
	case "renpho":
		return PasswordProvidersRenpho, nil
	case "peloton":
		return PasswordProvidersPeloton, nil
	case "zwift":
		return PasswordProvidersZwift, nil
	case "eight_sleep":
		return PasswordProvidersEightSleep, nil
	case "beurer_api":
		return PasswordProvidersBeurerApi, nil
	case "dexcom":
		return PasswordProvidersDexcom, nil
	case "hammerhead":
		return PasswordProvidersHammerhead, nil
	case "my_fitness_pal":
		return PasswordProvidersMyFitnessPal, nil
	case "kardia":
		return PasswordProvidersKardia, nil
	case "abbott_libreview":
		return PasswordProvidersAbbottLibreview, nil
	}
	var t PasswordProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PasswordProviders) Ptr() *PasswordProviders {
	return &p
}

type PatientAddressCompatible struct {
	ReceiverName *string `json:"receiver_name,omitempty" url:"receiver_name,omitempty"`
	FirstLine    string  `json:"first_line" url:"first_line"`
	SecondLine   *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City         string  `json:"city" url:"city"`
	State        string  `json:"state" url:"state"`
	Zip          string  `json:"zip" url:"zip"`
	Country      string  `json:"country" url:"country"`
	PhoneNumber  *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatientAddressCompatible) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatientAddressCompatible) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientAddressCompatible
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientAddressCompatible(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientAddressCompatible) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatientDetails struct {
	FirstName   string    `json:"first_name" url:"first_name"`
	LastName    string    `json:"last_name" url:"last_name"`
	Dob         time.Time `json:"dob" url:"dob"`
	Gender      Gender    `json:"gender" url:"gender"`
	PhoneNumber string    `json:"phone_number" url:"phone_number"`
	Email       string    `json:"email" url:"email"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatientDetails) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatientDetails) UnmarshalJSON(data []byte) error {
	type embed PatientDetails
	var unmarshaler = struct {
		embed
		Dob *core.DateTime `json:"dob"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PatientDetails(unmarshaler.embed)
	p.Dob = unmarshaler.Dob.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientDetails) MarshalJSON() ([]byte, error) {
	type embed PatientDetails
	var marshaler = struct {
		embed
		Dob *core.DateTime `json:"dob"`
	}{
		embed: embed(*p),
		Dob:   core.NewDateTime(p.Dob),
	}
	return json.Marshal(marshaler)
}

func (p *PatientDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Period struct {
	Value *int       `json:"value,omitempty" url:"value,omitempty"`
	Unit  PeriodUnit `json:"unit" url:"unit"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Period) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Period) UnmarshalJSON(data []byte) error {
	type unmarshaler Period
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Period(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Period) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PeriodUnit string

const (
	PeriodUnitMinute PeriodUnit = "minute"
	PeriodUnitHour   PeriodUnit = "hour"
	PeriodUnitDay    PeriodUnit = "day"
	PeriodUnitWeek   PeriodUnit = "week"
	PeriodUnitMonth  PeriodUnit = "month"
	PeriodUnitYear   PeriodUnit = "year"
)

func NewPeriodUnitFromString(s string) (PeriodUnit, error) {
	switch s {
	case "minute":
		return PeriodUnitMinute, nil
	case "hour":
		return PeriodUnitHour, nil
	case "day":
		return PeriodUnitDay, nil
	case "week":
		return PeriodUnitWeek, nil
	case "month":
		return PeriodUnitMonth, nil
	case "year":
		return PeriodUnitYear, nil
	}
	var t PeriodUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PeriodUnit) Ptr() *PeriodUnit {
	return &p
}

type PersonDetailsOutput struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Gender      Gender   `json:"gender" url:"gender"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`
	Dob         string   `json:"dob" url:"dob"`
	Email       string   `json:"email" url:"email"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PersonDetailsOutput) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PersonDetailsOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler PersonDetailsOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PersonDetailsOutput(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PersonDetailsOutput) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhlebotomyAreaInfo struct {
	IsServed  bool                      `json:"is_served" url:"is_served"`
	Providers []*PhlebotomyProviderInfo `json:"providers,omitempty" url:"providers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhlebotomyAreaInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhlebotomyAreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhlebotomyAreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhlebotomyAreaInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhlebotomyAreaInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhlebotomyProviderInfo struct {
	Name         AppointmentProvider      `json:"name" url:"name"`
	ServiceTypes []AppointmentServiceType `json:"service_types,omitempty" url:"service_types,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhlebotomyProviderInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhlebotomyProviderInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhlebotomyProviderInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhlebotomyProviderInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhlebotomyProviderInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequest struct {
	FirstName      string   `json:"first_name" url:"first_name"`
	LastName       string   `json:"last_name" url:"last_name"`
	Email          *string  `json:"email,omitempty" url:"email,omitempty"`
	Npi            string   `json:"npi" url:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty" url:"licensed_states,omitempty"`
	// An image of the physician signature for health insurance billing
	SignatureImage *PhysicianCreateRequestSignatureImage `json:"signature_image,omitempty" url:"signature_image,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhysicianCreateRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhysicianCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequestBase struct {
	FirstName      string   `json:"first_name" url:"first_name"`
	LastName       string   `json:"last_name" url:"last_name"`
	Email          *string  `json:"email,omitempty" url:"email,omitempty"`
	Npi            string   `json:"npi" url:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty" url:"licensed_states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhysicianCreateRequestBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhysicianCreateRequestBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequestBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequestBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequestBase) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An image of the physician signature for health insurance billing
type PhysicianCreateRequestSignatureImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewPhysicianCreateRequestSignatureImageFromJpeg(value *Jpeg) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{Jpeg: value}
}

func NewPhysicianCreateRequestSignatureImageFromPng(value *Png) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{Png: value}
}

func (p *PhysicianCreateRequestSignatureImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		p.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		p.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhysicianCreateRequestSignatureImage) MarshalJSON() ([]byte, error) {
	if p.Jpeg != nil {
		return json.Marshal(p.Jpeg)
	}
	if p.Png != nil {
		return json.Marshal(p.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhysicianCreateRequestSignatureImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (p *PhysicianCreateRequestSignatureImage) Accept(visitor PhysicianCreateRequestSignatureImageVisitor) error {
	if p.Jpeg != nil {
		return visitor.VisitJpeg(p.Jpeg)
	}
	if p.Png != nil {
		return visitor.VisitPng(p.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type Placeholder struct {
	Placeholder bool `json:"placeholder" url:"placeholder"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Placeholder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Placeholder) UnmarshalJSON(data []byte) error {
	type unmarshaler Placeholder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Placeholder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Placeholder) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Png struct {
	Content     string `json:"content" url:"content"`
	contentType string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Png) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Png) ContentType() string {
	return p.contentType
}

func (p *Png) UnmarshalJSON(data []byte) error {
	type embed Png
	var unmarshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Png(unmarshaler.embed)
	if unmarshaler.ContentType != "image/png" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "image/png", unmarshaler.ContentType)
	}
	p.contentType = unmarshaler.ContentType

	extraProperties, err := core.ExtractExtraProperties(data, *p, "content_type")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Png) MarshalJSON() ([]byte, error) {
	type embed Png
	var marshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed:       embed(*p),
		ContentType: "image/png",
	}
	return json.Marshal(marshaler)
}

func (p *Png) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostOrderResponse struct {
	Order   *ClientFacingOrder `json:"order,omitempty" url:"order,omitempty"`
	Status  string             `json:"status" url:"status"`
	Message string             `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PostOrderResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostOrderResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileInDb struct {
	Data       interface{}           `json:"data,omitempty" url:"data,omitempty"`
	UserId     string                `json:"user_id" url:"user_id"`
	SourceId   int                   `json:"source_id" url:"source_id"`
	PriorityId *int                  `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                `json:"id" url:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty" url:"source,omitempty"`
	UpdatedAt  *time.Time            `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProfileInDb) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProfileInDb) UnmarshalJSON(data []byte) error {
	type embed ProfileInDb
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = ProfileInDb(unmarshaler.embed)
	p.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileInDb) MarshalJSON() ([]byte, error) {
	type embed ProfileInDb
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*p),
		UpdatedAt: core.NewOptionalDateTime(p.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *ProfileInDb) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderLinkResponse struct {
	State       ProviderLinkResponseState `json:"state" url:"state"`
	RedirectUrl *string                   `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	ErrorType   *string                   `json:"error_type,omitempty" url:"error_type,omitempty"`
	Error       *string                   `json:"error,omitempty" url:"error,omitempty"`
	ProviderMfa *ProviderMfaRequest       `json:"provider_mfa,omitempty" url:"provider_mfa,omitempty"`
	Provider    PasswordProviders         `json:"provider" url:"provider"`
	Connected   bool                      `json:"connected" url:"connected"`
	ProviderId  *string                   `json:"provider_id,omitempty" url:"provider_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderLinkResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderLinkResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderLinkResponseState string

const (
	ProviderLinkResponseStateSuccess            ProviderLinkResponseState = "success"
	ProviderLinkResponseStateError              ProviderLinkResponseState = "error"
	ProviderLinkResponseStatePendingProviderMfa ProviderLinkResponseState = "pending_provider_mfa"
)

func NewProviderLinkResponseStateFromString(s string) (ProviderLinkResponseState, error) {
	switch s {
	case "success":
		return ProviderLinkResponseStateSuccess, nil
	case "error":
		return ProviderLinkResponseStateError, nil
	case "pending_provider_mfa":
		return ProviderLinkResponseStatePendingProviderMfa, nil
	}
	var t ProviderLinkResponseState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderLinkResponseState) Ptr() *ProviderLinkResponseState {
	return &p
}

type ProviderMfaRequest struct {
	Method ProviderMfaRequestMethod `json:"method" url:"method"`
	Hint   string                   `json:"hint" url:"hint"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderMfaRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderMfaRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderMfaRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderMfaRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderMfaRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderMfaRequestMethod string

const (
	ProviderMfaRequestMethodSms   ProviderMfaRequestMethod = "sms"
	ProviderMfaRequestMethodEmail ProviderMfaRequestMethod = "email"
)

func NewProviderMfaRequestMethodFromString(s string) (ProviderMfaRequestMethod, error) {
	switch s {
	case "sms":
		return ProviderMfaRequestMethodSms, nil
	case "email":
		return ProviderMfaRequestMethodEmail, nil
	}
	var t ProviderMfaRequestMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderMfaRequestMethod) Ptr() *ProviderMfaRequestMethod {
	return &p
}

type Providers string

const (
	ProvidersOura              Providers = "oura"
	ProvidersFitbit            Providers = "fitbit"
	ProvidersGarmin            Providers = "garmin"
	ProvidersWhoop             Providers = "whoop"
	ProvidersStrava            Providers = "strava"
	ProvidersRenpho            Providers = "renpho"
	ProvidersPeloton           Providers = "peloton"
	ProvidersWahoo             Providers = "wahoo"
	ProvidersZwift             Providers = "zwift"
	ProvidersFreestyleLibre    Providers = "freestyle_libre"
	ProvidersAbbottLibreview   Providers = "abbott_libreview"
	ProvidersFreestyleLibreBle Providers = "freestyle_libre_ble"
	ProvidersEightSleep        Providers = "eight_sleep"
	ProvidersWithings          Providers = "withings"
	ProvidersAppleHealthKit    Providers = "apple_health_kit"
	ProvidersManual            Providers = "manual"
	ProvidersIhealth           Providers = "ihealth"
	ProvidersGoogleFit         Providers = "google_fit"
	ProvidersBeurerApi         Providers = "beurer_api"
	ProvidersBeurerBle         Providers = "beurer_ble"
	ProvidersOmron             Providers = "omron"
	ProvidersOmronBle          Providers = "omron_ble"
	ProvidersOnetouchBle       Providers = "onetouch_ble"
	ProvidersAccuchekBle       Providers = "accuchek_ble"
	ProvidersContourBle        Providers = "contour_ble"
	ProvidersDexcom            Providers = "dexcom"
	ProvidersDexcomV3          Providers = "dexcom_v3"
	ProvidersHammerhead        Providers = "hammerhead"
	ProvidersMyFitnessPal      Providers = "my_fitness_pal"
	ProvidersHealthConnect     Providers = "health_connect"
	ProvidersPolar             Providers = "polar"
	ProvidersCronometer        Providers = "cronometer"
	ProvidersKardia            Providers = "kardia"
	ProvidersWhoopV2           Providers = "whoop_v2"
	ProvidersUltrahuman        Providers = "ultrahuman"
	ProvidersMyFitnessPalV2    Providers = "my_fitness_pal_v2"
	ProvidersMapMyFitness      Providers = "map_my_fitness"
)

func NewProvidersFromString(s string) (Providers, error) {
	switch s {
	case "oura":
		return ProvidersOura, nil
	case "fitbit":
		return ProvidersFitbit, nil
	case "garmin":
		return ProvidersGarmin, nil
	case "whoop":
		return ProvidersWhoop, nil
	case "strava":
		return ProvidersStrava, nil
	case "renpho":
		return ProvidersRenpho, nil
	case "peloton":
		return ProvidersPeloton, nil
	case "wahoo":
		return ProvidersWahoo, nil
	case "zwift":
		return ProvidersZwift, nil
	case "freestyle_libre":
		return ProvidersFreestyleLibre, nil
	case "abbott_libreview":
		return ProvidersAbbottLibreview, nil
	case "freestyle_libre_ble":
		return ProvidersFreestyleLibreBle, nil
	case "eight_sleep":
		return ProvidersEightSleep, nil
	case "withings":
		return ProvidersWithings, nil
	case "apple_health_kit":
		return ProvidersAppleHealthKit, nil
	case "manual":
		return ProvidersManual, nil
	case "ihealth":
		return ProvidersIhealth, nil
	case "google_fit":
		return ProvidersGoogleFit, nil
	case "beurer_api":
		return ProvidersBeurerApi, nil
	case "beurer_ble":
		return ProvidersBeurerBle, nil
	case "omron":
		return ProvidersOmron, nil
	case "omron_ble":
		return ProvidersOmronBle, nil
	case "onetouch_ble":
		return ProvidersOnetouchBle, nil
	case "accuchek_ble":
		return ProvidersAccuchekBle, nil
	case "contour_ble":
		return ProvidersContourBle, nil
	case "dexcom":
		return ProvidersDexcom, nil
	case "dexcom_v3":
		return ProvidersDexcomV3, nil
	case "hammerhead":
		return ProvidersHammerhead, nil
	case "my_fitness_pal":
		return ProvidersMyFitnessPal, nil
	case "health_connect":
		return ProvidersHealthConnect, nil
	case "polar":
		return ProvidersPolar, nil
	case "cronometer":
		return ProvidersCronometer, nil
	case "kardia":
		return ProvidersKardia, nil
	case "whoop_v2":
		return ProvidersWhoopV2, nil
	case "ultrahuman":
		return ProvidersUltrahuman, nil
	case "my_fitness_pal_v2":
		return ProvidersMyFitnessPalV2, nil
	case "map_my_fitness":
		return ProvidersMapMyFitness, nil
	}
	var t Providers
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Providers) Ptr() *Providers {
	return &p
}

type PscAreaInfo struct {
	PatientServiceCenters *PscAreaInfoDetails `json:"patient_service_centers,omitempty" url:"patient_service_centers,omitempty"`
	SupportedBillTypes    []Billing           `json:"supported_bill_types,omitempty" url:"supported_bill_types,omitempty"`
	LabId                 int                 `json:"lab_id" url:"lab_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PscAreaInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PscAreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PscAreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscAreaInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscAreaInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PscAreaInfoDetails struct {
	AppointmentWithVital bool   `json:"appointment_with_vital" url:"appointment_with_vital"`
	WithinRadius         int    `json:"within_radius" url:"within_radius"`
	Radius               string `json:"radius" url:"radius"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PscAreaInfoDetails) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PscAreaInfoDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PscAreaInfoDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscAreaInfoDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscAreaInfoDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PscInfo struct {
	LabId                 int                        `json:"lab_id" url:"lab_id"`
	Slug                  Labs                       `json:"slug" url:"slug"`
	PatientServiceCenters []*ClientFacingLabLocation `json:"patient_service_centers,omitempty" url:"patient_service_centers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PscInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PscInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PscInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type QueryConfig struct {
	WeekStartsOn              *QueryConfigWeekStartsOn                    `json:"week_starts_on,omitempty" url:"week_starts_on,omitempty"`
	ProviderPriorityOverrides []*QueryConfigProviderPriorityOverridesItem `json:"provider_priority_overrides,omitempty" url:"provider_priority_overrides,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryConfig) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryConfig) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryConfigProviderPriorityOverridesItem struct {
	Providers Providers
	Labs      Labs
}

func NewQueryConfigProviderPriorityOverridesItemFromProviders(value Providers) *QueryConfigProviderPriorityOverridesItem {
	return &QueryConfigProviderPriorityOverridesItem{Providers: value}
}

func NewQueryConfigProviderPriorityOverridesItemFromLabs(value Labs) *QueryConfigProviderPriorityOverridesItem {
	return &QueryConfigProviderPriorityOverridesItem{Labs: value}
}

func (q *QueryConfigProviderPriorityOverridesItem) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		q.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		q.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryConfigProviderPriorityOverridesItem) MarshalJSON() ([]byte, error) {
	if q.Providers != "" {
		return json.Marshal(q.Providers)
	}
	if q.Labs != "" {
		return json.Marshal(q.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryConfigProviderPriorityOverridesItemVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (q *QueryConfigProviderPriorityOverridesItem) Accept(visitor QueryConfigProviderPriorityOverridesItemVisitor) error {
	if q.Providers != "" {
		return visitor.VisitProviders(q.Providers)
	}
	if q.Labs != "" {
		return visitor.VisitLabs(q.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryConfigWeekStartsOn string

const (
	QueryConfigWeekStartsOnSunday QueryConfigWeekStartsOn = "sunday"
	QueryConfigWeekStartsOnMonday QueryConfigWeekStartsOn = "monday"
)

func NewQueryConfigWeekStartsOnFromString(s string) (QueryConfigWeekStartsOn, error) {
	switch s {
	case "sunday":
		return QueryConfigWeekStartsOnSunday, nil
	case "monday":
		return QueryConfigWeekStartsOnMonday, nil
	}
	var t QueryConfigWeekStartsOn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryConfigWeekStartsOn) Ptr() *QueryConfigWeekStartsOn {
	return &q
}

type QueryInstruction struct {
	Select        []*QueryInstructionSelectItem  `json:"select,omitempty" url:"select,omitempty"`
	GroupBy       []*QueryInstructionGroupByItem `json:"group_by,omitempty" url:"group_by,omitempty"`
	SplitBySource *bool                          `json:"split_by_source,omitempty" url:"split_by_source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryInstruction) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryInstruction) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryInstruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryInstruction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryInstruction) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryInstructionGroupByItem struct {
	DateTruncExpr *DateTruncExpr
	DatePartExpr  *DatePartExpr
}

func NewQueryInstructionGroupByItemFromDateTruncExpr(value *DateTruncExpr) *QueryInstructionGroupByItem {
	return &QueryInstructionGroupByItem{DateTruncExpr: value}
}

func NewQueryInstructionGroupByItemFromDatePartExpr(value *DatePartExpr) *QueryInstructionGroupByItem {
	return &QueryInstructionGroupByItem{DatePartExpr: value}
}

func (q *QueryInstructionGroupByItem) UnmarshalJSON(data []byte) error {
	valueDateTruncExpr := new(DateTruncExpr)
	if err := json.Unmarshal(data, &valueDateTruncExpr); err == nil {
		q.DateTruncExpr = valueDateTruncExpr
		return nil
	}
	valueDatePartExpr := new(DatePartExpr)
	if err := json.Unmarshal(data, &valueDatePartExpr); err == nil {
		q.DatePartExpr = valueDatePartExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryInstructionGroupByItem) MarshalJSON() ([]byte, error) {
	if q.DateTruncExpr != nil {
		return json.Marshal(q.DateTruncExpr)
	}
	if q.DatePartExpr != nil {
		return json.Marshal(q.DatePartExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryInstructionGroupByItemVisitor interface {
	VisitDateTruncExpr(*DateTruncExpr) error
	VisitDatePartExpr(*DatePartExpr) error
}

func (q *QueryInstructionGroupByItem) Accept(visitor QueryInstructionGroupByItemVisitor) error {
	if q.DateTruncExpr != nil {
		return visitor.VisitDateTruncExpr(q.DateTruncExpr)
	}
	if q.DatePartExpr != nil {
		return visitor.VisitDatePartExpr(q.DatePartExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryInstructionSelectItem struct {
	AggregateExpr              *AggregateExpr
	SleepColumnExpr            *SleepColumnExpr
	ActivityColumnExpr         *ActivityColumnExpr
	WorkoutColumnExpr          *WorkoutColumnExpr
	BodyColumnExpr             *BodyColumnExpr
	IndexColumnExpr            *IndexColumnExpr
	GroupKeyColumnExpr         *GroupKeyColumnExpr
	SleepScoreValueMacroExpr   *SleepScoreValueMacroExpr
	ChronotypeValueMacroExpr   *ChronotypeValueMacroExpr
	UnrecognizedValueMacroExpr *UnrecognizedValueMacroExpr
}

func NewQueryInstructionSelectItemFromAggregateExpr(value *AggregateExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{AggregateExpr: value}
}

func NewQueryInstructionSelectItemFromSleepColumnExpr(value *SleepColumnExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{SleepColumnExpr: value}
}

func NewQueryInstructionSelectItemFromActivityColumnExpr(value *ActivityColumnExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{ActivityColumnExpr: value}
}

func NewQueryInstructionSelectItemFromWorkoutColumnExpr(value *WorkoutColumnExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{WorkoutColumnExpr: value}
}

func NewQueryInstructionSelectItemFromBodyColumnExpr(value *BodyColumnExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{BodyColumnExpr: value}
}

func NewQueryInstructionSelectItemFromIndexColumnExpr(value *IndexColumnExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{IndexColumnExpr: value}
}

func NewQueryInstructionSelectItemFromGroupKeyColumnExpr(value *GroupKeyColumnExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{GroupKeyColumnExpr: value}
}

func NewQueryInstructionSelectItemFromSleepScoreValueMacroExpr(value *SleepScoreValueMacroExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{SleepScoreValueMacroExpr: value}
}

func NewQueryInstructionSelectItemFromChronotypeValueMacroExpr(value *ChronotypeValueMacroExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{ChronotypeValueMacroExpr: value}
}

func NewQueryInstructionSelectItemFromUnrecognizedValueMacroExpr(value *UnrecognizedValueMacroExpr) *QueryInstructionSelectItem {
	return &QueryInstructionSelectItem{UnrecognizedValueMacroExpr: value}
}

func (q *QueryInstructionSelectItem) UnmarshalJSON(data []byte) error {
	valueAggregateExpr := new(AggregateExpr)
	if err := json.Unmarshal(data, &valueAggregateExpr); err == nil {
		q.AggregateExpr = valueAggregateExpr
		return nil
	}
	valueSleepColumnExpr := new(SleepColumnExpr)
	if err := json.Unmarshal(data, &valueSleepColumnExpr); err == nil {
		q.SleepColumnExpr = valueSleepColumnExpr
		return nil
	}
	valueActivityColumnExpr := new(ActivityColumnExpr)
	if err := json.Unmarshal(data, &valueActivityColumnExpr); err == nil {
		q.ActivityColumnExpr = valueActivityColumnExpr
		return nil
	}
	valueWorkoutColumnExpr := new(WorkoutColumnExpr)
	if err := json.Unmarshal(data, &valueWorkoutColumnExpr); err == nil {
		q.WorkoutColumnExpr = valueWorkoutColumnExpr
		return nil
	}
	valueBodyColumnExpr := new(BodyColumnExpr)
	if err := json.Unmarshal(data, &valueBodyColumnExpr); err == nil {
		q.BodyColumnExpr = valueBodyColumnExpr
		return nil
	}
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		q.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valueGroupKeyColumnExpr := new(GroupKeyColumnExpr)
	if err := json.Unmarshal(data, &valueGroupKeyColumnExpr); err == nil {
		q.GroupKeyColumnExpr = valueGroupKeyColumnExpr
		return nil
	}
	valueSleepScoreValueMacroExpr := new(SleepScoreValueMacroExpr)
	if err := json.Unmarshal(data, &valueSleepScoreValueMacroExpr); err == nil {
		q.SleepScoreValueMacroExpr = valueSleepScoreValueMacroExpr
		return nil
	}
	valueChronotypeValueMacroExpr := new(ChronotypeValueMacroExpr)
	if err := json.Unmarshal(data, &valueChronotypeValueMacroExpr); err == nil {
		q.ChronotypeValueMacroExpr = valueChronotypeValueMacroExpr
		return nil
	}
	valueUnrecognizedValueMacroExpr := new(UnrecognizedValueMacroExpr)
	if err := json.Unmarshal(data, &valueUnrecognizedValueMacroExpr); err == nil {
		q.UnrecognizedValueMacroExpr = valueUnrecognizedValueMacroExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryInstructionSelectItem) MarshalJSON() ([]byte, error) {
	if q.AggregateExpr != nil {
		return json.Marshal(q.AggregateExpr)
	}
	if q.SleepColumnExpr != nil {
		return json.Marshal(q.SleepColumnExpr)
	}
	if q.ActivityColumnExpr != nil {
		return json.Marshal(q.ActivityColumnExpr)
	}
	if q.WorkoutColumnExpr != nil {
		return json.Marshal(q.WorkoutColumnExpr)
	}
	if q.BodyColumnExpr != nil {
		return json.Marshal(q.BodyColumnExpr)
	}
	if q.IndexColumnExpr != nil {
		return json.Marshal(q.IndexColumnExpr)
	}
	if q.GroupKeyColumnExpr != nil {
		return json.Marshal(q.GroupKeyColumnExpr)
	}
	if q.SleepScoreValueMacroExpr != nil {
		return json.Marshal(q.SleepScoreValueMacroExpr)
	}
	if q.ChronotypeValueMacroExpr != nil {
		return json.Marshal(q.ChronotypeValueMacroExpr)
	}
	if q.UnrecognizedValueMacroExpr != nil {
		return json.Marshal(q.UnrecognizedValueMacroExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryInstructionSelectItemVisitor interface {
	VisitAggregateExpr(*AggregateExpr) error
	VisitSleepColumnExpr(*SleepColumnExpr) error
	VisitActivityColumnExpr(*ActivityColumnExpr) error
	VisitWorkoutColumnExpr(*WorkoutColumnExpr) error
	VisitBodyColumnExpr(*BodyColumnExpr) error
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitGroupKeyColumnExpr(*GroupKeyColumnExpr) error
	VisitSleepScoreValueMacroExpr(*SleepScoreValueMacroExpr) error
	VisitChronotypeValueMacroExpr(*ChronotypeValueMacroExpr) error
	VisitUnrecognizedValueMacroExpr(*UnrecognizedValueMacroExpr) error
}

func (q *QueryInstructionSelectItem) Accept(visitor QueryInstructionSelectItemVisitor) error {
	if q.AggregateExpr != nil {
		return visitor.VisitAggregateExpr(q.AggregateExpr)
	}
	if q.SleepColumnExpr != nil {
		return visitor.VisitSleepColumnExpr(q.SleepColumnExpr)
	}
	if q.ActivityColumnExpr != nil {
		return visitor.VisitActivityColumnExpr(q.ActivityColumnExpr)
	}
	if q.WorkoutColumnExpr != nil {
		return visitor.VisitWorkoutColumnExpr(q.WorkoutColumnExpr)
	}
	if q.BodyColumnExpr != nil {
		return visitor.VisitBodyColumnExpr(q.BodyColumnExpr)
	}
	if q.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(q.IndexColumnExpr)
	}
	if q.GroupKeyColumnExpr != nil {
		return visitor.VisitGroupKeyColumnExpr(q.GroupKeyColumnExpr)
	}
	if q.SleepScoreValueMacroExpr != nil {
		return visitor.VisitSleepScoreValueMacroExpr(q.SleepScoreValueMacroExpr)
	}
	if q.ChronotypeValueMacroExpr != nil {
		return visitor.VisitChronotypeValueMacroExpr(q.ChronotypeValueMacroExpr)
	}
	if q.UnrecognizedValueMacroExpr != nil {
		return visitor.VisitUnrecognizedValueMacroExpr(q.UnrecognizedValueMacroExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type Question struct {
	Id         int          `json:"id" url:"id"`
	Required   bool         `json:"required" url:"required"`
	Code       string       `json:"code" url:"code"`
	Value      string       `json:"value" url:"value"`
	Type       QuestionType `json:"type" url:"type"`
	Sequence   int          `json:"sequence" url:"sequence"`
	Answers    []*Answer    `json:"answers,omitempty" url:"answers,omitempty"`
	Constraint *string      `json:"constraint,omitempty" url:"constraint,omitempty"`
	Default    *string      `json:"default,omitempty" url:"default,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *Question) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *Question) UnmarshalJSON(data []byte) error {
	type unmarshaler Question
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = Question(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *Question) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QuestionType string

const (
	QuestionTypeChoice      QuestionType = "choice"
	QuestionTypeText        QuestionType = "text"
	QuestionTypeNumeric     QuestionType = "numeric"
	QuestionTypeMultiChoice QuestionType = "multi_choice"
)

func NewQuestionTypeFromString(s string) (QuestionType, error) {
	switch s {
	case "choice":
		return QuestionTypeChoice, nil
	case "text":
		return QuestionTypeText, nil
	case "numeric":
		return QuestionTypeNumeric, nil
	case "multi_choice":
		return QuestionTypeMultiChoice, nil
	}
	var t QuestionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QuestionType) Ptr() *QuestionType {
	return &q
}

type RawActivity struct {
	Activity []*ActivityV2InDb `json:"activity,omitempty" url:"activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawActivity) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler RawActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawActivity(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawActivity) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawBody struct {
	Body []*BodyV2InDb `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawBody) UnmarshalJSON(data []byte) error {
	type unmarshaler RawBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawDevices struct {
	Devices []*DeviceV2InDb `json:"devices,omitempty" url:"devices,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawDevices) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawDevices) UnmarshalJSON(data []byte) error {
	type unmarshaler RawDevices
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawDevices(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawDevices) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawProfile struct {
	Profile *ProfileInDb `json:"profile,omitempty" url:"profile,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawProfile) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler RawProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawProfile) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawSleep struct {
	Sleep []*SleepV2InDb `json:"sleep,omitempty" url:"sleep,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawSleep) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawSleep) UnmarshalJSON(data []byte) error {
	type unmarshaler RawSleep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawSleep(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawSleep) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawWorkout struct {
	Workouts []*WorkoutV2InDb `json:"workouts,omitempty" url:"workouts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawWorkout) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawWorkout) UnmarshalJSON(data []byte) error {
	type unmarshaler RawWorkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawWorkout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawWorkout) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Region string

const (
	RegionUs Region = "us"
	RegionEu Region = "eu"
	RegionSg Region = "sg"
	RegionDe Region = "de"
	RegionAu Region = "au"
	RegionBr Region = "br"
	RegionNl Region = "nl"
	RegionFr Region = "fr"
	RegionCa Region = "ca"
	RegionIn Region = "in"
)

func NewRegionFromString(s string) (Region, error) {
	switch s {
	case "us":
		return RegionUs, nil
	case "eu":
		return RegionEu, nil
	case "sg":
		return RegionSg, nil
	case "de":
		return RegionDe, nil
	case "au":
		return RegionAu, nil
	case "br":
		return RegionBr, nil
	case "nl":
		return RegionNl, nil
	case "fr":
		return RegionFr, nil
	case "ca":
		return RegionCa, nil
	case "in":
		return RegionIn, nil
	}
	var t Region
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Region) Ptr() *Region {
	return &r
}

type RelativeTimeframe struct {
	Anchor string  `json:"anchor" url:"anchor"`
	Past   *Period `json:"past,omitempty" url:"past,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RelativeTimeframe) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RelativeTimeframe) Type() string {
	return r.type_
}

func (r *RelativeTimeframe) UnmarshalJSON(data []byte) error {
	type embed RelativeTimeframe
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RelativeTimeframe(unmarshaler.embed)
	if unmarshaler.Type != "relative" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "relative", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelativeTimeframe) MarshalJSON() ([]byte, error) {
	type embed RelativeTimeframe
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "relative",
	}
	return json.Marshal(marshaler)
}

func (r *RelativeTimeframe) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceAvailability struct {
	Status            Availability             `json:"status" url:"status"`
	ScopeRequirements *ScopeRequirementsGrants `json:"scope_requirements,omitempty" url:"scope_requirements,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResourceAvailability) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResourceAvailability) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceAvailability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceAvailability(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceAvailability) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponsibleRelationship string

const (
	ResponsibleRelationshipSelf   ResponsibleRelationship = "Self"
	ResponsibleRelationshipSpouse ResponsibleRelationship = "Spouse"
	ResponsibleRelationshipOther  ResponsibleRelationship = "Other"
)

func NewResponsibleRelationshipFromString(s string) (ResponsibleRelationship, error) {
	switch s {
	case "Self":
		return ResponsibleRelationshipSelf, nil
	case "Spouse":
		return ResponsibleRelationshipSpouse, nil
	case "Other":
		return ResponsibleRelationshipOther, nil
	}
	var t ResponsibleRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponsibleRelationship) Ptr() *ResponsibleRelationship {
	return &r
}

type ResultType string

const (
	ResultTypeNumeric ResultType = "numeric"
	ResultTypeRange   ResultType = "range"
	ResultTypeComment ResultType = "comment"
)

func NewResultTypeFromString(s string) (ResultType, error) {
	switch s {
	case "numeric":
		return ResultTypeNumeric, nil
	case "range":
		return ResultTypeRange, nil
	case "comment":
		return ResultTypeComment, nil
	}
	var t ResultType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResultType) Ptr() *ResultType {
	return &r
}

type ScopeRequirementsGrants struct {
	UserGranted *ScopeRequirementsStr `json:"user_granted,omitempty" url:"user_granted,omitempty"`
	UserDenied  *ScopeRequirementsStr `json:"user_denied,omitempty" url:"user_denied,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScopeRequirementsGrants) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopeRequirementsGrants) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsGrants
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsGrants(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsGrants) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScopeRequirementsStr struct {
	Required []string `json:"required,omitempty" url:"required,omitempty"`
	Optional []string `json:"optional,omitempty" url:"optional,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScopeRequirementsStr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopeRequirementsStr) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsStr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsStr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsStr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Select string

const (
	SelectSelectAll Select = "*"
)

func NewSelectFromString(s string) (Select, error) {
	switch s {
	case "*":
		return SelectSelectAll, nil
	}
	var t Select
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Select) Ptr() *Select {
	return &s
}

type SexualActivityEntry struct {
	Date           string `json:"date" url:"date"`
	ProtectionUsed *bool  `json:"protection_used,omitempty" url:"protection_used,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SexualActivityEntry) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SexualActivityEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler SexualActivityEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SexualActivityEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SexualActivityEntry) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ShippingAddress struct {
	ReceiverName string  `json:"receiver_name" url:"receiver_name"`
	FirstLine    string  `json:"first_line" url:"first_line"`
	SecondLine   *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City         string  `json:"city" url:"city"`
	State        string  `json:"state" url:"state"`
	Zip          string  `json:"zip" url:"zip"`
	Country      string  `json:"country" url:"country"`
	PhoneNumber  string  `json:"phone_number" url:"phone_number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShippingAddress) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShippingAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingAddress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingAddress) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleHistoricalPullStatistics struct {
	Status       HistoricalPullStatus    `json:"status" url:"status"`
	RangeStart   *string                 `json:"range_start,omitempty" url:"range_start,omitempty"`
	RangeEnd     *string                 `json:"range_end,omitempty" url:"range_end,omitempty"`
	Timeline     *HistoricalPullTimeline `json:"timeline,omitempty" url:"timeline,omitempty"`
	DaysWithData *int                    `json:"days_with_data,omitempty" url:"days_with_data,omitempty"`
	Release      string                  `json:"release" url:"release"`
	TraceId      *string                 `json:"trace_id,omitempty" url:"trace_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleHistoricalPullStatistics) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleHistoricalPullStatistics) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleHistoricalPullStatistics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleHistoricalPullStatistics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleHistoricalPullStatistics) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleProviderHistoricalPullResponse struct {
	Pulled    map[string]*SingleHistoricalPullStatistics `json:"pulled,omitempty" url:"pulled,omitempty"`
	NotPulled []ClientFacingResource                     `json:"not_pulled,omitempty" url:"not_pulled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleProviderHistoricalPullResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleProviderHistoricalPullResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleProviderHistoricalPullResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleProviderHistoricalPullResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleProviderHistoricalPullResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleResourceStatistics struct {
	LastAttempt *LastAttempt `json:"last_attempt,omitempty" url:"last_attempt,omitempty"`
	OldestData  *string      `json:"oldest_data,omitempty" url:"oldest_data,omitempty"`
	NewestData  *string      `json:"newest_data,omitempty" url:"newest_data,omitempty"`
	SentCount   *int         `json:"sent_count,omitempty" url:"sent_count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleResourceStatistics) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleResourceStatistics) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleResourceStatistics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleResourceStatistics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleResourceStatistics) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUserHistoricalPullResponse struct {
	UserId   string                                           `json:"user_id" url:"user_id"`
	Provider map[string]*SingleProviderHistoricalPullResponse `json:"provider,omitempty" url:"provider,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleUserHistoricalPullResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUserHistoricalPullResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUserHistoricalPullResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUserHistoricalPullResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUserHistoricalPullResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUserResourceResponse struct {
	UserId   string                                          `json:"user_id" url:"user_id"`
	Provider map[string]map[string]*SingleResourceStatistics `json:"provider,omitempty" url:"provider,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleUserResourceResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUserResourceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUserResourceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUserResourceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUserResourceResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepColumnExpr struct {
	Sleep SleepColumnExprSleep `json:"sleep" url:"sleep"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SleepColumnExpr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler SleepColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SleepColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepColumnExpr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepColumnExprSleep string

const (
	SleepColumnExprSleepSessionStart         SleepColumnExprSleep = "session_start"
	SleepColumnExprSleepSessionEnd           SleepColumnExprSleep = "session_end"
	SleepColumnExprSleepState                SleepColumnExprSleep = "state"
	SleepColumnExprSleepType                 SleepColumnExprSleep = "type"
	SleepColumnExprSleepDurationSecond       SleepColumnExprSleep = "duration_second"
	SleepColumnExprSleepStageAsleepSecond    SleepColumnExprSleep = "stage_asleep_second"
	SleepColumnExprSleepStageAwakeSecond     SleepColumnExprSleep = "stage_awake_second"
	SleepColumnExprSleepStageLightSecond     SleepColumnExprSleep = "stage_light_second"
	SleepColumnExprSleepStageRemSecond       SleepColumnExprSleep = "stage_rem_second"
	SleepColumnExprSleepStageDeepSecond      SleepColumnExprSleep = "stage_deep_second"
	SleepColumnExprSleepStageUnknownSecond   SleepColumnExprSleep = "stage_unknown_second"
	SleepColumnExprSleepLatencySecond        SleepColumnExprSleep = "latency_second"
	SleepColumnExprSleepHeartRateMinimum     SleepColumnExprSleep = "heart_rate_minimum"
	SleepColumnExprSleepHeartRateMean        SleepColumnExprSleep = "heart_rate_mean"
	SleepColumnExprSleepHeartRateMaximum     SleepColumnExprSleep = "heart_rate_maximum"
	SleepColumnExprSleepHeartRateDip         SleepColumnExprSleep = "heart_rate_dip"
	SleepColumnExprSleepEfficiency           SleepColumnExprSleep = "efficiency"
	SleepColumnExprSleepHrvMeanRmssd         SleepColumnExprSleep = "hrv_mean_rmssd"
	SleepColumnExprSleepHrvMeanSdnn          SleepColumnExprSleep = "hrv_mean_sdnn"
	SleepColumnExprSleepSkinTemperatureDelta SleepColumnExprSleep = "skin_temperature_delta"
	SleepColumnExprSleepRespiratoryRate      SleepColumnExprSleep = "respiratory_rate"
	SleepColumnExprSleepScore                SleepColumnExprSleep = "score"
	SleepColumnExprSleepSourceType           SleepColumnExprSleep = "source_type"
	SleepColumnExprSleepSourceProvider       SleepColumnExprSleep = "source_provider"
	SleepColumnExprSleepSourceAppId          SleepColumnExprSleep = "source_app_id"
)

func NewSleepColumnExprSleepFromString(s string) (SleepColumnExprSleep, error) {
	switch s {
	case "session_start":
		return SleepColumnExprSleepSessionStart, nil
	case "session_end":
		return SleepColumnExprSleepSessionEnd, nil
	case "state":
		return SleepColumnExprSleepState, nil
	case "type":
		return SleepColumnExprSleepType, nil
	case "duration_second":
		return SleepColumnExprSleepDurationSecond, nil
	case "stage_asleep_second":
		return SleepColumnExprSleepStageAsleepSecond, nil
	case "stage_awake_second":
		return SleepColumnExprSleepStageAwakeSecond, nil
	case "stage_light_second":
		return SleepColumnExprSleepStageLightSecond, nil
	case "stage_rem_second":
		return SleepColumnExprSleepStageRemSecond, nil
	case "stage_deep_second":
		return SleepColumnExprSleepStageDeepSecond, nil
	case "stage_unknown_second":
		return SleepColumnExprSleepStageUnknownSecond, nil
	case "latency_second":
		return SleepColumnExprSleepLatencySecond, nil
	case "heart_rate_minimum":
		return SleepColumnExprSleepHeartRateMinimum, nil
	case "heart_rate_mean":
		return SleepColumnExprSleepHeartRateMean, nil
	case "heart_rate_maximum":
		return SleepColumnExprSleepHeartRateMaximum, nil
	case "heart_rate_dip":
		return SleepColumnExprSleepHeartRateDip, nil
	case "efficiency":
		return SleepColumnExprSleepEfficiency, nil
	case "hrv_mean_rmssd":
		return SleepColumnExprSleepHrvMeanRmssd, nil
	case "hrv_mean_sdnn":
		return SleepColumnExprSleepHrvMeanSdnn, nil
	case "skin_temperature_delta":
		return SleepColumnExprSleepSkinTemperatureDelta, nil
	case "respiratory_rate":
		return SleepColumnExprSleepRespiratoryRate, nil
	case "score":
		return SleepColumnExprSleepScore, nil
	case "source_type":
		return SleepColumnExprSleepSourceType, nil
	case "source_provider":
		return SleepColumnExprSleepSourceProvider, nil
	case "source_app_id":
		return SleepColumnExprSleepSourceAppId, nil
	}
	var t SleepColumnExprSleep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepColumnExprSleep) Ptr() *SleepColumnExprSleep {
	return &s
}

type SleepScoreValueMacroExpr struct {
	Version    *string `json:"version,omitempty" url:"version,omitempty"`
	valueMacro string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SleepScoreValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepScoreValueMacroExpr) ValueMacro() string {
	return s.valueMacro
}

func (s *SleepScoreValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed SleepScoreValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SleepScoreValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "sleep_score" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "sleep_score", unmarshaler.ValueMacro)
	}
	s.valueMacro = unmarshaler.ValueMacro

	extraProperties, err := core.ExtractExtraProperties(data, *s, "value_macro")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepScoreValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed SleepScoreValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*s),
		ValueMacro: "sleep_score",
	}
	return json.Marshal(marshaler)
}

func (s *SleepScoreValueMacroExpr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepSummaryState string

const (
	SleepSummaryStateTentative SleepSummaryState = "tentative"
	SleepSummaryStateConfirmed SleepSummaryState = "confirmed"
)

func NewSleepSummaryStateFromString(s string) (SleepSummaryState, error) {
	switch s {
	case "tentative":
		return SleepSummaryStateTentative, nil
	case "confirmed":
		return SleepSummaryStateConfirmed, nil
	}
	var t SleepSummaryState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepSummaryState) Ptr() *SleepSummaryState {
	return &s
}

type SleepType string

const (
	SleepTypeLongSleep       SleepType = "long_sleep"
	SleepTypeShortSleep      SleepType = "short_sleep"
	SleepTypeAcknowledgedNap SleepType = "acknowledged_nap"
	SleepTypeUnknown         SleepType = "unknown"
)

func NewSleepTypeFromString(s string) (SleepType, error) {
	switch s {
	case "long_sleep":
		return SleepTypeLongSleep, nil
	case "short_sleep":
		return SleepTypeShortSleep, nil
	case "acknowledged_nap":
		return SleepTypeAcknowledgedNap, nil
	case "unknown":
		return SleepTypeUnknown, nil
	}
	var t SleepType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepType) Ptr() *SleepType {
	return &s
}

type SleepV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`
	Priority   *int                   `json:"priority,omitempty" url:"priority,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SleepV2InDb) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepV2InDb) UnmarshalJSON(data []byte) error {
	type embed SleepV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SleepV2InDb(unmarshaler.embed)
	s.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepV2InDb) MarshalJSON() ([]byte, error) {
	type embed SleepV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*s),
		Timestamp: core.NewDateTime(s.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (s *SleepV2InDb) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Source struct {
	Name            string          `json:"name" url:"name"`
	Slug            string          `json:"slug" url:"slug"`
	Description     string          `json:"description" url:"description"`
	Logo            string          `json:"logo" url:"logo"`
	Group           *string         `json:"group,omitempty" url:"group,omitempty"`
	OauthUrl        *string         `json:"oauth_url,omitempty" url:"oauth_url,omitempty"`
	AuthType        *SourceAuthType `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	SourceType      *SourceType     `json:"source_type,omitempty" url:"source_type,omitempty"`
	IsActive        *bool           `json:"is_active,omitempty" url:"is_active,omitempty"`
	BackfillNumDays *int            `json:"backfill_num_days,omitempty" url:"backfill_num_days,omitempty"`
	Id              int             `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Source) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceAuthType string

const (
	SourceAuthTypeOauth     SourceAuthType = "oauth"
	SourceAuthTypeTeamOauth SourceAuthType = "team_oauth"
	SourceAuthTypeSdk       SourceAuthType = "sdk"
	SourceAuthTypePassword  SourceAuthType = "password"
	SourceAuthTypeEmail     SourceAuthType = "email"
	SourceAuthTypeApp       SourceAuthType = "app"
	SourceAuthTypeEmpty     SourceAuthType = ""
)

func NewSourceAuthTypeFromString(s string) (SourceAuthType, error) {
	switch s {
	case "oauth":
		return SourceAuthTypeOauth, nil
	case "team_oauth":
		return SourceAuthTypeTeamOauth, nil
	case "sdk":
		return SourceAuthTypeSdk, nil
	case "password":
		return SourceAuthTypePassword, nil
	case "email":
		return SourceAuthTypeEmail, nil
	case "app":
		return SourceAuthTypeApp, nil
	case "":
		return SourceAuthTypeEmpty, nil
	}
	var t SourceAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAuthType) Ptr() *SourceAuthType {
	return &s
}

type SourceLink struct {
	Id             int                    `json:"id" url:"id"`
	Name           string                 `json:"name" url:"name"`
	Slug           string                 `json:"slug" url:"slug"`
	Description    string                 `json:"description" url:"description"`
	Logo           string                 `json:"logo" url:"logo"`
	OauthUrl       *string                `json:"oauth_url,omitempty" url:"oauth_url,omitempty"`
	AuthType       *SourceAuthType        `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	FormComponents map[string]interface{} `json:"form_components,omitempty" url:"form_components,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SourceLink) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceLink) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceLink(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceLink) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceType string

const (
	SourceTypeApp      SourceType = "app"
	SourceTypeBle      SourceType = "ble"
	SourceTypeDevice   SourceType = "device"
	SourceTypeLab      SourceType = "lab"
	SourceTypeProvider SourceType = "provider"
)

func NewSourceTypeFromString(s string) (SourceType, error) {
	switch s {
	case "app":
		return SourceTypeApp, nil
	case "ble":
		return SourceTypeBle, nil
	case "device":
		return SourceTypeDevice, nil
	case "lab":
		return SourceTypeLab, nil
	case "provider":
		return SourceTypeProvider, nil
	}
	var t SourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceType) Ptr() *SourceType {
	return &s
}

type TeamConfig struct {
	Libreview                      *LibreConfig                 `json:"libreview,omitempty" url:"libreview,omitempty"`
	TextsEnabled                   *bool                        `json:"texts_enabled,omitempty" url:"texts_enabled,omitempty"`
	PushHistoricalData             *bool                        `json:"push_historical_data,omitempty" url:"push_historical_data,omitempty"`
	ProviderRawData                *bool                        `json:"provider_raw_data,omitempty" url:"provider_raw_data,omitempty"`
	RejectDuplicateConnection      *bool                        `json:"reject_duplicate_connection,omitempty" url:"reject_duplicate_connection,omitempty"`
	SdkPerDeviceActivityTimeseries *bool                        `json:"sdk_per_device_activity_timeseries,omitempty" url:"sdk_per_device_activity_timeseries,omitempty"`
	EdsPreferences                 *EventDestinationPreferences `json:"eds_preferences,omitempty" url:"eds_preferences,omitempty"`
	EventTypePrefixes              []string                     `json:"event_type_prefixes,omitempty" url:"event_type_prefixes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamConfig) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamConfig) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeSlot struct {
	BookingKey *string `json:"booking_key,omitempty" url:"booking_key,omitempty"`
	// Time is in UTC
	Start string `json:"start" url:"start"`
	// Time is in UTC
	End                      string  `json:"end" url:"end"`
	ExpiresAt                *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	Price                    float64 `json:"price" url:"price"`
	IsPriority               bool    `json:"is_priority" url:"is_priority"`
	NumAppointmentsAvailable int     `json:"num_appointments_available" url:"num_appointments_available"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeSlot) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeSlot) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeSlot
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeSlot(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeSlot) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeseriesMetricPoint struct {
	Date  string  `json:"date" url:"date"`
	Value float64 `json:"value" url:"value"`
	All   float64 `json:"all" url:"all"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeseriesMetricPoint) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeseriesMetricPoint) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeseriesMetricPoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeseriesMetricPoint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeseriesMetricPoint) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeseriesResource string

const (
	TimeseriesResourceCaloriesActive           TimeseriesResource = "calories_active"
	TimeseriesResourceCaloriesBasal            TimeseriesResource = "calories_basal"
	TimeseriesResourceDistance                 TimeseriesResource = "distance"
	TimeseriesResourceBloodOxygen              TimeseriesResource = "blood_oxygen"
	TimeseriesResourceBloodPressure            TimeseriesResource = "blood_pressure"
	TimeseriesResourceBodyFat                  TimeseriesResource = "body_fat"
	TimeseriesResourceBodyWeight               TimeseriesResource = "body_weight"
	TimeseriesResourceBodyTemperature          TimeseriesResource = "body_temperature"
	TimeseriesResourceBodyTemperatureDelta     TimeseriesResource = "body_temperature_delta"
	TimeseriesResourceCholesterol              TimeseriesResource = "cholesterol"
	TimeseriesResourceCholesterolLdl           TimeseriesResource = "cholesterol/ldl"
	TimeseriesResourceCholesterolHdl           TimeseriesResource = "cholesterol/hdl"
	TimeseriesResourceCholesterolTotal         TimeseriesResource = "cholesterol/total"
	TimeseriesResourceCholesterolTriglycerides TimeseriesResource = "cholesterol/triglycerides"
	TimeseriesResourceElectrocardiogramVoltage TimeseriesResource = "electrocardiogram_voltage"
	TimeseriesResourceFloorsClimbed            TimeseriesResource = "floors_climbed"
	TimeseriesResourceGlucose                  TimeseriesResource = "glucose"
	TimeseriesResourceHeartrate                TimeseriesResource = "heartrate"
	TimeseriesResourceHrv                      TimeseriesResource = "hrv"
	TimeseriesResourceHypnogram                TimeseriesResource = "hypnogram"
	TimeseriesResourceIge                      TimeseriesResource = "ige"
	TimeseriesResourceIgg                      TimeseriesResource = "igg"
	TimeseriesResourceRespiratoryRate          TimeseriesResource = "respiratory_rate"
	TimeseriesResourceSteps                    TimeseriesResource = "steps"
	TimeseriesResourceStressLevel              TimeseriesResource = "stress_level"
	TimeseriesResourceVo2Max                   TimeseriesResource = "vo2_max"
	TimeseriesResourceWater                    TimeseriesResource = "water"
	TimeseriesResourceCaffeine                 TimeseriesResource = "caffeine"
	TimeseriesResourceMindfulnessMinutes       TimeseriesResource = "mindfulness_minutes"
	TimeseriesResourceAfibBurden               TimeseriesResource = "afib_burden"
	TimeseriesResourceHeartRateAlert           TimeseriesResource = "heart_rate_alert"
	TimeseriesResourceWorkoutDuration          TimeseriesResource = "workout_duration"
	TimeseriesResourceInsulinInjection         TimeseriesResource = "insulin_injection"
	TimeseriesResourceCarbohydrates            TimeseriesResource = "carbohydrates"
	TimeseriesResourceNote                     TimeseriesResource = "note"
)

func NewTimeseriesResourceFromString(s string) (TimeseriesResource, error) {
	switch s {
	case "calories_active":
		return TimeseriesResourceCaloriesActive, nil
	case "calories_basal":
		return TimeseriesResourceCaloriesBasal, nil
	case "distance":
		return TimeseriesResourceDistance, nil
	case "blood_oxygen":
		return TimeseriesResourceBloodOxygen, nil
	case "blood_pressure":
		return TimeseriesResourceBloodPressure, nil
	case "body_fat":
		return TimeseriesResourceBodyFat, nil
	case "body_weight":
		return TimeseriesResourceBodyWeight, nil
	case "body_temperature":
		return TimeseriesResourceBodyTemperature, nil
	case "body_temperature_delta":
		return TimeseriesResourceBodyTemperatureDelta, nil
	case "cholesterol":
		return TimeseriesResourceCholesterol, nil
	case "cholesterol/ldl":
		return TimeseriesResourceCholesterolLdl, nil
	case "cholesterol/hdl":
		return TimeseriesResourceCholesterolHdl, nil
	case "cholesterol/total":
		return TimeseriesResourceCholesterolTotal, nil
	case "cholesterol/triglycerides":
		return TimeseriesResourceCholesterolTriglycerides, nil
	case "electrocardiogram_voltage":
		return TimeseriesResourceElectrocardiogramVoltage, nil
	case "floors_climbed":
		return TimeseriesResourceFloorsClimbed, nil
	case "glucose":
		return TimeseriesResourceGlucose, nil
	case "heartrate":
		return TimeseriesResourceHeartrate, nil
	case "hrv":
		return TimeseriesResourceHrv, nil
	case "hypnogram":
		return TimeseriesResourceHypnogram, nil
	case "ige":
		return TimeseriesResourceIge, nil
	case "igg":
		return TimeseriesResourceIgg, nil
	case "respiratory_rate":
		return TimeseriesResourceRespiratoryRate, nil
	case "steps":
		return TimeseriesResourceSteps, nil
	case "stress_level":
		return TimeseriesResourceStressLevel, nil
	case "vo2_max":
		return TimeseriesResourceVo2Max, nil
	case "water":
		return TimeseriesResourceWater, nil
	case "caffeine":
		return TimeseriesResourceCaffeine, nil
	case "mindfulness_minutes":
		return TimeseriesResourceMindfulnessMinutes, nil
	case "afib_burden":
		return TimeseriesResourceAfibBurden, nil
	case "heart_rate_alert":
		return TimeseriesResourceHeartRateAlert, nil
	case "workout_duration":
		return TimeseriesResourceWorkoutDuration, nil
	case "insulin_injection":
		return TimeseriesResourceInsulinInjection, nil
	case "carbohydrates":
		return TimeseriesResourceCarbohydrates, nil
	case "note":
		return TimeseriesResourceNote, nil
	}
	var t TimeseriesResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeseriesResource) Ptr() *TimeseriesResource {
	return &t
}

type TraceElements string

const (
	TraceElementsChromium   TraceElements = "chromium"
	TraceElementsCopper     TraceElements = "copper"
	TraceElementsIodine     TraceElements = "iodine"
	TraceElementsManganese  TraceElements = "manganese"
	TraceElementsMolybdenum TraceElements = "molybdenum"
	TraceElementsSelenium   TraceElements = "selenium"
)

func NewTraceElementsFromString(s string) (TraceElements, error) {
	switch s {
	case "chromium":
		return TraceElementsChromium, nil
	case "copper":
		return TraceElementsCopper, nil
	case "iodine":
		return TraceElementsIodine, nil
	case "manganese":
		return TraceElementsManganese, nil
	case "molybdenum":
		return TraceElementsMolybdenum, nil
	case "selenium":
		return TraceElementsSelenium, nil
	}
	var t TraceElements
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TraceElements) Ptr() *TraceElements {
	return &t
}

type UnrecognizedValueMacroExpr struct {
	ValueMacro string `json:"value_macro" url:"value_macro"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UnrecognizedValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnrecognizedValueMacroExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler UnrecognizedValueMacroExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnrecognizedValueMacroExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnrecognizedValueMacroExpr) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsAddress struct {
	FirstLine  string  `json:"first_line" url:"first_line"`
	SecondLine *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City       string  `json:"city" url:"city"`
	State      string  `json:"state" url:"state"`
	ZipCode    string  `json:"zip_code" url:"zip_code"`
	// Deprecated. Use `second_line` instead to provide the unit number. Subject to removal after 20 Nov 2023.
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UsAddress) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler UsAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsAddress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsAddress) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserHistoricalPullsResponse struct {
	Data []*SingleUserHistoricalPullResponse `json:"data,omitempty" url:"data,omitempty"`
	Next *string                             `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserHistoricalPullsResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserHistoricalPullsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserHistoricalPullsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserHistoricalPullsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserHistoricalPullsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserInfo struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Email       string   `json:"email" url:"email"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`
	Gender      string   `json:"gender" url:"gender"`
	Dob         string   `json:"dob" url:"dob"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserInfo) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler UserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserInfo) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshErrorResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId        string   `json:"user_id" url:"user_id"`
	Error         string   `json:"error" url:"error"`
	FailedSources []string `json:"failed_sources,omitempty" url:"failed_sources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserRefreshErrorResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserRefreshErrorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshErrorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshErrorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshErrorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId            string   `json:"user_id" url:"user_id"`
	RefreshedSources  []string `json:"refreshed_sources,omitempty" url:"refreshed_sources,omitempty"`
	InProgressSources []string `json:"in_progress_sources,omitempty" url:"in_progress_sources,omitempty"`
	FailedSources     []string `json:"failed_sources,omitempty" url:"failed_sources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserRefreshSuccessResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserRefreshSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshSuccessResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserResourcesResponse struct {
	Data []*SingleUserResourceResponse `json:"data,omitempty" url:"data,omitempty"`
	Next *string                       `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserResourcesResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserResourcesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserResourcesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserResourcesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserResourcesResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSignInTokenResponse struct {
	UserId      string `json:"user_id" url:"user_id"`
	SignInToken string `json:"sign_in_token" url:"sign_in_token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserSignInTokenResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserSignInTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSignInTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSignInTokenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSignInTokenResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserSuccessResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSuccessResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty" url:"loc,omitempty"`
	Msg  string                    `json:"msg" url:"msg"`
	Type string                    `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *ValidationError) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	String  string
	Integer int
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{Integer: value}
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	if v.String != "" {
		return json.Marshal(v.String)
	}
	if v.Integer != 0 {
		return json.Marshal(v.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	if v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.Integer != 0 {
		return visitor.VisitInteger(v.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`
	PhoneType   *string  `json:"phone_type,omitempty" url:"phone_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Gender      Gender   `json:"gender" url:"gender"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`
	Dob         string   `json:"dob" url:"dob"`
	Email       string   `json:"email" url:"email"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VitalSleepStage = int

type VitalTokenCreatedResponse struct {
	Code        string `json:"code" url:"code"`
	ExchangeUrl string `json:"exchange_url" url:"exchange_url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VitalTokenCreatedResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VitalTokenCreatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalTokenCreatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalTokenCreatedResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalTokenCreatedResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type Vitamins string

const (
	VitaminsVitaminA        Vitamins = "vitamin_a"
	VitaminsVitaminB1       Vitamins = "vitamin_b1"
	VitaminsRiboflavin      Vitamins = "riboflavin"
	VitaminsNiacin          Vitamins = "niacin"
	VitaminsPantothenicAcid Vitamins = "pantothenic_acid"
	VitaminsVitaminB6       Vitamins = "vitamin_b6"
	VitaminsBiotin          Vitamins = "biotin"
	VitaminsVitaminB12      Vitamins = "vitamin_b12"
	VitaminsVitaminC        Vitamins = "vitamin_c"
	VitaminsVitaminD        Vitamins = "vitamin_d"
	VitaminsVitaminE        Vitamins = "vitamin_e"
	VitaminsVitaminK        Vitamins = "vitamin_k"
	VitaminsFolicAcid       Vitamins = "folic_acid"
)

func NewVitaminsFromString(s string) (Vitamins, error) {
	switch s {
	case "vitamin_a":
		return VitaminsVitaminA, nil
	case "vitamin_b1":
		return VitaminsVitaminB1, nil
	case "riboflavin":
		return VitaminsRiboflavin, nil
	case "niacin":
		return VitaminsNiacin, nil
	case "pantothenic_acid":
		return VitaminsPantothenicAcid, nil
	case "vitamin_b6":
		return VitaminsVitaminB6, nil
	case "biotin":
		return VitaminsBiotin, nil
	case "vitamin_b12":
		return VitaminsVitaminB12, nil
	case "vitamin_c":
		return VitaminsVitaminC, nil
	case "vitamin_d":
		return VitaminsVitaminD, nil
	case "vitamin_e":
		return VitaminsVitaminE, nil
	case "vitamin_k":
		return VitaminsVitaminK, nil
	case "folic_acid":
		return VitaminsFolicAcid, nil
	}
	var t Vitamins
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v Vitamins) Ptr() *Vitamins {
	return &v
}

type WorkoutColumnExpr struct {
	Workout WorkoutColumnExprWorkout `json:"workout" url:"workout"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkoutColumnExpr) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkoutColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkoutColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkoutColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutColumnExpr) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WorkoutColumnExprWorkout string

const (
	WorkoutColumnExprWorkoutSessionStart          WorkoutColumnExprWorkout = "session_start"
	WorkoutColumnExprWorkoutSessionEnd            WorkoutColumnExprWorkout = "session_end"
	WorkoutColumnExprWorkoutTitle                 WorkoutColumnExprWorkout = "title"
	WorkoutColumnExprWorkoutSportId               WorkoutColumnExprWorkout = "sport_id"
	WorkoutColumnExprWorkoutSportName             WorkoutColumnExprWorkout = "sport_name"
	WorkoutColumnExprWorkoutSportSlug             WorkoutColumnExprWorkout = "sport_slug"
	WorkoutColumnExprWorkoutDurationActiveSecond  WorkoutColumnExprWorkout = "duration_active_second"
	WorkoutColumnExprWorkoutHeartRateMean         WorkoutColumnExprWorkout = "heart_rate_mean"
	WorkoutColumnExprWorkoutHeartRateMinimum      WorkoutColumnExprWorkout = "heart_rate_minimum"
	WorkoutColumnExprWorkoutHeartRateMaximum      WorkoutColumnExprWorkout = "heart_rate_maximum"
	WorkoutColumnExprWorkoutHeartRateZone1        WorkoutColumnExprWorkout = "heart_rate_zone_1"
	WorkoutColumnExprWorkoutHeartRateZone2        WorkoutColumnExprWorkout = "heart_rate_zone_2"
	WorkoutColumnExprWorkoutHeartRateZone3        WorkoutColumnExprWorkout = "heart_rate_zone_3"
	WorkoutColumnExprWorkoutHeartRateZone4        WorkoutColumnExprWorkout = "heart_rate_zone_4"
	WorkoutColumnExprWorkoutHeartRateZone5        WorkoutColumnExprWorkout = "heart_rate_zone_5"
	WorkoutColumnExprWorkoutHeartRateZone6        WorkoutColumnExprWorkout = "heart_rate_zone_6"
	WorkoutColumnExprWorkoutDistanceMeter         WorkoutColumnExprWorkout = "distance_meter"
	WorkoutColumnExprWorkoutCalories              WorkoutColumnExprWorkout = "calories"
	WorkoutColumnExprWorkoutElevationGainMeter    WorkoutColumnExprWorkout = "elevation_gain_meter"
	WorkoutColumnExprWorkoutElevationMaximumMeter WorkoutColumnExprWorkout = "elevation_maximum_meter"
	WorkoutColumnExprWorkoutElevationMinimumMeter WorkoutColumnExprWorkout = "elevation_minimum_meter"
	WorkoutColumnExprWorkoutSpeedMean             WorkoutColumnExprWorkout = "speed_mean"
	WorkoutColumnExprWorkoutSpeedMaximum          WorkoutColumnExprWorkout = "speed_maximum"
	WorkoutColumnExprWorkoutPowerSource           WorkoutColumnExprWorkout = "power_source"
	WorkoutColumnExprWorkoutPowerMean             WorkoutColumnExprWorkout = "power_mean"
	WorkoutColumnExprWorkoutPowerMaximum          WorkoutColumnExprWorkout = "power_maximum"
	WorkoutColumnExprWorkoutPowerWeightedMean     WorkoutColumnExprWorkout = "power_weighted_mean"
	WorkoutColumnExprWorkoutSteps                 WorkoutColumnExprWorkout = "steps"
	WorkoutColumnExprWorkoutMap                   WorkoutColumnExprWorkout = "map"
	WorkoutColumnExprWorkoutSourceType            WorkoutColumnExprWorkout = "source_type"
	WorkoutColumnExprWorkoutSourceProvider        WorkoutColumnExprWorkout = "source_provider"
	WorkoutColumnExprWorkoutSourceAppId           WorkoutColumnExprWorkout = "source_app_id"
)

func NewWorkoutColumnExprWorkoutFromString(s string) (WorkoutColumnExprWorkout, error) {
	switch s {
	case "session_start":
		return WorkoutColumnExprWorkoutSessionStart, nil
	case "session_end":
		return WorkoutColumnExprWorkoutSessionEnd, nil
	case "title":
		return WorkoutColumnExprWorkoutTitle, nil
	case "sport_id":
		return WorkoutColumnExprWorkoutSportId, nil
	case "sport_name":
		return WorkoutColumnExprWorkoutSportName, nil
	case "sport_slug":
		return WorkoutColumnExprWorkoutSportSlug, nil
	case "duration_active_second":
		return WorkoutColumnExprWorkoutDurationActiveSecond, nil
	case "heart_rate_mean":
		return WorkoutColumnExprWorkoutHeartRateMean, nil
	case "heart_rate_minimum":
		return WorkoutColumnExprWorkoutHeartRateMinimum, nil
	case "heart_rate_maximum":
		return WorkoutColumnExprWorkoutHeartRateMaximum, nil
	case "heart_rate_zone_1":
		return WorkoutColumnExprWorkoutHeartRateZone1, nil
	case "heart_rate_zone_2":
		return WorkoutColumnExprWorkoutHeartRateZone2, nil
	case "heart_rate_zone_3":
		return WorkoutColumnExprWorkoutHeartRateZone3, nil
	case "heart_rate_zone_4":
		return WorkoutColumnExprWorkoutHeartRateZone4, nil
	case "heart_rate_zone_5":
		return WorkoutColumnExprWorkoutHeartRateZone5, nil
	case "heart_rate_zone_6":
		return WorkoutColumnExprWorkoutHeartRateZone6, nil
	case "distance_meter":
		return WorkoutColumnExprWorkoutDistanceMeter, nil
	case "calories":
		return WorkoutColumnExprWorkoutCalories, nil
	case "elevation_gain_meter":
		return WorkoutColumnExprWorkoutElevationGainMeter, nil
	case "elevation_maximum_meter":
		return WorkoutColumnExprWorkoutElevationMaximumMeter, nil
	case "elevation_minimum_meter":
		return WorkoutColumnExprWorkoutElevationMinimumMeter, nil
	case "speed_mean":
		return WorkoutColumnExprWorkoutSpeedMean, nil
	case "speed_maximum":
		return WorkoutColumnExprWorkoutSpeedMaximum, nil
	case "power_source":
		return WorkoutColumnExprWorkoutPowerSource, nil
	case "power_mean":
		return WorkoutColumnExprWorkoutPowerMean, nil
	case "power_maximum":
		return WorkoutColumnExprWorkoutPowerMaximum, nil
	case "power_weighted_mean":
		return WorkoutColumnExprWorkoutPowerWeightedMean, nil
	case "steps":
		return WorkoutColumnExprWorkoutSteps, nil
	case "map":
		return WorkoutColumnExprWorkoutMap, nil
	case "source_type":
		return WorkoutColumnExprWorkoutSourceType, nil
	case "source_provider":
		return WorkoutColumnExprWorkoutSourceProvider, nil
	case "source_app_id":
		return WorkoutColumnExprWorkoutSourceAppId, nil
	}
	var t WorkoutColumnExprWorkout
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkoutColumnExprWorkout) Ptr() *WorkoutColumnExprWorkout {
	return &w
}

type WorkoutV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                 `json:"id" url:"id"`
	SportId    int                    `json:"sport_id" url:"sport_id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`
	Sport      *ClientFacingSport     `json:"sport,omitempty" url:"sport,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkoutV2InDb) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkoutV2InDb) UnmarshalJSON(data []byte) error {
	type embed WorkoutV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WorkoutV2InDb(unmarshaler.embed)
	w.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutV2InDb) MarshalJSON() ([]byte, error) {
	type embed WorkoutV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*w),
		Timestamp: core.NewDateTime(w.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (w *WorkoutV2InDb) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
