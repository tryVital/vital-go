// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/tryVital/vital-go/core"
	time "time"
)

type ActivityColumnExpr struct {
	Activity ActivityColumnExprActivity `json:"activity" url:"activity"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActivityColumnExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActivityColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivityColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivityColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityColumnExpr) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActivityColumnExprActivity string

const (
	ActivityColumnExprActivityDate                     ActivityColumnExprActivity = "date"
	ActivityColumnExprActivityCaloriesTotal            ActivityColumnExprActivity = "calories_total"
	ActivityColumnExprActivityCaloriesActive           ActivityColumnExprActivity = "calories_active"
	ActivityColumnExprActivitySteps                    ActivityColumnExprActivity = "steps"
	ActivityColumnExprActivityDistanceMeter            ActivityColumnExprActivity = "distance_meter"
	ActivityColumnExprActivityFloorsClimbed            ActivityColumnExprActivity = "floors_climbed"
	ActivityColumnExprActivityDurationActiveSecond     ActivityColumnExprActivity = "duration_active_second"
	ActivityColumnExprActivityIntensitySedentarySecond ActivityColumnExprActivity = "intensity_sedentary_second"
	ActivityColumnExprActivityIntensityLowSecond       ActivityColumnExprActivity = "intensity_low_second"
	ActivityColumnExprActivityIntensityMediumSecond    ActivityColumnExprActivity = "intensity_medium_second"
	ActivityColumnExprActivityIntensityHighSecond      ActivityColumnExprActivity = "intensity_high_second"
	ActivityColumnExprActivityHeartRateMean            ActivityColumnExprActivity = "heart_rate_mean"
	ActivityColumnExprActivityHeartRateMinimum         ActivityColumnExprActivity = "heart_rate_minimum"
	ActivityColumnExprActivityHeartRateMaximum         ActivityColumnExprActivity = "heart_rate_maximum"
	ActivityColumnExprActivityHeartRateResting         ActivityColumnExprActivity = "heart_rate_resting"
	ActivityColumnExprActivityHeartRateMeanWalking     ActivityColumnExprActivity = "heart_rate_mean_walking"
	ActivityColumnExprActivityWheelchairUse            ActivityColumnExprActivity = "wheelchair_use"
	ActivityColumnExprActivityWheelchairPush           ActivityColumnExprActivity = "wheelchair_push"
	ActivityColumnExprActivitySourceType               ActivityColumnExprActivity = "source_type"
	ActivityColumnExprActivitySourceProvider           ActivityColumnExprActivity = "source_provider"
	ActivityColumnExprActivitySourceAppId              ActivityColumnExprActivity = "source_app_id"
	ActivityColumnExprActivityTimeZone                 ActivityColumnExprActivity = "time_zone"
	ActivityColumnExprActivityTimeZoneOffset           ActivityColumnExprActivity = "time_zone_offset"
)

func NewActivityColumnExprActivityFromString(s string) (ActivityColumnExprActivity, error) {
	switch s {
	case "date":
		return ActivityColumnExprActivityDate, nil
	case "calories_total":
		return ActivityColumnExprActivityCaloriesTotal, nil
	case "calories_active":
		return ActivityColumnExprActivityCaloriesActive, nil
	case "steps":
		return ActivityColumnExprActivitySteps, nil
	case "distance_meter":
		return ActivityColumnExprActivityDistanceMeter, nil
	case "floors_climbed":
		return ActivityColumnExprActivityFloorsClimbed, nil
	case "duration_active_second":
		return ActivityColumnExprActivityDurationActiveSecond, nil
	case "intensity_sedentary_second":
		return ActivityColumnExprActivityIntensitySedentarySecond, nil
	case "intensity_low_second":
		return ActivityColumnExprActivityIntensityLowSecond, nil
	case "intensity_medium_second":
		return ActivityColumnExprActivityIntensityMediumSecond, nil
	case "intensity_high_second":
		return ActivityColumnExprActivityIntensityHighSecond, nil
	case "heart_rate_mean":
		return ActivityColumnExprActivityHeartRateMean, nil
	case "heart_rate_minimum":
		return ActivityColumnExprActivityHeartRateMinimum, nil
	case "heart_rate_maximum":
		return ActivityColumnExprActivityHeartRateMaximum, nil
	case "heart_rate_resting":
		return ActivityColumnExprActivityHeartRateResting, nil
	case "heart_rate_mean_walking":
		return ActivityColumnExprActivityHeartRateMeanWalking, nil
	case "wheelchair_use":
		return ActivityColumnExprActivityWheelchairUse, nil
	case "wheelchair_push":
		return ActivityColumnExprActivityWheelchairPush, nil
	case "source_type":
		return ActivityColumnExprActivitySourceType, nil
	case "source_provider":
		return ActivityColumnExprActivitySourceProvider, nil
	case "source_app_id":
		return ActivityColumnExprActivitySourceAppId, nil
	case "time_zone":
		return ActivityColumnExprActivityTimeZone, nil
	case "time_zone_offset":
		return ActivityColumnExprActivityTimeZoneOffset, nil
	}
	var t ActivityColumnExprActivity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActivityColumnExprActivity) Ptr() *ActivityColumnExprActivity {
	return &a
}

type ActivityV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId int                    `json:"priority_id" url:"priority_id"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ActivityV2InDb) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActivityV2InDb) UnmarshalJSON(data []byte) error {
	type embed ActivityV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActivityV2InDb(unmarshaler.embed)
	a.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityV2InDb) MarshalJSON() ([]byte, error) {
	type embed ActivityV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*a),
		Timestamp: core.NewDateTime(a.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (a *ActivityV2InDb) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AddOnOrder struct {
	MarkerIds   []int    `json:"marker_ids,omitempty" url:"marker_ids,omitempty"`
	ProviderIds []string `json:"provider_ids,omitempty" url:"provider_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddOnOrder) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddOnOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler AddOnOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddOnOrder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddOnOrder) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Address struct {
	FirstLine  string  `json:"first_line" url:"first_line"`
	SecondLine *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	Country    string  `json:"country" url:"country"`
	Zip        string  `json:"zip" url:"zip"`
	City       string  `json:"city" url:"city"`
	State      string  `json:"state" url:"state"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AggregateExpr struct {
	Arg  *AggregateExprArg `json:"arg,omitempty" url:"arg,omitempty"`
	Func AggregateExprFunc `json:"func" url:"func"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AggregateExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregateExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregateExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregateExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregateExpr) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AggregateExprArg struct {
	SleepColumnExpr            *SleepColumnExpr
	ActivityColumnExpr         *ActivityColumnExpr
	WorkoutColumnExpr          *WorkoutColumnExpr
	BodyColumnExpr             *BodyColumnExpr
	IndexColumnExpr            *IndexColumnExpr
	SleepScoreValueMacroExpr   *SleepScoreValueMacroExpr
	ChronotypeValueMacroExpr   *ChronotypeValueMacroExpr
	UnrecognizedValueMacroExpr *UnrecognizedValueMacroExpr
}

func NewAggregateExprArgFromSleepColumnExpr(value *SleepColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{SleepColumnExpr: value}
}

func NewAggregateExprArgFromActivityColumnExpr(value *ActivityColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{ActivityColumnExpr: value}
}

func NewAggregateExprArgFromWorkoutColumnExpr(value *WorkoutColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{WorkoutColumnExpr: value}
}

func NewAggregateExprArgFromBodyColumnExpr(value *BodyColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{BodyColumnExpr: value}
}

func NewAggregateExprArgFromIndexColumnExpr(value *IndexColumnExpr) *AggregateExprArg {
	return &AggregateExprArg{IndexColumnExpr: value}
}

func NewAggregateExprArgFromSleepScoreValueMacroExpr(value *SleepScoreValueMacroExpr) *AggregateExprArg {
	return &AggregateExprArg{SleepScoreValueMacroExpr: value}
}

func NewAggregateExprArgFromChronotypeValueMacroExpr(value *ChronotypeValueMacroExpr) *AggregateExprArg {
	return &AggregateExprArg{ChronotypeValueMacroExpr: value}
}

func NewAggregateExprArgFromUnrecognizedValueMacroExpr(value *UnrecognizedValueMacroExpr) *AggregateExprArg {
	return &AggregateExprArg{UnrecognizedValueMacroExpr: value}
}

func (a *AggregateExprArg) UnmarshalJSON(data []byte) error {
	valueSleepColumnExpr := new(SleepColumnExpr)
	if err := json.Unmarshal(data, &valueSleepColumnExpr); err == nil {
		a.SleepColumnExpr = valueSleepColumnExpr
		return nil
	}
	valueActivityColumnExpr := new(ActivityColumnExpr)
	if err := json.Unmarshal(data, &valueActivityColumnExpr); err == nil {
		a.ActivityColumnExpr = valueActivityColumnExpr
		return nil
	}
	valueWorkoutColumnExpr := new(WorkoutColumnExpr)
	if err := json.Unmarshal(data, &valueWorkoutColumnExpr); err == nil {
		a.WorkoutColumnExpr = valueWorkoutColumnExpr
		return nil
	}
	valueBodyColumnExpr := new(BodyColumnExpr)
	if err := json.Unmarshal(data, &valueBodyColumnExpr); err == nil {
		a.BodyColumnExpr = valueBodyColumnExpr
		return nil
	}
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		a.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valueSleepScoreValueMacroExpr := new(SleepScoreValueMacroExpr)
	if err := json.Unmarshal(data, &valueSleepScoreValueMacroExpr); err == nil {
		a.SleepScoreValueMacroExpr = valueSleepScoreValueMacroExpr
		return nil
	}
	valueChronotypeValueMacroExpr := new(ChronotypeValueMacroExpr)
	if err := json.Unmarshal(data, &valueChronotypeValueMacroExpr); err == nil {
		a.ChronotypeValueMacroExpr = valueChronotypeValueMacroExpr
		return nil
	}
	valueUnrecognizedValueMacroExpr := new(UnrecognizedValueMacroExpr)
	if err := json.Unmarshal(data, &valueUnrecognizedValueMacroExpr); err == nil {
		a.UnrecognizedValueMacroExpr = valueUnrecognizedValueMacroExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AggregateExprArg) MarshalJSON() ([]byte, error) {
	if a.SleepColumnExpr != nil {
		return json.Marshal(a.SleepColumnExpr)
	}
	if a.ActivityColumnExpr != nil {
		return json.Marshal(a.ActivityColumnExpr)
	}
	if a.WorkoutColumnExpr != nil {
		return json.Marshal(a.WorkoutColumnExpr)
	}
	if a.BodyColumnExpr != nil {
		return json.Marshal(a.BodyColumnExpr)
	}
	if a.IndexColumnExpr != nil {
		return json.Marshal(a.IndexColumnExpr)
	}
	if a.SleepScoreValueMacroExpr != nil {
		return json.Marshal(a.SleepScoreValueMacroExpr)
	}
	if a.ChronotypeValueMacroExpr != nil {
		return json.Marshal(a.ChronotypeValueMacroExpr)
	}
	if a.UnrecognizedValueMacroExpr != nil {
		return json.Marshal(a.UnrecognizedValueMacroExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregateExprArgVisitor interface {
	VisitSleepColumnExpr(*SleepColumnExpr) error
	VisitActivityColumnExpr(*ActivityColumnExpr) error
	VisitWorkoutColumnExpr(*WorkoutColumnExpr) error
	VisitBodyColumnExpr(*BodyColumnExpr) error
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitSleepScoreValueMacroExpr(*SleepScoreValueMacroExpr) error
	VisitChronotypeValueMacroExpr(*ChronotypeValueMacroExpr) error
	VisitUnrecognizedValueMacroExpr(*UnrecognizedValueMacroExpr) error
}

func (a *AggregateExprArg) Accept(visitor AggregateExprArgVisitor) error {
	if a.SleepColumnExpr != nil {
		return visitor.VisitSleepColumnExpr(a.SleepColumnExpr)
	}
	if a.ActivityColumnExpr != nil {
		return visitor.VisitActivityColumnExpr(a.ActivityColumnExpr)
	}
	if a.WorkoutColumnExpr != nil {
		return visitor.VisitWorkoutColumnExpr(a.WorkoutColumnExpr)
	}
	if a.BodyColumnExpr != nil {
		return visitor.VisitBodyColumnExpr(a.BodyColumnExpr)
	}
	if a.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(a.IndexColumnExpr)
	}
	if a.SleepScoreValueMacroExpr != nil {
		return visitor.VisitSleepScoreValueMacroExpr(a.SleepScoreValueMacroExpr)
	}
	if a.ChronotypeValueMacroExpr != nil {
		return visitor.VisitChronotypeValueMacroExpr(a.ChronotypeValueMacroExpr)
	}
	if a.UnrecognizedValueMacroExpr != nil {
		return visitor.VisitUnrecognizedValueMacroExpr(a.UnrecognizedValueMacroExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregateExprFunc string

const (
	AggregateExprFuncMean   AggregateExprFunc = "mean"
	AggregateExprFuncMin    AggregateExprFunc = "min"
	AggregateExprFuncMax    AggregateExprFunc = "max"
	AggregateExprFuncSum    AggregateExprFunc = "sum"
	AggregateExprFuncCount  AggregateExprFunc = "count"
	AggregateExprFuncMedian AggregateExprFunc = "median"
	AggregateExprFuncStddev AggregateExprFunc = "stddev"
	AggregateExprFuncOldest AggregateExprFunc = "oldest"
	AggregateExprFuncNewest AggregateExprFunc = "newest"
)

func NewAggregateExprFuncFromString(s string) (AggregateExprFunc, error) {
	switch s {
	case "mean":
		return AggregateExprFuncMean, nil
	case "min":
		return AggregateExprFuncMin, nil
	case "max":
		return AggregateExprFuncMax, nil
	case "sum":
		return AggregateExprFuncSum, nil
	case "count":
		return AggregateExprFuncCount, nil
	case "median":
		return AggregateExprFuncMedian, nil
	case "stddev":
		return AggregateExprFuncStddev, nil
	case "oldest":
		return AggregateExprFuncOldest, nil
	case "newest":
		return AggregateExprFuncNewest, nil
	}
	var t AggregateExprFunc
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregateExprFunc) Ptr() *AggregateExprFunc {
	return &a
}

type AggregationResponse struct {
	Results []*AggregationResult `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AggregationResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregationResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AggregationResult struct {
	// The result table of the query, organized in a column oriented format.
	Table map[string][]interface{} `json:"table,omitempty" url:"table,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AggregationResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregationResult) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregationResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregationResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregationResult) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AllowedRadius string

const (
	AllowedRadiusTen        AllowedRadius = "10"
	AllowedRadiusTwenty     AllowedRadius = "20"
	AllowedRadiusTwentyFive AllowedRadius = "25"
	AllowedRadiusFifty      AllowedRadius = "50"
)

func NewAllowedRadiusFromString(s string) (AllowedRadius, error) {
	switch s {
	case "10":
		return AllowedRadiusTen, nil
	case "20":
		return AllowedRadiusTwenty, nil
	case "25":
		return AllowedRadiusTwentyFive, nil
	case "50":
		return AllowedRadiusFifty, nil
	}
	var t AllowedRadius
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AllowedRadius) Ptr() *AllowedRadius {
	return &a
}

type Answer struct {
	Id    int    `json:"id" url:"id"`
	Code  string `json:"code" url:"code"`
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Answer) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Answer) UnmarshalJSON(data []byte) error {
	type unmarshaler Answer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Answer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Answer) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AoE struct {
	Questions []*Question `json:"questions,omitempty" url:"questions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AoE) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AoE) UnmarshalJSON(data []byte) error {
	type unmarshaler AoE
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AoE(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AoE) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AoEAnswer struct {
	MarkerId   int    `json:"marker_id" url:"marker_id"`
	QuestionId int    `json:"question_id" url:"question_id"`
	Answer     string `json:"answer" url:"answer"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AoEAnswer) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AoEAnswer) UnmarshalJSON(data []byte) error {
	type unmarshaler AoEAnswer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AoEAnswer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AoEAnswer) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentAvailabilitySlots struct {
	Slots    []*DaySlots `json:"slots,omitempty" url:"slots,omitempty"`
	Timezone *string     `json:"timezone,omitempty" url:"timezone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentAvailabilitySlots) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentAvailabilitySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentAvailabilitySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentAvailabilitySlots(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentAvailabilitySlots) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentBookingRequest struct {
	BookingKey string `json:"booking_key" url:"booking_key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentBookingRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentBookingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentBookingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentBookingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentBookingRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentEventStatus string

const (
	AppointmentEventStatusPending    AppointmentEventStatus = "pending"
	AppointmentEventStatusScheduled  AppointmentEventStatus = "scheduled"
	AppointmentEventStatusCompleted  AppointmentEventStatus = "completed"
	AppointmentEventStatusCancelled  AppointmentEventStatus = "cancelled"
	AppointmentEventStatusInProgress AppointmentEventStatus = "in_progress"
)

func NewAppointmentEventStatusFromString(s string) (AppointmentEventStatus, error) {
	switch s {
	case "pending":
		return AppointmentEventStatusPending, nil
	case "scheduled":
		return AppointmentEventStatusScheduled, nil
	case "completed":
		return AppointmentEventStatusCompleted, nil
	case "cancelled":
		return AppointmentEventStatusCancelled, nil
	case "in_progress":
		return AppointmentEventStatusInProgress, nil
	}
	var t AppointmentEventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentEventStatus) Ptr() *AppointmentEventStatus {
	return &a
}

type AppointmentLocation struct {
	Location     *LngLat    `json:"location,omitempty" url:"location,omitempty"`
	Address      *UsAddress `json:"address,omitempty" url:"address,omitempty"`
	Code         string     `json:"code" url:"code"`
	Name         string     `json:"name" url:"name"`
	IanaTimezone *string    `json:"iana_timezone,omitempty" url:"iana_timezone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentLocation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentLocation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentLocation) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentProvider string

const (
	AppointmentProviderGetlabs      AppointmentProvider = "getlabs"
	AppointmentProviderAxlehealth   AppointmentProvider = "axlehealth"
	AppointmentProviderPhlebfinders AppointmentProvider = "phlebfinders"
	AppointmentProviderQuest        AppointmentProvider = "quest"
)

func NewAppointmentProviderFromString(s string) (AppointmentProvider, error) {
	switch s {
	case "getlabs":
		return AppointmentProviderGetlabs, nil
	case "axlehealth":
		return AppointmentProviderAxlehealth, nil
	case "phlebfinders":
		return AppointmentProviderPhlebfinders, nil
	case "quest":
		return AppointmentProviderQuest, nil
	}
	var t AppointmentProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentProvider) Ptr() *AppointmentProvider {
	return &a
}

type AppointmentPscLabs = string

type AppointmentRescheduleRequest struct {
	BookingKey string `json:"booking_key" url:"booking_key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentRescheduleRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentRescheduleRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentRescheduleRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentRescheduleRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentRescheduleRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentServiceType string

const (
	AppointmentServiceTypeAppointmentReady   AppointmentServiceType = "appointment-ready"
	AppointmentServiceTypeAppointmentRequest AppointmentServiceType = "appointment-request"
)

func NewAppointmentServiceTypeFromString(s string) (AppointmentServiceType, error) {
	switch s {
	case "appointment-ready":
		return AppointmentServiceTypeAppointmentReady, nil
	case "appointment-request":
		return AppointmentServiceTypeAppointmentRequest, nil
	}
	var t AppointmentServiceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentServiceType) Ptr() *AppointmentServiceType {
	return &a
}

type AppointmentStatus string

const (
	AppointmentStatusConfirmed  AppointmentStatus = "confirmed"
	AppointmentStatusPending    AppointmentStatus = "pending"
	AppointmentStatusInProgress AppointmentStatus = "in_progress"
	AppointmentStatusCompleted  AppointmentStatus = "completed"
	AppointmentStatusCancelled  AppointmentStatus = "cancelled"
)

func NewAppointmentStatusFromString(s string) (AppointmentStatus, error) {
	switch s {
	case "confirmed":
		return AppointmentStatusConfirmed, nil
	case "pending":
		return AppointmentStatusPending, nil
	case "in_progress":
		return AppointmentStatusInProgress, nil
	case "completed":
		return AppointmentStatusCompleted, nil
	case "cancelled":
		return AppointmentStatusCancelled, nil
	}
	var t AppointmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentStatus) Ptr() *AppointmentStatus {
	return &a
}

type AppointmentType string

const (
	AppointmentTypePhlebotomy           AppointmentType = "phlebotomy"
	AppointmentTypePatientServiceCenter AppointmentType = "patient_service_center"
)

func NewAppointmentTypeFromString(s string) (AppointmentType, error) {
	switch s {
	case "phlebotomy":
		return AppointmentTypePhlebotomy, nil
	case "patient_service_center":
		return AppointmentTypePatientServiceCenter, nil
	}
	var t AppointmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentType) Ptr() *AppointmentType {
	return &a
}

type AreaInfo struct {
	ZipCode     string                  `json:"zip_code" url:"zip_code"`
	Phlebotomy  *PhlebotomyAreaInfo     `json:"phlebotomy,omitempty" url:"phlebotomy,omitempty"`
	CentralLabs map[string]*PscAreaInfo `json:"central_labs,omitempty" url:"central_labs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AreaInfo) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler AreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AreaInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AreaInfo) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttemptStatus string

const (
	AttemptStatusSuccess AttemptStatus = "success"
	AttemptStatusFailure AttemptStatus = "failure"
)

func NewAttemptStatusFromString(s string) (AttemptStatus, error) {
	switch s {
	case "success":
		return AttemptStatusSuccess, nil
	case "failure":
		return AttemptStatusFailure, nil
	}
	var t AttemptStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptStatus) Ptr() *AttemptStatus {
	return &a
}

type AuthType string

const (
	AuthTypePassword AuthType = "password"
	AuthTypeOauth    AuthType = "oauth"
	AuthTypeEmail    AuthType = "email"
)

func NewAuthTypeFromString(s string) (AuthType, error) {
	switch s {
	case "password":
		return AuthTypePassword, nil
	case "oauth":
		return AuthTypeOauth, nil
	case "email":
		return AuthTypeEmail, nil
	}
	var t AuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthType) Ptr() *AuthType {
	return &a
}

type Availability string

const (
	AvailabilityAvailable   Availability = "available"
	AvailabilityUnavailable Availability = "unavailable"
)

func NewAvailabilityFromString(s string) (Availability, error) {
	switch s {
	case "available":
		return AvailabilityAvailable, nil
	case "unavailable":
		return AvailabilityUnavailable, nil
	}
	var t Availability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a Availability) Ptr() *Availability {
	return &a
}

type BasalBodyTemperatureEntry struct {
	Date  string  `json:"date" url:"date"`
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasalBodyTemperatureEntry) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasalBodyTemperatureEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler BasalBodyTemperatureEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasalBodyTemperatureEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasalBodyTemperatureEntry) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Billing string

const (
	BillingClientBill             Billing = "client_bill"
	BillingCommercialInsurance    Billing = "commercial_insurance"
	BillingPatientBillPassthrough Billing = "patient_bill_passthrough"
	BillingPatientBill            Billing = "patient_bill"
)

func NewBillingFromString(s string) (Billing, error) {
	switch s {
	case "client_bill":
		return BillingClientBill, nil
	case "commercial_insurance":
		return BillingCommercialInsurance, nil
	case "patient_bill_passthrough":
		return BillingPatientBillPassthrough, nil
	case "patient_bill":
		return BillingPatientBill, nil
	}
	var t Billing
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b Billing) Ptr() *Billing {
	return &b
}

// Represent the schema for an individual biomarker result.
type BiomarkerResult struct {
	Name            string                 `json:"name" url:"name"`
	Slug            *string                `json:"slug,omitempty" url:"slug,omitempty"`
	Value           float64                `json:"value" url:"value"`
	Result          string                 `json:"result" url:"result"`
	Type            ResultType             `json:"type" url:"type"`
	Unit            *string                `json:"unit,omitempty" url:"unit,omitempty"`
	Timestamp       *time.Time             `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	Notes           *string                `json:"notes,omitempty" url:"notes,omitempty"`
	MinRangeValue   *float64               `json:"min_range_value,omitempty" url:"min_range_value,omitempty"`
	MaxRangeValue   *float64               `json:"max_range_value,omitempty" url:"max_range_value,omitempty"`
	IsAboveMaxRange *bool                  `json:"is_above_max_range,omitempty" url:"is_above_max_range,omitempty"`
	IsBelowMinRange *bool                  `json:"is_below_min_range,omitempty" url:"is_below_min_range,omitempty"`
	Interpretation  *string                `json:"interpretation,omitempty" url:"interpretation,omitempty"`
	Loinc           *string                `json:"loinc,omitempty" url:"loinc,omitempty"`
	LoincSlug       *string                `json:"loinc_slug,omitempty" url:"loinc_slug,omitempty"`
	ProviderId      *string                `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	SourceMarkers   []*ParentBiomarkerData `json:"source_markers,omitempty" url:"source_markers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BiomarkerResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BiomarkerResult) UnmarshalJSON(data []byte) error {
	type embed BiomarkerResult
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BiomarkerResult(unmarshaler.embed)
	b.Timestamp = unmarshaler.Timestamp.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BiomarkerResult) MarshalJSON() ([]byte, error) {
	type embed BiomarkerResult
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*b),
		Timestamp: core.NewOptionalDateTime(b.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (b *BiomarkerResult) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BodyColumnExpr struct {
	Body BodyColumnExprBody `json:"body" url:"body"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BodyColumnExpr) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyColumnExpr) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BodyColumnExprBody string

const (
	BodyColumnExprBodyMeasuredAt                   BodyColumnExprBody = "measured_at"
	BodyColumnExprBodyWeightKilogram               BodyColumnExprBody = "weight_kilogram"
	BodyColumnExprBodyFatMassPercentage            BodyColumnExprBody = "fat_mass_percentage"
	BodyColumnExprBodyWaterPercentage              BodyColumnExprBody = "water_percentage"
	BodyColumnExprBodyMuscleMassPercentage         BodyColumnExprBody = "muscle_mass_percentage"
	BodyColumnExprBodyVisceralFatIndex             BodyColumnExprBody = "visceral_fat_index"
	BodyColumnExprBodyBoneMassPercentage           BodyColumnExprBody = "bone_mass_percentage"
	BodyColumnExprBodyBodyMassIndex                BodyColumnExprBody = "body_mass_index"
	BodyColumnExprBodyLeanBodyMassKilogram         BodyColumnExprBody = "lean_body_mass_kilogram"
	BodyColumnExprBodyWaistCircumferenceCentimeter BodyColumnExprBody = "waist_circumference_centimeter"
	BodyColumnExprBodySourceType                   BodyColumnExprBody = "source_type"
	BodyColumnExprBodySourceProvider               BodyColumnExprBody = "source_provider"
	BodyColumnExprBodySourceAppId                  BodyColumnExprBody = "source_app_id"
	BodyColumnExprBodyTimeZone                     BodyColumnExprBody = "time_zone"
)

func NewBodyColumnExprBodyFromString(s string) (BodyColumnExprBody, error) {
	switch s {
	case "measured_at":
		return BodyColumnExprBodyMeasuredAt, nil
	case "weight_kilogram":
		return BodyColumnExprBodyWeightKilogram, nil
	case "fat_mass_percentage":
		return BodyColumnExprBodyFatMassPercentage, nil
	case "water_percentage":
		return BodyColumnExprBodyWaterPercentage, nil
	case "muscle_mass_percentage":
		return BodyColumnExprBodyMuscleMassPercentage, nil
	case "visceral_fat_index":
		return BodyColumnExprBodyVisceralFatIndex, nil
	case "bone_mass_percentage":
		return BodyColumnExprBodyBoneMassPercentage, nil
	case "body_mass_index":
		return BodyColumnExprBodyBodyMassIndex, nil
	case "lean_body_mass_kilogram":
		return BodyColumnExprBodyLeanBodyMassKilogram, nil
	case "waist_circumference_centimeter":
		return BodyColumnExprBodyWaistCircumferenceCentimeter, nil
	case "source_type":
		return BodyColumnExprBodySourceType, nil
	case "source_provider":
		return BodyColumnExprBodySourceProvider, nil
	case "source_app_id":
		return BodyColumnExprBodySourceAppId, nil
	case "time_zone":
		return BodyColumnExprBodyTimeZone, nil
	}
	var t BodyColumnExprBody
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BodyColumnExprBody) Ptr() *BodyColumnExprBody {
	return &b
}

type BodyV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`
	Priority   *int                   `json:"priority,omitempty" url:"priority,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BodyV2InDb) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyV2InDb) UnmarshalJSON(data []byte) error {
	type embed BodyV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BodyV2InDb(unmarshaler.embed)
	b.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyV2InDb) MarshalJSON() ([]byte, error) {
	type embed BodyV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*b),
		Timestamp: core.NewDateTime(b.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (b *BodyV2InDb) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkExportConnectionsResponse struct {
	Data      []*ConnectionRecipe `json:"data,omitempty" url:"data,omitempty"`
	NextToken *string             `json:"next_token,omitempty" url:"next_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkExportConnectionsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkExportConnectionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkExportConnectionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkExportConnectionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkExportConnectionsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkImportConnectionsResponse struct {
	UserIdsImported []string `json:"user_ids_imported,omitempty" url:"user_ids_imported,omitempty"`
	UserIdsFailed   []string `json:"user_ids_failed,omitempty" url:"user_ids_failed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkImportConnectionsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkImportConnectionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkImportConnectionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkImportConnectionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkImportConnectionsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CervicalMucusEntry struct {
	Date    string                    `json:"date" url:"date"`
	Quality CervicalMucusEntryQuality `json:"quality" url:"quality"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CervicalMucusEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CervicalMucusEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler CervicalMucusEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CervicalMucusEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CervicalMucusEntry) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CervicalMucusEntryQuality string

const (
	CervicalMucusEntryQualityDry      CervicalMucusEntryQuality = "dry"
	CervicalMucusEntryQualitySticky   CervicalMucusEntryQuality = "sticky"
	CervicalMucusEntryQualityCreamy   CervicalMucusEntryQuality = "creamy"
	CervicalMucusEntryQualityWatery   CervicalMucusEntryQuality = "watery"
	CervicalMucusEntryQualityEggWhite CervicalMucusEntryQuality = "egg_white"
)

func NewCervicalMucusEntryQualityFromString(s string) (CervicalMucusEntryQuality, error) {
	switch s {
	case "dry":
		return CervicalMucusEntryQualityDry, nil
	case "sticky":
		return CervicalMucusEntryQualitySticky, nil
	case "creamy":
		return CervicalMucusEntryQualityCreamy, nil
	case "watery":
		return CervicalMucusEntryQualityWatery, nil
	case "egg_white":
		return CervicalMucusEntryQualityEggWhite, nil
	}
	var t CervicalMucusEntryQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CervicalMucusEntryQuality) Ptr() *CervicalMucusEntryQuality {
	return &c
}

type ChronotypeValueMacroExpr struct {
	Version    *string `json:"version,omitempty" url:"version,omitempty"`
	valueMacro string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChronotypeValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChronotypeValueMacroExpr) ValueMacro() string {
	return c.valueMacro
}

func (c *ChronotypeValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed ChronotypeValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChronotypeValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "chronotype" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "chronotype", unmarshaler.ValueMacro)
	}
	c.valueMacro = unmarshaler.ValueMacro

	extraProperties, err := core.ExtractExtraProperties(data, *c, "value_macro")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChronotypeValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed ChronotypeValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*c),
		ValueMacro: "chronotype",
	}
	return json.Marshal(marshaler)
}

func (c *ChronotypeValueMacroExpr) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientActivityResponse struct {
	Activity []*ClientFacingActivity `json:"activity,omitempty" url:"activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientActivityResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientActivityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientActivityResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientBodyResponse struct {
	Body []*ClientFacingBody `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientBodyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientBodyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientBodyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientBodyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientBodyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAFibBurdenSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAFibBurdenSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAFibBurdenSample) Unit() string {
	return c.unit
}

func (c *ClientFacingAFibBurdenSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAFibBurdenSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAFibBurdenSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "%" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "%", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAFibBurdenSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAFibBurdenSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "%",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingAFibBurdenSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingActivity struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date" url:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// Total energy consumption during the day including Basal Metabolic Rate in kilocalories::kilocalories
	CaloriesTotal *float64 `json:"calories_total,omitempty" url:"calories_total,omitempty"`
	// Energy consumption caused by the physical activity of the day in kilocalories::kilocalories
	CaloriesActive *float64 `json:"calories_active,omitempty" url:"calories_active,omitempty"`
	// Total number of steps registered during the day::steps
	Steps *int `json:"steps,omitempty" url:"steps,omitempty"`
	// Deprecated. Daily physical activity as equal meters i.e. amount of walking needed to get the same amount of activity::meters
	DailyMovement *float64 `json:"daily_movement,omitempty" url:"daily_movement,omitempty"`
	// Distance traveled during activities throughout the day::meters
	Distance *float64 `json:"distance,omitempty" url:"distance,omitempty"`
	// Number of minutes during the day with low intensity activity (e.g. household work)::minutes
	Low *float64 `json:"low,omitempty" url:"low,omitempty"`
	// Number of minutes during the day with medium intensity activity (e.g. walking)::minutes
	Medium *float64 `json:"medium,omitempty" url:"medium,omitempty"`
	// Number of minutes during the day with high intensity activity (e.g. running)::minutes
	High *float64 `json:"high,omitempty" url:"high,omitempty"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`
	// Number of floors climbed by the user::count
	FloorsClimbed *int `json:"floors_climbed,omitempty" url:"floors_climbed,omitempty"`
	// [DEPRECATED] The time zone full identifier for the data. Example: 'Europe/London'.
	TimeZone *string `json:"time_zone,omitempty" url:"time_zone,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Heart rate daily summary.
	HeartRate      *ClientFacingHeartRate `json:"heart_rate,omitempty" url:"heart_rate,omitempty"`
	WheelchairUse  *bool                  `json:"wheelchair_use,omitempty" url:"wheelchair_use,omitempty"`
	WheelchairPush *int                   `json:"wheelchair_push,omitempty" url:"wheelchair_push,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingActivity) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingActivity) UnmarshalJSON(data []byte) error {
	type embed ClientFacingActivity
	var unmarshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingActivity(unmarshaler.embed)
	c.Date = unmarshaler.Date.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingActivity) MarshalJSON() ([]byte, error) {
	type embed ClientFacingActivity
	var marshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*c),
		Date:  core.NewDateTime(c.Date),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingActivity) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingActivityChanged struct {
	EventType    ClientFacingActivityChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                               `json:"user_id" url:"user_id"`
	ClientUserId string                               `json:"client_user_id" url:"client_user_id"`
	TeamId       string                               `json:"team_id" url:"team_id"`
	Data         *ClientFacingActivity                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingActivityChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingActivityChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingActivityChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingActivityChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingActivityChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingActivityChangedEventType string

const (
	ClientFacingActivityChangedEventTypeDailyDataActivityCreated ClientFacingActivityChangedEventType = "daily.data.activity.created"
	ClientFacingActivityChangedEventTypeDailyDataActivityUpdated ClientFacingActivityChangedEventType = "daily.data.activity.updated"
)

func NewClientFacingActivityChangedEventTypeFromString(s string) (ClientFacingActivityChangedEventType, error) {
	switch s {
	case "daily.data.activity.created":
		return ClientFacingActivityChangedEventTypeDailyDataActivityCreated, nil
	case "daily.data.activity.updated":
		return ClientFacingActivityChangedEventTypeDailyDataActivityUpdated, nil
	}
	var t ClientFacingActivityChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingActivityChangedEventType) Ptr() *ClientFacingActivityChangedEventType {
	return &c
}

type ClientFacingActivityHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingActivityHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingActivityHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingActivityHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingActivityHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingActivityHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.activity.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.activity.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingActivityHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingActivityHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.activity.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingActivityHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAfibBurdenChanged struct {
	EventType    ClientFacingAfibBurdenChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                 `json:"user_id" url:"user_id"`
	ClientUserId string                                 `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                 `json:"team_id" url:"team_id"`
	Data         *GroupedAFibBurden                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAfibBurdenChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAfibBurdenChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAfibBurdenChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAfibBurdenChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAfibBurdenChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAfibBurdenChangedEventType string

const (
	ClientFacingAfibBurdenChangedEventTypeDailyDataAfibBurdenCreated ClientFacingAfibBurdenChangedEventType = "daily.data.afib_burden.created"
	ClientFacingAfibBurdenChangedEventTypeDailyDataAfibBurdenUpdated ClientFacingAfibBurdenChangedEventType = "daily.data.afib_burden.updated"
)

func NewClientFacingAfibBurdenChangedEventTypeFromString(s string) (ClientFacingAfibBurdenChangedEventType, error) {
	switch s {
	case "daily.data.afib_burden.created":
		return ClientFacingAfibBurdenChangedEventTypeDailyDataAfibBurdenCreated, nil
	case "daily.data.afib_burden.updated":
		return ClientFacingAfibBurdenChangedEventTypeDailyDataAfibBurdenUpdated, nil
	}
	var t ClientFacingAfibBurdenChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingAfibBurdenChangedEventType) Ptr() *ClientFacingAfibBurdenChangedEventType {
	return &c
}

type ClientFacingAfibBurdenHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAfibBurdenHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAfibBurdenHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingAfibBurdenHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAfibBurdenHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAfibBurdenHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.afib_burden.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.afib_burden.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAfibBurdenHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAfibBurdenHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.afib_burden.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingAfibBurdenHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingApiKey struct {
	Label     string     `json:"label" url:"label"`
	Value     string     `json:"value" url:"value"`
	TeamId    *string    `json:"team_id,omitempty" url:"team_id,omitempty"`
	Id        string     `json:"id" url:"id"`
	CreatedAt time.Time  `json:"created_at" url:"created_at"`
	DeletedAt *time.Time `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingApiKey) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingApiKey) UnmarshalJSON(data []byte) error {
	type embed ClientFacingApiKey
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		DeletedAt *core.DateTime `json:"deleted_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingApiKey(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.DeletedAt = unmarshaler.DeletedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingApiKey) MarshalJSON() ([]byte, error) {
	type embed ClientFacingApiKey
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		DeletedAt *core.DateTime `json:"deleted_at,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		DeletedAt: core.NewOptionalDateTime(c.DeletedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingApiKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointment struct {
	Id       string     `json:"id" url:"id"`
	UserId   string     `json:"user_id" url:"user_id"`
	OrderId  string     `json:"order_id" url:"order_id"`
	Address  *UsAddress `json:"address,omitempty" url:"address,omitempty"`
	Location *LngLat    `json:"location,omitempty" url:"location,omitempty"`
	// Time is in UTC
	StartAt *time.Time `json:"start_at,omitempty" url:"start_at,omitempty"`
	// Time is in UTC
	EndAt         *time.Time                      `json:"end_at,omitempty" url:"end_at,omitempty"`
	IanaTimezone  *string                         `json:"iana_timezone,omitempty" url:"iana_timezone,omitempty"`
	Type          AppointmentType                 `json:"type" url:"type"`
	Provider      AppointmentProvider             `json:"provider" url:"provider"`
	Status        AppointmentStatus               `json:"status" url:"status"`
	ProviderId    string                          `json:"provider_id" url:"provider_id"`
	CanReschedule bool                            `json:"can_reschedule" url:"can_reschedule"`
	EventStatus   AppointmentEventStatus          `json:"event_status" url:"event_status"`
	EventData     map[string]interface{}          `json:"event_data,omitempty" url:"event_data,omitempty"`
	Events        []*ClientFacingAppointmentEvent `json:"events,omitempty" url:"events,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAppointment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAppointment) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAppointment
	var unmarshaler = struct {
		embed
		StartAt *core.DateTime `json:"start_at,omitempty"`
		EndAt   *core.DateTime `json:"end_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAppointment(unmarshaler.embed)
	c.StartAt = unmarshaler.StartAt.TimePtr()
	c.EndAt = unmarshaler.EndAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointment) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAppointment
	var marshaler = struct {
		embed
		StartAt *core.DateTime `json:"start_at,omitempty"`
		EndAt   *core.DateTime `json:"end_at,omitempty"`
	}{
		embed:   embed(*c),
		StartAt: core.NewOptionalDateTime(c.StartAt),
		EndAt:   core.NewOptionalDateTime(c.EndAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingAppointment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentCancellationReason struct {
	Id           string `json:"id" url:"id"`
	Name         string `json:"name" url:"name"`
	IsRefundable bool   `json:"is_refundable" url:"is_refundable"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAppointmentCancellationReason) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAppointmentCancellationReason) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentCancellationReason
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentCancellationReason(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentCancellationReason) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentChanged struct {
	EventType    ClientFacingAppointmentChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                  `json:"user_id" url:"user_id"`
	ClientUserId string                                  `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                  `json:"team_id" url:"team_id"`
	Data         *ClientFacingAppointment                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAppointmentChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAppointmentChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentChangedEventType string

const (
	ClientFacingAppointmentChangedEventTypeLabtestAppointmentCreated ClientFacingAppointmentChangedEventType = "labtest.appointment.created"
	ClientFacingAppointmentChangedEventTypeLabtestAppointmentUpdated ClientFacingAppointmentChangedEventType = "labtest.appointment.updated"
)

func NewClientFacingAppointmentChangedEventTypeFromString(s string) (ClientFacingAppointmentChangedEventType, error) {
	switch s {
	case "labtest.appointment.created":
		return ClientFacingAppointmentChangedEventTypeLabtestAppointmentCreated, nil
	case "labtest.appointment.updated":
		return ClientFacingAppointmentChangedEventTypeLabtestAppointmentUpdated, nil
	}
	var t ClientFacingAppointmentChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingAppointmentChangedEventType) Ptr() *ClientFacingAppointmentChangedEventType {
	return &c
}

type ClientFacingAppointmentEvent struct {
	CreatedAt time.Time              `json:"created_at" url:"created_at"`
	Status    AppointmentEventStatus `json:"status" url:"status"`
	Data      map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAppointmentEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAppointmentEvent) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAppointmentEvent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAppointmentEvent(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentEvent) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAppointmentEvent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingAppointmentEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a at-home-phlebotomy test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingAtHomePhlebotomyOrder struct {
	// The Vital at-home phlebotomy Order ID
	Id            string    `json:"id" url:"id"`
	AppointmentId *string   `json:"appointment_id,omitempty" url:"appointment_id,omitempty"`
	CreatedAt     time.Time `json:"created_at" url:"created_at"`
	UpdatedAt     time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAtHomePhlebotomyOrder) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAtHomePhlebotomyOrder
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrder(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrder) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAtHomePhlebotomyOrder
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingAtHomePhlebotomyOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAtHomePhlebotomyOrderDetails struct {
	Data *ClientFacingAtHomePhlebotomyOrder `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAtHomePhlebotomyOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrderDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBasalBodyTemperatureChanged struct {
	EventType    ClientFacingBasalBodyTemperatureChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                           `json:"user_id" url:"user_id"`
	ClientUserId string                                           `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                           `json:"team_id" url:"team_id"`
	Data         *GroupedBasalBodyTemperature                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBasalBodyTemperatureChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBasalBodyTemperatureChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBasalBodyTemperatureChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBasalBodyTemperatureChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBasalBodyTemperatureChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBasalBodyTemperatureChangedEventType string

const (
	ClientFacingBasalBodyTemperatureChangedEventTypeDailyDataBasalBodyTemperatureCreated ClientFacingBasalBodyTemperatureChangedEventType = "daily.data.basal_body_temperature.created"
	ClientFacingBasalBodyTemperatureChangedEventTypeDailyDataBasalBodyTemperatureUpdated ClientFacingBasalBodyTemperatureChangedEventType = "daily.data.basal_body_temperature.updated"
)

func NewClientFacingBasalBodyTemperatureChangedEventTypeFromString(s string) (ClientFacingBasalBodyTemperatureChangedEventType, error) {
	switch s {
	case "daily.data.basal_body_temperature.created":
		return ClientFacingBasalBodyTemperatureChangedEventTypeDailyDataBasalBodyTemperatureCreated, nil
	case "daily.data.basal_body_temperature.updated":
		return ClientFacingBasalBodyTemperatureChangedEventTypeDailyDataBasalBodyTemperatureUpdated, nil
	}
	var t ClientFacingBasalBodyTemperatureChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBasalBodyTemperatureChangedEventType) Ptr() *ClientFacingBasalBodyTemperatureChangedEventType {
	return &c
}

type ClientFacingBasalBodyTemperatureHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBasalBodyTemperatureHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBasalBodyTemperatureHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingBasalBodyTemperatureHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBasalBodyTemperatureHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBasalBodyTemperatureHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.basal_body_temperature.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.basal_body_temperature.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBasalBodyTemperatureHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBasalBodyTemperatureHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.basal_body_temperature.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBasalBodyTemperatureHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBasalBodyTemperatureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBasalBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBasalBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBasalBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBasalBodyTemperatureSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBasalBodyTemperatureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBasalBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBasalBodyTemperatureSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "C",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBasalBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodOxygenChanged struct {
	EventType    ClientFacingBloodOxygenChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                  `json:"user_id" url:"user_id"`
	ClientUserId string                                  `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                  `json:"team_id" url:"team_id"`
	Data         *GroupedBloodOxygen                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodOxygenChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodOxygenChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodOxygenChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodOxygenChangedEventType string

const (
	ClientFacingBloodOxygenChangedEventTypeDailyDataBloodOxygenCreated ClientFacingBloodOxygenChangedEventType = "daily.data.blood_oxygen.created"
	ClientFacingBloodOxygenChangedEventTypeDailyDataBloodOxygenUpdated ClientFacingBloodOxygenChangedEventType = "daily.data.blood_oxygen.updated"
)

func NewClientFacingBloodOxygenChangedEventTypeFromString(s string) (ClientFacingBloodOxygenChangedEventType, error) {
	switch s {
	case "daily.data.blood_oxygen.created":
		return ClientFacingBloodOxygenChangedEventTypeDailyDataBloodOxygenCreated, nil
	case "daily.data.blood_oxygen.updated":
		return ClientFacingBloodOxygenChangedEventTypeDailyDataBloodOxygenUpdated, nil
	}
	var t ClientFacingBloodOxygenChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBloodOxygenChangedEventType) Ptr() *ClientFacingBloodOxygenChangedEventType {
	return &c
}

type ClientFacingBloodOxygenHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodOxygenHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodOxygenHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingBloodOxygenHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodOxygenHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.blood_oxygen.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.blood_oxygen.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodOxygenHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.blood_oxygen.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBloodOxygenHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodOxygenTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (spo2).
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodOxygenTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodOxygenTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodOxygenTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodOxygenTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBloodOxygenTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodPressureChanged struct {
	EventType    ClientFacingBloodPressureChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                    `json:"user_id" url:"user_id"`
	ClientUserId string                                    `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                    `json:"team_id" url:"team_id"`
	Data         *GroupedBloodPressure                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodPressureChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodPressureChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodPressureChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodPressureChangedEventType string

const (
	ClientFacingBloodPressureChangedEventTypeDailyDataBloodPressureCreated ClientFacingBloodPressureChangedEventType = "daily.data.blood_pressure.created"
	ClientFacingBloodPressureChangedEventTypeDailyDataBloodPressureUpdated ClientFacingBloodPressureChangedEventType = "daily.data.blood_pressure.updated"
)

func NewClientFacingBloodPressureChangedEventTypeFromString(s string) (ClientFacingBloodPressureChangedEventType, error) {
	switch s {
	case "daily.data.blood_pressure.created":
		return ClientFacingBloodPressureChangedEventTypeDailyDataBloodPressureCreated, nil
	case "daily.data.blood_pressure.updated":
		return ClientFacingBloodPressureChangedEventTypeDailyDataBloodPressureUpdated, nil
	}
	var t ClientFacingBloodPressureChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBloodPressureChangedEventType) Ptr() *ClientFacingBloodPressureChangedEventType {
	return &c
}

type ClientFacingBloodPressureHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodPressureHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodPressureHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingBloodPressureHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodPressureHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.blood_pressure.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.blood_pressure.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodPressureHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.blood_pressure.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBloodPressureHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodPressureTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unit of the value. We use SI units where possible, e.g. mmol/L for glucose/cholesterol, bpm for heart rate, etc.
	Unit      string                          `json:"unit" url:"unit"`
	Grouping  *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	Timestamp time.Time                       `json:"timestamp" url:"timestamp"`
	Systolic  float64                         `json:"systolic" url:"systolic"`
	Diastolic float64                         `json:"diastolic" url:"diastolic"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBloodPressureTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodPressureTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodPressureTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodPressureTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBloodPressureTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBody struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date" url:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// Weight in kg::kg
	Weight *float64 `json:"weight,omitempty" url:"weight,omitempty"`
	// Total body fat percentage::perc
	Fat *float64 `json:"fat,omitempty" url:"fat,omitempty"`
	// Water percentage in the body::perc
	WaterPercentage *float64 `json:"water_percentage,omitempty" url:"water_percentage,omitempty"`
	// Muscle mass percentage in the body::perc
	MuscleMassPercentage *float64 `json:"muscle_mass_percentage,omitempty" url:"muscle_mass_percentage,omitempty"`
	// Visceral fat index::scalar
	VisceralFatIndex *float64 `json:"visceral_fat_index,omitempty" url:"visceral_fat_index,omitempty"`
	// Bone mass percentage in the body::perc
	BoneMassPercentage           *float64            `json:"bone_mass_percentage,omitempty" url:"bone_mass_percentage,omitempty"`
	BodyMassIndex                *float64            `json:"body_mass_index,omitempty" url:"body_mass_index,omitempty"`
	LeanBodyMassKilogram         *float64            `json:"lean_body_mass_kilogram,omitempty" url:"lean_body_mass_kilogram,omitempty"`
	WaistCircumferenceCentimeter *float64            `json:"waist_circumference_centimeter,omitempty" url:"waist_circumference_centimeter,omitempty"`
	Source                       *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBody) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBody
	var unmarshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBody(unmarshaler.embed)
	c.Date = unmarshaler.Date.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBody) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBody
	var marshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*c),
		Date:  core.NewDateTime(c.Date),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBody) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyChanged struct {
	EventType    ClientFacingBodyChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                           `json:"user_id" url:"user_id"`
	ClientUserId string                           `json:"client_user_id" url:"client_user_id"`
	TeamId       string                           `json:"team_id" url:"team_id"`
	Data         *ClientFacingBody                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyChangedEventType string

const (
	ClientFacingBodyChangedEventTypeDailyDataBodyCreated ClientFacingBodyChangedEventType = "daily.data.body.created"
	ClientFacingBodyChangedEventTypeDailyDataBodyUpdated ClientFacingBodyChangedEventType = "daily.data.body.updated"
)

func NewClientFacingBodyChangedEventTypeFromString(s string) (ClientFacingBodyChangedEventType, error) {
	switch s {
	case "daily.data.body.created":
		return ClientFacingBodyChangedEventTypeDailyDataBodyCreated, nil
	case "daily.data.body.updated":
		return ClientFacingBodyChangedEventTypeDailyDataBodyUpdated, nil
	}
	var t ClientFacingBodyChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyChangedEventType) Ptr() *ClientFacingBodyChangedEventType {
	return &c
}

type ClientFacingBodyFatTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyFatTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyFatTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyFatTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyFatTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyFatTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyFatTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyFatTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingBodyHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.body.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.body.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.body.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureChanged struct {
	EventType    ClientFacingBodyTemperatureChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                      `json:"user_id" url:"user_id"`
	ClientUserId string                                      `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                      `json:"team_id" url:"team_id"`
	Data         *GroupedBodyTemperature                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyTemperatureChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureChangedEventType string

const (
	ClientFacingBodyTemperatureChangedEventTypeDailyDataBodyTemperatureCreated ClientFacingBodyTemperatureChangedEventType = "daily.data.body_temperature.created"
	ClientFacingBodyTemperatureChangedEventTypeDailyDataBodyTemperatureUpdated ClientFacingBodyTemperatureChangedEventType = "daily.data.body_temperature.updated"
)

func NewClientFacingBodyTemperatureChangedEventTypeFromString(s string) (ClientFacingBodyTemperatureChangedEventType, error) {
	switch s {
	case "daily.data.body_temperature.created":
		return ClientFacingBodyTemperatureChangedEventTypeDailyDataBodyTemperatureCreated, nil
	case "daily.data.body_temperature.updated":
		return ClientFacingBodyTemperatureChangedEventTypeDailyDataBodyTemperatureUpdated, nil
	}
	var t ClientFacingBodyTemperatureChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureChangedEventType) Ptr() *ClientFacingBodyTemperatureChangedEventType {
	return &c
}

type ClientFacingBodyTemperatureDeltaChanged struct {
	EventType    ClientFacingBodyTemperatureDeltaChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                           `json:"user_id" url:"user_id"`
	ClientUserId string                                           `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                           `json:"team_id" url:"team_id"`
	Data         *GroupedBodyTemperatureDelta                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureDeltaChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureDeltaChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyTemperatureDeltaChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureDeltaChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureDeltaChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaChangedEventType string

const (
	ClientFacingBodyTemperatureDeltaChangedEventTypeDailyDataBodyTemperatureDeltaCreated ClientFacingBodyTemperatureDeltaChangedEventType = "daily.data.body_temperature_delta.created"
	ClientFacingBodyTemperatureDeltaChangedEventTypeDailyDataBodyTemperatureDeltaUpdated ClientFacingBodyTemperatureDeltaChangedEventType = "daily.data.body_temperature_delta.updated"
)

func NewClientFacingBodyTemperatureDeltaChangedEventTypeFromString(s string) (ClientFacingBodyTemperatureDeltaChangedEventType, error) {
	switch s {
	case "daily.data.body_temperature_delta.created":
		return ClientFacingBodyTemperatureDeltaChangedEventTypeDailyDataBodyTemperatureDeltaCreated, nil
	case "daily.data.body_temperature_delta.updated":
		return ClientFacingBodyTemperatureDeltaChangedEventTypeDailyDataBodyTemperatureDeltaUpdated, nil
	}
	var t ClientFacingBodyTemperatureDeltaChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureDeltaChangedEventType) Ptr() *ClientFacingBodyTemperatureDeltaChangedEventType {
	return &c
}

type ClientFacingBodyTemperatureDeltaHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureDeltaHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureDeltaHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingBodyTemperatureDeltaHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureDeltaHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureDeltaHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.body_temperature_delta.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.body_temperature_delta.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureDeltaHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureDeltaHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.body_temperature_delta.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureDeltaHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.
	SensorLocation *ClientFacingBodyTemperatureDeltaSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`
	unit           string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureDeltaSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureDeltaSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureDeltaSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureDeltaSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureDeltaSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "C",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSampleSensorLocation string

const (
	ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationBody             ClientFacingBodyTemperatureDeltaSampleSensorLocation = "body"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEar              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureDeltaSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationToe              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum          ClientFacingBodyTemperatureDeltaSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureDeltaSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead         ClientFacingBodyTemperatureDeltaSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureDeltaSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureDeltaSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureDeltaSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureDeltaSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureDeltaSampleSensorLocation {
	return &c
}

type ClientFacingBodyTemperatureHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingBodyTemperatureHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.body_temperature.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.body_temperature.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.body_temperature.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.
	SensorLocation *ClientFacingBodyTemperatureSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`
	unit           string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "C",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureSampleSensorLocation string

const (
	ClientFacingBodyTemperatureSampleSensorLocationArmpit           ClientFacingBodyTemperatureSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureSampleSensorLocationBody             ClientFacingBodyTemperatureSampleSensorLocation = "body"
	ClientFacingBodyTemperatureSampleSensorLocationEar              ClientFacingBodyTemperatureSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureSampleSensorLocationFinger           ClientFacingBodyTemperatureSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureSampleSensorLocationMouth            ClientFacingBodyTemperatureSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureSampleSensorLocationRectum           ClientFacingBodyTemperatureSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureSampleSensorLocationToe              ClientFacingBodyTemperatureSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureSampleSensorLocationEardrum          ClientFacingBodyTemperatureSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureSampleSensorLocationForehead         ClientFacingBodyTemperatureSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureSampleSensorLocationWrist            ClientFacingBodyTemperatureSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureSampleSensorLocation {
	return &c
}

type ClientFacingBodyWeightTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilograms (kg).
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingBodyWeightTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyWeightTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyWeightTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyWeightTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyWeightTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyWeightTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyWeightTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaffeineChanged struct {
	EventType    ClientFacingCaffeineChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                               `json:"user_id" url:"user_id"`
	ClientUserId string                               `json:"client_user_id" url:"client_user_id"`
	TeamId       string                               `json:"team_id" url:"team_id"`
	Data         *GroupedCaffeine                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaffeineChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaffeineChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaffeineChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaffeineChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaffeineChangedEventType string

const (
	ClientFacingCaffeineChangedEventTypeDailyDataCaffeineCreated ClientFacingCaffeineChangedEventType = "daily.data.caffeine.created"
	ClientFacingCaffeineChangedEventTypeDailyDataCaffeineUpdated ClientFacingCaffeineChangedEventType = "daily.data.caffeine.updated"
)

func NewClientFacingCaffeineChangedEventTypeFromString(s string) (ClientFacingCaffeineChangedEventType, error) {
	switch s {
	case "daily.data.caffeine.created":
		return ClientFacingCaffeineChangedEventTypeDailyDataCaffeineCreated, nil
	case "daily.data.caffeine.updated":
		return ClientFacingCaffeineChangedEventTypeDailyDataCaffeineUpdated, nil
	}
	var t ClientFacingCaffeineChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingCaffeineChangedEventType) Ptr() *ClientFacingCaffeineChangedEventType {
	return &c
}

type ClientFacingCaffeineHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaffeineHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaffeineHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingCaffeineHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaffeineHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaffeineHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.caffeine.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.caffeine.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaffeineHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.caffeine.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaffeineHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaffeineTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Quantity of caffeine consumed during the time period.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaffeineTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaffeineTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaffeineTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaffeineTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaffeineTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaffeineTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesActiveChanged struct {
	EventType    ClientFacingCaloriesActiveChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                     `json:"user_id" url:"user_id"`
	ClientUserId string                                     `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                     `json:"team_id" url:"team_id"`
	Data         *GroupedCaloriesActive                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesActiveChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesActiveChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesActiveChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesActiveChangedEventType string

const (
	ClientFacingCaloriesActiveChangedEventTypeDailyDataCaloriesActiveCreated ClientFacingCaloriesActiveChangedEventType = "daily.data.calories_active.created"
	ClientFacingCaloriesActiveChangedEventTypeDailyDataCaloriesActiveUpdated ClientFacingCaloriesActiveChangedEventType = "daily.data.calories_active.updated"
)

func NewClientFacingCaloriesActiveChangedEventTypeFromString(s string) (ClientFacingCaloriesActiveChangedEventType, error) {
	switch s {
	case "daily.data.calories_active.created":
		return ClientFacingCaloriesActiveChangedEventTypeDailyDataCaloriesActiveCreated, nil
	case "daily.data.calories_active.updated":
		return ClientFacingCaloriesActiveChangedEventTypeDailyDataCaloriesActiveUpdated, nil
	}
	var t ClientFacingCaloriesActiveChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingCaloriesActiveChangedEventType) Ptr() *ClientFacingCaloriesActiveChangedEventType {
	return &c
}

type ClientFacingCaloriesActiveHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesActiveHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesActiveHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingCaloriesActiveHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesActiveHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.calories_active.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.calories_active.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.calories_active.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesActiveHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesActiveTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Energy consumption caused by the physical activity at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesActiveTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesActiveTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesActiveTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesActiveTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesActiveTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesBasalChanged struct {
	EventType    ClientFacingCaloriesBasalChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                    `json:"user_id" url:"user_id"`
	ClientUserId string                                    `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                    `json:"team_id" url:"team_id"`
	Data         *GroupedCaloriesBasal                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesBasalChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesBasalChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesBasalChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesBasalChangedEventType string

const (
	ClientFacingCaloriesBasalChangedEventTypeDailyDataCaloriesBasalCreated ClientFacingCaloriesBasalChangedEventType = "daily.data.calories_basal.created"
	ClientFacingCaloriesBasalChangedEventTypeDailyDataCaloriesBasalUpdated ClientFacingCaloriesBasalChangedEventType = "daily.data.calories_basal.updated"
)

func NewClientFacingCaloriesBasalChangedEventTypeFromString(s string) (ClientFacingCaloriesBasalChangedEventType, error) {
	switch s {
	case "daily.data.calories_basal.created":
		return ClientFacingCaloriesBasalChangedEventTypeDailyDataCaloriesBasalCreated, nil
	case "daily.data.calories_basal.updated":
		return ClientFacingCaloriesBasalChangedEventTypeDailyDataCaloriesBasalUpdated, nil
	}
	var t ClientFacingCaloriesBasalChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingCaloriesBasalChangedEventType) Ptr() *ClientFacingCaloriesBasalChangedEventType {
	return &c
}

type ClientFacingCaloriesBasalHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesBasalHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesBasalHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingCaloriesBasalHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesBasalHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.calories_basal.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.calories_basal.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.calories_basal.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesBasalHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesBasalTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Basal Metabolic Rate at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCaloriesBasalTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesBasalTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesBasalTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesBasalTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Unit:      "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesBasalTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCarbohydratesChanged struct {
	EventType    ClientFacingCarbohydratesChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                    `json:"user_id" url:"user_id"`
	ClientUserId string                                    `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                    `json:"team_id" url:"team_id"`
	Data         *GroupedCarbohydrates                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCarbohydratesChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCarbohydratesChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCarbohydratesChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCarbohydratesChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCarbohydratesChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCarbohydratesChangedEventType string

const (
	ClientFacingCarbohydratesChangedEventTypeDailyDataCarbohydratesCreated ClientFacingCarbohydratesChangedEventType = "daily.data.carbohydrates.created"
	ClientFacingCarbohydratesChangedEventTypeDailyDataCarbohydratesUpdated ClientFacingCarbohydratesChangedEventType = "daily.data.carbohydrates.updated"
)

func NewClientFacingCarbohydratesChangedEventTypeFromString(s string) (ClientFacingCarbohydratesChangedEventType, error) {
	switch s {
	case "daily.data.carbohydrates.created":
		return ClientFacingCarbohydratesChangedEventTypeDailyDataCarbohydratesCreated, nil
	case "daily.data.carbohydrates.updated":
		return ClientFacingCarbohydratesChangedEventTypeDailyDataCarbohydratesUpdated, nil
	}
	var t ClientFacingCarbohydratesChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingCarbohydratesChangedEventType) Ptr() *ClientFacingCarbohydratesChangedEventType {
	return &c
}

type ClientFacingCarbohydratesHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCarbohydratesHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCarbohydratesHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingCarbohydratesHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCarbohydratesHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCarbohydratesHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.carbohydrates.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.carbohydrates.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCarbohydratesHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCarbohydratesHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.carbohydrates.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCarbohydratesHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCarbohydratesSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCarbohydratesSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCarbohydratesSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCarbohydratesSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCarbohydratesSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCarbohydratesSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCarbohydratesSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCholesterolChanged struct {
	EventType    ClientFacingCholesterolChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                  `json:"user_id" url:"user_id"`
	ClientUserId string                                  `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                  `json:"team_id" url:"team_id"`
	Data         *GroupedCholesterol                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCholesterolChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCholesterolChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCholesterolChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCholesterolChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCholesterolChangedEventType string

const (
	ClientFacingCholesterolChangedEventTypeDailyDataCholesterolCreated ClientFacingCholesterolChangedEventType = "daily.data.cholesterol.created"
	ClientFacingCholesterolChangedEventTypeDailyDataCholesterolUpdated ClientFacingCholesterolChangedEventType = "daily.data.cholesterol.updated"
)

func NewClientFacingCholesterolChangedEventTypeFromString(s string) (ClientFacingCholesterolChangedEventType, error) {
	switch s {
	case "daily.data.cholesterol.created":
		return ClientFacingCholesterolChangedEventTypeDailyDataCholesterolCreated, nil
	case "daily.data.cholesterol.updated":
		return ClientFacingCholesterolChangedEventTypeDailyDataCholesterolUpdated, nil
	}
	var t ClientFacingCholesterolChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingCholesterolChangedEventType) Ptr() *ClientFacingCholesterolChangedEventType {
	return &c
}

type ClientFacingCholesterolHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCholesterolHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCholesterolHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingCholesterolHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCholesterolHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCholesterolHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.cholesterol.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.cholesterol.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCholesterolHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.cholesterol.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCholesterolHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCholesterolTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mmol/L.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCholesterolTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCholesterolTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCholesterolTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCholesterolTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCholesterolTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCholesterolTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingConnectionErrorDetails struct {
	ErrorType    ClientFacingConnectionErrorDetailsErrorType `json:"error_type" url:"error_type"`
	ErrorMessage string                                      `json:"error_message" url:"error_message"`
	ErroredAt    time.Time                                   `json:"errored_at" url:"errored_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingConnectionErrorDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingConnectionErrorDetails) UnmarshalJSON(data []byte) error {
	type embed ClientFacingConnectionErrorDetails
	var unmarshaler = struct {
		embed
		ErroredAt *core.DateTime `json:"errored_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingConnectionErrorDetails(unmarshaler.embed)
	c.ErroredAt = unmarshaler.ErroredAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingConnectionErrorDetails) MarshalJSON() ([]byte, error) {
	type embed ClientFacingConnectionErrorDetails
	var marshaler = struct {
		embed
		ErroredAt *core.DateTime `json:"errored_at"`
	}{
		embed:     embed(*c),
		ErroredAt: core.NewDateTime(c.ErroredAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingConnectionErrorDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingConnectionErrorDetailsErrorType string

const (
	ClientFacingConnectionErrorDetailsErrorTypeTokenRefreshFailed        ClientFacingConnectionErrorDetailsErrorType = "token_refresh_failed"
	ClientFacingConnectionErrorDetailsErrorTypeWebhookRegistrationFailed ClientFacingConnectionErrorDetailsErrorType = "webhook_registration_failed"
	ClientFacingConnectionErrorDetailsErrorTypeUserNotFound              ClientFacingConnectionErrorDetailsErrorType = "user_not_found"
	ClientFacingConnectionErrorDetailsErrorTypeDeregisteredPerProvider   ClientFacingConnectionErrorDetailsErrorType = "deregistered_per_provider"
	ClientFacingConnectionErrorDetailsErrorTypeRequiredScopesNotGranted  ClientFacingConnectionErrorDetailsErrorType = "required_scopes_not_granted"
	ClientFacingConnectionErrorDetailsErrorTypeProviderCredentialError   ClientFacingConnectionErrorDetailsErrorType = "provider_credential_error"
	ClientFacingConnectionErrorDetailsErrorTypeUnknown                   ClientFacingConnectionErrorDetailsErrorType = "unknown"
)

func NewClientFacingConnectionErrorDetailsErrorTypeFromString(s string) (ClientFacingConnectionErrorDetailsErrorType, error) {
	switch s {
	case "token_refresh_failed":
		return ClientFacingConnectionErrorDetailsErrorTypeTokenRefreshFailed, nil
	case "webhook_registration_failed":
		return ClientFacingConnectionErrorDetailsErrorTypeWebhookRegistrationFailed, nil
	case "user_not_found":
		return ClientFacingConnectionErrorDetailsErrorTypeUserNotFound, nil
	case "deregistered_per_provider":
		return ClientFacingConnectionErrorDetailsErrorTypeDeregisteredPerProvider, nil
	case "required_scopes_not_granted":
		return ClientFacingConnectionErrorDetailsErrorTypeRequiredScopesNotGranted, nil
	case "provider_credential_error":
		return ClientFacingConnectionErrorDetailsErrorTypeProviderCredentialError, nil
	case "unknown":
		return ClientFacingConnectionErrorDetailsErrorTypeUnknown, nil
	}
	var t ClientFacingConnectionErrorDetailsErrorType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingConnectionErrorDetailsErrorType) Ptr() *ClientFacingConnectionErrorDetailsErrorType {
	return &c
}

type ClientFacingContinuousQueryResultTableChanged struct {
	UserId       string                               `json:"user_id" url:"user_id"`
	ClientUserId string                               `json:"client_user_id" url:"client_user_id"`
	TeamId       string                               `json:"team_id" url:"team_id"`
	Data         []*ContinuousQueryResultTableChanges `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingContinuousQueryResultTableChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingContinuousQueryResultTableChanged) EventType() string {
	return c.eventType
}

func (c *ClientFacingContinuousQueryResultTableChanged) UnmarshalJSON(data []byte) error {
	type embed ClientFacingContinuousQueryResultTableChanged
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingContinuousQueryResultTableChanged(unmarshaler.embed)
	if unmarshaler.EventType != "continuous_query.result_table.changed" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "continuous_query.result_table.changed", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingContinuousQueryResultTableChanged) MarshalJSON() ([]byte, error) {
	type embed ClientFacingContinuousQueryResultTableChanged
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "continuous_query.result_table.changed",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingContinuousQueryResultTableChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCriticalResult struct {
	// The Vital Order ID
	OrderId string `json:"order_id" url:"order_id"`
	// Sample ID
	SampleId string `json:"sample_id" url:"sample_id"`
	// The current results status, can be either (final, partial).
	Status string `json:"status" url:"status"`
	// The results interpretation, can be either (normal, abnormal, critical).
	Interpretation string `json:"interpretation" url:"interpretation"`
	// Your team id.
	TeamId string `json:"team_id" url:"team_id"`
	UserId string `json:"user_id" url:"user_id"`
	// When the result was first fetched from a laboratory.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// When the result was last fetched from a laboratory.
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCriticalResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCriticalResult) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCriticalResult
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCriticalResult(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCriticalResult) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCriticalResult
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCriticalResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCriticalResultIdentified struct {
	UserId       string                      `json:"user_id" url:"user_id"`
	ClientUserId string                      `json:"client_user_id" url:"client_user_id"`
	TeamId       string                      `json:"team_id" url:"team_id"`
	Data         *ClientFacingCriticalResult `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingCriticalResultIdentified) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCriticalResultIdentified) EventType() string {
	return c.eventType
}

func (c *ClientFacingCriticalResultIdentified) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCriticalResultIdentified
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCriticalResultIdentified(unmarshaler.embed)
	if unmarshaler.EventType != "labtest.result.critical" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "labtest.result.critical", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCriticalResultIdentified) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCriticalResultIdentified
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "labtest.result.critical",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCriticalResultIdentified) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDaylightExposureChanged struct {
	EventType    ClientFacingDaylightExposureChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                       `json:"user_id" url:"user_id"`
	ClientUserId string                                       `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                       `json:"team_id" url:"team_id"`
	Data         *GroupedDaylightExposure                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDaylightExposureChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDaylightExposureChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDaylightExposureChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDaylightExposureChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDaylightExposureChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDaylightExposureChangedEventType string

const (
	ClientFacingDaylightExposureChangedEventTypeDailyDataDaylightExposureCreated ClientFacingDaylightExposureChangedEventType = "daily.data.daylight_exposure.created"
	ClientFacingDaylightExposureChangedEventTypeDailyDataDaylightExposureUpdated ClientFacingDaylightExposureChangedEventType = "daily.data.daylight_exposure.updated"
)

func NewClientFacingDaylightExposureChangedEventTypeFromString(s string) (ClientFacingDaylightExposureChangedEventType, error) {
	switch s {
	case "daily.data.daylight_exposure.created":
		return ClientFacingDaylightExposureChangedEventTypeDailyDataDaylightExposureCreated, nil
	case "daily.data.daylight_exposure.updated":
		return ClientFacingDaylightExposureChangedEventTypeDailyDataDaylightExposureUpdated, nil
	}
	var t ClientFacingDaylightExposureChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingDaylightExposureChangedEventType) Ptr() *ClientFacingDaylightExposureChangedEventType {
	return &c
}

type ClientFacingDaylightExposureHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDaylightExposureHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDaylightExposureHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingDaylightExposureHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDaylightExposureHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDaylightExposureHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.daylight_exposure.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.daylight_exposure.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDaylightExposureHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDaylightExposureHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.daylight_exposure.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingDaylightExposureHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDaylightExposureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDaylightExposureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDaylightExposureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingDaylightExposureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDaylightExposureSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDaylightExposureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDaylightExposureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDaylightExposureSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "min",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingDaylightExposureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDiagnosisInformation struct {
	// Diagnosis code for insurance information.
	DiagnosisCode string `json:"diagnosis_code" url:"diagnosis_code"`
	// Diagnosis description insurance information.
	Description string `json:"description" url:"description"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDiagnosisInformation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDiagnosisInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDiagnosisInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDiagnosisInformation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDiagnosisInformation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDistanceChanged struct {
	EventType    ClientFacingDistanceChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                               `json:"user_id" url:"user_id"`
	ClientUserId string                               `json:"client_user_id" url:"client_user_id"`
	TeamId       string                               `json:"team_id" url:"team_id"`
	Data         *GroupedDistance                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDistanceChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDistanceChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDistanceChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDistanceChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDistanceChangedEventType string

const (
	ClientFacingDistanceChangedEventTypeDailyDataDistanceCreated ClientFacingDistanceChangedEventType = "daily.data.distance.created"
	ClientFacingDistanceChangedEventTypeDailyDataDistanceUpdated ClientFacingDistanceChangedEventType = "daily.data.distance.updated"
)

func NewClientFacingDistanceChangedEventTypeFromString(s string) (ClientFacingDistanceChangedEventType, error) {
	switch s {
	case "daily.data.distance.created":
		return ClientFacingDistanceChangedEventTypeDailyDataDistanceCreated, nil
	case "daily.data.distance.updated":
		return ClientFacingDistanceChangedEventTypeDailyDataDistanceUpdated, nil
	}
	var t ClientFacingDistanceChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingDistanceChangedEventType) Ptr() *ClientFacingDistanceChangedEventType {
	return &c
}

type ClientFacingDistanceHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDistanceHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDistanceHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingDistanceHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDistanceHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDistanceHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.distance.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.distance.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.distance.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingDistanceHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDistanceTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in meters (m)
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Distance traveled during activities at the time or interval::steps
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingDistanceTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDistanceTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingDistanceTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDistanceTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDistanceTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "m" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "m", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "m",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingDistanceTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogram struct {
	Id                  string                                          `json:"id" url:"id"`
	SessionStart        time.Time                                       `json:"session_start" url:"session_start"`
	SessionEnd          time.Time                                       `json:"session_end" url:"session_end"`
	VoltageSampleCount  int                                             `json:"voltage_sample_count" url:"voltage_sample_count"`
	HeartRateMean       *int                                            `json:"heart_rate_mean,omitempty" url:"heart_rate_mean,omitempty"`
	SamplingFrequencyHz *float64                                        `json:"sampling_frequency_hz,omitempty" url:"sampling_frequency_hz,omitempty"`
	Classification      *ClientFacingElectrocardiogramClassification    `json:"classification,omitempty" url:"classification,omitempty"`
	InconclusiveCause   *ClientFacingElectrocardiogramInconclusiveCause `json:"inconclusive_cause,omitempty" url:"inconclusive_cause,omitempty"`
	AlgorithmVersion    *string                                         `json:"algorithm_version,omitempty" url:"algorithm_version,omitempty"`
	TimeZone            *string                                         `json:"time_zone,omitempty" url:"time_zone,omitempty"`
	SourceProvider      *ClientFacingElectrocardiogramSourceProvider    `json:"source_provider,omitempty" url:"source_provider,omitempty"`
	SourceType          ClientFacingElectrocardiogramSourceType         `json:"source_type" url:"source_type"`
	SourceAppId         *string                                         `json:"source_app_id,omitempty" url:"source_app_id,omitempty"`
	SourceDeviceModel   *string                                         `json:"source_device_model,omitempty" url:"source_device_model,omitempty"`
	UserId              string                                          `json:"user_id" url:"user_id"`
	Source              *ClientFacingSource                             `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogram) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogram) UnmarshalJSON(data []byte) error {
	type embed ClientFacingElectrocardiogram
	var unmarshaler = struct {
		embed
		SessionStart *core.DateTime `json:"session_start"`
		SessionEnd   *core.DateTime `json:"session_end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogram(unmarshaler.embed)
	c.SessionStart = unmarshaler.SessionStart.Time()
	c.SessionEnd = unmarshaler.SessionEnd.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogram) MarshalJSON() ([]byte, error) {
	type embed ClientFacingElectrocardiogram
	var marshaler = struct {
		embed
		SessionStart *core.DateTime `json:"session_start"`
		SessionEnd   *core.DateTime `json:"session_end"`
	}{
		embed:        embed(*c),
		SessionStart: core.NewDateTime(c.SessionStart),
		SessionEnd:   core.NewDateTime(c.SessionEnd),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingElectrocardiogram) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramChanged struct {
	EventType    ClientFacingElectrocardiogramChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                        `json:"user_id" url:"user_id"`
	ClientUserId string                                        `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                        `json:"team_id" url:"team_id"`
	Data         *ClientFacingElectrocardiogram                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogramChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingElectrocardiogramChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramChangedEventType string

const (
	ClientFacingElectrocardiogramChangedEventTypeDailyDataElectrocardiogramCreated ClientFacingElectrocardiogramChangedEventType = "daily.data.electrocardiogram.created"
	ClientFacingElectrocardiogramChangedEventTypeDailyDataElectrocardiogramUpdated ClientFacingElectrocardiogramChangedEventType = "daily.data.electrocardiogram.updated"
)

func NewClientFacingElectrocardiogramChangedEventTypeFromString(s string) (ClientFacingElectrocardiogramChangedEventType, error) {
	switch s {
	case "daily.data.electrocardiogram.created":
		return ClientFacingElectrocardiogramChangedEventTypeDailyDataElectrocardiogramCreated, nil
	case "daily.data.electrocardiogram.updated":
		return ClientFacingElectrocardiogramChangedEventTypeDailyDataElectrocardiogramUpdated, nil
	}
	var t ClientFacingElectrocardiogramChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingElectrocardiogramChangedEventType) Ptr() *ClientFacingElectrocardiogramChangedEventType {
	return &c
}

type ClientFacingElectrocardiogramClassification string

const (
	ClientFacingElectrocardiogramClassificationSinusRhythm        ClientFacingElectrocardiogramClassification = "sinus_rhythm"
	ClientFacingElectrocardiogramClassificationAtrialFibrillation ClientFacingElectrocardiogramClassification = "atrial_fibrillation"
	ClientFacingElectrocardiogramClassificationInconclusive       ClientFacingElectrocardiogramClassification = "inconclusive"
)

func NewClientFacingElectrocardiogramClassificationFromString(s string) (ClientFacingElectrocardiogramClassification, error) {
	switch s {
	case "sinus_rhythm":
		return ClientFacingElectrocardiogramClassificationSinusRhythm, nil
	case "atrial_fibrillation":
		return ClientFacingElectrocardiogramClassificationAtrialFibrillation, nil
	case "inconclusive":
		return ClientFacingElectrocardiogramClassificationInconclusive, nil
	}
	var t ClientFacingElectrocardiogramClassification
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingElectrocardiogramClassification) Ptr() *ClientFacingElectrocardiogramClassification {
	return &c
}

type ClientFacingElectrocardiogramHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogramHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingElectrocardiogramHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingElectrocardiogramHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.electrocardiogram.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.electrocardiogram.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingElectrocardiogramHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.electrocardiogram.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingElectrocardiogramHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramInconclusiveCause string

const (
	ClientFacingElectrocardiogramInconclusiveCauseHighHeartRate ClientFacingElectrocardiogramInconclusiveCause = "high_heart_rate"
	ClientFacingElectrocardiogramInconclusiveCauseLowHeartRate  ClientFacingElectrocardiogramInconclusiveCause = "low_heart_rate"
	ClientFacingElectrocardiogramInconclusiveCausePoorReading   ClientFacingElectrocardiogramInconclusiveCause = "poor_reading"
)

func NewClientFacingElectrocardiogramInconclusiveCauseFromString(s string) (ClientFacingElectrocardiogramInconclusiveCause, error) {
	switch s {
	case "high_heart_rate":
		return ClientFacingElectrocardiogramInconclusiveCauseHighHeartRate, nil
	case "low_heart_rate":
		return ClientFacingElectrocardiogramInconclusiveCauseLowHeartRate, nil
	case "poor_reading":
		return ClientFacingElectrocardiogramInconclusiveCausePoorReading, nil
	}
	var t ClientFacingElectrocardiogramInconclusiveCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingElectrocardiogramInconclusiveCause) Ptr() *ClientFacingElectrocardiogramInconclusiveCause {
	return &c
}

type ClientFacingElectrocardiogramResponse struct {
	Electrocardiogram []*ClientFacingElectrocardiogram `json:"electrocardiogram,omitempty" url:"electrocardiogram,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogramResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingElectrocardiogramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramSourceProvider struct {
	Providers Providers
	Labs      Labs
}

func NewClientFacingElectrocardiogramSourceProviderFromProviders(value Providers) *ClientFacingElectrocardiogramSourceProvider {
	return &ClientFacingElectrocardiogramSourceProvider{Providers: value}
}

func NewClientFacingElectrocardiogramSourceProviderFromLabs(value Labs) *ClientFacingElectrocardiogramSourceProvider {
	return &ClientFacingElectrocardiogramSourceProvider{Labs: value}
}

func (c *ClientFacingElectrocardiogramSourceProvider) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		c.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		c.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingElectrocardiogramSourceProvider) MarshalJSON() ([]byte, error) {
	if c.Providers != "" {
		return json.Marshal(c.Providers)
	}
	if c.Labs != "" {
		return json.Marshal(c.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingElectrocardiogramSourceProviderVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (c *ClientFacingElectrocardiogramSourceProvider) Accept(visitor ClientFacingElectrocardiogramSourceProviderVisitor) error {
	if c.Providers != "" {
		return visitor.VisitProviders(c.Providers)
	}
	if c.Labs != "" {
		return visitor.VisitLabs(c.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingElectrocardiogramSourceType string

const (
	ClientFacingElectrocardiogramSourceTypeUnknown         ClientFacingElectrocardiogramSourceType = "unknown"
	ClientFacingElectrocardiogramSourceTypePhone           ClientFacingElectrocardiogramSourceType = "phone"
	ClientFacingElectrocardiogramSourceTypeWatch           ClientFacingElectrocardiogramSourceType = "watch"
	ClientFacingElectrocardiogramSourceTypeApp             ClientFacingElectrocardiogramSourceType = "app"
	ClientFacingElectrocardiogramSourceTypeMultipleSources ClientFacingElectrocardiogramSourceType = "multiple_sources"
	ClientFacingElectrocardiogramSourceTypeFingerprick     ClientFacingElectrocardiogramSourceType = "fingerprick"
	ClientFacingElectrocardiogramSourceTypeCuff            ClientFacingElectrocardiogramSourceType = "cuff"
	ClientFacingElectrocardiogramSourceTypeManualScan      ClientFacingElectrocardiogramSourceType = "manual_scan"
	ClientFacingElectrocardiogramSourceTypeAutomatic       ClientFacingElectrocardiogramSourceType = "automatic"
	ClientFacingElectrocardiogramSourceTypeScale           ClientFacingElectrocardiogramSourceType = "scale"
	ClientFacingElectrocardiogramSourceTypeChestStrap      ClientFacingElectrocardiogramSourceType = "chest_strap"
	ClientFacingElectrocardiogramSourceTypeRing            ClientFacingElectrocardiogramSourceType = "ring"
	ClientFacingElectrocardiogramSourceTypeLab             ClientFacingElectrocardiogramSourceType = "lab"
)

func NewClientFacingElectrocardiogramSourceTypeFromString(s string) (ClientFacingElectrocardiogramSourceType, error) {
	switch s {
	case "unknown":
		return ClientFacingElectrocardiogramSourceTypeUnknown, nil
	case "phone":
		return ClientFacingElectrocardiogramSourceTypePhone, nil
	case "watch":
		return ClientFacingElectrocardiogramSourceTypeWatch, nil
	case "app":
		return ClientFacingElectrocardiogramSourceTypeApp, nil
	case "multiple_sources":
		return ClientFacingElectrocardiogramSourceTypeMultipleSources, nil
	case "fingerprick":
		return ClientFacingElectrocardiogramSourceTypeFingerprick, nil
	case "cuff":
		return ClientFacingElectrocardiogramSourceTypeCuff, nil
	case "manual_scan":
		return ClientFacingElectrocardiogramSourceTypeManualScan, nil
	case "automatic":
		return ClientFacingElectrocardiogramSourceTypeAutomatic, nil
	case "scale":
		return ClientFacingElectrocardiogramSourceTypeScale, nil
	case "chest_strap":
		return ClientFacingElectrocardiogramSourceTypeChestStrap, nil
	case "ring":
		return ClientFacingElectrocardiogramSourceTypeRing, nil
	case "lab":
		return ClientFacingElectrocardiogramSourceTypeLab, nil
	}
	var t ClientFacingElectrocardiogramSourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingElectrocardiogramSourceType) Ptr() *ClientFacingElectrocardiogramSourceType {
	return &c
}

type ClientFacingElectrocardiogramVoltageChanged struct {
	EventType    ClientFacingElectrocardiogramVoltageChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                               `json:"user_id" url:"user_id"`
	ClientUserId string                                               `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                               `json:"team_id" url:"team_id"`
	Data         *GroupedElectrocardiogramVoltage                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramVoltageChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingElectrocardiogramVoltageChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramVoltageChangedEventType string

const (
	ClientFacingElectrocardiogramVoltageChangedEventTypeDailyDataElectrocardiogramVoltageCreated ClientFacingElectrocardiogramVoltageChangedEventType = "daily.data.electrocardiogram_voltage.created"
	ClientFacingElectrocardiogramVoltageChangedEventTypeDailyDataElectrocardiogramVoltageUpdated ClientFacingElectrocardiogramVoltageChangedEventType = "daily.data.electrocardiogram_voltage.updated"
)

func NewClientFacingElectrocardiogramVoltageChangedEventTypeFromString(s string) (ClientFacingElectrocardiogramVoltageChangedEventType, error) {
	switch s {
	case "daily.data.electrocardiogram_voltage.created":
		return ClientFacingElectrocardiogramVoltageChangedEventTypeDailyDataElectrocardiogramVoltageCreated, nil
	case "daily.data.electrocardiogram_voltage.updated":
		return ClientFacingElectrocardiogramVoltageChangedEventTypeDailyDataElectrocardiogramVoltageUpdated, nil
	}
	var t ClientFacingElectrocardiogramVoltageChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingElectrocardiogramVoltageChangedEventType) Ptr() *ClientFacingElectrocardiogramVoltageChangedEventType {
	return &c
}

type ClientFacingElectrocardiogramVoltageHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramVoltageHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingElectrocardiogramVoltageHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingElectrocardiogramVoltageHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.electrocardiogram_voltage.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.electrocardiogram_voltage.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingElectrocardiogramVoltageHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.electrocardiogram_voltage.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingElectrocardiogramVoltageHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramVoltageTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The lead of the measurement.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mV.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingElectrocardiogramVoltageTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingElectrocardiogramVoltageTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFallChanged struct {
	EventType    ClientFacingFallChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                           `json:"user_id" url:"user_id"`
	ClientUserId string                           `json:"client_user_id" url:"client_user_id"`
	TeamId       string                           `json:"team_id" url:"team_id"`
	Data         *GroupedFall                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFallChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFallChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFallChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFallChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFallChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFallChangedEventType string

const (
	ClientFacingFallChangedEventTypeDailyDataFallCreated ClientFacingFallChangedEventType = "daily.data.fall.created"
	ClientFacingFallChangedEventTypeDailyDataFallUpdated ClientFacingFallChangedEventType = "daily.data.fall.updated"
)

func NewClientFacingFallChangedEventTypeFromString(s string) (ClientFacingFallChangedEventType, error) {
	switch s {
	case "daily.data.fall.created":
		return ClientFacingFallChangedEventTypeDailyDataFallCreated, nil
	case "daily.data.fall.updated":
		return ClientFacingFallChangedEventTypeDailyDataFallUpdated, nil
	}
	var t ClientFacingFallChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingFallChangedEventType) Ptr() *ClientFacingFallChangedEventType {
	return &c
}

type ClientFacingFallHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFallHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFallHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingFallHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFallHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFallHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.fall.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.fall.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFallHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFallHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.fall.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFallHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFallSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFallSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFallSample) Unit() string {
	return c.unit
}

func (c *ClientFacingFallSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFallSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFallSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFallSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFallSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFallSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFatChanged struct {
	EventType    ClientFacingFatChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                          `json:"user_id" url:"user_id"`
	ClientUserId string                          `json:"client_user_id" url:"client_user_id"`
	TeamId       string                          `json:"team_id" url:"team_id"`
	Data         *GroupedBodyFat                 `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFatChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFatChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFatChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFatChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFatChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFatChangedEventType string

const (
	ClientFacingFatChangedEventTypeDailyDataFatCreated ClientFacingFatChangedEventType = "daily.data.fat.created"
	ClientFacingFatChangedEventTypeDailyDataFatUpdated ClientFacingFatChangedEventType = "daily.data.fat.updated"
)

func NewClientFacingFatChangedEventTypeFromString(s string) (ClientFacingFatChangedEventType, error) {
	switch s {
	case "daily.data.fat.created":
		return ClientFacingFatChangedEventTypeDailyDataFatCreated, nil
	case "daily.data.fat.updated":
		return ClientFacingFatChangedEventTypeDailyDataFatUpdated, nil
	}
	var t ClientFacingFatChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingFatChangedEventType) Ptr() *ClientFacingFatChangedEventType {
	return &c
}

type ClientFacingFatHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFatHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFatHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingFatHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFatHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFatHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.fat.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.fat.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFatHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFatHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.fat.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFatHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFloorsClimbedChanged struct {
	EventType    ClientFacingFloorsClimbedChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                    `json:"user_id" url:"user_id"`
	ClientUserId string                                    `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                    `json:"team_id" url:"team_id"`
	Data         *GroupedFloorsClimbed                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFloorsClimbedChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFloorsClimbedChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFloorsClimbedChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFloorsClimbedChangedEventType string

const (
	ClientFacingFloorsClimbedChangedEventTypeDailyDataFloorsClimbedCreated ClientFacingFloorsClimbedChangedEventType = "daily.data.floors_climbed.created"
	ClientFacingFloorsClimbedChangedEventTypeDailyDataFloorsClimbedUpdated ClientFacingFloorsClimbedChangedEventType = "daily.data.floors_climbed.updated"
)

func NewClientFacingFloorsClimbedChangedEventTypeFromString(s string) (ClientFacingFloorsClimbedChangedEventType, error) {
	switch s {
	case "daily.data.floors_climbed.created":
		return ClientFacingFloorsClimbedChangedEventTypeDailyDataFloorsClimbedCreated, nil
	case "daily.data.floors_climbed.updated":
		return ClientFacingFloorsClimbedChangedEventTypeDailyDataFloorsClimbedUpdated, nil
	}
	var t ClientFacingFloorsClimbedChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingFloorsClimbedChangedEventType) Ptr() *ClientFacingFloorsClimbedChangedEventType {
	return &c
}

type ClientFacingFloorsClimbedHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFloorsClimbedHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFloorsClimbedHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingFloorsClimbedHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFloorsClimbedHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.floors_climbed.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.floors_climbed.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.floors_climbed.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFloorsClimbedHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFloorsClimbedTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Number of floors climbed at the time or interval::count
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFloorsClimbedTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFloorsClimbedTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingFloorsClimbedTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFloorsClimbedTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFloorsClimbedTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFood struct {
	Energy *Energy `json:"energy,omitempty" url:"energy,omitempty"`
	Macros *Macros `json:"macros,omitempty" url:"macros,omitempty"`
	Micros *Micros `json:"micros,omitempty" url:"micros,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingFood) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFood) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFood
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFood(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFood) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingForcedExpiratoryVolume1Changed struct {
	EventType    ClientFacingForcedExpiratoryVolume1ChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                              `json:"user_id" url:"user_id"`
	ClientUserId string                                              `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                              `json:"team_id" url:"team_id"`
	Data         *GroupedForcedExpiratoryVolume1                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingForcedExpiratoryVolume1Changed) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedExpiratoryVolume1Changed) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingForcedExpiratoryVolume1Changed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingForcedExpiratoryVolume1Changed(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedExpiratoryVolume1Changed) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingForcedExpiratoryVolume1ChangedEventType string

const (
	ClientFacingForcedExpiratoryVolume1ChangedEventTypeDailyDataForcedExpiratoryVolume1Created ClientFacingForcedExpiratoryVolume1ChangedEventType = "daily.data.forced_expiratory_volume_1.created"
	ClientFacingForcedExpiratoryVolume1ChangedEventTypeDailyDataForcedExpiratoryVolume1Updated ClientFacingForcedExpiratoryVolume1ChangedEventType = "daily.data.forced_expiratory_volume_1.updated"
)

func NewClientFacingForcedExpiratoryVolume1ChangedEventTypeFromString(s string) (ClientFacingForcedExpiratoryVolume1ChangedEventType, error) {
	switch s {
	case "daily.data.forced_expiratory_volume_1.created":
		return ClientFacingForcedExpiratoryVolume1ChangedEventTypeDailyDataForcedExpiratoryVolume1Created, nil
	case "daily.data.forced_expiratory_volume_1.updated":
		return ClientFacingForcedExpiratoryVolume1ChangedEventTypeDailyDataForcedExpiratoryVolume1Updated, nil
	}
	var t ClientFacingForcedExpiratoryVolume1ChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingForcedExpiratoryVolume1ChangedEventType) Ptr() *ClientFacingForcedExpiratoryVolume1ChangedEventType {
	return &c
}

type ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.forced_expiratory_volume_1.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.forced_expiratory_volume_1.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.forced_expiratory_volume_1.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingForcedExpiratoryVolume1HistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingForcedExpiratoryVolume1Sample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) Unit() string {
	return c.unit
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedExpiratoryVolume1Sample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedExpiratoryVolume1Sample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedExpiratoryVolume1Sample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "L",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingForcedVitalCapacityChanged struct {
	EventType    ClientFacingForcedVitalCapacityChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                          `json:"user_id" url:"user_id"`
	ClientUserId string                                          `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                          `json:"team_id" url:"team_id"`
	Data         *GroupedForcedVitalCapacity                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingForcedVitalCapacityChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedVitalCapacityChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingForcedVitalCapacityChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingForcedVitalCapacityChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedVitalCapacityChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingForcedVitalCapacityChangedEventType string

const (
	ClientFacingForcedVitalCapacityChangedEventTypeDailyDataForcedVitalCapacityCreated ClientFacingForcedVitalCapacityChangedEventType = "daily.data.forced_vital_capacity.created"
	ClientFacingForcedVitalCapacityChangedEventTypeDailyDataForcedVitalCapacityUpdated ClientFacingForcedVitalCapacityChangedEventType = "daily.data.forced_vital_capacity.updated"
)

func NewClientFacingForcedVitalCapacityChangedEventTypeFromString(s string) (ClientFacingForcedVitalCapacityChangedEventType, error) {
	switch s {
	case "daily.data.forced_vital_capacity.created":
		return ClientFacingForcedVitalCapacityChangedEventTypeDailyDataForcedVitalCapacityCreated, nil
	case "daily.data.forced_vital_capacity.updated":
		return ClientFacingForcedVitalCapacityChangedEventTypeDailyDataForcedVitalCapacityUpdated, nil
	}
	var t ClientFacingForcedVitalCapacityChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingForcedVitalCapacityChangedEventType) Ptr() *ClientFacingForcedVitalCapacityChangedEventType {
	return &c
}

type ClientFacingForcedVitalCapacityHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingForcedVitalCapacityHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedVitalCapacityHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingForcedVitalCapacityHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedVitalCapacityHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedVitalCapacityHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.forced_vital_capacity.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.forced_vital_capacity.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedVitalCapacityHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedVitalCapacityHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.forced_vital_capacity.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingForcedVitalCapacityHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingForcedVitalCapacitySample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingForcedVitalCapacitySample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedVitalCapacitySample) Unit() string {
	return c.unit
}

func (c *ClientFacingForcedVitalCapacitySample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedVitalCapacitySample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedVitalCapacitySample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedVitalCapacitySample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedVitalCapacitySample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "L",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingForcedVitalCapacitySample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGlucoseChanged struct {
	EventType    ClientFacingGlucoseChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                              `json:"user_id" url:"user_id"`
	ClientUserId string                              `json:"client_user_id" url:"client_user_id"`
	TeamId       string                              `json:"team_id" url:"team_id"`
	Data         *GroupedGlucose                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGlucoseChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGlucoseChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGlucoseChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGlucoseChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGlucoseChangedEventType string

const (
	ClientFacingGlucoseChangedEventTypeDailyDataGlucoseCreated ClientFacingGlucoseChangedEventType = "daily.data.glucose.created"
	ClientFacingGlucoseChangedEventTypeDailyDataGlucoseUpdated ClientFacingGlucoseChangedEventType = "daily.data.glucose.updated"
)

func NewClientFacingGlucoseChangedEventTypeFromString(s string) (ClientFacingGlucoseChangedEventType, error) {
	switch s {
	case "daily.data.glucose.created":
		return ClientFacingGlucoseChangedEventTypeDailyDataGlucoseCreated, nil
	case "daily.data.glucose.updated":
		return ClientFacingGlucoseChangedEventTypeDailyDataGlucoseUpdated, nil
	}
	var t ClientFacingGlucoseChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingGlucoseChangedEventType) Ptr() *ClientFacingGlucoseChangedEventType {
	return &c
}

type ClientFacingGlucoseHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGlucoseHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGlucoseHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingGlucoseHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingGlucoseHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingGlucoseHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.glucose.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.glucose.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingGlucoseHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.glucose.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingGlucoseHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGlucoseTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mmol/L.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingGlucoseTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGlucoseTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingGlucoseTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingGlucoseTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingGlucoseTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingGlucoseTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHandwashingChanged struct {
	EventType    ClientFacingHandwashingChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                  `json:"user_id" url:"user_id"`
	ClientUserId string                                  `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                  `json:"team_id" url:"team_id"`
	Data         *GroupedHandwashing                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHandwashingChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHandwashingChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHandwashingChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHandwashingChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHandwashingChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHandwashingChangedEventType string

const (
	ClientFacingHandwashingChangedEventTypeDailyDataHandwashingCreated ClientFacingHandwashingChangedEventType = "daily.data.handwashing.created"
	ClientFacingHandwashingChangedEventTypeDailyDataHandwashingUpdated ClientFacingHandwashingChangedEventType = "daily.data.handwashing.updated"
)

func NewClientFacingHandwashingChangedEventTypeFromString(s string) (ClientFacingHandwashingChangedEventType, error) {
	switch s {
	case "daily.data.handwashing.created":
		return ClientFacingHandwashingChangedEventTypeDailyDataHandwashingCreated, nil
	case "daily.data.handwashing.updated":
		return ClientFacingHandwashingChangedEventTypeDailyDataHandwashingUpdated, nil
	}
	var t ClientFacingHandwashingChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHandwashingChangedEventType) Ptr() *ClientFacingHandwashingChangedEventType {
	return &c
}

type ClientFacingHandwashingHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHandwashingHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHandwashingHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingHandwashingHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHandwashingHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHandwashingHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.handwashing.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.handwashing.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHandwashingHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHandwashingHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.handwashing.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHandwashingHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHandwashingSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHandwashingSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHandwashingSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHandwashingSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHandwashingSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHandwashingSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHandwashingSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHandwashingSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHandwashingSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRate struct {
	// Average heart rate::bpm
	AvgBpm *float64 `json:"avg_bpm,omitempty" url:"avg_bpm,omitempty"`
	// Minimum heart rate::bpm
	MinBpm *float64 `json:"min_bpm,omitempty" url:"min_bpm,omitempty"`
	// Maximum heart rate::bpm
	MaxBpm *float64 `json:"max_bpm,omitempty" url:"max_bpm,omitempty"`
	// Resting heart rate::bpm
	RestingBpm    *float64 `json:"resting_bpm,omitempty" url:"resting_bpm,omitempty"`
	AvgWalkingBpm *float64 `json:"avg_walking_bpm,omitempty" url:"avg_walking_bpm,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateAlertChanged struct {
	EventType    ClientFacingHeartRateAlertChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                     `json:"user_id" url:"user_id"`
	ClientUserId string                                     `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                     `json:"team_id" url:"team_id"`
	Data         *GroupedHeartRateAlert                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRateAlertChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateAlertChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRateAlertChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRateAlertChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateAlertChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateAlertChangedEventType string

const (
	ClientFacingHeartRateAlertChangedEventTypeDailyDataHeartRateAlertCreated ClientFacingHeartRateAlertChangedEventType = "daily.data.heart_rate_alert.created"
	ClientFacingHeartRateAlertChangedEventTypeDailyDataHeartRateAlertUpdated ClientFacingHeartRateAlertChangedEventType = "daily.data.heart_rate_alert.updated"
)

func NewClientFacingHeartRateAlertChangedEventTypeFromString(s string) (ClientFacingHeartRateAlertChangedEventType, error) {
	switch s {
	case "daily.data.heart_rate_alert.created":
		return ClientFacingHeartRateAlertChangedEventTypeDailyDataHeartRateAlertCreated, nil
	case "daily.data.heart_rate_alert.updated":
		return ClientFacingHeartRateAlertChangedEventTypeDailyDataHeartRateAlertUpdated, nil
	}
	var t ClientFacingHeartRateAlertChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHeartRateAlertChangedEventType) Ptr() *ClientFacingHeartRateAlertChangedEventType {
	return &c
}

type ClientFacingHeartRateAlertHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRateAlertHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateAlertHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingHeartRateAlertHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateAlertHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateAlertHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.heart_rate_alert.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.heart_rate_alert.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateAlertHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateAlertHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.heart_rate_alert.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHeartRateAlertHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateAlertSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int                                 `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	Type           ClientFacingHeartRateAlertSampleType `json:"type" url:"type"`
	Grouping       *ClientFacingSampleGroupingKeys      `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End   time.Time `json:"end" url:"end"`
	Value int       `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRateAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateAlertSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHeartRateAlertSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateAlertSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateAlertSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateAlertSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateAlertSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHeartRateAlertSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateAlertSampleType string

const (
	ClientFacingHeartRateAlertSampleTypeLowHeartRate    ClientFacingHeartRateAlertSampleType = "low_heart_rate"
	ClientFacingHeartRateAlertSampleTypeHighHeartRate   ClientFacingHeartRateAlertSampleType = "high_heart_rate"
	ClientFacingHeartRateAlertSampleTypeIrregularRhythm ClientFacingHeartRateAlertSampleType = "irregular_rhythm"
)

func NewClientFacingHeartRateAlertSampleTypeFromString(s string) (ClientFacingHeartRateAlertSampleType, error) {
	switch s {
	case "low_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeLowHeartRate, nil
	case "high_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeHighHeartRate, nil
	case "irregular_rhythm":
		return ClientFacingHeartRateAlertSampleTypeIrregularRhythm, nil
	}
	var t ClientFacingHeartRateAlertSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHeartRateAlertSampleType) Ptr() *ClientFacingHeartRateAlertSampleType {
	return &c
}

type ClientFacingHeartRateTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in bpm.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Heart rate in bpm
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartRateTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHeartRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartrateChanged struct {
	EventType    ClientFacingHeartrateChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                `json:"user_id" url:"user_id"`
	ClientUserId string                                `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                `json:"team_id" url:"team_id"`
	Data         *GroupedHeartRate                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartrateChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartrateChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartrateChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartrateChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartrateChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartrateChangedEventType string

const (
	ClientFacingHeartrateChangedEventTypeDailyDataHeartrateCreated ClientFacingHeartrateChangedEventType = "daily.data.heartrate.created"
	ClientFacingHeartrateChangedEventTypeDailyDataHeartrateUpdated ClientFacingHeartrateChangedEventType = "daily.data.heartrate.updated"
)

func NewClientFacingHeartrateChangedEventTypeFromString(s string) (ClientFacingHeartrateChangedEventType, error) {
	switch s {
	case "daily.data.heartrate.created":
		return ClientFacingHeartrateChangedEventTypeDailyDataHeartrateCreated, nil
	case "daily.data.heartrate.updated":
		return ClientFacingHeartrateChangedEventTypeDailyDataHeartrateUpdated, nil
	}
	var t ClientFacingHeartrateChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHeartrateChangedEventType) Ptr() *ClientFacingHeartrateChangedEventType {
	return &c
}

type ClientFacingHeartrateHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHeartrateHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartrateHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingHeartrateHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartrateHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartrateHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.heartrate.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.heartrate.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartrateHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartrateHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.heartrate.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHeartrateHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHrvChanged struct {
	EventType    ClientFacingHrvChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                          `json:"user_id" url:"user_id"`
	ClientUserId string                          `json:"client_user_id" url:"client_user_id"`
	TeamId       string                          `json:"team_id" url:"team_id"`
	Data         *GroupedHrv                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHrvChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHrvChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHrvChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHrvChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHrvChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHrvChangedEventType string

const (
	ClientFacingHrvChangedEventTypeDailyDataHrvCreated ClientFacingHrvChangedEventType = "daily.data.hrv.created"
	ClientFacingHrvChangedEventTypeDailyDataHrvUpdated ClientFacingHrvChangedEventType = "daily.data.hrv.updated"
)

func NewClientFacingHrvChangedEventTypeFromString(s string) (ClientFacingHrvChangedEventType, error) {
	switch s {
	case "daily.data.hrv.created":
		return ClientFacingHrvChangedEventTypeDailyDataHrvCreated, nil
	case "daily.data.hrv.updated":
		return ClientFacingHrvChangedEventTypeDailyDataHrvUpdated, nil
	}
	var t ClientFacingHrvChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHrvChangedEventType) Ptr() *ClientFacingHrvChangedEventType {
	return &c
}

type ClientFacingHrvHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHrvHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHrvHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingHrvHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHrvHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHrvHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.hrv.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.hrv.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHrvHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHrvHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.hrv.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHrvHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHrvTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in rmssd.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// HRV calculated using rmssd during sleep
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHrvTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHrvTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHrvTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHrvTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHrvTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHrvTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHrvTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHypnogramTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// enum: 1: deep, 2: light, 3: rem, 4: awake, -1: missing_data.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Hypnogram for sleep stages {"deep": 1, "light": 2, "rem": 3, "awake": 4, "manual": 5, "missing_data": -1}
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingHypnogramTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHypnogramTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHypnogramTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHypnogramTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHypnogramTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHypnogramTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingHypnogramTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIgeChanged struct {
	EventType    ClientFacingIgeChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                          `json:"user_id" url:"user_id"`
	ClientUserId string                          `json:"client_user_id" url:"client_user_id"`
	TeamId       string                          `json:"team_id" url:"team_id"`
	Data         *GroupedIge                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIgeChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIgeChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIgeChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIgeChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIgeChangedEventType string

const (
	ClientFacingIgeChangedEventTypeDailyDataIgeCreated ClientFacingIgeChangedEventType = "daily.data.ige.created"
	ClientFacingIgeChangedEventTypeDailyDataIgeUpdated ClientFacingIgeChangedEventType = "daily.data.ige.updated"
)

func NewClientFacingIgeChangedEventTypeFromString(s string) (ClientFacingIgeChangedEventType, error) {
	switch s {
	case "daily.data.ige.created":
		return ClientFacingIgeChangedEventTypeDailyDataIgeCreated, nil
	case "daily.data.ige.updated":
		return ClientFacingIgeChangedEventTypeDailyDataIgeUpdated, nil
	}
	var t ClientFacingIgeChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingIgeChangedEventType) Ptr() *ClientFacingIgeChangedEventType {
	return &c
}

type ClientFacingIgeHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIgeHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIgeHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingIgeHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIgeHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIgeHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.ige.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.ige.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIgeHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.ige.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingIgeHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIgeTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in FSU.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIgeTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIgeTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIgeTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIgeTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIgeTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingIgeTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIggChanged struct {
	EventType    ClientFacingIggChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                          `json:"user_id" url:"user_id"`
	ClientUserId string                          `json:"client_user_id" url:"client_user_id"`
	TeamId       string                          `json:"team_id" url:"team_id"`
	Data         *GroupedIgg                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIggChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIggChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIggChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIggChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIggChangedEventType string

const (
	ClientFacingIggChangedEventTypeDailyDataIggCreated ClientFacingIggChangedEventType = "daily.data.igg.created"
	ClientFacingIggChangedEventTypeDailyDataIggUpdated ClientFacingIggChangedEventType = "daily.data.igg.updated"
)

func NewClientFacingIggChangedEventTypeFromString(s string) (ClientFacingIggChangedEventType, error) {
	switch s {
	case "daily.data.igg.created":
		return ClientFacingIggChangedEventTypeDailyDataIggCreated, nil
	case "daily.data.igg.updated":
		return ClientFacingIggChangedEventTypeDailyDataIggUpdated, nil
	}
	var t ClientFacingIggChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingIggChangedEventType) Ptr() *ClientFacingIggChangedEventType {
	return &c
}

type ClientFacingIggHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIggHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIggHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingIggHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIggHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIggHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.igg.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.igg.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIggHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.igg.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingIggHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIggTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in FSU.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingIggTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIggTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIggTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIggTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIggTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingIggTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInhalerUsageChanged struct {
	EventType    ClientFacingInhalerUsageChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                   `json:"user_id" url:"user_id"`
	ClientUserId string                                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                   `json:"team_id" url:"team_id"`
	Data         *GroupedInhalerUsage                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInhalerUsageChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInhalerUsageChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingInhalerUsageChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingInhalerUsageChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInhalerUsageChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInhalerUsageChangedEventType string

const (
	ClientFacingInhalerUsageChangedEventTypeDailyDataInhalerUsageCreated ClientFacingInhalerUsageChangedEventType = "daily.data.inhaler_usage.created"
	ClientFacingInhalerUsageChangedEventTypeDailyDataInhalerUsageUpdated ClientFacingInhalerUsageChangedEventType = "daily.data.inhaler_usage.updated"
)

func NewClientFacingInhalerUsageChangedEventTypeFromString(s string) (ClientFacingInhalerUsageChangedEventType, error) {
	switch s {
	case "daily.data.inhaler_usage.created":
		return ClientFacingInhalerUsageChangedEventTypeDailyDataInhalerUsageCreated, nil
	case "daily.data.inhaler_usage.updated":
		return ClientFacingInhalerUsageChangedEventTypeDailyDataInhalerUsageUpdated, nil
	}
	var t ClientFacingInhalerUsageChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingInhalerUsageChangedEventType) Ptr() *ClientFacingInhalerUsageChangedEventType {
	return &c
}

type ClientFacingInhalerUsageHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInhalerUsageHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInhalerUsageHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingInhalerUsageHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInhalerUsageHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInhalerUsageHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.inhaler_usage.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.inhaler_usage.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInhalerUsageHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInhalerUsageHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.inhaler_usage.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingInhalerUsageHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInhalerUsageSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInhalerUsageSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInhalerUsageSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInhalerUsageSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInhalerUsageSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInhalerUsageSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInhalerUsageSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInhalerUsageSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingInhalerUsageSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInsulinInjectionChanged struct {
	EventType    ClientFacingInsulinInjectionChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                       `json:"user_id" url:"user_id"`
	ClientUserId string                                       `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                       `json:"team_id" url:"team_id"`
	Data         *GroupedInsulinInjection                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInsulinInjectionChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsulinInjectionChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingInsulinInjectionChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingInsulinInjectionChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsulinInjectionChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInsulinInjectionChangedEventType string

const (
	ClientFacingInsulinInjectionChangedEventTypeDailyDataInsulinInjectionCreated ClientFacingInsulinInjectionChangedEventType = "daily.data.insulin_injection.created"
	ClientFacingInsulinInjectionChangedEventTypeDailyDataInsulinInjectionUpdated ClientFacingInsulinInjectionChangedEventType = "daily.data.insulin_injection.updated"
)

func NewClientFacingInsulinInjectionChangedEventTypeFromString(s string) (ClientFacingInsulinInjectionChangedEventType, error) {
	switch s {
	case "daily.data.insulin_injection.created":
		return ClientFacingInsulinInjectionChangedEventTypeDailyDataInsulinInjectionCreated, nil
	case "daily.data.insulin_injection.updated":
		return ClientFacingInsulinInjectionChangedEventTypeDailyDataInsulinInjectionUpdated, nil
	}
	var t ClientFacingInsulinInjectionChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingInsulinInjectionChangedEventType) Ptr() *ClientFacingInsulinInjectionChangedEventType {
	return &c
}

type ClientFacingInsulinInjectionHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInsulinInjectionHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsulinInjectionHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingInsulinInjectionHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInsulinInjectionHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInsulinInjectionHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.insulin_injection.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.insulin_injection.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsulinInjectionHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInsulinInjectionHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.insulin_injection.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingInsulinInjectionHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInsulinInjectionSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Insulin type: rapid vs long acting
	Type     ClientFacingInsulinInjectionSampleType `json:"type" url:"type"`
	Grouping *ClientFacingSampleGroupingKeys        `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInsulinInjectionSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsulinInjectionSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInsulinInjectionSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInsulinInjectionSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "unit" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "unit", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsulinInjectionSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInsulinInjectionSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "unit",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingInsulinInjectionSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Insulin type: rapid vs long acting
type ClientFacingInsulinInjectionSampleType string

const (
	ClientFacingInsulinInjectionSampleTypeRapidActing ClientFacingInsulinInjectionSampleType = "rapid_acting"
	ClientFacingInsulinInjectionSampleTypeLongActing  ClientFacingInsulinInjectionSampleType = "long_acting"
)

func NewClientFacingInsulinInjectionSampleTypeFromString(s string) (ClientFacingInsulinInjectionSampleType, error) {
	switch s {
	case "rapid_acting":
		return ClientFacingInsulinInjectionSampleTypeRapidActing, nil
	case "long_acting":
		return ClientFacingInsulinInjectionSampleTypeLongActing, nil
	}
	var t ClientFacingInsulinInjectionSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingInsulinInjectionSampleType) Ptr() *ClientFacingInsulinInjectionSampleType {
	return &c
}

type ClientFacingInsurance struct {
	MemberId     string                                                  `json:"member_id" url:"member_id"`
	PayorCode    string                                                  `json:"payor_code" url:"payor_code"`
	Relationship ResponsibleRelationship                                 `json:"relationship" url:"relationship"`
	Insured      *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails `json:"insured,omitempty" url:"insured,omitempty"`
	Company      *CompanyDetails                                         `json:"company,omitempty" url:"company,omitempty"`
	GroupId      *string                                                 `json:"group_id,omitempty" url:"group_id,omitempty"`
	Guarantor    *GuarantorDetails                                       `json:"guarantor,omitempty" url:"guarantor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingInsurance) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsurance) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingInsurance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingInsurance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsurance) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLab struct {
	Id                int                       `json:"id" url:"id"`
	Slug              string                    `json:"slug" url:"slug"`
	Name              string                    `json:"name" url:"name"`
	FirstLineAddress  string                    `json:"first_line_address" url:"first_line_address"`
	City              string                    `json:"city" url:"city"`
	Zipcode           string                    `json:"zipcode" url:"zipcode"`
	CollectionMethods []LabTestCollectionMethod `json:"collection_methods,omitempty" url:"collection_methods,omitempty"`
	SampleTypes       []LabTestSampleType       `json:"sample_types,omitempty" url:"sample_types,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLab) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLab) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLab(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLab) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabLocation struct {
	Metadata           *LabLocationMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	Distance           int                  `json:"distance" url:"distance"`
	SiteCode           string               `json:"site_code" url:"site_code"`
	SupportedBillTypes []Billing            `json:"supported_bill_types,omitempty" url:"supported_bill_types,omitempty"`
	Location           *LngLat              `json:"location,omitempty" url:"location,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLabLocation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLabLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLabLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLabLocation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLabLocation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabTest struct {
	Id         string                  `json:"id" url:"id"`
	Slug       string                  `json:"slug" url:"slug"`
	Name       string                  `json:"name" url:"name"`
	SampleType LabTestSampleType       `json:"sample_type" url:"sample_type"`
	Method     LabTestCollectionMethod `json:"method" url:"method"`
	Price      float64                 `json:"price" url:"price"`
	// Deprecated. Use status instead.
	IsActive bool          `json:"is_active" url:"is_active"`
	Status   LabTestStatus `json:"status" url:"status"`
	// Defines whether a lab test requires fasting.
	Fasting *bool                 `json:"fasting,omitempty" url:"fasting,omitempty"`
	Lab     *ClientFacingLab      `json:"lab,omitempty" url:"lab,omitempty"`
	Markers []*ClientFacingMarker `json:"markers,omitempty" url:"markers,omitempty"`
	// Denotes whether a lab test requires using non-Vital physician networks. If it does then it's delegated - no otherwise.
	IsDelegated *bool `json:"is_delegated,omitempty" url:"is_delegated,omitempty"`
	// Whether the lab test was auto-generated by Vital
	AutoGenerated *bool `json:"auto_generated,omitempty" url:"auto_generated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLabTest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLabTest) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLabTest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLabTest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLabTest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabs string

const (
	ClientFacingLabsQuest        ClientFacingLabs = "quest"
	ClientFacingLabsLabcorp      ClientFacingLabs = "labcorp"
	ClientFacingLabsBioreference ClientFacingLabs = "bioreference"
)

func NewClientFacingLabsFromString(s string) (ClientFacingLabs, error) {
	switch s {
	case "quest":
		return ClientFacingLabsQuest, nil
	case "labcorp":
		return ClientFacingLabsLabcorp, nil
	case "bioreference":
		return ClientFacingLabsBioreference, nil
	}
	var t ClientFacingLabs
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingLabs) Ptr() *ClientFacingLabs {
	return &c
}

type ClientFacingLoinc struct {
	Id   int     `json:"id" url:"id"`
	Name string  `json:"name" url:"name"`
	Slug string  `json:"slug" url:"slug"`
	Code string  `json:"code" url:"code"`
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingLoinc) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLoinc) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLoinc
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLoinc(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLoinc) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarker struct {
	Id              int         `json:"id" url:"id"`
	Name            string      `json:"name" url:"name"`
	Slug            string      `json:"slug" url:"slug"`
	Description     *string     `json:"description,omitempty" url:"description,omitempty"`
	LabId           *int        `json:"lab_id,omitempty" url:"lab_id,omitempty"`
	ProviderId      *string     `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	Type            *MarkerType `json:"type,omitempty" url:"type,omitempty"`
	Unit            *string     `json:"unit,omitempty" url:"unit,omitempty"`
	Price           *string     `json:"price,omitempty" url:"price,omitempty"`
	Aoe             *AoE        `json:"aoe,omitempty" url:"aoe,omitempty"`
	ALaCarteEnabled *bool       `json:"a_la_carte_enabled,omitempty" url:"a_la_carte_enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMarker) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMarker) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarker
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarker(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarker) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarkerComplete struct {
	Id              int                   `json:"id" url:"id"`
	Name            string                `json:"name" url:"name"`
	Slug            string                `json:"slug" url:"slug"`
	Description     *string               `json:"description,omitempty" url:"description,omitempty"`
	LabId           *int                  `json:"lab_id,omitempty" url:"lab_id,omitempty"`
	ProviderId      *string               `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	Type            *MarkerType           `json:"type,omitempty" url:"type,omitempty"`
	Unit            *string               `json:"unit,omitempty" url:"unit,omitempty"`
	Price           *string               `json:"price,omitempty" url:"price,omitempty"`
	Aoe             *AoE                  `json:"aoe,omitempty" url:"aoe,omitempty"`
	ALaCarteEnabled *bool                 `json:"a_la_carte_enabled,omitempty" url:"a_la_carte_enabled,omitempty"`
	ExpectedResults []*ClientFacingResult `json:"expected_results,omitempty" url:"expected_results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMarkerComplete) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMarkerComplete) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarkerComplete
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarkerComplete(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarkerComplete) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMealChanged struct {
	EventType    ClientFacingMealChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                           `json:"user_id" url:"user_id"`
	ClientUserId string                           `json:"client_user_id" url:"client_user_id"`
	TeamId       string                           `json:"team_id" url:"team_id"`
	Data         *MealInDbBaseClientFacingSource  `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMealChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMealChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMealChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMealChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMealChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMealChangedEventType string

const (
	ClientFacingMealChangedEventTypeDailyDataMealCreated ClientFacingMealChangedEventType = "daily.data.meal.created"
	ClientFacingMealChangedEventTypeDailyDataMealUpdated ClientFacingMealChangedEventType = "daily.data.meal.updated"
)

func NewClientFacingMealChangedEventTypeFromString(s string) (ClientFacingMealChangedEventType, error) {
	switch s {
	case "daily.data.meal.created":
		return ClientFacingMealChangedEventTypeDailyDataMealCreated, nil
	case "daily.data.meal.updated":
		return ClientFacingMealChangedEventTypeDailyDataMealUpdated, nil
	}
	var t ClientFacingMealChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingMealChangedEventType) Ptr() *ClientFacingMealChangedEventType {
	return &c
}

type ClientFacingMealHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMealHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMealHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingMealHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingMealHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingMealHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.meal.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.meal.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMealHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingMealHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.meal.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingMealHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMealResponse struct {
	Meals []*MealInDbBaseClientFacingSource `json:"meals,omitempty" url:"meals,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMealResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMealResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMealResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMealResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMealResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMenstrualCycle struct {
	Id                     string                                    `json:"id" url:"id"`
	PeriodStart            string                                    `json:"period_start" url:"period_start"`
	PeriodEnd              *string                                   `json:"period_end,omitempty" url:"period_end,omitempty"`
	CycleEnd               *string                                   `json:"cycle_end,omitempty" url:"cycle_end,omitempty"`
	IsPredicted            *bool                                     `json:"is_predicted,omitempty" url:"is_predicted,omitempty"`
	MenstrualFlow          []*MenstrualFlowEntry                     `json:"menstrual_flow,omitempty" url:"menstrual_flow,omitempty"`
	CervicalMucus          []*CervicalMucusEntry                     `json:"cervical_mucus,omitempty" url:"cervical_mucus,omitempty"`
	IntermenstrualBleeding []*IntermenstrualBleedingEntry            `json:"intermenstrual_bleeding,omitempty" url:"intermenstrual_bleeding,omitempty"`
	Contraceptive          []*ContraceptiveEntry                     `json:"contraceptive,omitempty" url:"contraceptive,omitempty"`
	DetectedDeviations     []*DetectedDeviationEntry                 `json:"detected_deviations,omitempty" url:"detected_deviations,omitempty"`
	OvulationTest          []*OvulationTestEntry                     `json:"ovulation_test,omitempty" url:"ovulation_test,omitempty"`
	HomePregnancyTest      []*HomePregnancyTestEntry                 `json:"home_pregnancy_test,omitempty" url:"home_pregnancy_test,omitempty"`
	HomeProgesteroneTest   []*HomeProgesteroneTestEntry              `json:"home_progesterone_test,omitempty" url:"home_progesterone_test,omitempty"`
	SexualActivity         []*SexualActivityEntry                    `json:"sexual_activity,omitempty" url:"sexual_activity,omitempty"`
	BasalBodyTemperature   []*BasalBodyTemperatureEntry              `json:"basal_body_temperature,omitempty" url:"basal_body_temperature,omitempty"`
	SourceProvider         *ClientFacingMenstrualCycleSourceProvider `json:"source_provider,omitempty" url:"source_provider,omitempty"`
	SourceType             ClientFacingMenstrualCycleSourceType      `json:"source_type" url:"source_type"`
	SourceAppId            *string                                   `json:"source_app_id,omitempty" url:"source_app_id,omitempty"`
	UserId                 string                                    `json:"user_id" url:"user_id"`
	Source                 *ClientFacingSource                       `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMenstrualCycle) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMenstrualCycle) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMenstrualCycle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMenstrualCycle(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMenstrualCycle) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMenstrualCycleChanged struct {
	EventType    ClientFacingMenstrualCycleChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                     `json:"user_id" url:"user_id"`
	ClientUserId string                                     `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                     `json:"team_id" url:"team_id"`
	Data         *ClientFacingMenstrualCycle                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMenstrualCycleChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMenstrualCycleChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMenstrualCycleChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMenstrualCycleChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMenstrualCycleChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMenstrualCycleChangedEventType string

const (
	ClientFacingMenstrualCycleChangedEventTypeDailyDataMenstrualCycleCreated ClientFacingMenstrualCycleChangedEventType = "daily.data.menstrual_cycle.created"
	ClientFacingMenstrualCycleChangedEventTypeDailyDataMenstrualCycleUpdated ClientFacingMenstrualCycleChangedEventType = "daily.data.menstrual_cycle.updated"
)

func NewClientFacingMenstrualCycleChangedEventTypeFromString(s string) (ClientFacingMenstrualCycleChangedEventType, error) {
	switch s {
	case "daily.data.menstrual_cycle.created":
		return ClientFacingMenstrualCycleChangedEventTypeDailyDataMenstrualCycleCreated, nil
	case "daily.data.menstrual_cycle.updated":
		return ClientFacingMenstrualCycleChangedEventTypeDailyDataMenstrualCycleUpdated, nil
	}
	var t ClientFacingMenstrualCycleChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingMenstrualCycleChangedEventType) Ptr() *ClientFacingMenstrualCycleChangedEventType {
	return &c
}

type ClientFacingMenstrualCycleHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMenstrualCycleHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMenstrualCycleHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingMenstrualCycleHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingMenstrualCycleHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingMenstrualCycleHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.menstrual_cycle.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.menstrual_cycle.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMenstrualCycleHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingMenstrualCycleHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.menstrual_cycle.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingMenstrualCycleHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMenstrualCycleSourceProvider struct {
	Providers Providers
	Labs      Labs
}

func NewClientFacingMenstrualCycleSourceProviderFromProviders(value Providers) *ClientFacingMenstrualCycleSourceProvider {
	return &ClientFacingMenstrualCycleSourceProvider{Providers: value}
}

func NewClientFacingMenstrualCycleSourceProviderFromLabs(value Labs) *ClientFacingMenstrualCycleSourceProvider {
	return &ClientFacingMenstrualCycleSourceProvider{Labs: value}
}

func (c *ClientFacingMenstrualCycleSourceProvider) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		c.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		c.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingMenstrualCycleSourceProvider) MarshalJSON() ([]byte, error) {
	if c.Providers != "" {
		return json.Marshal(c.Providers)
	}
	if c.Labs != "" {
		return json.Marshal(c.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingMenstrualCycleSourceProviderVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (c *ClientFacingMenstrualCycleSourceProvider) Accept(visitor ClientFacingMenstrualCycleSourceProviderVisitor) error {
	if c.Providers != "" {
		return visitor.VisitProviders(c.Providers)
	}
	if c.Labs != "" {
		return visitor.VisitLabs(c.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingMenstrualCycleSourceType string

const (
	ClientFacingMenstrualCycleSourceTypeUnknown         ClientFacingMenstrualCycleSourceType = "unknown"
	ClientFacingMenstrualCycleSourceTypePhone           ClientFacingMenstrualCycleSourceType = "phone"
	ClientFacingMenstrualCycleSourceTypeWatch           ClientFacingMenstrualCycleSourceType = "watch"
	ClientFacingMenstrualCycleSourceTypeApp             ClientFacingMenstrualCycleSourceType = "app"
	ClientFacingMenstrualCycleSourceTypeMultipleSources ClientFacingMenstrualCycleSourceType = "multiple_sources"
	ClientFacingMenstrualCycleSourceTypeFingerprick     ClientFacingMenstrualCycleSourceType = "fingerprick"
	ClientFacingMenstrualCycleSourceTypeCuff            ClientFacingMenstrualCycleSourceType = "cuff"
	ClientFacingMenstrualCycleSourceTypeManualScan      ClientFacingMenstrualCycleSourceType = "manual_scan"
	ClientFacingMenstrualCycleSourceTypeAutomatic       ClientFacingMenstrualCycleSourceType = "automatic"
	ClientFacingMenstrualCycleSourceTypeScale           ClientFacingMenstrualCycleSourceType = "scale"
	ClientFacingMenstrualCycleSourceTypeChestStrap      ClientFacingMenstrualCycleSourceType = "chest_strap"
	ClientFacingMenstrualCycleSourceTypeRing            ClientFacingMenstrualCycleSourceType = "ring"
	ClientFacingMenstrualCycleSourceTypeLab             ClientFacingMenstrualCycleSourceType = "lab"
)

func NewClientFacingMenstrualCycleSourceTypeFromString(s string) (ClientFacingMenstrualCycleSourceType, error) {
	switch s {
	case "unknown":
		return ClientFacingMenstrualCycleSourceTypeUnknown, nil
	case "phone":
		return ClientFacingMenstrualCycleSourceTypePhone, nil
	case "watch":
		return ClientFacingMenstrualCycleSourceTypeWatch, nil
	case "app":
		return ClientFacingMenstrualCycleSourceTypeApp, nil
	case "multiple_sources":
		return ClientFacingMenstrualCycleSourceTypeMultipleSources, nil
	case "fingerprick":
		return ClientFacingMenstrualCycleSourceTypeFingerprick, nil
	case "cuff":
		return ClientFacingMenstrualCycleSourceTypeCuff, nil
	case "manual_scan":
		return ClientFacingMenstrualCycleSourceTypeManualScan, nil
	case "automatic":
		return ClientFacingMenstrualCycleSourceTypeAutomatic, nil
	case "scale":
		return ClientFacingMenstrualCycleSourceTypeScale, nil
	case "chest_strap":
		return ClientFacingMenstrualCycleSourceTypeChestStrap, nil
	case "ring":
		return ClientFacingMenstrualCycleSourceTypeRing, nil
	case "lab":
		return ClientFacingMenstrualCycleSourceTypeLab, nil
	}
	var t ClientFacingMenstrualCycleSourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingMenstrualCycleSourceType) Ptr() *ClientFacingMenstrualCycleSourceType {
	return &c
}

type ClientFacingMindfulnessMinutesChanged struct {
	EventType    ClientFacingMindfulnessMinutesChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                         `json:"user_id" url:"user_id"`
	ClientUserId string                                         `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                         `json:"team_id" url:"team_id"`
	Data         *GroupedMindfulnessMinutes                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMindfulnessMinutesChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMindfulnessMinutesChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMindfulnessMinutesChangedEventType string

const (
	ClientFacingMindfulnessMinutesChangedEventTypeDailyDataMindfulnessMinutesCreated ClientFacingMindfulnessMinutesChangedEventType = "daily.data.mindfulness_minutes.created"
	ClientFacingMindfulnessMinutesChangedEventTypeDailyDataMindfulnessMinutesUpdated ClientFacingMindfulnessMinutesChangedEventType = "daily.data.mindfulness_minutes.updated"
)

func NewClientFacingMindfulnessMinutesChangedEventTypeFromString(s string) (ClientFacingMindfulnessMinutesChangedEventType, error) {
	switch s {
	case "daily.data.mindfulness_minutes.created":
		return ClientFacingMindfulnessMinutesChangedEventTypeDailyDataMindfulnessMinutesCreated, nil
	case "daily.data.mindfulness_minutes.updated":
		return ClientFacingMindfulnessMinutesChangedEventTypeDailyDataMindfulnessMinutesUpdated, nil
	}
	var t ClientFacingMindfulnessMinutesChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingMindfulnessMinutesChangedEventType) Ptr() *ClientFacingMindfulnessMinutesChangedEventType {
	return &c
}

type ClientFacingMindfulnessMinutesHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMindfulnessMinutesHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingMindfulnessMinutesHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingMindfulnessMinutesHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.mindfulness_minutes.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.mindfulness_minutes.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingMindfulnessMinutesHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.mindfulness_minutes.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingMindfulnessMinutesHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMindfulnessMinutesTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in minutes.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Number of minutes spent in a mindful state.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMindfulnessMinutesTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingMindfulnessMinutesTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingMindfulnessMinutesTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingMindfulnessMinutesTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteChanged struct {
	EventType    ClientFacingNoteChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                           `json:"user_id" url:"user_id"`
	ClientUserId string                           `json:"client_user_id" url:"client_user_id"`
	TeamId       string                           `json:"team_id" url:"team_id"`
	Data         *GroupedNote                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingNoteChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingNoteChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingNoteChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingNoteChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingNoteChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteChangedEventType string

const (
	ClientFacingNoteChangedEventTypeDailyDataNoteCreated ClientFacingNoteChangedEventType = "daily.data.note.created"
	ClientFacingNoteChangedEventTypeDailyDataNoteUpdated ClientFacingNoteChangedEventType = "daily.data.note.updated"
)

func NewClientFacingNoteChangedEventTypeFromString(s string) (ClientFacingNoteChangedEventType, error) {
	switch s {
	case "daily.data.note.created":
		return ClientFacingNoteChangedEventTypeDailyDataNoteCreated, nil
	case "daily.data.note.updated":
		return ClientFacingNoteChangedEventTypeDailyDataNoteUpdated, nil
	}
	var t ClientFacingNoteChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingNoteChangedEventType) Ptr() *ClientFacingNoteChangedEventType {
	return &c
}

type ClientFacingNoteHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingNoteHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingNoteHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingNoteHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingNoteHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingNoteHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.note.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.note.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingNoteHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingNoteHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.note.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingNoteHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// User notes as text.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value string `json:"value" url:"value"`
	// What the note refers to.
	Tags []ClientFacingNoteSampleTagsItem `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingNoteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingNoteSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingNoteSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingNoteSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingNoteSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingNoteSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSampleTagsItem string

const (
	ClientFacingNoteSampleTagsItemFood             ClientFacingNoteSampleTagsItem = "food"
	ClientFacingNoteSampleTagsItemExercise         ClientFacingNoteSampleTagsItem = "exercise"
	ClientFacingNoteSampleTagsItemInsulinInjection ClientFacingNoteSampleTagsItem = "insulin_injection"
	ClientFacingNoteSampleTagsItemUnspecified      ClientFacingNoteSampleTagsItem = "unspecified"
)

func NewClientFacingNoteSampleTagsItemFromString(s string) (ClientFacingNoteSampleTagsItem, error) {
	switch s {
	case "food":
		return ClientFacingNoteSampleTagsItemFood, nil
	case "exercise":
		return ClientFacingNoteSampleTagsItemExercise, nil
	case "insulin_injection":
		return ClientFacingNoteSampleTagsItemInsulinInjection, nil
	case "unspecified":
		return ClientFacingNoteSampleTagsItemUnspecified, nil
	}
	var t ClientFacingNoteSampleTagsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingNoteSampleTagsItem) Ptr() *ClientFacingNoteSampleTagsItem {
	return &c
}

type ClientFacingOrder struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	// The Vital Order ID
	Id string `json:"id" url:"id"`
	// Your team id.
	TeamId string `json:"team_id" url:"team_id"`
	// Patient Details
	PatientDetails *ClientFacingPatientDetailsCompatible `json:"patient_details,omitempty" url:"patient_details,omitempty"`
	// Patient Address
	PatientAddress *PatientAddressCompatible `json:"patient_address,omitempty" url:"patient_address,omitempty"`
	// The Vital Test associated with the order
	LabTest *ClientFacingLabTest      `json:"lab_test,omitempty" url:"lab_test,omitempty"`
	Details *ClientFacingOrderDetails `json:"details,omitempty" url:"details,omitempty"`
	// Sample ID
	SampleId *string `json:"sample_id,omitempty" url:"sample_id,omitempty"`
	// Notes associated with the order
	Notes *string `json:"notes,omitempty" url:"notes,omitempty"`
	// When your order was created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// When your order was last updated.
	UpdatedAt time.Time                 `json:"updated_at" url:"updated_at"`
	Events    []*ClientFacingOrderEvent `json:"events,omitempty" url:"events,omitempty"`
	Status    *OrderTopLevelStatus      `json:"status,omitempty" url:"status,omitempty"`
	Physician *ClientFacingPhysician    `json:"physician,omitempty" url:"physician,omitempty"`
	// Vital ID of the health insurance.
	HealthInsuranceId *string `json:"health_insurance_id,omitempty" url:"health_insurance_id,omitempty"`
	// DEPRECATED. Requistion form url.
	RequisitionFormUrl *string `json:"requisition_form_url,omitempty" url:"requisition_form_url,omitempty"`
	// Defines whether order is priority or not. For some labs, this refers to a STAT order.
	Priority *bool `json:"priority,omitempty" url:"priority,omitempty"`
	// Shipping Details. For unregistered testkit orders.
	ShippingDetails *ShippingAddress `json:"shipping_details,omitempty" url:"shipping_details,omitempty"`
	// Schedule an Order to be processed in a future date.
	ActivateBy  *string  `json:"activate_by,omitempty" url:"activate_by,omitempty"`
	Passthrough *string  `json:"passthrough,omitempty" url:"passthrough,omitempty"`
	BillingType *Billing `json:"billing_type,omitempty" url:"billing_type,omitempty"`
	IcdCodes    []string `json:"icd_codes,omitempty" url:"icd_codes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingOrder) UnmarshalJSON(data []byte) error {
	type embed ClientFacingOrder
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingOrder(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrder) MarshalJSON() ([]byte, error) {
	type embed ClientFacingOrder
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingOrderChanged struct {
	EventType    ClientFacingOrderChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                            `json:"user_id" url:"user_id"`
	ClientUserId string                            `json:"client_user_id" url:"client_user_id"`
	TeamId       string                            `json:"team_id" url:"team_id"`
	Data         *ClientFacingOrder                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingOrderChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingOrderChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingOrderChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingOrderChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrderChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingOrderChangedEventType string

const (
	ClientFacingOrderChangedEventTypeLabtestOrderCreated ClientFacingOrderChangedEventType = "labtest.order.created"
	ClientFacingOrderChangedEventTypeLabtestOrderUpdated ClientFacingOrderChangedEventType = "labtest.order.updated"
)

func NewClientFacingOrderChangedEventTypeFromString(s string) (ClientFacingOrderChangedEventType, error) {
	switch s {
	case "labtest.order.created":
		return ClientFacingOrderChangedEventTypeLabtestOrderCreated, nil
	case "labtest.order.updated":
		return ClientFacingOrderChangedEventTypeLabtestOrderUpdated, nil
	}
	var t ClientFacingOrderChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingOrderChangedEventType) Ptr() *ClientFacingOrderChangedEventType {
	return &c
}

type ClientFacingOrderDetails struct {
	Type             string
	WalkInTest       *ClientFacingWalkInOrderDetails
	Testkit          *ClientFacingTestKitOrderDetails
	AtHomePhlebotomy *ClientFacingAtHomePhlebotomyOrderDetails
}

func NewClientFacingOrderDetailsFromWalkInTest(value *ClientFacingWalkInOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "walk_in_test", WalkInTest: value}
}

func NewClientFacingOrderDetailsFromTestkit(value *ClientFacingTestKitOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "testkit", Testkit: value}
}

func NewClientFacingOrderDetailsFromAtHomePhlebotomy(value *ClientFacingAtHomePhlebotomyOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "at_home_phlebotomy", AtHomePhlebotomy: value}
}

func (c *ClientFacingOrderDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "walk_in_test":
		value := new(ClientFacingWalkInOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.WalkInTest = value
	case "testkit":
		value := new(ClientFacingTestKitOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Testkit = value
	case "at_home_phlebotomy":
		value := new(ClientFacingAtHomePhlebotomyOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.AtHomePhlebotomy = value
	}
	return nil
}

func (c ClientFacingOrderDetails) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		return core.MarshalJSONWithExtraProperty(c.WalkInTest, "type", "walk_in_test")
	case "testkit":
		return core.MarshalJSONWithExtraProperty(c.Testkit, "type", "testkit")
	case "at_home_phlebotomy":
		return core.MarshalJSONWithExtraProperty(c.AtHomePhlebotomy, "type", "at_home_phlebotomy")
	}
}

type ClientFacingOrderDetailsVisitor interface {
	VisitWalkInTest(*ClientFacingWalkInOrderDetails) error
	VisitTestkit(*ClientFacingTestKitOrderDetails) error
	VisitAtHomePhlebotomy(*ClientFacingAtHomePhlebotomyOrderDetails) error
}

func (c *ClientFacingOrderDetails) Accept(visitor ClientFacingOrderDetailsVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		return visitor.VisitWalkInTest(c.WalkInTest)
	case "testkit":
		return visitor.VisitTestkit(c.Testkit)
	case "at_home_phlebotomy":
		return visitor.VisitAtHomePhlebotomy(c.AtHomePhlebotomy)
	}
}

type ClientFacingOrderEvent struct {
	Id        int         `json:"id" url:"id"`
	CreatedAt time.Time   `json:"created_at" url:"created_at"`
	Status    OrderStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingOrderEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingOrderEvent) UnmarshalJSON(data []byte) error {
	type embed ClientFacingOrderEvent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingOrderEvent(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrderEvent) MarshalJSON() ([]byte, error) {
	type embed ClientFacingOrderEvent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingOrderEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPatientDetailsCompatible struct {
	FirstName   *string   `json:"first_name,omitempty" url:"first_name,omitempty"`
	LastName    *string   `json:"last_name,omitempty" url:"last_name,omitempty"`
	Dob         time.Time `json:"dob" url:"dob"`
	Gender      string    `json:"gender" url:"gender"`
	PhoneNumber *string   `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	Email       *string   `json:"email,omitempty" url:"email,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPatientDetailsCompatible) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPatientDetailsCompatible) UnmarshalJSON(data []byte) error {
	type embed ClientFacingPatientDetailsCompatible
	var unmarshaler = struct {
		embed
		Dob *core.DateTime `json:"dob"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingPatientDetailsCompatible(unmarshaler.embed)
	c.Dob = unmarshaler.Dob.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPatientDetailsCompatible) MarshalJSON() ([]byte, error) {
	type embed ClientFacingPatientDetailsCompatible
	var marshaler = struct {
		embed
		Dob *core.DateTime `json:"dob"`
	}{
		embed: embed(*c),
		Dob:   core.NewDateTime(c.Dob),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingPatientDetailsCompatible) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPayorSearchResponse struct {
	// Payor code returned for the insurance information.
	PayorCode string `json:"payor_code" url:"payor_code"`
	// Insurance name returned for the insurance information.
	Name string `json:"name" url:"name"`
	// Insurance name aliases returned for the insurance information.
	Aliases []string `json:"aliases,omitempty" url:"aliases,omitempty"`
	// Insurance business address returned for the insurance information.
	OrgAddress *Address `json:"org_address,omitempty" url:"org_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPayorSearchResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPayorSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPayorSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPayorSearchResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPayorSearchResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPayorSearchResponseDeprecated struct {
	// Payor code returned for the insurance information.
	Code string `json:"code" url:"code"`
	// Insurance name returned for the insurance information.
	Name string `json:"name" url:"name"`
	// Insurance name aliases returned for the insurance information.
	Aliases []string `json:"aliases,omitempty" url:"aliases,omitempty"`
	// Insurance business address returned for the insurance information.
	OrgAddress *Address `json:"org_address,omitempty" url:"org_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPayorSearchResponseDeprecated) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPayorSearchResponseDeprecated) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPayorSearchResponseDeprecated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPayorSearchResponseDeprecated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPayorSearchResponseDeprecated) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPeakExpiratoryFlowRateChanged struct {
	EventType    ClientFacingPeakExpiratoryFlowRateChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                             `json:"user_id" url:"user_id"`
	ClientUserId string                                             `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                             `json:"team_id" url:"team_id"`
	Data         *GroupedPeakExpiratoryFlowRate                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPeakExpiratoryFlowRateChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPeakExpiratoryFlowRateChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPeakExpiratoryFlowRateChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPeakExpiratoryFlowRateChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPeakExpiratoryFlowRateChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPeakExpiratoryFlowRateChangedEventType string

const (
	ClientFacingPeakExpiratoryFlowRateChangedEventTypeDailyDataPeakExpiratoryFlowRateCreated ClientFacingPeakExpiratoryFlowRateChangedEventType = "daily.data.peak_expiratory_flow_rate.created"
	ClientFacingPeakExpiratoryFlowRateChangedEventTypeDailyDataPeakExpiratoryFlowRateUpdated ClientFacingPeakExpiratoryFlowRateChangedEventType = "daily.data.peak_expiratory_flow_rate.updated"
)

func NewClientFacingPeakExpiratoryFlowRateChangedEventTypeFromString(s string) (ClientFacingPeakExpiratoryFlowRateChangedEventType, error) {
	switch s {
	case "daily.data.peak_expiratory_flow_rate.created":
		return ClientFacingPeakExpiratoryFlowRateChangedEventTypeDailyDataPeakExpiratoryFlowRateCreated, nil
	case "daily.data.peak_expiratory_flow_rate.updated":
		return ClientFacingPeakExpiratoryFlowRateChangedEventTypeDailyDataPeakExpiratoryFlowRateUpdated, nil
	}
	var t ClientFacingPeakExpiratoryFlowRateChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingPeakExpiratoryFlowRateChangedEventType) Ptr() *ClientFacingPeakExpiratoryFlowRateChangedEventType {
	return &c
}

type ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.peak_expiratory_flow_rate.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.peak_expiratory_flow_rate.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.peak_expiratory_flow_rate.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingPeakExpiratoryFlowRateHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPeakExpiratoryFlowRateSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) Unit() string {
	return c.unit
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingPeakExpiratoryFlowRateSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingPeakExpiratoryFlowRateSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L/min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L/min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingPeakExpiratoryFlowRateSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "L/min",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPhysician struct {
	FirstName string `json:"first_name" url:"first_name"`
	LastName  string `json:"last_name" url:"last_name"`
	Npi       string `json:"npi" url:"npi"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingPhysician) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPhysician) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPhysician
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPhysician(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPhysician) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProfile struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId        string              `json:"user_id" url:"user_id"`
	Id            string              `json:"id" url:"id"`
	Height        *int                `json:"height,omitempty" url:"height,omitempty"`
	BirthDate     *string             `json:"birth_date,omitempty" url:"birth_date,omitempty"`
	WheelchairUse *bool               `json:"wheelchair_use,omitempty" url:"wheelchair_use,omitempty"`
	Source        *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProfile) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProfile) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProfileChanged struct {
	EventType    ClientFacingProfileChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                              `json:"user_id" url:"user_id"`
	ClientUserId string                              `json:"client_user_id" url:"client_user_id"`
	TeamId       string                              `json:"team_id" url:"team_id"`
	Data         *ClientFacingProfile                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProfileChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProfileChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProfileChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProfileChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProfileChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProfileChangedEventType string

const (
	ClientFacingProfileChangedEventTypeDailyDataProfileCreated ClientFacingProfileChangedEventType = "daily.data.profile.created"
	ClientFacingProfileChangedEventTypeDailyDataProfileUpdated ClientFacingProfileChangedEventType = "daily.data.profile.updated"
)

func NewClientFacingProfileChangedEventTypeFromString(s string) (ClientFacingProfileChangedEventType, error) {
	switch s {
	case "daily.data.profile.created":
		return ClientFacingProfileChangedEventTypeDailyDataProfileCreated, nil
	case "daily.data.profile.updated":
		return ClientFacingProfileChangedEventTypeDailyDataProfileUpdated, nil
	}
	var t ClientFacingProfileChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingProfileChangedEventType) Ptr() *ClientFacingProfileChangedEventType {
	return &c
}

type ClientFacingProfileHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProfileHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProfileHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingProfileHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingProfileHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingProfileHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.profile.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.profile.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProfileHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingProfileHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.profile.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingProfileHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A vendor, a service, or a platform which Vital can connect with.
type ClientFacingProvider struct {
	// Name of source of information
	Name string `json:"name" url:"name"`
	// Slug for designated source
	Slug string `json:"slug" url:"slug"`
	// URL for source logo
	Logo string `json:"logo" url:"logo"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProvider) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProvider) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProvider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProvider(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProvider) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderConnectionCreatedEvent struct {
	UserId       string                     `json:"user_id" url:"user_id"`
	ClientUserId string                     `json:"client_user_id" url:"client_user_id"`
	TeamId       string                     `json:"team_id" url:"team_id"`
	Data         *ProviderConnectionCreated `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProviderConnectionCreatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProviderConnectionCreatedEvent) EventType() string {
	return c.eventType
}

func (c *ClientFacingProviderConnectionCreatedEvent) UnmarshalJSON(data []byte) error {
	type embed ClientFacingProviderConnectionCreatedEvent
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingProviderConnectionCreatedEvent(unmarshaler.embed)
	if unmarshaler.EventType != "provider.connection.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "provider.connection.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderConnectionCreatedEvent) MarshalJSON() ([]byte, error) {
	type embed ClientFacingProviderConnectionCreatedEvent
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "provider.connection.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingProviderConnectionCreatedEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderConnectionErrorEvent struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *ProviderConnectionError `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProviderConnectionErrorEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProviderConnectionErrorEvent) EventType() string {
	return c.eventType
}

func (c *ClientFacingProviderConnectionErrorEvent) UnmarshalJSON(data []byte) error {
	type embed ClientFacingProviderConnectionErrorEvent
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingProviderConnectionErrorEvent(unmarshaler.embed)
	if unmarshaler.EventType != "provider.connection.error" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "provider.connection.error", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderConnectionErrorEvent) MarshalJSON() ([]byte, error) {
	type embed ClientFacingProviderConnectionErrorEvent
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "provider.connection.error",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingProviderConnectionErrorEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderDetailed struct {
	// Name of source of information
	Name string `json:"name" url:"name"`
	// Slug for designated source
	Slug string `json:"slug" url:"slug"`
	// Description of source of information
	Description string `json:"description" url:"description"`
	// URL for source logo
	Logo               *string                `json:"logo,omitempty" url:"logo,omitempty"`
	AuthType           *SourceAuthType        `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	SupportedResources []ClientFacingResource `json:"supported_resources,omitempty" url:"supported_resources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProviderDetailed) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProviderDetailed) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProviderDetailed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProviderDetailed(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderDetailed) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderWithStatus struct {
	// Name of source of information
	Name string `json:"name" url:"name"`
	// Slug for designated source
	Slug string `json:"slug" url:"slug"`
	// URL for source logo
	Logo      string    `json:"logo" url:"logo"`
	CreatedOn time.Time `json:"created_on" url:"created_on"`
	// Status of source, either error or connected
	Status string `json:"status" url:"status"`
	// Details of the terminal connection error  populated only when the status is `error`.
	ErrorDetails         *ClientFacingConnectionErrorDetails `json:"error_details,omitempty" url:"error_details,omitempty"`
	ResourceAvailability map[string]*ResourceAvailability    `json:"resource_availability,omitempty" url:"resource_availability,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingProviderWithStatus) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProviderWithStatus) UnmarshalJSON(data []byte) error {
	type embed ClientFacingProviderWithStatus
	var unmarshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingProviderWithStatus(unmarshaler.embed)
	c.CreatedOn = unmarshaler.CreatedOn.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderWithStatus) MarshalJSON() ([]byte, error) {
	type embed ClientFacingProviderWithStatus
	var marshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed:     embed(*c),
		CreatedOn: core.NewDateTime(c.CreatedOn),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingProviderWithStatus) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingResource string

const (
	ClientFacingResourceProfile                   ClientFacingResource = "profile"
	ClientFacingResourceActivity                  ClientFacingResource = "activity"
	ClientFacingResourceSleep                     ClientFacingResource = "sleep"
	ClientFacingResourceBody                      ClientFacingResource = "body"
	ClientFacingResourceWorkouts                  ClientFacingResource = "workouts"
	ClientFacingResourceWorkoutStream             ClientFacingResource = "workout_stream"
	ClientFacingResourceConnection                ClientFacingResource = "connection"
	ClientFacingResourceOrder                     ClientFacingResource = "order"
	ClientFacingResourceResult                    ClientFacingResource = "result"
	ClientFacingResourceAppointment               ClientFacingResource = "appointment"
	ClientFacingResourceGlucose                   ClientFacingResource = "glucose"
	ClientFacingResourceHeartrate                 ClientFacingResource = "heartrate"
	ClientFacingResourceHrv                       ClientFacingResource = "hrv"
	ClientFacingResourceIge                       ClientFacingResource = "ige"
	ClientFacingResourceIgg                       ClientFacingResource = "igg"
	ClientFacingResourceBloodOxygen               ClientFacingResource = "blood_oxygen"
	ClientFacingResourceBloodPressure             ClientFacingResource = "blood_pressure"
	ClientFacingResourceCholesterol               ClientFacingResource = "cholesterol"
	ClientFacingResourceDevice                    ClientFacingResource = "device"
	ClientFacingResourceWeight                    ClientFacingResource = "weight"
	ClientFacingResourceFat                       ClientFacingResource = "fat"
	ClientFacingResourceBodyTemperature           ClientFacingResource = "body_temperature"
	ClientFacingResourceBodyTemperatureDelta      ClientFacingResource = "body_temperature_delta"
	ClientFacingResourceMeal                      ClientFacingResource = "meal"
	ClientFacingResourceWater                     ClientFacingResource = "water"
	ClientFacingResourceCaffeine                  ClientFacingResource = "caffeine"
	ClientFacingResourceMindfulnessMinutes        ClientFacingResource = "mindfulness_minutes"
	ClientFacingResourceSteps                     ClientFacingResource = "steps"
	ClientFacingResourceCaloriesActive            ClientFacingResource = "calories_active"
	ClientFacingResourceDistance                  ClientFacingResource = "distance"
	ClientFacingResourceFloorsClimbed             ClientFacingResource = "floors_climbed"
	ClientFacingResourceRespiratoryRate           ClientFacingResource = "respiratory_rate"
	ClientFacingResourceVo2Max                    ClientFacingResource = "vo2_max"
	ClientFacingResourceCaloriesBasal             ClientFacingResource = "calories_basal"
	ClientFacingResourceStressLevel               ClientFacingResource = "stress_level"
	ClientFacingResourceMenstrualCycle            ClientFacingResource = "menstrual_cycle"
	ClientFacingResourceSleepCycle                ClientFacingResource = "sleep_cycle"
	ClientFacingResourceElectrocardiogram         ClientFacingResource = "electrocardiogram"
	ClientFacingResourceElectrocardiogramVoltage  ClientFacingResource = "electrocardiogram_voltage"
	ClientFacingResourceAfibBurden                ClientFacingResource = "afib_burden"
	ClientFacingResourceHeartRateAlert            ClientFacingResource = "heart_rate_alert"
	ClientFacingResourceStandHour                 ClientFacingResource = "stand_hour"
	ClientFacingResourceStandDuration             ClientFacingResource = "stand_duration"
	ClientFacingResourceSleepApneaAlert           ClientFacingResource = "sleep_apnea_alert"
	ClientFacingResourceSleepBreathingDisturbance ClientFacingResource = "sleep_breathing_disturbance"
	ClientFacingResourceWheelchairPush            ClientFacingResource = "wheelchair_push"
	ClientFacingResourceForcedExpiratoryVolume1   ClientFacingResource = "forced_expiratory_volume_1"
	ClientFacingResourceForcedVitalCapacity       ClientFacingResource = "forced_vital_capacity"
	ClientFacingResourcePeakExpiratoryFlowRate    ClientFacingResource = "peak_expiratory_flow_rate"
	ClientFacingResourceInhalerUsage              ClientFacingResource = "inhaler_usage"
	ClientFacingResourceFall                      ClientFacingResource = "fall"
	ClientFacingResourceUvExposure                ClientFacingResource = "uv_exposure"
	ClientFacingResourceDaylightExposure          ClientFacingResource = "daylight_exposure"
	ClientFacingResourceHandwashing               ClientFacingResource = "handwashing"
	ClientFacingResourceBasalBodyTemperature      ClientFacingResource = "basal_body_temperature"
	ClientFacingResourceWorkoutDuration           ClientFacingResource = "workout_duration"
	ClientFacingResourceInsulinInjection          ClientFacingResource = "insulin_injection"
	ClientFacingResourceCarbohydrates             ClientFacingResource = "carbohydrates"
	ClientFacingResourceNote                      ClientFacingResource = "note"
	ClientFacingResourceSleepStream               ClientFacingResource = "sleep_stream"
	ClientFacingResourceHypnogram                 ClientFacingResource = "hypnogram"
)

func NewClientFacingResourceFromString(s string) (ClientFacingResource, error) {
	switch s {
	case "profile":
		return ClientFacingResourceProfile, nil
	case "activity":
		return ClientFacingResourceActivity, nil
	case "sleep":
		return ClientFacingResourceSleep, nil
	case "body":
		return ClientFacingResourceBody, nil
	case "workouts":
		return ClientFacingResourceWorkouts, nil
	case "workout_stream":
		return ClientFacingResourceWorkoutStream, nil
	case "connection":
		return ClientFacingResourceConnection, nil
	case "order":
		return ClientFacingResourceOrder, nil
	case "result":
		return ClientFacingResourceResult, nil
	case "appointment":
		return ClientFacingResourceAppointment, nil
	case "glucose":
		return ClientFacingResourceGlucose, nil
	case "heartrate":
		return ClientFacingResourceHeartrate, nil
	case "hrv":
		return ClientFacingResourceHrv, nil
	case "ige":
		return ClientFacingResourceIge, nil
	case "igg":
		return ClientFacingResourceIgg, nil
	case "blood_oxygen":
		return ClientFacingResourceBloodOxygen, nil
	case "blood_pressure":
		return ClientFacingResourceBloodPressure, nil
	case "cholesterol":
		return ClientFacingResourceCholesterol, nil
	case "device":
		return ClientFacingResourceDevice, nil
	case "weight":
		return ClientFacingResourceWeight, nil
	case "fat":
		return ClientFacingResourceFat, nil
	case "body_temperature":
		return ClientFacingResourceBodyTemperature, nil
	case "body_temperature_delta":
		return ClientFacingResourceBodyTemperatureDelta, nil
	case "meal":
		return ClientFacingResourceMeal, nil
	case "water":
		return ClientFacingResourceWater, nil
	case "caffeine":
		return ClientFacingResourceCaffeine, nil
	case "mindfulness_minutes":
		return ClientFacingResourceMindfulnessMinutes, nil
	case "steps":
		return ClientFacingResourceSteps, nil
	case "calories_active":
		return ClientFacingResourceCaloriesActive, nil
	case "distance":
		return ClientFacingResourceDistance, nil
	case "floors_climbed":
		return ClientFacingResourceFloorsClimbed, nil
	case "respiratory_rate":
		return ClientFacingResourceRespiratoryRate, nil
	case "vo2_max":
		return ClientFacingResourceVo2Max, nil
	case "calories_basal":
		return ClientFacingResourceCaloriesBasal, nil
	case "stress_level":
		return ClientFacingResourceStressLevel, nil
	case "menstrual_cycle":
		return ClientFacingResourceMenstrualCycle, nil
	case "sleep_cycle":
		return ClientFacingResourceSleepCycle, nil
	case "electrocardiogram":
		return ClientFacingResourceElectrocardiogram, nil
	case "electrocardiogram_voltage":
		return ClientFacingResourceElectrocardiogramVoltage, nil
	case "afib_burden":
		return ClientFacingResourceAfibBurden, nil
	case "heart_rate_alert":
		return ClientFacingResourceHeartRateAlert, nil
	case "stand_hour":
		return ClientFacingResourceStandHour, nil
	case "stand_duration":
		return ClientFacingResourceStandDuration, nil
	case "sleep_apnea_alert":
		return ClientFacingResourceSleepApneaAlert, nil
	case "sleep_breathing_disturbance":
		return ClientFacingResourceSleepBreathingDisturbance, nil
	case "wheelchair_push":
		return ClientFacingResourceWheelchairPush, nil
	case "forced_expiratory_volume_1":
		return ClientFacingResourceForcedExpiratoryVolume1, nil
	case "forced_vital_capacity":
		return ClientFacingResourceForcedVitalCapacity, nil
	case "peak_expiratory_flow_rate":
		return ClientFacingResourcePeakExpiratoryFlowRate, nil
	case "inhaler_usage":
		return ClientFacingResourceInhalerUsage, nil
	case "fall":
		return ClientFacingResourceFall, nil
	case "uv_exposure":
		return ClientFacingResourceUvExposure, nil
	case "daylight_exposure":
		return ClientFacingResourceDaylightExposure, nil
	case "handwashing":
		return ClientFacingResourceHandwashing, nil
	case "basal_body_temperature":
		return ClientFacingResourceBasalBodyTemperature, nil
	case "workout_duration":
		return ClientFacingResourceWorkoutDuration, nil
	case "insulin_injection":
		return ClientFacingResourceInsulinInjection, nil
	case "carbohydrates":
		return ClientFacingResourceCarbohydrates, nil
	case "note":
		return ClientFacingResourceNote, nil
	case "sleep_stream":
		return ClientFacingResourceSleepStream, nil
	case "hypnogram":
		return ClientFacingResourceHypnogram, nil
	}
	var t ClientFacingResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingResource) Ptr() *ClientFacingResource {
	return &c
}

type ClientFacingRespiratoryRateChanged struct {
	EventType    ClientFacingRespiratoryRateChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                      `json:"user_id" url:"user_id"`
	ClientUserId string                                      `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                      `json:"team_id" url:"team_id"`
	Data         *GroupedRespiratoryRate                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingRespiratoryRateChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingRespiratoryRateChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingRespiratoryRateChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingRespiratoryRateChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingRespiratoryRateChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingRespiratoryRateChangedEventType string

const (
	ClientFacingRespiratoryRateChangedEventTypeDailyDataRespiratoryRateCreated ClientFacingRespiratoryRateChangedEventType = "daily.data.respiratory_rate.created"
	ClientFacingRespiratoryRateChangedEventTypeDailyDataRespiratoryRateUpdated ClientFacingRespiratoryRateChangedEventType = "daily.data.respiratory_rate.updated"
)

func NewClientFacingRespiratoryRateChangedEventTypeFromString(s string) (ClientFacingRespiratoryRateChangedEventType, error) {
	switch s {
	case "daily.data.respiratory_rate.created":
		return ClientFacingRespiratoryRateChangedEventTypeDailyDataRespiratoryRateCreated, nil
	case "daily.data.respiratory_rate.updated":
		return ClientFacingRespiratoryRateChangedEventTypeDailyDataRespiratoryRateUpdated, nil
	}
	var t ClientFacingRespiratoryRateChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingRespiratoryRateChangedEventType) Ptr() *ClientFacingRespiratoryRateChangedEventType {
	return &c
}

type ClientFacingRespiratoryRateHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingRespiratoryRateHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingRespiratoryRateHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingRespiratoryRateHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingRespiratoryRateHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingRespiratoryRateHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.respiratory_rate.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.respiratory_rate.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingRespiratoryRateHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingRespiratoryRateHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.respiratory_rate.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingRespiratoryRateHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingRespiratoryRateTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in bpm.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Average respiratory rate::breaths per minute
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingRespiratoryRateTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingRespiratoryRateTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingRespiratoryRateTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingRespiratoryRateTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingRespiratoryRateTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingRespiratoryRateTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingRespiratoryRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingResult struct {
	Id         int                `json:"id" url:"id"`
	Name       string             `json:"name" url:"name"`
	Slug       string             `json:"slug" url:"slug"`
	LabId      *int               `json:"lab_id,omitempty" url:"lab_id,omitempty"`
	ProviderId *string            `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	Required   bool               `json:"required" url:"required"`
	Loinc      *ClientFacingLoinc `json:"loinc,omitempty" url:"loinc,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSampleGroupingKeys = []interface{}

type ClientFacingShallowWorkoutStream struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId     string  `json:"user_id" url:"user_id"`
	WorkoutId  string  `json:"workout_id" url:"workout_id"`
	ProviderId string  `json:"provider_id" url:"provider_id"`
	Message    *string `json:"message,omitempty" url:"message,omitempty"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`
	// Sport's name
	Sport *ClientFacingSport `json:"sport,omitempty" url:"sport,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingShallowWorkoutStream) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingShallowWorkoutStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingShallowWorkoutStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingShallowWorkoutStream(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingShallowWorkoutStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a Shipment in the client facing API.
//
// To be used as part of a ClientFacingTestkitOrder.
type ClientFacingShipment struct {
	// The Vital Shipment ID
	Id string `json:"id" url:"id"`
	// Tracking number for delivery to customer
	OutboundTrackingNumber *string `json:"outbound_tracking_number,omitempty" url:"outbound_tracking_number,omitempty"`
	// Tracking url for delivery to customer
	OutboundTrackingUrl *string `json:"outbound_tracking_url,omitempty" url:"outbound_tracking_url,omitempty"`
	// Tracking number for delivery to lab
	InboundTrackingNumber *string `json:"inbound_tracking_number,omitempty" url:"inbound_tracking_number,omitempty"`
	// Tracking url for delivery to lab
	InboundTrackingUrl *string `json:"inbound_tracking_url,omitempty" url:"inbound_tracking_url,omitempty"`
	// Courier used for delivery to customer
	OutboundCourier *string `json:"outbound_courier,omitempty" url:"outbound_courier,omitempty"`
	// Courier used for delivery to lab
	InboundCourier *string `json:"inbound_courier,omitempty" url:"inbound_courier,omitempty"`
	// Notes associated to the Vital shipment
	Notes *string `json:"notes,omitempty" url:"notes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingShipment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingShipment) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingShipment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingShipment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingShipment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleep struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date" url:"date"`
	// Date of the sleep summary in the YYYY-mm-dd format. This generally matches the sleep end date.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// UTC Time when the sleep period started
	BedtimeStart time.Time `json:"bedtime_start" url:"bedtime_start"`
	// UTC Time when the sleep period ended
	BedtimeStop time.Time `json:"bedtime_stop" url:"bedtime_stop"`
	// `long_sleep`: >=3 hours of sleep;
	// `short_sleep`: <3 hours of sleep;
	// `acknowledged_nap`: User-acknowledged naps, typically under 3 hours of sleep;
	// `unknown`: The sleep session recording is ongoing.
	Type SleepType `json:"type" url:"type"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Total duration of the sleep period (sleep.duration = sleep.bedtime_end - sleep.bedtime_start)::seconds
	Duration int `json:"duration" url:"duration"`
	// Total amount of sleep registered during the sleep period (sleep.total = sleep.rem + sleep.light + sleep.deep)::seconds
	Total int `json:"total" url:"total"`
	// Total amount of awake time registered during the sleep period::seconds
	Awake int `json:"awake" url:"awake"`
	// Total amount of light sleep registered during the sleep period::seconds
	Light int `json:"light" url:"light"`
	// Total amount of REM sleep registered during the sleep period, minutes::seconds
	Rem int `json:"rem" url:"rem"`
	// Total amount of deep (N3) sleep registered during the sleep period::seconds
	Deep int `json:"deep" url:"deep"`
	// A value between 1 and 100 representing how well the user slept. Currently only available for Withings, Oura, Whoop and Garmin::scalar
	Score *int `json:"score,omitempty" url:"score,omitempty"`
	// The lowest heart rate (5 minutes sliding average) registered during the sleep period::beats per minute
	HrLowest *int `json:"hr_lowest,omitempty" url:"hr_lowest,omitempty"`
	// The average heart rate registered during the sleep period::beats per minute
	HrAverage *int `json:"hr_average,omitempty" url:"hr_average,omitempty"`
	// Resting heart rate recorded during a sleep session::bpm
	HrResting *int `json:"hr_resting,omitempty" url:"hr_resting,omitempty"`
	// Sleep efficiency is the percentage of the sleep period spent asleep (100% \* sleep.total / sleep.duration)::perc
	Efficiency *float64 `json:"efficiency,omitempty" url:"efficiency,omitempty"`
	// Detected latency from bedtime_start to the beginning of the first five minutes of persistent sleep::seconds
	Latency *int `json:"latency,omitempty" url:"latency,omitempty"`
	// Skin temperature deviation from the long-term temperature average::celcius
	TemperatureDelta *float64 `json:"temperature_delta,omitempty" url:"temperature_delta,omitempty"`
	// The skin temperature::celcius
	SkinTemperature *float64 `json:"skin_temperature,omitempty" url:"skin_temperature,omitempty"`
	// Sleeping Heart Rate Dip is the percentage difference between your average waking heart rate and your average sleeping heart rate. In health studies, a greater "dip" is typically seen as a positive indicator of overall health. Currently only available for Garmin::perc
	HrDip *float64 `json:"hr_dip,omitempty" url:"hr_dip,omitempty"`
	// Some providers can provide updates to the sleep summary hours after the sleep period has ended. This field indicates the state of the sleep summary. For example, TENTATIVE means the summary is an intial prediction from the provider and can be subject to change. Currently only available for Garmin and EightSleep::str
	State *SleepSummaryState `json:"state,omitempty" url:"state,omitempty"`
	// The average heart rate variability registered during the sleep period::rmssd
	AverageHrv *float64 `json:"average_hrv,omitempty" url:"average_hrv,omitempty"`
	// Average respiratory rate::breaths per minute
	RespiratoryRate *float64 `json:"respiratory_rate,omitempty" url:"respiratory_rate,omitempty"`
	// Source the data has come from.
	Source      *ClientFacingSource      `json:"source,omitempty" url:"source,omitempty"`
	SleepStream *ClientFacingSleepStream `json:"sleep_stream,omitempty" url:"sleep_stream,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleep) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleep) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleep
	var unmarshaler = struct {
		embed
		Date         *core.DateTime `json:"date"`
		BedtimeStart *core.DateTime `json:"bedtime_start"`
		BedtimeStop  *core.DateTime `json:"bedtime_stop"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleep(unmarshaler.embed)
	c.Date = unmarshaler.Date.Time()
	c.BedtimeStart = unmarshaler.BedtimeStart.Time()
	c.BedtimeStop = unmarshaler.BedtimeStop.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleep) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleep
	var marshaler = struct {
		embed
		Date         *core.DateTime `json:"date"`
		BedtimeStart *core.DateTime `json:"bedtime_start"`
		BedtimeStop  *core.DateTime `json:"bedtime_stop"`
	}{
		embed:        embed(*c),
		Date:         core.NewDateTime(c.Date),
		BedtimeStart: core.NewDateTime(c.BedtimeStart),
		BedtimeStop:  core.NewDateTime(c.BedtimeStop),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleep) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepApneaAlertChanged struct {
	EventType    ClientFacingSleepApneaAlertChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                      `json:"user_id" url:"user_id"`
	ClientUserId string                                      `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                      `json:"team_id" url:"team_id"`
	Data         *GroupedSleepApneaAlert                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepApneaAlertChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepApneaAlertChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepApneaAlertChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepApneaAlertChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepApneaAlertChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepApneaAlertChangedEventType string

const (
	ClientFacingSleepApneaAlertChangedEventTypeDailyDataSleepApneaAlertCreated ClientFacingSleepApneaAlertChangedEventType = "daily.data.sleep_apnea_alert.created"
	ClientFacingSleepApneaAlertChangedEventTypeDailyDataSleepApneaAlertUpdated ClientFacingSleepApneaAlertChangedEventType = "daily.data.sleep_apnea_alert.updated"
)

func NewClientFacingSleepApneaAlertChangedEventTypeFromString(s string) (ClientFacingSleepApneaAlertChangedEventType, error) {
	switch s {
	case "daily.data.sleep_apnea_alert.created":
		return ClientFacingSleepApneaAlertChangedEventTypeDailyDataSleepApneaAlertCreated, nil
	case "daily.data.sleep_apnea_alert.updated":
		return ClientFacingSleepApneaAlertChangedEventTypeDailyDataSleepApneaAlertUpdated, nil
	}
	var t ClientFacingSleepApneaAlertChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepApneaAlertChangedEventType) Ptr() *ClientFacingSleepApneaAlertChangedEventType {
	return &c
}

type ClientFacingSleepApneaAlertHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepApneaAlertHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepApneaAlertHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingSleepApneaAlertHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepApneaAlertHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepApneaAlertHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.sleep_apnea_alert.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.sleep_apnea_alert.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepApneaAlertHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepApneaAlertHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.sleep_apnea_alert.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepApneaAlertHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepApneaAlertSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepApneaAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepApneaAlertSample) Unit() string {
	return c.unit
}

func (c *ClientFacingSleepApneaAlertSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepApneaAlertSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepApneaAlertSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepApneaAlertSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepApneaAlertSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepApneaAlertSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepBreathingDisturbanceChanged struct {
	EventType    ClientFacingSleepBreathingDisturbanceChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                                `json:"user_id" url:"user_id"`
	ClientUserId string                                                `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                                `json:"team_id" url:"team_id"`
	Data         *GroupedSleepBreathingDisturbance                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepBreathingDisturbanceChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepBreathingDisturbanceChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepBreathingDisturbanceChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepBreathingDisturbanceChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepBreathingDisturbanceChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepBreathingDisturbanceChangedEventType string

const (
	ClientFacingSleepBreathingDisturbanceChangedEventTypeDailyDataSleepBreathingDisturbanceCreated ClientFacingSleepBreathingDisturbanceChangedEventType = "daily.data.sleep_breathing_disturbance.created"
	ClientFacingSleepBreathingDisturbanceChangedEventTypeDailyDataSleepBreathingDisturbanceUpdated ClientFacingSleepBreathingDisturbanceChangedEventType = "daily.data.sleep_breathing_disturbance.updated"
)

func NewClientFacingSleepBreathingDisturbanceChangedEventTypeFromString(s string) (ClientFacingSleepBreathingDisturbanceChangedEventType, error) {
	switch s {
	case "daily.data.sleep_breathing_disturbance.created":
		return ClientFacingSleepBreathingDisturbanceChangedEventTypeDailyDataSleepBreathingDisturbanceCreated, nil
	case "daily.data.sleep_breathing_disturbance.updated":
		return ClientFacingSleepBreathingDisturbanceChangedEventTypeDailyDataSleepBreathingDisturbanceUpdated, nil
	}
	var t ClientFacingSleepBreathingDisturbanceChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepBreathingDisturbanceChangedEventType) Ptr() *ClientFacingSleepBreathingDisturbanceChangedEventType {
	return &c
}

type ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.sleep_breathing_disturbance.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.sleep_breathing_disturbance.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.sleep_breathing_disturbance.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepBreathingDisturbanceHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepBreathingDisturbanceSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int                                            `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	Type           ClientFacingSleepBreathingDisturbanceSampleType `json:"type" url:"type"`
	Grouping       *ClientFacingSampleGroupingKeys                 `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepBreathingDisturbanceSample) Unit() string {
	return c.unit
}

func (c *ClientFacingSleepBreathingDisturbanceSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepBreathingDisturbanceSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepBreathingDisturbanceSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepBreathingDisturbanceSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepBreathingDisturbanceSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepBreathingDisturbanceSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepBreathingDisturbanceSampleType string

const (
	ClientFacingSleepBreathingDisturbanceSampleTypeElevated    ClientFacingSleepBreathingDisturbanceSampleType = "elevated"
	ClientFacingSleepBreathingDisturbanceSampleTypeNotElevated ClientFacingSleepBreathingDisturbanceSampleType = "not_elevated"
)

func NewClientFacingSleepBreathingDisturbanceSampleTypeFromString(s string) (ClientFacingSleepBreathingDisturbanceSampleType, error) {
	switch s {
	case "elevated":
		return ClientFacingSleepBreathingDisturbanceSampleTypeElevated, nil
	case "not_elevated":
		return ClientFacingSleepBreathingDisturbanceSampleTypeNotElevated, nil
	}
	var t ClientFacingSleepBreathingDisturbanceSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepBreathingDisturbanceSampleType) Ptr() *ClientFacingSleepBreathingDisturbanceSampleType {
	return &c
}

type ClientFacingSleepChanged struct {
	EventType    ClientFacingSleepChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                            `json:"user_id" url:"user_id"`
	ClientUserId string                            `json:"client_user_id" url:"client_user_id"`
	TeamId       string                            `json:"team_id" url:"team_id"`
	Data         *ClientFacingSleep                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepChangedEventType string

const (
	ClientFacingSleepChangedEventTypeDailyDataSleepCreated ClientFacingSleepChangedEventType = "daily.data.sleep.created"
	ClientFacingSleepChangedEventTypeDailyDataSleepUpdated ClientFacingSleepChangedEventType = "daily.data.sleep.updated"
)

func NewClientFacingSleepChangedEventTypeFromString(s string) (ClientFacingSleepChangedEventType, error) {
	switch s {
	case "daily.data.sleep.created":
		return ClientFacingSleepChangedEventTypeDailyDataSleepCreated, nil
	case "daily.data.sleep.updated":
		return ClientFacingSleepChangedEventTypeDailyDataSleepUpdated, nil
	}
	var t ClientFacingSleepChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepChangedEventType) Ptr() *ClientFacingSleepChangedEventType {
	return &c
}

type ClientFacingSleepCycle struct {
	Id                     string    `json:"id" url:"id"`
	SleepId                string    `json:"sleep_id" url:"sleep_id"`
	SessionStart           time.Time `json:"session_start" url:"session_start"`
	SessionEnd             time.Time `json:"session_end" url:"session_end"`
	StageStartOffsetSecond []int     `json:"stage_start_offset_second,omitempty" url:"stage_start_offset_second,omitempty"`
	StageEndOffsetSecond   []int     `json:"stage_end_offset_second,omitempty" url:"stage_end_offset_second,omitempty"`
	// Sleep stage classification:
	// `-1`: Unknown or unclassified sleep stage;
	// `1`: Deep sleep;
	// `2`: Light/non-REM sleep;
	// `3`: Rapid Eye Movement sleep;
	// `4`: Awake period;
	// `5`: Manually classified stage.
	StageType      []VitalSleepStage                     `json:"stage_type,omitempty" url:"stage_type,omitempty"`
	TimeZone       *string                               `json:"time_zone,omitempty" url:"time_zone,omitempty"`
	SourceProvider *ClientFacingSleepCycleSourceProvider `json:"source_provider,omitempty" url:"source_provider,omitempty"`
	SourceType     ClientFacingSleepCycleSourceType      `json:"source_type" url:"source_type"`
	SourceAppId    *string                               `json:"source_app_id,omitempty" url:"source_app_id,omitempty"`
	UserId         string                                `json:"user_id" url:"user_id"`
	Source         *ClientFacingSource                   `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepCycle) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepCycle) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepCycle
	var unmarshaler = struct {
		embed
		SessionStart *core.DateTime `json:"session_start"`
		SessionEnd   *core.DateTime `json:"session_end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepCycle(unmarshaler.embed)
	c.SessionStart = unmarshaler.SessionStart.Time()
	c.SessionEnd = unmarshaler.SessionEnd.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepCycle) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepCycle
	var marshaler = struct {
		embed
		SessionStart *core.DateTime `json:"session_start"`
		SessionEnd   *core.DateTime `json:"session_end"`
	}{
		embed:        embed(*c),
		SessionStart: core.NewDateTime(c.SessionStart),
		SessionEnd:   core.NewDateTime(c.SessionEnd),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepCycle) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepCycleChanged struct {
	EventType    ClientFacingSleepCycleChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                 `json:"user_id" url:"user_id"`
	ClientUserId string                                 `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                 `json:"team_id" url:"team_id"`
	Data         *ClientFacingSleepCycle                `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepCycleChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepCycleChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepCycleChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepCycleChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepCycleChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepCycleChangedEventType string

const (
	ClientFacingSleepCycleChangedEventTypeDailyDataSleepCycleCreated ClientFacingSleepCycleChangedEventType = "daily.data.sleep_cycle.created"
	ClientFacingSleepCycleChangedEventTypeDailyDataSleepCycleUpdated ClientFacingSleepCycleChangedEventType = "daily.data.sleep_cycle.updated"
)

func NewClientFacingSleepCycleChangedEventTypeFromString(s string) (ClientFacingSleepCycleChangedEventType, error) {
	switch s {
	case "daily.data.sleep_cycle.created":
		return ClientFacingSleepCycleChangedEventTypeDailyDataSleepCycleCreated, nil
	case "daily.data.sleep_cycle.updated":
		return ClientFacingSleepCycleChangedEventTypeDailyDataSleepCycleUpdated, nil
	}
	var t ClientFacingSleepCycleChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepCycleChangedEventType) Ptr() *ClientFacingSleepCycleChangedEventType {
	return &c
}

type ClientFacingSleepCycleHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepCycleHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepCycleHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingSleepCycleHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepCycleHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepCycleHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.sleep_cycle.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.sleep_cycle.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepCycleHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepCycleHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.sleep_cycle.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepCycleHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepCycleSourceProvider struct {
	Providers Providers
	Labs      Labs
}

func NewClientFacingSleepCycleSourceProviderFromProviders(value Providers) *ClientFacingSleepCycleSourceProvider {
	return &ClientFacingSleepCycleSourceProvider{Providers: value}
}

func NewClientFacingSleepCycleSourceProviderFromLabs(value Labs) *ClientFacingSleepCycleSourceProvider {
	return &ClientFacingSleepCycleSourceProvider{Labs: value}
}

func (c *ClientFacingSleepCycleSourceProvider) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		c.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		c.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingSleepCycleSourceProvider) MarshalJSON() ([]byte, error) {
	if c.Providers != "" {
		return json.Marshal(c.Providers)
	}
	if c.Labs != "" {
		return json.Marshal(c.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingSleepCycleSourceProviderVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (c *ClientFacingSleepCycleSourceProvider) Accept(visitor ClientFacingSleepCycleSourceProviderVisitor) error {
	if c.Providers != "" {
		return visitor.VisitProviders(c.Providers)
	}
	if c.Labs != "" {
		return visitor.VisitLabs(c.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingSleepCycleSourceType string

const (
	ClientFacingSleepCycleSourceTypeUnknown         ClientFacingSleepCycleSourceType = "unknown"
	ClientFacingSleepCycleSourceTypePhone           ClientFacingSleepCycleSourceType = "phone"
	ClientFacingSleepCycleSourceTypeWatch           ClientFacingSleepCycleSourceType = "watch"
	ClientFacingSleepCycleSourceTypeApp             ClientFacingSleepCycleSourceType = "app"
	ClientFacingSleepCycleSourceTypeMultipleSources ClientFacingSleepCycleSourceType = "multiple_sources"
	ClientFacingSleepCycleSourceTypeFingerprick     ClientFacingSleepCycleSourceType = "fingerprick"
	ClientFacingSleepCycleSourceTypeCuff            ClientFacingSleepCycleSourceType = "cuff"
	ClientFacingSleepCycleSourceTypeManualScan      ClientFacingSleepCycleSourceType = "manual_scan"
	ClientFacingSleepCycleSourceTypeAutomatic       ClientFacingSleepCycleSourceType = "automatic"
	ClientFacingSleepCycleSourceTypeScale           ClientFacingSleepCycleSourceType = "scale"
	ClientFacingSleepCycleSourceTypeChestStrap      ClientFacingSleepCycleSourceType = "chest_strap"
	ClientFacingSleepCycleSourceTypeRing            ClientFacingSleepCycleSourceType = "ring"
	ClientFacingSleepCycleSourceTypeLab             ClientFacingSleepCycleSourceType = "lab"
)

func NewClientFacingSleepCycleSourceTypeFromString(s string) (ClientFacingSleepCycleSourceType, error) {
	switch s {
	case "unknown":
		return ClientFacingSleepCycleSourceTypeUnknown, nil
	case "phone":
		return ClientFacingSleepCycleSourceTypePhone, nil
	case "watch":
		return ClientFacingSleepCycleSourceTypeWatch, nil
	case "app":
		return ClientFacingSleepCycleSourceTypeApp, nil
	case "multiple_sources":
		return ClientFacingSleepCycleSourceTypeMultipleSources, nil
	case "fingerprick":
		return ClientFacingSleepCycleSourceTypeFingerprick, nil
	case "cuff":
		return ClientFacingSleepCycleSourceTypeCuff, nil
	case "manual_scan":
		return ClientFacingSleepCycleSourceTypeManualScan, nil
	case "automatic":
		return ClientFacingSleepCycleSourceTypeAutomatic, nil
	case "scale":
		return ClientFacingSleepCycleSourceTypeScale, nil
	case "chest_strap":
		return ClientFacingSleepCycleSourceTypeChestStrap, nil
	case "ring":
		return ClientFacingSleepCycleSourceTypeRing, nil
	case "lab":
		return ClientFacingSleepCycleSourceTypeLab, nil
	}
	var t ClientFacingSleepCycleSourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepCycleSourceType) Ptr() *ClientFacingSleepCycleSourceType {
	return &c
}

type ClientFacingSleepHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingSleepHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.sleep.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.sleep.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.sleep.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingSleepHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepStream struct {
	Hrv             []*ClientFacingHrvTimeseries             `json:"hrv,omitempty" url:"hrv,omitempty"`
	Heartrate       []*ClientFacingHeartRateTimeseries       `json:"heartrate,omitempty" url:"heartrate,omitempty"`
	Hypnogram       []*ClientFacingHypnogramTimeseries       `json:"hypnogram,omitempty" url:"hypnogram,omitempty"`
	RespiratoryRate []*ClientFacingRespiratoryRateTimeseries `json:"respiratory_rate,omitempty" url:"respiratory_rate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSleepStream) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepStream(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Source summarizes where a sample or a summary is sourced from.
// At minimum, the source provider is always included.
type ClientFacingSource struct {
	// Provider slug. e.g., `oura`, `fitbit`, `garmin`.
	Provider string `json:"provider" url:"provider"`
	// The type of the data source (app or device) by which the summary or the timeseries data were recorded. This defaults to `unknown` when Vital cannot extract or infer that information
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The identifier of the app which recorded this summary. This is only applicable to multi-source providers like Apple Health and Android Health Connect.
	AppId *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// For workout stream timeseries, this is the standard sport slug of the workout with which the timeseries data are associated.
	//
	// For the `distance` timeseries, this is `wheelchair_pushing` if the user is a wheelchair user, or `null` otherwise.
	//
	// For all summary types and non-workout timeseries, this is always `null`.
	Sport *string `json:"sport,omitempty" url:"sport,omitempty"`
	// For workout stream timeseries, this is the workout ID with which the timeseries data are associated.
	//
	// For all other types, this is always `null`.
	WorkoutId *string `json:"workout_id,omitempty" url:"workout_id,omitempty"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSource) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSport struct {
	// This ID is unstable across environments. Use the slug instead.
	Id int `json:"id" url:"id"`
	// Sport's name
	Name string `json:"name" url:"name"`
	// Slug for designated sport
	Slug string `json:"slug" url:"slug"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingSport) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSport) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSport) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStandDurationChanged struct {
	EventType    ClientFacingStandDurationChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                    `json:"user_id" url:"user_id"`
	ClientUserId string                                    `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                    `json:"team_id" url:"team_id"`
	Data         *GroupedStandDuration                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStandDurationChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandDurationChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStandDurationChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStandDurationChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandDurationChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStandDurationChangedEventType string

const (
	ClientFacingStandDurationChangedEventTypeDailyDataStandDurationCreated ClientFacingStandDurationChangedEventType = "daily.data.stand_duration.created"
	ClientFacingStandDurationChangedEventTypeDailyDataStandDurationUpdated ClientFacingStandDurationChangedEventType = "daily.data.stand_duration.updated"
)

func NewClientFacingStandDurationChangedEventTypeFromString(s string) (ClientFacingStandDurationChangedEventType, error) {
	switch s {
	case "daily.data.stand_duration.created":
		return ClientFacingStandDurationChangedEventTypeDailyDataStandDurationCreated, nil
	case "daily.data.stand_duration.updated":
		return ClientFacingStandDurationChangedEventTypeDailyDataStandDurationUpdated, nil
	}
	var t ClientFacingStandDurationChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingStandDurationChangedEventType) Ptr() *ClientFacingStandDurationChangedEventType {
	return &c
}

type ClientFacingStandDurationHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStandDurationHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandDurationHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingStandDurationHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandDurationHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandDurationHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.stand_duration.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.stand_duration.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandDurationHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandDurationHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.stand_duration.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStandDurationHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStandDurationSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStandDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingStandDurationSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandDurationSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandDurationSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandDurationSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "min",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStandDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStandHourChanged struct {
	EventType    ClientFacingStandHourChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                `json:"user_id" url:"user_id"`
	ClientUserId string                                `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                `json:"team_id" url:"team_id"`
	Data         *GroupedStandHour                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStandHourChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandHourChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStandHourChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStandHourChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandHourChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStandHourChangedEventType string

const (
	ClientFacingStandHourChangedEventTypeDailyDataStandHourCreated ClientFacingStandHourChangedEventType = "daily.data.stand_hour.created"
	ClientFacingStandHourChangedEventTypeDailyDataStandHourUpdated ClientFacingStandHourChangedEventType = "daily.data.stand_hour.updated"
)

func NewClientFacingStandHourChangedEventTypeFromString(s string) (ClientFacingStandHourChangedEventType, error) {
	switch s {
	case "daily.data.stand_hour.created":
		return ClientFacingStandHourChangedEventTypeDailyDataStandHourCreated, nil
	case "daily.data.stand_hour.updated":
		return ClientFacingStandHourChangedEventTypeDailyDataStandHourUpdated, nil
	}
	var t ClientFacingStandHourChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingStandHourChangedEventType) Ptr() *ClientFacingStandHourChangedEventType {
	return &c
}

type ClientFacingStandHourHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStandHourHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandHourHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingStandHourHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandHourHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandHourHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.stand_hour.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.stand_hour.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandHourHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandHourHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.stand_hour.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStandHourHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStandHourSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStandHourSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandHourSample) Unit() string {
	return c.unit
}

func (c *ClientFacingStandHourSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandHourSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandHourSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandHourSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandHourSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStandHourSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStepsChanged struct {
	EventType    ClientFacingStepsChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                            `json:"user_id" url:"user_id"`
	ClientUserId string                            `json:"client_user_id" url:"client_user_id"`
	TeamId       string                            `json:"team_id" url:"team_id"`
	Data         *GroupedSteps                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStepsChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStepsChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStepsChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStepsChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStepsChangedEventType string

const (
	ClientFacingStepsChangedEventTypeDailyDataStepsCreated ClientFacingStepsChangedEventType = "daily.data.steps.created"
	ClientFacingStepsChangedEventTypeDailyDataStepsUpdated ClientFacingStepsChangedEventType = "daily.data.steps.updated"
)

func NewClientFacingStepsChangedEventTypeFromString(s string) (ClientFacingStepsChangedEventType, error) {
	switch s {
	case "daily.data.steps.created":
		return ClientFacingStepsChangedEventTypeDailyDataStepsCreated, nil
	case "daily.data.steps.updated":
		return ClientFacingStepsChangedEventTypeDailyDataStepsUpdated, nil
	}
	var t ClientFacingStepsChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingStepsChangedEventType) Ptr() *ClientFacingStepsChangedEventType {
	return &c
}

type ClientFacingStepsHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStepsHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStepsHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingStepsHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStepsHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStepsHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.steps.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.steps.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStepsHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.steps.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStepsHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStepsTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The number of steps sampled at the time or interval::count
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStepsTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStepsTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingStepsTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStepsTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStepsTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStepsTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStepsTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStream struct {
	// RPM for cycling, Steps per minute for running
	Cadence *ClientFacingStreamCadence `json:"cadence,omitempty" url:"cadence,omitempty"`
	// Corresponding time stamp in unix time for datapoint
	Time []int `json:"time,omitempty" url:"time,omitempty"`
	// Data points for altitude
	Altitude *ClientFacingStreamAltitude `json:"altitude,omitempty" url:"altitude,omitempty"`
	// Velocity in m/s
	VelocitySmooth *ClientFacingStreamVelocitySmooth `json:"velocity_smooth,omitempty" url:"velocity_smooth,omitempty"`
	// Heart rate in bpm
	Heartrate *ClientFacingStreamHeartrate `json:"heartrate,omitempty" url:"heartrate,omitempty"`
	// Latitude for data point
	Lat *ClientFacingStreamLat `json:"lat,omitempty" url:"lat,omitempty"`
	// Longitude for data point
	Lng *ClientFacingStreamLng `json:"lng,omitempty" url:"lng,omitempty"`
	// Cumulated distance for exercise
	Distance *ClientFacingStreamDistance `json:"distance,omitempty" url:"distance,omitempty"`
	// Power in watts
	Power *ClientFacingStreamPower `json:"power,omitempty" url:"power,omitempty"`
	// Resistance on bike
	Resistance *ClientFacingStreamResistance `json:"resistance,omitempty" url:"resistance,omitempty"`
	// Temperature stream measured by device in Celsius
	Temperature *ClientFacingStreamTemperature `json:"temperature,omitempty" url:"temperature,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStream) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStream(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Data points for altitude
type ClientFacingStreamAltitude struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamAltitudeFromDoubleOptionalList(value []*float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{DoubleOptionalList: value}
}

func NewClientFacingStreamAltitudeFromDoubleList(value []float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{DoubleList: value}
}

func (c *ClientFacingStreamAltitude) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamAltitude) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamAltitudeVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamAltitude) Accept(visitor ClientFacingStreamAltitudeVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// RPM for cycling, Steps per minute for running
type ClientFacingStreamCadence struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamCadenceFromDoubleOptionalList(value []*float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{DoubleOptionalList: value}
}

func NewClientFacingStreamCadenceFromDoubleList(value []float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{DoubleList: value}
}

func (c *ClientFacingStreamCadence) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamCadence) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamCadenceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamCadence) Accept(visitor ClientFacingStreamCadenceVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Cumulated distance for exercise
type ClientFacingStreamDistance struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamDistanceFromDoubleOptionalList(value []*float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{DoubleOptionalList: value}
}

func NewClientFacingStreamDistanceFromDoubleList(value []float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{DoubleList: value}
}

func (c *ClientFacingStreamDistance) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamDistance) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamDistanceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamDistance) Accept(visitor ClientFacingStreamDistanceVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Heart rate in bpm
type ClientFacingStreamHeartrate struct {
	IntegerOptionalList []*int
	IntegerList         []int
}

func NewClientFacingStreamHeartrateFromIntegerOptionalList(value []*int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{IntegerOptionalList: value}
}

func NewClientFacingStreamHeartrateFromIntegerList(value []int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{IntegerList: value}
}

func (c *ClientFacingStreamHeartrate) UnmarshalJSON(data []byte) error {
	var valueIntegerOptionalList []*int
	if err := json.Unmarshal(data, &valueIntegerOptionalList); err == nil {
		c.IntegerOptionalList = valueIntegerOptionalList
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamHeartrate) MarshalJSON() ([]byte, error) {
	if c.IntegerOptionalList != nil {
		return json.Marshal(c.IntegerOptionalList)
	}
	if c.IntegerList != nil {
		return json.Marshal(c.IntegerList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamHeartrateVisitor interface {
	VisitIntegerOptionalList([]*int) error
	VisitIntegerList([]int) error
}

func (c *ClientFacingStreamHeartrate) Accept(visitor ClientFacingStreamHeartrateVisitor) error {
	if c.IntegerOptionalList != nil {
		return visitor.VisitIntegerOptionalList(c.IntegerOptionalList)
	}
	if c.IntegerList != nil {
		return visitor.VisitIntegerList(c.IntegerList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Latitude for data point
type ClientFacingStreamLat struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamLatFromDoubleOptionalList(value []*float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{DoubleOptionalList: value}
}

func NewClientFacingStreamLatFromDoubleList(value []float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{DoubleList: value}
}

func (c *ClientFacingStreamLat) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLat) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamLatVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLat) Accept(visitor ClientFacingStreamLatVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Longitude for data point
type ClientFacingStreamLng struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamLngFromDoubleOptionalList(value []*float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{DoubleOptionalList: value}
}

func NewClientFacingStreamLngFromDoubleList(value []float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{DoubleList: value}
}

func (c *ClientFacingStreamLng) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLng) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamLngVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLng) Accept(visitor ClientFacingStreamLngVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Power in watts
type ClientFacingStreamPower struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamPowerFromDoubleOptionalList(value []*float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{DoubleOptionalList: value}
}

func NewClientFacingStreamPowerFromDoubleList(value []float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{DoubleList: value}
}

func (c *ClientFacingStreamPower) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamPower) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamPowerVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamPower) Accept(visitor ClientFacingStreamPowerVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Resistance on bike
type ClientFacingStreamResistance struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamResistanceFromDoubleOptionalList(value []*float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{DoubleOptionalList: value}
}

func NewClientFacingStreamResistanceFromDoubleList(value []float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{DoubleList: value}
}

func (c *ClientFacingStreamResistance) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamResistance) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamResistanceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamResistance) Accept(visitor ClientFacingStreamResistanceVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Temperature stream measured by device in Celsius
type ClientFacingStreamTemperature struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamTemperatureFromDoubleOptionalList(value []*float64) *ClientFacingStreamTemperature {
	return &ClientFacingStreamTemperature{DoubleOptionalList: value}
}

func NewClientFacingStreamTemperatureFromDoubleList(value []float64) *ClientFacingStreamTemperature {
	return &ClientFacingStreamTemperature{DoubleList: value}
}

func (c *ClientFacingStreamTemperature) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamTemperature) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamTemperatureVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamTemperature) Accept(visitor ClientFacingStreamTemperatureVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// Velocity in m/s
type ClientFacingStreamVelocitySmooth struct {
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamVelocitySmoothFromDoubleOptionalList(value []*float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{DoubleOptionalList: value}
}

func NewClientFacingStreamVelocitySmoothFromDoubleList(value []float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{DoubleList: value}
}

func (c *ClientFacingStreamVelocitySmooth) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamVelocitySmooth) MarshalJSON() ([]byte, error) {
	if c.DoubleOptionalList != nil {
		return json.Marshal(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return json.Marshal(c.DoubleList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStreamVelocitySmoothVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamVelocitySmooth) Accept(visitor ClientFacingStreamVelocitySmoothVisitor) error {
	if c.DoubleOptionalList != nil {
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	}
	if c.DoubleList != nil {
		return visitor.VisitDoubleList(c.DoubleList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingStressLevelChanged struct {
	EventType    ClientFacingStressLevelChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                  `json:"user_id" url:"user_id"`
	ClientUserId string                                  `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                  `json:"team_id" url:"team_id"`
	Data         *GroupedStressLevel                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStressLevelChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStressLevelChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStressLevelChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStressLevelChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStressLevelChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStressLevelChangedEventType string

const (
	ClientFacingStressLevelChangedEventTypeDailyDataStressLevelCreated ClientFacingStressLevelChangedEventType = "daily.data.stress_level.created"
	ClientFacingStressLevelChangedEventTypeDailyDataStressLevelUpdated ClientFacingStressLevelChangedEventType = "daily.data.stress_level.updated"
)

func NewClientFacingStressLevelChangedEventTypeFromString(s string) (ClientFacingStressLevelChangedEventType, error) {
	switch s {
	case "daily.data.stress_level.created":
		return ClientFacingStressLevelChangedEventTypeDailyDataStressLevelCreated, nil
	case "daily.data.stress_level.updated":
		return ClientFacingStressLevelChangedEventTypeDailyDataStressLevelUpdated, nil
	}
	var t ClientFacingStressLevelChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingStressLevelChangedEventType) Ptr() *ClientFacingStressLevelChangedEventType {
	return &c
}

type ClientFacingStressLevelHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStressLevelHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStressLevelHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingStressLevelHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStressLevelHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStressLevelHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.stress_level.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.stress_level.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStressLevelHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStressLevelHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.stress_level.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStressLevelHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStressLevelTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	Value     float64   `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingStressLevelTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStressLevelTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStressLevelTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStressLevelTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStressLevelTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStressLevelTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStressLevelTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// [Deprecated] GET /v2/team is in the process of being removed.
// Neither customers nor Dashboard should retrieve team settings and metadata directly.
//
// All must migrate to the Team endpoints of the Org Management API.
type ClientFacingTeam struct {
	Id                                       string                `json:"id" url:"id"`
	OrgId                                    string                `json:"org_id" url:"org_id"`
	Name                                     string                `json:"name" url:"name"`
	SvixAppId                                *string               `json:"svix_app_id,omitempty" url:"svix_app_id,omitempty"`
	ClientId                                 *string               `json:"client_id,omitempty" url:"client_id,omitempty"`
	ClientSecret                             *string               `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	AirtableApiKey                           *string               `json:"airtable_api_key,omitempty" url:"airtable_api_key,omitempty"`
	AirtableBaseId                           *string               `json:"airtable_base_id,omitempty" url:"airtable_base_id,omitempty"`
	WebhookSecret                            *string               `json:"webhook_secret,omitempty" url:"webhook_secret,omitempty"`
	ApiKey                                   *string               `json:"api_key,omitempty" url:"api_key,omitempty"`
	ApiKeys                                  []*ClientFacingApiKey `json:"api_keys,omitempty" url:"api_keys,omitempty"`
	Configuration                            *TeamConfig           `json:"configuration,omitempty" url:"configuration,omitempty"`
	TestkitsTextsEnabled                     bool                  `json:"testkits_texts_enabled" url:"testkits_texts_enabled"`
	LabTestsPatientCommunicationEnabled      bool                  `json:"lab_tests_patient_communication_enabled" url:"lab_tests_patient_communication_enabled"`
	LabTestsPatientSmsCommunicationEnabled   bool                  `json:"lab_tests_patient_sms_communication_enabled" url:"lab_tests_patient_sms_communication_enabled"`
	LabTestsPatientEmailCommunicationEnabled bool                  `json:"lab_tests_patient_email_communication_enabled" url:"lab_tests_patient_email_communication_enabled"`
	LogoUrl                                  *string               `json:"logo_url,omitempty" url:"logo_url,omitempty"`
	DelegatedFlow                            DelegatedFlowType     `json:"delegated_flow" url:"delegated_flow"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTeam) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTeam) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTeam
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTeam(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTeam) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTestKitOrderDetails struct {
	Data *ClientFacingTestkitOrder `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTestKitOrderDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTestKitOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTestKitOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTestKitOrderDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestKitOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a testkit order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingTestkitOrder struct {
	// The Vital TestKit Order ID
	Id string `json:"id" url:"id"`
	// Shipment object
	Shipment  *ClientFacingShipment `json:"shipment,omitempty" url:"shipment,omitempty"`
	CreatedAt time.Time             `json:"created_at" url:"created_at"`
	UpdatedAt time.Time             `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingTestkitOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingTestkitOrder) UnmarshalJSON(data []byte) error {
	type embed ClientFacingTestkitOrder
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingTestkitOrder(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestkitOrder) MarshalJSON() ([]byte, error) {
	type embed ClientFacingTestkitOrder
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingTestkitOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUser struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	// Your team id.
	TeamId string `json:"team_id" url:"team_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id" url:"client_user_id"`
	// When your item is created
	CreatedOn time.Time `json:"created_on" url:"created_on"`
	// A list of the users connected sources.
	ConnectedSources []*ConnectedSourceClientFacing `json:"connected_sources,omitempty" url:"connected_sources,omitempty"`
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	FallbackTimeZone *FallbackTimeZone `json:"fallback_time_zone,omitempty" url:"fallback_time_zone,omitempty"`
	// Fallback date of birth of the user, in YYYY-mm-dd format. Used for calculating max heartrate for providers that don not provide users' age.
	FallbackBirthDate *FallbackBirthDate `json:"fallback_birth_date,omitempty" url:"fallback_birth_date,omitempty"`
	// Starting bound for user [data ingestion bounds](https://docs.tryvital.io/wearables/providers/data-ingestion-bounds).
	IngestionStart *string `json:"ingestion_start,omitempty" url:"ingestion_start,omitempty"`
	// Ending bound for user [data ingestion bounds](https://docs.tryvital.io/wearables/providers/data-ingestion-bounds).
	IngestionEnd *string `json:"ingestion_end,omitempty" url:"ingestion_end,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingUser) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUser) UnmarshalJSON(data []byte) error {
	type embed ClientFacingUser
	var unmarshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingUser(unmarshaler.embed)
	c.CreatedOn = unmarshaler.CreatedOn.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUser) MarshalJSON() ([]byte, error) {
	type embed ClientFacingUser
	var marshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed:     embed(*c),
		CreatedOn: core.NewDateTime(c.CreatedOn),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingUser) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUserKey struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id" url:"client_user_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingUserKey) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUserKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUserKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUserKey(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUserKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUvExposureChanged struct {
	EventType    ClientFacingUvExposureChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                 `json:"user_id" url:"user_id"`
	ClientUserId string                                 `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                 `json:"team_id" url:"team_id"`
	Data         *GroupedUvExposure                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingUvExposureChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUvExposureChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUvExposureChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUvExposureChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUvExposureChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUvExposureChangedEventType string

const (
	ClientFacingUvExposureChangedEventTypeDailyDataUvExposureCreated ClientFacingUvExposureChangedEventType = "daily.data.uv_exposure.created"
	ClientFacingUvExposureChangedEventTypeDailyDataUvExposureUpdated ClientFacingUvExposureChangedEventType = "daily.data.uv_exposure.updated"
)

func NewClientFacingUvExposureChangedEventTypeFromString(s string) (ClientFacingUvExposureChangedEventType, error) {
	switch s {
	case "daily.data.uv_exposure.created":
		return ClientFacingUvExposureChangedEventTypeDailyDataUvExposureCreated, nil
	case "daily.data.uv_exposure.updated":
		return ClientFacingUvExposureChangedEventTypeDailyDataUvExposureUpdated, nil
	}
	var t ClientFacingUvExposureChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingUvExposureChangedEventType) Ptr() *ClientFacingUvExposureChangedEventType {
	return &c
}

type ClientFacingUvExposureHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingUvExposureHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUvExposureHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingUvExposureHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingUvExposureHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingUvExposureHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.uv_exposure.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.uv_exposure.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUvExposureHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingUvExposureHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.uv_exposure.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingUvExposureHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUvExposureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingUvExposureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUvExposureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingUvExposureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingUvExposureSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingUvExposureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "index" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "index", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUvExposureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingUvExposureSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "index",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingUvExposureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingVo2MaxChanged struct {
	EventType    ClientFacingVo2MaxChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                             `json:"user_id" url:"user_id"`
	ClientUserId string                             `json:"client_user_id" url:"client_user_id"`
	TeamId       string                             `json:"team_id" url:"team_id"`
	Data         *GroupedVo2Max                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingVo2MaxChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingVo2MaxChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingVo2MaxChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingVo2MaxChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingVo2MaxChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingVo2MaxChangedEventType string

const (
	ClientFacingVo2MaxChangedEventTypeDailyDataVo2MaxCreated ClientFacingVo2MaxChangedEventType = "daily.data.vo2_max.created"
	ClientFacingVo2MaxChangedEventTypeDailyDataVo2MaxUpdated ClientFacingVo2MaxChangedEventType = "daily.data.vo2_max.updated"
)

func NewClientFacingVo2MaxChangedEventTypeFromString(s string) (ClientFacingVo2MaxChangedEventType, error) {
	switch s {
	case "daily.data.vo2_max.created":
		return ClientFacingVo2MaxChangedEventTypeDailyDataVo2MaxCreated, nil
	case "daily.data.vo2_max.updated":
		return ClientFacingVo2MaxChangedEventTypeDailyDataVo2MaxUpdated, nil
	}
	var t ClientFacingVo2MaxChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingVo2MaxChangedEventType) Ptr() *ClientFacingVo2MaxChangedEventType {
	return &c
}

type ClientFacingVo2MaxHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingVo2MaxHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingVo2MaxHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingVo2MaxHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingVo2MaxHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingVo2MaxHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.vo2_max.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.vo2_max.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingVo2MaxHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingVo2MaxHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.vo2_max.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingVo2MaxHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingVo2MaxTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mL/kg/min.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingVo2MaxTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingVo2MaxTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingVo2MaxTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingVo2MaxTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingVo2MaxTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingVo2MaxTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingVo2MaxTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWalkInOrderDetails struct {
	Data *ClientFacingWalkInTestOrder `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWalkInOrderDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWalkInOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWalkInOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWalkInOrderDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a walk-in test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingWalkInTestOrder struct {
	// The Vital walk-in test Order ID
	Id            string    `json:"id" url:"id"`
	CreatedAt     time.Time `json:"created_at" url:"created_at"`
	UpdatedAt     time.Time `json:"updated_at" url:"updated_at"`
	AppointmentId *string   `json:"appointment_id,omitempty" url:"appointment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWalkInTestOrder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWalkInTestOrder) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWalkInTestOrder
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWalkInTestOrder(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInTestOrder) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWalkInTestOrder
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWalkInTestOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWaterChanged struct {
	EventType    ClientFacingWaterChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                            `json:"user_id" url:"user_id"`
	ClientUserId string                            `json:"client_user_id" url:"client_user_id"`
	TeamId       string                            `json:"team_id" url:"team_id"`
	Data         *GroupedWater                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWaterChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaterChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWaterChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWaterChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWaterChangedEventType string

const (
	ClientFacingWaterChangedEventTypeDailyDataWaterCreated ClientFacingWaterChangedEventType = "daily.data.water.created"
	ClientFacingWaterChangedEventTypeDailyDataWaterUpdated ClientFacingWaterChangedEventType = "daily.data.water.updated"
)

func NewClientFacingWaterChangedEventTypeFromString(s string) (ClientFacingWaterChangedEventType, error) {
	switch s {
	case "daily.data.water.created":
		return ClientFacingWaterChangedEventTypeDailyDataWaterCreated, nil
	case "daily.data.water.updated":
		return ClientFacingWaterChangedEventTypeDailyDataWaterUpdated, nil
	}
	var t ClientFacingWaterChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWaterChangedEventType) Ptr() *ClientFacingWaterChangedEventType {
	return &c
}

type ClientFacingWaterHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWaterHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaterHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingWaterHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWaterHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWaterHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.water.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.water.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWaterHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.water.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWaterHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWaterTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in milliters.
	Unit     string                          `json:"unit" url:"unit"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Quantity of water drank during the time period.
	Value float64 `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWaterTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaterTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWaterTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWaterTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWaterTimeseries
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWaterTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWeightChanged struct {
	EventType    ClientFacingWeightChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                             `json:"user_id" url:"user_id"`
	ClientUserId string                             `json:"client_user_id" url:"client_user_id"`
	TeamId       string                             `json:"team_id" url:"team_id"`
	Data         *GroupedBodyWeight                 `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWeightChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWeightChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWeightChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWeightChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWeightChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWeightChangedEventType string

const (
	ClientFacingWeightChangedEventTypeDailyDataWeightCreated ClientFacingWeightChangedEventType = "daily.data.weight.created"
	ClientFacingWeightChangedEventTypeDailyDataWeightUpdated ClientFacingWeightChangedEventType = "daily.data.weight.updated"
)

func NewClientFacingWeightChangedEventTypeFromString(s string) (ClientFacingWeightChangedEventType, error) {
	switch s {
	case "daily.data.weight.created":
		return ClientFacingWeightChangedEventTypeDailyDataWeightCreated, nil
	case "daily.data.weight.updated":
		return ClientFacingWeightChangedEventTypeDailyDataWeightUpdated, nil
	}
	var t ClientFacingWeightChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWeightChangedEventType) Ptr() *ClientFacingWeightChangedEventType {
	return &c
}

type ClientFacingWeightHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWeightHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWeightHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingWeightHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWeightHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWeightHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.weight.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.weight.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWeightHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWeightHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.weight.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWeightHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWheelchairPushChanged struct {
	EventType    ClientFacingWheelchairPushChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                     `json:"user_id" url:"user_id"`
	ClientUserId string                                     `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                     `json:"team_id" url:"team_id"`
	Data         *GroupedWheelchairPush                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWheelchairPushChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWheelchairPushChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWheelchairPushChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWheelchairPushChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWheelchairPushChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWheelchairPushChangedEventType string

const (
	ClientFacingWheelchairPushChangedEventTypeDailyDataWheelchairPushCreated ClientFacingWheelchairPushChangedEventType = "daily.data.wheelchair_push.created"
	ClientFacingWheelchairPushChangedEventTypeDailyDataWheelchairPushUpdated ClientFacingWheelchairPushChangedEventType = "daily.data.wheelchair_push.updated"
)

func NewClientFacingWheelchairPushChangedEventTypeFromString(s string) (ClientFacingWheelchairPushChangedEventType, error) {
	switch s {
	case "daily.data.wheelchair_push.created":
		return ClientFacingWheelchairPushChangedEventTypeDailyDataWheelchairPushCreated, nil
	case "daily.data.wheelchair_push.updated":
		return ClientFacingWheelchairPushChangedEventTypeDailyDataWheelchairPushUpdated, nil
	}
	var t ClientFacingWheelchairPushChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWheelchairPushChangedEventType) Ptr() *ClientFacingWheelchairPushChangedEventType {
	return &c
}

type ClientFacingWheelchairPushHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWheelchairPushHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWheelchairPushHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingWheelchairPushHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWheelchairPushHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWheelchairPushHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.wheelchair_push.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.wheelchair_push.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWheelchairPushHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWheelchairPushHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.wheelchair_push.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWheelchairPushHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWheelchairPushSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWheelchairPushSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWheelchairPushSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWheelchairPushSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWheelchairPushSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWheelchairPushSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWheelchairPushSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWheelchairPushSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWheelchairPushSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkout struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	Id     string `json:"id" url:"id"`
	// Title given for the workout
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Average heart rate during workout::bpm
	AverageHr *int `json:"average_hr,omitempty" url:"average_hr,omitempty"`
	// Max heart rate during workout::bpm
	MaxHr *int `json:"max_hr,omitempty" url:"max_hr,omitempty"`
	// Distance travelled during workout::meters
	Distance *float64 `json:"distance,omitempty" url:"distance,omitempty"`
	// Date of the workout summary in the YYYY-mm-dd format. This generally matches the workout start date.
	CalendarDate string `json:"calendar_date" url:"calendar_date"`
	// Start time of the workout::time
	TimeStart time.Time `json:"time_start" url:"time_start"`
	// End time of the workout::time
	TimeEnd time.Time `json:"time_end" url:"time_end"`
	// Calories burned during the workout::kCal
	Calories *float64 `json:"calories,omitempty" url:"calories,omitempty"`
	// Sport's name
	Sport *ClientFacingSport `json:"sport,omitempty" url:"sport,omitempty"`
	// Time in seconds spent in different heart rate zones <50%, 50-60%, 60-70%, 70-80%, 80-90%, 90%+. Due to rounding errors, it's possible that summing all values is different than the total time of the workout. Not available for all providers::seconds
	HrZones []int `json:"hr_zones,omitempty" url:"hr_zones,omitempty"`
	// Time spent active during the workout::seconds
	MovingTime *int `json:"moving_time,omitempty" url:"moving_time,omitempty"`
	// Elevation gain during the workout::meters
	TotalElevationGain *float64 `json:"total_elevation_gain,omitempty" url:"total_elevation_gain,omitempty"`
	// Highest point of elevation::meters
	ElevHigh *float64 `json:"elev_high,omitempty" url:"elev_high,omitempty"`
	// Lowest point of elevation::meters
	ElevLow *float64 `json:"elev_low,omitempty" url:"elev_low,omitempty"`
	// Average speed during workout in m/s::meters/sec
	AverageSpeed *float64 `json:"average_speed,omitempty" url:"average_speed,omitempty"`
	// Max speed during workout in m/s::meters/sec
	MaxSpeed *float64 `json:"max_speed,omitempty" url:"max_speed,omitempty"`
	// Average watts burned during exercise::watts
	AverageWatts *float64 `json:"average_watts,omitempty" url:"average_watts,omitempty"`
	// Watts burned during exercise::watts
	DeviceWatts *float64 `json:"device_watts,omitempty" url:"device_watts,omitempty"`
	// Max watts burned during exercise::watts
	MaxWatts *float64 `json:"max_watts,omitempty" url:"max_watts,omitempty"`
	// Weighted average watts burned during exercise::watts
	WeightedAverageWatts *float64 `json:"weighted_average_watts,omitempty" url:"weighted_average_watts,omitempty"`
	// Number of steps accumulated during this workout::count
	Steps *int `json:"steps,omitempty" url:"steps,omitempty"`
	// Map of the workout
	Map *ClientFacingWorkoutMap `json:"map,omitempty" url:"map,omitempty"`
	// Provider ID given for that specific workout
	ProviderId string `json:"provider_id" url:"provider_id"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkout) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkout) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkout
	var unmarshaler = struct {
		embed
		TimeStart *core.DateTime `json:"time_start"`
		TimeEnd   *core.DateTime `json:"time_end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkout(unmarshaler.embed)
	c.TimeStart = unmarshaler.TimeStart.Time()
	c.TimeEnd = unmarshaler.TimeEnd.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkout) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkout
	var marshaler = struct {
		embed
		TimeStart *core.DateTime `json:"time_start"`
		TimeEnd   *core.DateTime `json:"time_end"`
	}{
		embed:     embed(*c),
		TimeStart: core.NewDateTime(c.TimeStart),
		TimeEnd:   core.NewDateTime(c.TimeEnd),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWorkout) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationChanged struct {
	EventType    ClientFacingWorkoutDurationChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                      `json:"user_id" url:"user_id"`
	ClientUserId string                                      `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                      `json:"team_id" url:"team_id"`
	Data         *GroupedWorkoutDuration                     `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutDurationChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDurationChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkoutDurationChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDurationChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDurationChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationChangedEventType string

const (
	ClientFacingWorkoutDurationChangedEventTypeDailyDataWorkoutDurationCreated ClientFacingWorkoutDurationChangedEventType = "daily.data.workout_duration.created"
	ClientFacingWorkoutDurationChangedEventTypeDailyDataWorkoutDurationUpdated ClientFacingWorkoutDurationChangedEventType = "daily.data.workout_duration.updated"
)

func NewClientFacingWorkoutDurationChangedEventTypeFromString(s string) (ClientFacingWorkoutDurationChangedEventType, error) {
	switch s {
	case "daily.data.workout_duration.created":
		return ClientFacingWorkoutDurationChangedEventTypeDailyDataWorkoutDurationCreated, nil
	case "daily.data.workout_duration.updated":
		return ClientFacingWorkoutDurationChangedEventTypeDailyDataWorkoutDurationUpdated, nil
	}
	var t ClientFacingWorkoutDurationChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutDurationChangedEventType) Ptr() *ClientFacingWorkoutDurationChangedEventType {
	return &c
}

type ClientFacingWorkoutDurationHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutDurationHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDurationHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingWorkoutDurationHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutDurationHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDurationHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.workout_duration.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.workout_duration.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDurationHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDurationHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.workout_duration.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWorkoutDurationHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement. This is applicable only to Cholesterol, IGG, IGE and InsulinInjection.
	Type     *string                         `json:"type,omitempty" url:"type,omitempty"`
	Grouping *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Workout intensity.
	Intensity *ClientFacingWorkoutDurationSampleIntensity `json:"intensity,omitempty" url:"intensity,omitempty"`
	unit      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutDurationSample
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDurationSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDurationSample
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		Unit      string         `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: core.NewDateTime(c.Timestamp),
		Start:     core.NewDateTime(c.Start),
		End:       core.NewDateTime(c.End),
		Unit:      "min",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWorkoutDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSampleIntensity string

const (
	ClientFacingWorkoutDurationSampleIntensityLow    ClientFacingWorkoutDurationSampleIntensity = "low"
	ClientFacingWorkoutDurationSampleIntensityMedium ClientFacingWorkoutDurationSampleIntensity = "medium"
	ClientFacingWorkoutDurationSampleIntensityHigh   ClientFacingWorkoutDurationSampleIntensity = "high"
)

func NewClientFacingWorkoutDurationSampleIntensityFromString(s string) (ClientFacingWorkoutDurationSampleIntensity, error) {
	switch s {
	case "low":
		return ClientFacingWorkoutDurationSampleIntensityLow, nil
	case "medium":
		return ClientFacingWorkoutDurationSampleIntensityMedium, nil
	case "high":
		return ClientFacingWorkoutDurationSampleIntensityHigh, nil
	}
	var t ClientFacingWorkoutDurationSampleIntensity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutDurationSampleIntensity) Ptr() *ClientFacingWorkoutDurationSampleIntensity {
	return &c
}

type ClientFacingWorkoutMap struct {
	// Polyline of the map
	Polyline *string `json:"polyline,omitempty" url:"polyline,omitempty"`
	// A lower resolution summary of the polyline
	SummaryPolyline *string `json:"summary_polyline,omitempty" url:"summary_polyline,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutMap) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutMap) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkoutMap
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkoutMap(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutMap) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutStreamChanged struct {
	EventType    ClientFacingWorkoutStreamChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                                    `json:"user_id" url:"user_id"`
	ClientUserId string                                    `json:"client_user_id" url:"client_user_id"`
	TeamId       string                                    `json:"team_id" url:"team_id"`
	Data         *ClientFacingShallowWorkoutStream         `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutStreamChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutStreamChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkoutStreamChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkoutStreamChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutStreamChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutStreamChangedEventType string

const (
	ClientFacingWorkoutStreamChangedEventTypeDailyDataWorkoutStreamCreated ClientFacingWorkoutStreamChangedEventType = "daily.data.workout_stream.created"
	ClientFacingWorkoutStreamChangedEventTypeDailyDataWorkoutStreamUpdated ClientFacingWorkoutStreamChangedEventType = "daily.data.workout_stream.updated"
)

func NewClientFacingWorkoutStreamChangedEventTypeFromString(s string) (ClientFacingWorkoutStreamChangedEventType, error) {
	switch s {
	case "daily.data.workout_stream.created":
		return ClientFacingWorkoutStreamChangedEventTypeDailyDataWorkoutStreamCreated, nil
	case "daily.data.workout_stream.updated":
		return ClientFacingWorkoutStreamChangedEventTypeDailyDataWorkoutStreamUpdated, nil
	}
	var t ClientFacingWorkoutStreamChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutStreamChangedEventType) Ptr() *ClientFacingWorkoutStreamChangedEventType {
	return &c
}

type ClientFacingWorkoutStreamHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutStreamHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutStreamHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingWorkoutStreamHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutStreamHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutStreamHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.workout_stream.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.workout_stream.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutStreamHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutStreamHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.workout_stream.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWorkoutStreamHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutsChanged struct {
	EventType    ClientFacingWorkoutsChangedEventType `json:"event_type" url:"event_type"`
	UserId       string                               `json:"user_id" url:"user_id"`
	ClientUserId string                               `json:"client_user_id" url:"client_user_id"`
	TeamId       string                               `json:"team_id" url:"team_id"`
	Data         *ClientFacingWorkout                 `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutsChanged) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutsChanged) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkoutsChanged
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkoutsChanged(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutsChanged) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutsChangedEventType string

const (
	ClientFacingWorkoutsChangedEventTypeDailyDataWorkoutsCreated ClientFacingWorkoutsChangedEventType = "daily.data.workouts.created"
	ClientFacingWorkoutsChangedEventTypeDailyDataWorkoutsUpdated ClientFacingWorkoutsChangedEventType = "daily.data.workouts.updated"
)

func NewClientFacingWorkoutsChangedEventTypeFromString(s string) (ClientFacingWorkoutsChangedEventType, error) {
	switch s {
	case "daily.data.workouts.created":
		return ClientFacingWorkoutsChangedEventTypeDailyDataWorkoutsCreated, nil
	case "daily.data.workouts.updated":
		return ClientFacingWorkoutsChangedEventTypeDailyDataWorkoutsUpdated, nil
	}
	var t ClientFacingWorkoutsChangedEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutsChangedEventType) Ptr() *ClientFacingWorkoutsChangedEventType {
	return &c
}

type ClientFacingWorkoutsHistoricalPullCompleted struct {
	UserId       string                   `json:"user_id" url:"user_id"`
	ClientUserId string                   `json:"client_user_id" url:"client_user_id"`
	TeamId       string                   `json:"team_id" url:"team_id"`
	Data         *HistoricalPullCompleted `json:"data,omitempty" url:"data,omitempty"`
	eventType    string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientFacingWorkoutsHistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutsHistoricalPullCompleted) EventType() string {
	return c.eventType
}

func (c *ClientFacingWorkoutsHistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutsHistoricalPullCompleted
	var unmarshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutsHistoricalPullCompleted(unmarshaler.embed)
	if unmarshaler.EventType != "historical.data.workouts.created" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "historical.data.workouts.created", unmarshaler.EventType)
	}
	c.eventType = unmarshaler.EventType

	extraProperties, err := core.ExtractExtraProperties(data, *c, "event_type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutsHistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutsHistoricalPullCompleted
	var marshaler = struct {
		embed
		EventType string `json:"event_type"`
	}{
		embed:     embed(*c),
		EventType: "historical.data.workouts.created",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWorkoutsHistoricalPullCompleted) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientSleepCycleResponse struct {
	SleepCycle []*ClientFacingSleepCycle `json:"sleep_cycle,omitempty" url:"sleep_cycle,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientSleepCycleResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientSleepCycleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSleepCycleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSleepCycleResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSleepCycleResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientSleepResponse struct {
	Sleep []*ClientFacingSleep `json:"sleep,omitempty" url:"sleep,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientSleepResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientSleepResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSleepResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSleepResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSleepResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientUserIdConflict struct {
	ErrorType    string    `json:"error_type" url:"error_type"`
	ErrorMessage string    `json:"error_message" url:"error_message"`
	UserId       string    `json:"user_id" url:"user_id"`
	CreatedOn    time.Time `json:"created_on" url:"created_on"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientUserIdConflict) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientUserIdConflict) UnmarshalJSON(data []byte) error {
	type embed ClientUserIdConflict
	var unmarshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientUserIdConflict(unmarshaler.embed)
	c.CreatedOn = unmarshaler.CreatedOn.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientUserIdConflict) MarshalJSON() ([]byte, error) {
	type embed ClientUserIdConflict
	var marshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed:     embed(*c),
		CreatedOn: core.NewDateTime(c.CreatedOn),
	}
	return json.Marshal(marshaler)
}

func (c *ClientUserIdConflict) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientUserIdConflictResponse struct {
	Detail *ClientUserIdConflict `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientUserIdConflictResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientUserIdConflictResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientUserIdConflictResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientUserIdConflictResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientUserIdConflictResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientWorkoutResponse struct {
	Workouts []*ClientFacingWorkout `json:"workouts,omitempty" url:"workouts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientWorkoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientWorkoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientWorkoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientWorkoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientWorkoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompanyDetails struct {
	Name    string   `json:"name" url:"name"`
	Address *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CompanyDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompanyDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectedSourceClientFacing struct {
	// The provider of this connected source.
	Provider *ClientFacingProvider `json:"provider,omitempty" url:"provider,omitempty"`
	// When your item is created
	CreatedOn time.Time `json:"created_on" url:"created_on"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Source *ClientFacingProvider `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConnectedSourceClientFacing) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectedSourceClientFacing) UnmarshalJSON(data []byte) error {
	type embed ConnectedSourceClientFacing
	var unmarshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConnectedSourceClientFacing(unmarshaler.embed)
	c.CreatedOn = unmarshaler.CreatedOn.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectedSourceClientFacing) MarshalJSON() ([]byte, error) {
	type embed ConnectedSourceClientFacing
	var marshaler = struct {
		embed
		CreatedOn *core.DateTime `json:"created_on"`
	}{
		embed:     embed(*c),
		CreatedOn: core.NewDateTime(c.CreatedOn),
	}
	return json.Marshal(marshaler)
}

func (c *ConnectedSourceClientFacing) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionRecipe struct {
	// Vital User ID. The user must be created ahead of the bulk import operation.
	UserId string `json:"user_id" url:"user_id"`
	// - OAuth 2.0 providers (Fitbit, etc): The latest Access Token.
	// - OAuth 1.0 providers (Garmin): The Access Token.
	AccessToken string `json:"access_token" url:"access_token"`
	// - OAuth 2.0 providers (Fitbit, etc): The latest Refresh Token.
	// - OAuth 1.0 providers (Garmin): The Token Secret.
	RefreshToken string `json:"refresh_token" url:"refresh_token"`
	// User ID of the data provider.
	//
	// - Fitbit: 6-character Fitbit User ID
	// - Garmin: 36-character Garmin User ID
	ProviderId string `json:"provider_id" url:"provider_id"`
	// Access token expiry date, in terms of UNIX epoch seconds.
	//
	// - OAuth 2.0 providers (Fitbit, etc): The latest expiry date on your record.
	// - OAuth 1.0 providers (Garmin): Use the constant value `2147483647`.
	ExpiresAt int `json:"expires_at" url:"expires_at"`
	// OAuth scopes of the data provider. Specify `null` if you do not
	// have any scopes on record.
	//
	// - Fitbit: Has scopes
	// - Garmin: No scope
	OauthScopes []string `json:"oauth_scopes,omitempty" url:"oauth_scopes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConnectionRecipe) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectionRecipe) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionRecipe
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionRecipe(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionRecipe) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Consent struct {
	ConsentType   ConsentType `json:"consentType" url:"consentType"`
	Version       *string     `json:"version,omitempty" url:"version,omitempty"`
	TimeOfConsent *time.Time  `json:"timeOfConsent,omitempty" url:"timeOfConsent,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Consent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Consent) UnmarshalJSON(data []byte) error {
	type embed Consent
	var unmarshaler = struct {
		embed
		TimeOfConsent *core.DateTime `json:"timeOfConsent,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Consent(unmarshaler.embed)
	c.TimeOfConsent = unmarshaler.TimeOfConsent.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Consent) MarshalJSON() ([]byte, error) {
	type embed Consent
	var marshaler = struct {
		embed
		TimeOfConsent *core.DateTime `json:"timeOfConsent,omitempty"`
	}{
		embed:         embed(*c),
		TimeOfConsent: core.NewOptionalDateTime(c.TimeOfConsent),
	}
	return json.Marshal(marshaler)
}

func (c *Consent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConsentType string

const (
	ConsentTypeTermsOfUse                ConsentType = "terms-of-use"
	ConsentTypeTelehealthInformedConsent ConsentType = "telehealth-informed-consent"
	ConsentTypeMobileTermsAndConditions  ConsentType = "mobile-terms-and-conditions"
	ConsentTypeNoticeOfPrivacyPractices  ConsentType = "notice-of-privacy-practices"
	ConsentTypePrivacyPolicy             ConsentType = "privacy-policy"
	ConsentTypeHipaaAuthorization        ConsentType = "hipaa-authorization"
)

func NewConsentTypeFromString(s string) (ConsentType, error) {
	switch s {
	case "terms-of-use":
		return ConsentTypeTermsOfUse, nil
	case "telehealth-informed-consent":
		return ConsentTypeTelehealthInformedConsent, nil
	case "mobile-terms-and-conditions":
		return ConsentTypeMobileTermsAndConditions, nil
	case "notice-of-privacy-practices":
		return ConsentTypeNoticeOfPrivacyPractices, nil
	case "privacy-policy":
		return ConsentTypePrivacyPolicy, nil
	case "hipaa-authorization":
		return ConsentTypeHipaaAuthorization, nil
	}
	var t ConsentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsentType) Ptr() *ConsentType {
	return &c
}

type ContinuousQueryResultTableChanges struct {
	QueryId   string                   `json:"query_id" url:"query_id"`
	QuerySlug string                   `json:"query_slug" url:"query_slug"`
	Data      map[string][]interface{} `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ContinuousQueryResultTableChanges) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContinuousQueryResultTableChanges) UnmarshalJSON(data []byte) error {
	type unmarshaler ContinuousQueryResultTableChanges
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContinuousQueryResultTableChanges(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContinuousQueryResultTableChanges) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContraceptiveEntry struct {
	Date string                 `json:"date" url:"date"`
	Type ContraceptiveEntryType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ContraceptiveEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContraceptiveEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ContraceptiveEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContraceptiveEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContraceptiveEntry) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContraceptiveEntryType string

const (
	ContraceptiveEntryTypeUnspecified      ContraceptiveEntryType = "unspecified"
	ContraceptiveEntryTypeImplant          ContraceptiveEntryType = "implant"
	ContraceptiveEntryTypeInjection        ContraceptiveEntryType = "injection"
	ContraceptiveEntryTypeIud              ContraceptiveEntryType = "iud"
	ContraceptiveEntryTypeIntravaginalRing ContraceptiveEntryType = "intravaginal_ring"
	ContraceptiveEntryTypeOral             ContraceptiveEntryType = "oral"
	ContraceptiveEntryTypePatch            ContraceptiveEntryType = "patch"
)

func NewContraceptiveEntryTypeFromString(s string) (ContraceptiveEntryType, error) {
	switch s {
	case "unspecified":
		return ContraceptiveEntryTypeUnspecified, nil
	case "implant":
		return ContraceptiveEntryTypeImplant, nil
	case "injection":
		return ContraceptiveEntryTypeInjection, nil
	case "iud":
		return ContraceptiveEntryTypeIud, nil
	case "intravaginal_ring":
		return ContraceptiveEntryTypeIntravaginalRing, nil
	case "oral":
		return ContraceptiveEntryTypeOral, nil
	case "patch":
		return ContraceptiveEntryTypePatch, nil
	}
	var t ContraceptiveEntryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContraceptiveEntryType) Ptr() *ContraceptiveEntryType {
	return &c
}

type DatePartExpr struct {
	Arg      *DatePartExprArg     `json:"arg,omitempty" url:"arg,omitempty"`
	DatePart DatePartExprDatePart `json:"date_part" url:"date_part"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DatePartExpr) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DatePartExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler DatePartExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatePartExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatePartExpr) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DatePartExprArg struct {
	IndexColumnExpr *IndexColumnExpr
	Placeholder     *Placeholder
}

func NewDatePartExprArgFromIndexColumnExpr(value *IndexColumnExpr) *DatePartExprArg {
	return &DatePartExprArg{IndexColumnExpr: value}
}

func NewDatePartExprArgFromPlaceholder(value *Placeholder) *DatePartExprArg {
	return &DatePartExprArg{Placeholder: value}
}

func (d *DatePartExprArg) UnmarshalJSON(data []byte) error {
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		d.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		d.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DatePartExprArg) MarshalJSON() ([]byte, error) {
	if d.IndexColumnExpr != nil {
		return json.Marshal(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return json.Marshal(d.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DatePartExprArgVisitor interface {
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitPlaceholder(*Placeholder) error
}

func (d *DatePartExprArg) Accept(visitor DatePartExprArgVisitor) error {
	if d.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return visitor.VisitPlaceholder(d.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DatePartExprDatePart string

const (
	DatePartExprDatePartMinute     DatePartExprDatePart = "minute"
	DatePartExprDatePartHour       DatePartExprDatePart = "hour"
	DatePartExprDatePartDay        DatePartExprDatePart = "day"
	DatePartExprDatePartWeek       DatePartExprDatePart = "week"
	DatePartExprDatePartMonth      DatePartExprDatePart = "month"
	DatePartExprDatePartYear       DatePartExprDatePart = "year"
	DatePartExprDatePartWeekday    DatePartExprDatePart = "weekday"
	DatePartExprDatePartWeekOfYear DatePartExprDatePart = "week_of_year"
	DatePartExprDatePartDayOfYear  DatePartExprDatePart = "day_of_year"
)

func NewDatePartExprDatePartFromString(s string) (DatePartExprDatePart, error) {
	switch s {
	case "minute":
		return DatePartExprDatePartMinute, nil
	case "hour":
		return DatePartExprDatePartHour, nil
	case "day":
		return DatePartExprDatePartDay, nil
	case "week":
		return DatePartExprDatePartWeek, nil
	case "month":
		return DatePartExprDatePartMonth, nil
	case "year":
		return DatePartExprDatePartYear, nil
	case "weekday":
		return DatePartExprDatePartWeekday, nil
	case "week_of_year":
		return DatePartExprDatePartWeekOfYear, nil
	case "day_of_year":
		return DatePartExprDatePartDayOfYear, nil
	}
	var t DatePartExprDatePart
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatePartExprDatePart) Ptr() *DatePartExprDatePart {
	return &d
}

type DateTruncExpr struct {
	DateTrunc *Period           `json:"date_trunc,omitempty" url:"date_trunc,omitempty"`
	Arg       *DateTruncExprArg `json:"arg,omitempty" url:"arg,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DateTruncExpr) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateTruncExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler DateTruncExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateTruncExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateTruncExpr) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DateTruncExprArg struct {
	IndexColumnExpr *IndexColumnExpr
	Placeholder     *Placeholder
}

func NewDateTruncExprArgFromIndexColumnExpr(value *IndexColumnExpr) *DateTruncExprArg {
	return &DateTruncExprArg{IndexColumnExpr: value}
}

func NewDateTruncExprArgFromPlaceholder(value *Placeholder) *DateTruncExprArg {
	return &DateTruncExprArg{Placeholder: value}
}

func (d *DateTruncExprArg) UnmarshalJSON(data []byte) error {
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		d.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		d.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DateTruncExprArg) MarshalJSON() ([]byte, error) {
	if d.IndexColumnExpr != nil {
		return json.Marshal(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return json.Marshal(d.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DateTruncExprArgVisitor interface {
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitPlaceholder(*Placeholder) error
}

func (d *DateTruncExprArg) Accept(visitor DateTruncExprArgVisitor) error {
	if d.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(d.IndexColumnExpr)
	}
	if d.Placeholder != nil {
		return visitor.VisitPlaceholder(d.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DaySlots struct {
	Location *AppointmentLocation `json:"location,omitempty" url:"location,omitempty"`
	Date     string               `json:"date" url:"date"`
	Slots    []*TimeSlot          `json:"slots,omitempty" url:"slots,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DaySlots) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DaySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler DaySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DaySlots(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DaySlots) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DelegatedFlowType string

const (
	DelegatedFlowTypeOrderAndResultsWithCustomerPhysicianNetwork DelegatedFlowType = "order_and_results_with_customer_physician_network"
	DelegatedFlowTypeOrderWithVitalPhysicianNetwork              DelegatedFlowType = "order_with_vital_physician_network"
	DelegatedFlowTypeOrderAndResultsWithVitalPhysicianNetwork    DelegatedFlowType = "order_and_results_with_vital_physician_network"
)

func NewDelegatedFlowTypeFromString(s string) (DelegatedFlowType, error) {
	switch s {
	case "order_and_results_with_customer_physician_network":
		return DelegatedFlowTypeOrderAndResultsWithCustomerPhysicianNetwork, nil
	case "order_with_vital_physician_network":
		return DelegatedFlowTypeOrderWithVitalPhysicianNetwork, nil
	case "order_and_results_with_vital_physician_network":
		return DelegatedFlowTypeOrderAndResultsWithVitalPhysicianNetwork, nil
	}
	var t DelegatedFlowType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DelegatedFlowType) Ptr() *DelegatedFlowType {
	return &d
}

type DemoConnectionStatus struct {
	Success bool   `json:"success" url:"success"`
	Detail  string `json:"detail" url:"detail"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DemoConnectionStatus) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DemoConnectionStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler DemoConnectionStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DemoConnectionStatus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DemoConnectionStatus) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DemoProviders string

const (
	DemoProvidersAppleHealthKit DemoProviders = "apple_health_kit"
	DemoProvidersFitbit         DemoProviders = "fitbit"
	DemoProvidersFreestyleLibre DemoProviders = "freestyle_libre"
	DemoProvidersOura           DemoProviders = "oura"
)

func NewDemoProvidersFromString(s string) (DemoProviders, error) {
	switch s {
	case "apple_health_kit":
		return DemoProvidersAppleHealthKit, nil
	case "fitbit":
		return DemoProvidersFitbit, nil
	case "freestyle_libre":
		return DemoProvidersFreestyleLibre, nil
	case "oura":
		return DemoProvidersOura, nil
	}
	var t DemoProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DemoProviders) Ptr() *DemoProviders {
	return &d
}

type DetectedDeviationEntry struct {
	Date      string                          `json:"date" url:"date"`
	Deviation DetectedDeviationEntryDeviation `json:"deviation" url:"deviation"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DetectedDeviationEntry) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetectedDeviationEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler DetectedDeviationEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetectedDeviationEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetectedDeviationEntry) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DetectedDeviationEntryDeviation string

const (
	DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding DetectedDeviationEntryDeviation = "persistent_intermenstrual_bleeding"
	DetectedDeviationEntryDeviationProlongedMenstrualPeriods        DetectedDeviationEntryDeviation = "prolonged_menstrual_periods"
	DetectedDeviationEntryDeviationIrregularMenstrualCycles         DetectedDeviationEntryDeviation = "irregular_menstrual_cycles"
	DetectedDeviationEntryDeviationInfrequentMenstrualCycles        DetectedDeviationEntryDeviation = "infrequent_menstrual_cycles"
)

func NewDetectedDeviationEntryDeviationFromString(s string) (DetectedDeviationEntryDeviation, error) {
	switch s {
	case "persistent_intermenstrual_bleeding":
		return DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding, nil
	case "prolonged_menstrual_periods":
		return DetectedDeviationEntryDeviationProlongedMenstrualPeriods, nil
	case "irregular_menstrual_cycles":
		return DetectedDeviationEntryDeviationIrregularMenstrualCycles, nil
	case "infrequent_menstrual_cycles":
		return DetectedDeviationEntryDeviationInfrequentMenstrualCycles, nil
	}
	var t DetectedDeviationEntryDeviation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DetectedDeviationEntryDeviation) Ptr() *DetectedDeviationEntryDeviation {
	return &d
}

type DeviceV2InDb struct {
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceV2InDb) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceV2InDb(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceV2InDb) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmailProviders = string

type Energy struct {
	Value float64 `json:"value" url:"value"`
	unit  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Energy) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Energy) Unit() string {
	return e.unit
}

func (e *Energy) UnmarshalJSON(data []byte) error {
	type embed Energy
	var unmarshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Energy(unmarshaler.embed)
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "kcal", unmarshaler.Unit)
	}
	e.unit = unmarshaler.Unit

	extraProperties, err := core.ExtractExtraProperties(data, *e, "unit")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Energy) MarshalJSON() ([]byte, error) {
	type embed Energy
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*e),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (e *Energy) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventDestinationPreferences struct {
	Preferred EventDestinationPreferencesPreferred     `json:"preferred" url:"preferred"`
	Enabled   []EventDestinationPreferencesEnabledItem `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventDestinationPreferences) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventDestinationPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler EventDestinationPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventDestinationPreferences(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventDestinationPreferences) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventDestinationPreferencesEnabledItem string

const (
	EventDestinationPreferencesEnabledItemCloudPubsub EventDestinationPreferencesEnabledItem = "cloud_pubsub"
	EventDestinationPreferencesEnabledItemRabbitmq    EventDestinationPreferencesEnabledItem = "rabbitmq"
	EventDestinationPreferencesEnabledItemSvix        EventDestinationPreferencesEnabledItem = "svix"
	EventDestinationPreferencesEnabledItemAzureAmqp   EventDestinationPreferencesEnabledItem = "azure_amqp"
)

func NewEventDestinationPreferencesEnabledItemFromString(s string) (EventDestinationPreferencesEnabledItem, error) {
	switch s {
	case "cloud_pubsub":
		return EventDestinationPreferencesEnabledItemCloudPubsub, nil
	case "rabbitmq":
		return EventDestinationPreferencesEnabledItemRabbitmq, nil
	case "svix":
		return EventDestinationPreferencesEnabledItemSvix, nil
	case "azure_amqp":
		return EventDestinationPreferencesEnabledItemAzureAmqp, nil
	}
	var t EventDestinationPreferencesEnabledItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventDestinationPreferencesEnabledItem) Ptr() *EventDestinationPreferencesEnabledItem {
	return &e
}

type EventDestinationPreferencesPreferred string

const (
	EventDestinationPreferencesPreferredCloudPubsub EventDestinationPreferencesPreferred = "cloud_pubsub"
	EventDestinationPreferencesPreferredRabbitmq    EventDestinationPreferencesPreferred = "rabbitmq"
	EventDestinationPreferencesPreferredSvix        EventDestinationPreferencesPreferred = "svix"
	EventDestinationPreferencesPreferredAzureAmqp   EventDestinationPreferencesPreferred = "azure_amqp"
)

func NewEventDestinationPreferencesPreferredFromString(s string) (EventDestinationPreferencesPreferred, error) {
	switch s {
	case "cloud_pubsub":
		return EventDestinationPreferencesPreferredCloudPubsub, nil
	case "rabbitmq":
		return EventDestinationPreferencesPreferredRabbitmq, nil
	case "svix":
		return EventDestinationPreferencesPreferredSvix, nil
	case "azure_amqp":
		return EventDestinationPreferencesPreferredAzureAmqp, nil
	}
	var t EventDestinationPreferencesPreferred
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventDestinationPreferencesPreferred) Ptr() *EventDestinationPreferencesPreferred {
	return &e
}

type FailureType string

const (
	FailureTypeQuantityNotSufficientFailure FailureType = "quantity_not_sufficient_failure"
	FailureTypeCollectionProcessFailure     FailureType = "collection_process_failure"
	FailureTypeDropOffFailure               FailureType = "drop_off_failure"
	FailureTypeInternalLabFailure           FailureType = "internal_lab_failure"
	FailureTypeOrderEntryFailure            FailureType = "order_entry_failure"
	FailureTypeNonFailure                   FailureType = "non_failure"
	FailureTypeUnknownFailure               FailureType = "unknown_failure"
	FailureTypePatientConditionFailure      FailureType = "patient_condition_failure"
	FailureTypeMissingResultCalcFailure     FailureType = "missing_result_calc_failure"
	FailureTypeMissingDemoAoeCalcFailure    FailureType = "missing_demo_aoe_calc_failure"
	FailureTypeInsufficientVolume           FailureType = "insufficient_volume"
)

func NewFailureTypeFromString(s string) (FailureType, error) {
	switch s {
	case "quantity_not_sufficient_failure":
		return FailureTypeQuantityNotSufficientFailure, nil
	case "collection_process_failure":
		return FailureTypeCollectionProcessFailure, nil
	case "drop_off_failure":
		return FailureTypeDropOffFailure, nil
	case "internal_lab_failure":
		return FailureTypeInternalLabFailure, nil
	case "order_entry_failure":
		return FailureTypeOrderEntryFailure, nil
	case "non_failure":
		return FailureTypeNonFailure, nil
	case "unknown_failure":
		return FailureTypeUnknownFailure, nil
	case "patient_condition_failure":
		return FailureTypePatientConditionFailure, nil
	case "missing_result_calc_failure":
		return FailureTypeMissingResultCalcFailure, nil
	case "missing_demo_aoe_calc_failure":
		return FailureTypeMissingDemoAoeCalcFailure, nil
	case "insufficient_volume":
		return FailureTypeInsufficientVolume, nil
	}
	var t FailureType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FailureType) Ptr() *FailureType {
	return &f
}

type FallbackBirthDate struct {
	// Fallback date of birth of the user, in YYYY-mm-dd format. Used for calculating max heartrate for providers that don not provide users' age.
	Value string `json:"value" url:"value"`
	// Slug for designated source
	SourceSlug string    `json:"source_slug" url:"source_slug"`
	UpdatedAt  time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FallbackBirthDate) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackBirthDate) UnmarshalJSON(data []byte) error {
	type embed FallbackBirthDate
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackBirthDate(unmarshaler.embed)
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackBirthDate) MarshalJSON() ([]byte, error) {
	type embed FallbackBirthDate
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*f),
		UpdatedAt: core.NewDateTime(f.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (f *FallbackBirthDate) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackTimeZone struct {
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	Id string `json:"id" url:"id"`
	// Slug for designated source
	SourceSlug string    `json:"source_slug" url:"source_slug"`
	UpdatedAt  time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FallbackTimeZone) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackTimeZone) UnmarshalJSON(data []byte) error {
	type embed FallbackTimeZone
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FallbackTimeZone(unmarshaler.embed)
	f.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTimeZone) MarshalJSON() ([]byte, error) {
	type embed FallbackTimeZone
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*f),
		UpdatedAt: core.NewDateTime(f.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (f *FallbackTimeZone) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Fats struct {
	// Amount of saturated fats in grams (g)
	Saturated *float64 `json:"saturated,omitempty" url:"saturated,omitempty"`
	// Amount of monounsaturated fats in grams (g)
	Monounsaturated *float64 `json:"monounsaturated,omitempty" url:"monounsaturated,omitempty"`
	// Amount of polyunsaturated fats in grams (g)
	Polyunsaturated *float64 `json:"polyunsaturated,omitempty" url:"polyunsaturated,omitempty"`
	// Amount of Omega-3 fatty acids in grams (g)
	Omega3 *float64 `json:"omega3,omitempty" url:"omega3,omitempty"`
	// Amount of Omega-6 fatty acids in grams (g)
	Omega6 *float64 `json:"omega6,omitempty" url:"omega6,omitempty"`
	// Total amount of fats in grams (g)
	Total *float64 `json:"total,omitempty" url:"total,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Fats) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fats) UnmarshalJSON(data []byte) error {
	type unmarshaler Fats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fats(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fats) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Gender string

const (
	GenderFemale  Gender = "female"
	GenderMale    Gender = "male"
	GenderOther   Gender = "other"
	GenderUnknown Gender = "unknown"
)

func NewGenderFromString(s string) (Gender, error) {
	switch s {
	case "female":
		return GenderFemale, nil
	case "male":
		return GenderMale, nil
	case "other":
		return GenderOther, nil
	case "unknown":
		return GenderUnknown, nil
	}
	var t Gender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g Gender) Ptr() *Gender {
	return &g
}

type GetMarkersResponse struct {
	Markers []*ClientFacingMarkerComplete `json:"markers,omitempty" url:"markers,omitempty"`
	Total   *int                          `json:"total,omitempty" url:"total,omitempty"`
	Page    *int                          `json:"page,omitempty" url:"page,omitempty"`
	Size    *int                          `json:"size,omitempty" url:"size,omitempty"`
	Pages   *int                          `json:"pages,omitempty" url:"pages,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetMarkersResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetMarkersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetMarkersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetMarkersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetMarkersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetOrdersResponse struct {
	Orders []*ClientFacingOrder `json:"orders,omitempty" url:"orders,omitempty"`
	Total  *int                 `json:"total,omitempty" url:"total,omitempty"`
	Page   *int                 `json:"page,omitempty" url:"page,omitempty"`
	Size   *int                 `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrdersResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrdersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupKeyColumnExpr struct {
	GroupKey *GroupKeyColumnExprGroupKey `json:"group_key,omitempty" url:"group_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupKeyColumnExpr) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupKeyColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupKeyColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupKeyColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupKeyColumnExpr) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupKeyColumnExprGroupKey struct {
	Integer int
	Select  Select
}

func NewGroupKeyColumnExprGroupKeyFromInteger(value int) *GroupKeyColumnExprGroupKey {
	return &GroupKeyColumnExprGroupKey{Integer: value}
}

func NewGroupKeyColumnExprGroupKeyFromSelect(value Select) *GroupKeyColumnExprGroupKey {
	return &GroupKeyColumnExprGroupKey{Select: value}
}

func (g *GroupKeyColumnExprGroupKey) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.Integer = valueInteger
		return nil
	}
	var valueSelect Select
	if err := json.Unmarshal(data, &valueSelect); err == nil {
		g.Select = valueSelect
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroupKeyColumnExprGroupKey) MarshalJSON() ([]byte, error) {
	if g.Integer != 0 {
		return json.Marshal(g.Integer)
	}
	if g.Select != "" {
		return json.Marshal(g.Select)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroupKeyColumnExprGroupKeyVisitor interface {
	VisitInteger(int) error
	VisitSelect(Select) error
}

func (g *GroupKeyColumnExprGroupKey) Accept(visitor GroupKeyColumnExprGroupKeyVisitor) error {
	if g.Integer != 0 {
		return visitor.VisitInteger(g.Integer)
	}
	if g.Select != "" {
		return visitor.VisitSelect(g.Select)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroupedAFibBurden struct {
	Source *ClientFacingSource             `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingAFibBurdenSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedAFibBurden) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAFibBurden) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAFibBurden
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAFibBurden(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAFibBurden) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedAFibBurdenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedAFibBurden `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedAFibBurdenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAFibBurdenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAFibBurdenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAFibBurdenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAFibBurdenResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBasalBodyTemperature struct {
	Source *ClientFacingSource                       `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBasalBodyTemperatureSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBasalBodyTemperature) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBasalBodyTemperature) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBasalBodyTemperature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBasalBodyTemperature(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBasalBodyTemperature) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBasalBodyTemperatureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBasalBodyTemperature `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBasalBodyTemperatureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBasalBodyTemperatureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBasalBodyTemperatureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBasalBodyTemperatureResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBasalBodyTemperatureResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodOxygen struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBloodOxygenTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodOxygen) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygen) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygen(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygen) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodOxygenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodOxygen `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodOxygenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygenResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodPressure struct {
	Source *ClientFacingSource                    `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBloodPressureTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodPressure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressure(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressure) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodPressureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodPressure `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBloodPressureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressureResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressureResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyFat struct {
	Source *ClientFacingSource              `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyFatTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyFat) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFat) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFat(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFat) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyFatResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyFat `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyFatResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFatResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFatResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyTemperature struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyTemperatureSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyTemperature) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperature) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperature(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperature) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyTemperatureDelta struct {
	Source *ClientFacingSource                       `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyTemperatureDeltaSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyTemperatureDelta) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureDelta(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureDelta) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyTemperatureDeltaResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyTemperatureDelta `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyTemperatureDeltaResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureDeltaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureDeltaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureDeltaResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureDeltaResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyTemperatureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyTemperature `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyTemperatureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyWeight struct {
	Source *ClientFacingSource                 `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingBodyWeightTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyWeight) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeight) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeight
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeight(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeight) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyWeightResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyWeight `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedBodyWeightResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeightResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeightResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeightResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeightResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaffeine struct {
	Source *ClientFacingSource               `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCaffeineTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaffeine) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeine) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeine(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeine) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaffeineResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaffeine `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaffeineResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeineResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeineResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeineResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeineResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesActive struct {
	Source *ClientFacingSource                     `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCaloriesActiveTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesActive) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActive) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActive(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActive) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesActiveResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesActive `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesActiveResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActiveResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActiveResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActiveResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActiveResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesBasal struct {
	Source *ClientFacingSource                    `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCaloriesBasalTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesBasal) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasal) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasal(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasal) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesBasalResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesBasal `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCaloriesBasalResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasalResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasalResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasalResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasalResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCarbohydrates struct {
	Source *ClientFacingSource                `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCarbohydratesSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCarbohydrates) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCarbohydrates) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCarbohydrates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCarbohydrates(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCarbohydrates) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCarbohydratesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCarbohydrates `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCarbohydratesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCarbohydratesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCarbohydratesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCarbohydratesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCarbohydratesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCholesterol struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingCholesterolTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCholesterol) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterol) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterol
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterol(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterol) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCholesterolResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCholesterol `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedCholesterolResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterolResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterolResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterolResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterolResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDaylightExposure struct {
	Source *ClientFacingSource                   `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingDaylightExposureSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedDaylightExposure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDaylightExposure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDaylightExposure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDaylightExposure(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDaylightExposure) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDaylightExposureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedDaylightExposure `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedDaylightExposureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDaylightExposureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDaylightExposureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDaylightExposureResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDaylightExposureResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDistance struct {
	Source *ClientFacingSource               `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingDistanceTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedDistance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistance) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDistanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedDistance `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedDistanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistanceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistanceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedElectrocardiogramVoltage struct {
	Source *ClientFacingSource                               `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingElectrocardiogramVoltageTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedElectrocardiogramVoltage) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltage) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedElectrocardiogramVoltageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedElectrocardiogramVoltage `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedElectrocardiogramVoltageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFall struct {
	Source *ClientFacingSource       `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingFallSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedFall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFall) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFall(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFall) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFallResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedFall `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedFallResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFallResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFallResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFallResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFallResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFloorsClimbed struct {
	Source *ClientFacingSource                    `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingFloorsClimbedTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedFloorsClimbed) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbed) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbed(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbed) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFloorsClimbedResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedFloorsClimbed `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedFloorsClimbedResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbedResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbedResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedForcedExpiratoryVolume1 struct {
	Source *ClientFacingSource                          `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingForcedExpiratoryVolume1Sample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedForcedExpiratoryVolume1) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedExpiratoryVolume1) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedExpiratoryVolume1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedExpiratoryVolume1(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedExpiratoryVolume1) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedForcedExpiratoryVolume1Response struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedForcedExpiratoryVolume1 `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedForcedExpiratoryVolume1Response) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedExpiratoryVolume1Response) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedExpiratoryVolume1Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedExpiratoryVolume1Response(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedExpiratoryVolume1Response) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedForcedVitalCapacity struct {
	Source *ClientFacingSource                      `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingForcedVitalCapacitySample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedForcedVitalCapacity) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedVitalCapacity) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedVitalCapacity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedVitalCapacity(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedVitalCapacity) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedForcedVitalCapacityResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedForcedVitalCapacity `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedForcedVitalCapacityResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedVitalCapacityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedVitalCapacityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedVitalCapacityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedVitalCapacityResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedGlucose struct {
	Source *ClientFacingSource              `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingGlucoseTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedGlucose) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucose) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucose(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucose) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedGlucoseResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedGlucose `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedGlucoseResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucoseResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucoseResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucoseResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucoseResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHandwashing struct {
	Source *ClientFacingSource              `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHandwashingSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHandwashing) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHandwashing) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHandwashing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHandwashing(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHandwashing) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHandwashingResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHandwashing `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHandwashingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHandwashingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHandwashingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHandwashingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHandwashingResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRate struct {
	Source *ClientFacingSource                `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHeartRateTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHeartRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRateAlert struct {
	Source *ClientFacingSource                 `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHeartRateAlertSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHeartRateAlert) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateAlert) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateAlert
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateAlert(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateAlert) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRateAlertResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRateAlert `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHeartRateAlertResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateAlertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateAlertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateAlertResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateAlertResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRate `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHeartRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHrv struct {
	Source *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHrvTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHrv) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrv) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrv
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrv(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrv) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHrvResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHrv `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHrvResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrvResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrvResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrvResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrvResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHypnogram struct {
	Source *ClientFacingSource                `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingHypnogramTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHypnogram) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogram) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogram(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogram) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHypnogramResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHypnogram `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedHypnogramResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogramResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogramResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIge struct {
	Source *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingIgeTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIge) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIge) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIge) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIgeResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIge `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIgeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIgg struct {
	Source *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingIggTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIgg) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgg) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgg(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgg) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIggResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIgg `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedIggResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIggResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIggResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIggResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIggResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedInhalerUsage struct {
	Source *ClientFacingSource               `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingInhalerUsageSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedInhalerUsage) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInhalerUsage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInhalerUsage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInhalerUsage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInhalerUsage) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedInhalerUsageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedInhalerUsage `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedInhalerUsageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInhalerUsageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInhalerUsageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInhalerUsageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInhalerUsageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedInsulinInjection struct {
	Source *ClientFacingSource                   `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingInsulinInjectionSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedInsulinInjection) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInsulinInjection) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInsulinInjection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInsulinInjection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInsulinInjection) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedInsulinInjectionResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedInsulinInjection `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedInsulinInjectionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInsulinInjectionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInsulinInjectionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInsulinInjectionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInsulinInjectionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedMindfulnessMinutes struct {
	Source *ClientFacingSource                         `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingMindfulnessMinutesTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedMindfulnessMinutes) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutes) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutes(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutes) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedMindfulnessMinutesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedMindfulnessMinutes `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedMindfulnessMinutesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedNote struct {
	Source *ClientFacingSource       `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingNoteSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedNote) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedNote) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedNote
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedNote(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedNote) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedNoteResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedNote `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedNoteResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedNoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedNoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedNoteResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedNoteResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedPeakExpiratoryFlowRate struct {
	Source *ClientFacingSource                         `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingPeakExpiratoryFlowRateSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedPeakExpiratoryFlowRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedPeakExpiratoryFlowRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedPeakExpiratoryFlowRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedPeakExpiratoryFlowRate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedPeakExpiratoryFlowRate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedPeakExpiratoryFlowRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedPeakExpiratoryFlowRate `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedPeakExpiratoryFlowRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedPeakExpiratoryFlowRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedPeakExpiratoryFlowRateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedPeakExpiratoryFlowRateResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedRespiratoryRate struct {
	Source *ClientFacingSource                      `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingRespiratoryRateTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedRespiratoryRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedRespiratoryRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedRespiratoryRate `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedRespiratoryRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRateResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedSleepApneaAlert struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingSleepApneaAlertSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedSleepApneaAlert) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepApneaAlert) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepApneaAlert
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepApneaAlert(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepApneaAlert) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedSleepApneaAlertResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSleepApneaAlert `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedSleepApneaAlertResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepApneaAlertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepApneaAlertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepApneaAlertResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepApneaAlertResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedSleepBreathingDisturbance struct {
	Source *ClientFacingSource                            `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingSleepBreathingDisturbanceSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedSleepBreathingDisturbance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepBreathingDisturbance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepBreathingDisturbance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepBreathingDisturbance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepBreathingDisturbance) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedSleepBreathingDisturbanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSleepBreathingDisturbance `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepBreathingDisturbanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepBreathingDisturbanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepBreathingDisturbanceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepBreathingDisturbanceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStandDuration struct {
	Source *ClientFacingSource                `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingStandDurationSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStandDuration) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandDuration) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandDuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandDuration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandDuration) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStandDurationResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStandDuration `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStandDurationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandDurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandDurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandDurationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandDurationResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStandHour struct {
	Source *ClientFacingSource            `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingStandHourSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStandHour) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandHour) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandHour
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandHour(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandHour) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStandHourResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStandHour `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStandHourResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandHourResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandHourResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandHourResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandHourResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedSteps struct {
	Source *ClientFacingSource            `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingStepsTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedSteps) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSteps) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSteps
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSteps(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSteps) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStepsResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSteps `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStepsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStepsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStepsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStepsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStepsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStressLevel struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingStressLevelTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStressLevel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevel) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevel) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStressLevelResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStressLevel `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedStressLevelResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevelResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevelResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedUvExposure struct {
	Source *ClientFacingSource             `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingUvExposureSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedUvExposure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedUvExposure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedUvExposure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedUvExposure(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedUvExposure) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedUvExposureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedUvExposure `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedUvExposureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedUvExposureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedUvExposureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedUvExposureResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedUvExposureResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedVo2Max struct {
	Source *ClientFacingSource             `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingVo2MaxTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedVo2Max) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2Max) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2Max
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2Max(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2Max) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedVo2MaxResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedVo2Max `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedVo2MaxResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2MaxResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2MaxResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2MaxResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2MaxResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWater struct {
	Source *ClientFacingSource            `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingWaterTimeseries `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWater) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWater) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWater
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWater(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWater) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWaterResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWater `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWaterResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaterResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaterResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWheelchairPush struct {
	Source *ClientFacingSource                 `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingWheelchairPushSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWheelchairPush) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWheelchairPush) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWheelchairPush
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWheelchairPush(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWheelchairPush) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWheelchairPushResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWheelchairPush `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWheelchairPushResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWheelchairPushResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWheelchairPushResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWheelchairPushResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWheelchairPushResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWorkoutDuration struct {
	Source *ClientFacingSource                  `json:"source,omitempty" url:"source,omitempty"`
	Data   []*ClientFacingWorkoutDurationSample `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWorkoutDuration) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDuration) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDuration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDuration) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWorkoutDurationResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWorkoutDuration `json:"groups,omitempty" url:"groups,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupedWorkoutDurationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDurationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDurationResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GuarantorDetails struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`
	Email       *string  `json:"email,omitempty" url:"email,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GuarantorDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GuarantorDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler GuarantorDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GuarantorDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GuarantorDetails) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HealthInsuranceCreateRequest struct {
	// An image of the front of the patient insurance card.
	FrontImage *HealthInsuranceCreateRequestFrontImage `json:"front_image,omitempty" url:"front_image,omitempty"`
	// An image of the back of the patient insurance card.
	BackImage *HealthInsuranceCreateRequestBackImage `json:"back_image,omitempty" url:"back_image,omitempty"`
	// An image of the patient signature for health insurance billing.
	PatientSignatureImage *HealthInsuranceCreateRequestPatientSignatureImage `json:"patient_signature_image,omitempty" url:"patient_signature_image,omitempty"`
	// Textual description of what are the patient symptoms and attempted treatments.
	Subjective *string `json:"subjective,omitempty" url:"subjective,omitempty"`
	// Textual description of what are the physician assessments and testing plans.
	AssessmentPlan *string `json:"assessment_plan,omitempty" url:"assessment_plan,omitempty"`
	// Unique identifier representing a specific Health Insurance.
	PayorCode *string `json:"payor_code,omitempty" url:"payor_code,omitempty"`
	// Insurance unique number assigned to a patient, usually present on the insurance card.
	InsuranceId *string `json:"insurance_id,omitempty" url:"insurance_id,omitempty"`
	// Relationship between the patient and the insurance contractor. Values can be (Self, Spouse, Other Relationship).
	ResponsibleRelationship *ResponsibleRelationship `json:"responsible_relationship,omitempty" url:"responsible_relationship,omitempty"`
	// Responsible details when the value of responsible_relationship is not 'Self'.
	ResponsibleDetails *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails `json:"responsible_details,omitempty" url:"responsible_details,omitempty"`
	// Diagnosis codes for insurance billing.
	DiagnosisCodes []string `json:"diagnosis_codes,omitempty" url:"diagnosis_codes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HealthInsuranceCreateRequest) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HealthInsuranceCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HealthInsuranceCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HealthInsuranceCreateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HealthInsuranceCreateRequest) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// An image of the back of the patient insurance card.
type HealthInsuranceCreateRequestBackImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewHealthInsuranceCreateRequestBackImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{Jpeg: value}
}

func NewHealthInsuranceCreateRequestBackImageFromPng(value *Png) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{Png: value}
}

func (h *HealthInsuranceCreateRequestBackImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestBackImage) MarshalJSON() ([]byte, error) {
	if h.Jpeg != nil {
		return json.Marshal(h.Jpeg)
	}
	if h.Png != nil {
		return json.Marshal(h.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HealthInsuranceCreateRequestBackImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestBackImage) Accept(visitor HealthInsuranceCreateRequestBackImageVisitor) error {
	if h.Jpeg != nil {
		return visitor.VisitJpeg(h.Jpeg)
	}
	if h.Png != nil {
		return visitor.VisitPng(h.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

// An image of the front of the patient insurance card.
type HealthInsuranceCreateRequestFrontImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewHealthInsuranceCreateRequestFrontImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{Jpeg: value}
}

func NewHealthInsuranceCreateRequestFrontImageFromPng(value *Png) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{Png: value}
}

func (h *HealthInsuranceCreateRequestFrontImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestFrontImage) MarshalJSON() ([]byte, error) {
	if h.Jpeg != nil {
		return json.Marshal(h.Jpeg)
	}
	if h.Png != nil {
		return json.Marshal(h.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HealthInsuranceCreateRequestFrontImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestFrontImage) Accept(visitor HealthInsuranceCreateRequestFrontImageVisitor) error {
	if h.Jpeg != nil {
		return visitor.VisitJpeg(h.Jpeg)
	}
	if h.Png != nil {
		return visitor.VisitPng(h.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

// An image of the patient signature for health insurance billing.
type HealthInsuranceCreateRequestPatientSignatureImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{Jpeg: value}
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromPng(value *Png) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{Png: value}
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestPatientSignatureImage) MarshalJSON() ([]byte, error) {
	if h.Jpeg != nil {
		return json.Marshal(h.Jpeg)
	}
	if h.Png != nil {
		return json.Marshal(h.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HealthInsuranceCreateRequestPatientSignatureImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) Accept(visitor HealthInsuranceCreateRequestPatientSignatureImageVisitor) error {
	if h.Jpeg != nil {
		return visitor.VisitJpeg(h.Jpeg)
	}
	if h.Png != nil {
		return visitor.VisitPng(h.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", h)
}

type HistoricalPullCompleted struct {
	UserId    string    `json:"user_id" url:"user_id"`
	StartDate time.Time `json:"start_date" url:"start_date"`
	EndDate   time.Time `json:"end_date" url:"end_date"`
	IsFinal   bool      `json:"is_final" url:"is_final"`
	Provider  string    `json:"provider" url:"provider"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HistoricalPullCompleted) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HistoricalPullCompleted) UnmarshalJSON(data []byte) error {
	type embed HistoricalPullCompleted
	var unmarshaler = struct {
		embed
		StartDate *core.DateTime `json:"start_date"`
		EndDate   *core.DateTime `json:"end_date"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HistoricalPullCompleted(unmarshaler.embed)
	h.StartDate = unmarshaler.StartDate.Time()
	h.EndDate = unmarshaler.EndDate.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HistoricalPullCompleted) MarshalJSON() ([]byte, error) {
	type embed HistoricalPullCompleted
	var marshaler = struct {
		embed
		StartDate *core.DateTime `json:"start_date"`
		EndDate   *core.DateTime `json:"end_date"`
	}{
		embed:     embed(*h),
		StartDate: core.NewDateTime(h.StartDate),
		EndDate:   core.NewDateTime(h.EndDate),
	}
	return json.Marshal(marshaler)
}

func (h *HistoricalPullCompleted) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HistoricalPullStatus string

const (
	HistoricalPullStatusSuccess    HistoricalPullStatus = "success"
	HistoricalPullStatusFailure    HistoricalPullStatus = "failure"
	HistoricalPullStatusInProgress HistoricalPullStatus = "in_progress"
	HistoricalPullStatusScheduled  HistoricalPullStatus = "scheduled"
	HistoricalPullStatusRetrying   HistoricalPullStatus = "retrying"
)

func NewHistoricalPullStatusFromString(s string) (HistoricalPullStatus, error) {
	switch s {
	case "success":
		return HistoricalPullStatusSuccess, nil
	case "failure":
		return HistoricalPullStatusFailure, nil
	case "in_progress":
		return HistoricalPullStatusInProgress, nil
	case "scheduled":
		return HistoricalPullStatusScheduled, nil
	case "retrying":
		return HistoricalPullStatusRetrying, nil
	}
	var t HistoricalPullStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HistoricalPullStatus) Ptr() *HistoricalPullStatus {
	return &h
}

type HistoricalPullTimeline struct {
	ScheduledAt time.Time  `json:"scheduled_at" url:"scheduled_at"`
	StartedAt   *time.Time `json:"started_at,omitempty" url:"started_at,omitempty"`
	EndedAt     *time.Time `json:"ended_at,omitempty" url:"ended_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HistoricalPullTimeline) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HistoricalPullTimeline) UnmarshalJSON(data []byte) error {
	type embed HistoricalPullTimeline
	var unmarshaler = struct {
		embed
		ScheduledAt *core.DateTime `json:"scheduled_at"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
		EndedAt     *core.DateTime `json:"ended_at,omitempty"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HistoricalPullTimeline(unmarshaler.embed)
	h.ScheduledAt = unmarshaler.ScheduledAt.Time()
	h.StartedAt = unmarshaler.StartedAt.TimePtr()
	h.EndedAt = unmarshaler.EndedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HistoricalPullTimeline) MarshalJSON() ([]byte, error) {
	type embed HistoricalPullTimeline
	var marshaler = struct {
		embed
		ScheduledAt *core.DateTime `json:"scheduled_at"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
		EndedAt     *core.DateTime `json:"ended_at,omitempty"`
	}{
		embed:       embed(*h),
		ScheduledAt: core.NewDateTime(h.ScheduledAt),
		StartedAt:   core.NewOptionalDateTime(h.StartedAt),
		EndedAt:     core.NewOptionalDateTime(h.EndedAt),
	}
	return json.Marshal(marshaler)
}

func (h *HistoricalPullTimeline) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomePregnancyTestEntry struct {
	Date       string                           `json:"date" url:"date"`
	TestResult HomePregnancyTestEntryTestResult `json:"test_result" url:"test_result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HomePregnancyTestEntry) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HomePregnancyTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomePregnancyTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomePregnancyTestEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomePregnancyTestEntry) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomePregnancyTestEntryTestResult string

const (
	HomePregnancyTestEntryTestResultNegative      HomePregnancyTestEntryTestResult = "negative"
	HomePregnancyTestEntryTestResultPositive      HomePregnancyTestEntryTestResult = "positive"
	HomePregnancyTestEntryTestResultIndeterminate HomePregnancyTestEntryTestResult = "indeterminate"
)

func NewHomePregnancyTestEntryTestResultFromString(s string) (HomePregnancyTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomePregnancyTestEntryTestResultNegative, nil
	case "positive":
		return HomePregnancyTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomePregnancyTestEntryTestResultIndeterminate, nil
	}
	var t HomePregnancyTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomePregnancyTestEntryTestResult) Ptr() *HomePregnancyTestEntryTestResult {
	return &h
}

type HomeProgesteroneTestEntry struct {
	Date       string                              `json:"date" url:"date"`
	TestResult HomeProgesteroneTestEntryTestResult `json:"test_result" url:"test_result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HomeProgesteroneTestEntry) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HomeProgesteroneTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomeProgesteroneTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomeProgesteroneTestEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomeProgesteroneTestEntry) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomeProgesteroneTestEntryTestResult string

const (
	HomeProgesteroneTestEntryTestResultNegative      HomeProgesteroneTestEntryTestResult = "negative"
	HomeProgesteroneTestEntryTestResultPositive      HomeProgesteroneTestEntryTestResult = "positive"
	HomeProgesteroneTestEntryTestResultIndeterminate HomeProgesteroneTestEntryTestResult = "indeterminate"
)

func NewHomeProgesteroneTestEntryTestResultFromString(s string) (HomeProgesteroneTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomeProgesteroneTestEntryTestResultNegative, nil
	case "positive":
		return HomeProgesteroneTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomeProgesteroneTestEntryTestResultIndeterminate, nil
	}
	var t HomeProgesteroneTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomeProgesteroneTestEntryTestResult) Ptr() *HomeProgesteroneTestEntryTestResult {
	return &h
}

type HttpValidationError struct {
	Detail interface{} `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpValidationError) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpValidationError) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type IndexColumnExpr struct {
	Index IndexColumnExprIndex `json:"index" url:"index"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IndexColumnExpr) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndexColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler IndexColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndexColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndexColumnExpr) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndexColumnExprIndex string

const (
	IndexColumnExprIndexSleep    IndexColumnExprIndex = "sleep"
	IndexColumnExprIndexActivity IndexColumnExprIndex = "activity"
	IndexColumnExprIndexWorkout  IndexColumnExprIndex = "workout"
	IndexColumnExprIndexBody     IndexColumnExprIndex = "body"
	IndexColumnExprIndexMeal     IndexColumnExprIndex = "meal"
)

func NewIndexColumnExprIndexFromString(s string) (IndexColumnExprIndex, error) {
	switch s {
	case "sleep":
		return IndexColumnExprIndexSleep, nil
	case "activity":
		return IndexColumnExprIndexActivity, nil
	case "workout":
		return IndexColumnExprIndexWorkout, nil
	case "body":
		return IndexColumnExprIndexBody, nil
	case "meal":
		return IndexColumnExprIndexMeal, nil
	}
	var t IndexColumnExprIndex
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IndexColumnExprIndex) Ptr() *IndexColumnExprIndex {
	return &i
}

type IntermenstrualBleedingEntry struct {
	Date string `json:"date" url:"date"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntermenstrualBleedingEntry) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntermenstrualBleedingEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler IntermenstrualBleedingEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntermenstrualBleedingEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntermenstrualBleedingEntry) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Jpeg struct {
	Content     string `json:"content" url:"content"`
	contentType string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *Jpeg) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *Jpeg) ContentType() string {
	return j.contentType
}

func (j *Jpeg) UnmarshalJSON(data []byte) error {
	type embed Jpeg
	var unmarshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed: embed(*j),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*j = Jpeg(unmarshaler.embed)
	if unmarshaler.ContentType != "image/jpeg" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", j, "image/jpeg", unmarshaler.ContentType)
	}
	j.contentType = unmarshaler.ContentType

	extraProperties, err := core.ExtractExtraProperties(data, *j, "content_type")
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *Jpeg) MarshalJSON() ([]byte, error) {
	type embed Jpeg
	var marshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed:       embed(*j),
		ContentType: "image/jpeg",
	}
	return json.Marshal(marshaler)
}

func (j *Jpeg) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type LabLocationMetadata struct {
	Name        string                 `json:"name" url:"name"`
	State       string                 `json:"state" url:"state"`
	City        string                 `json:"city" url:"city"`
	ZipCode     string                 `json:"zip_code" url:"zip_code"`
	FirstLine   string                 `json:"first_line" url:"first_line"`
	SecondLine  *string                `json:"second_line,omitempty" url:"second_line,omitempty"`
	PhoneNumber *string                `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	FaxNumber   *string                `json:"fax_number,omitempty" url:"fax_number,omitempty"`
	Hours       map[string]interface{} `json:"hours,omitempty" url:"hours,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabLocationMetadata) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabLocationMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LabLocationMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabLocationMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabLocationMetadata) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsMetadata struct {
	Age            string  `json:"age" url:"age"`
	Dob            string  `json:"dob" url:"dob"`
	Clia           *string `json:"clia_#,omitempty" url:"clia_#,omitempty"`
	Patient        string  `json:"patient" url:"patient"`
	Provider       *string `json:"provider,omitempty" url:"provider,omitempty"`
	Laboratory     *string `json:"laboratory,omitempty" url:"laboratory,omitempty"`
	DateReported   string  `json:"date_reported" url:"date_reported"`
	DateCollected  *string `json:"date_collected,omitempty" url:"date_collected,omitempty"`
	SpecimenNumber string  `json:"specimen_number" url:"specimen_number"`
	DateReceived   *string `json:"date_received,omitempty" url:"date_received,omitempty"`
	Status         *string `json:"status,omitempty" url:"status,omitempty"`
	Interpretation *string `json:"interpretation,omitempty" url:"interpretation,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabResultsMetadata) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabResultsMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsMetadata) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRaw struct {
	Metadata       *LabResultsMetadata       `json:"metadata,omitempty" url:"metadata,omitempty"`
	Results        *LabResultsRawResults     `json:"results,omitempty" url:"results,omitempty"`
	MissingResults []*MissingBiomarkerResult `json:"missing_results,omitempty" url:"missing_results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabResultsRaw) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabResultsRaw) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsRaw
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsRaw(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsRaw) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRawResults struct {
	BiomarkerResultList []*BiomarkerResult
	StringUnknownMap    map[string]interface{}
}

func NewLabResultsRawResultsFromBiomarkerResultList(value []*BiomarkerResult) *LabResultsRawResults {
	return &LabResultsRawResults{BiomarkerResultList: value}
}

func NewLabResultsRawResultsFromStringUnknownMap(value map[string]interface{}) *LabResultsRawResults {
	return &LabResultsRawResults{StringUnknownMap: value}
}

func (l *LabResultsRawResults) UnmarshalJSON(data []byte) error {
	var valueBiomarkerResultList []*BiomarkerResult
	if err := json.Unmarshal(data, &valueBiomarkerResultList); err == nil {
		l.BiomarkerResultList = valueBiomarkerResultList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		l.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LabResultsRawResults) MarshalJSON() ([]byte, error) {
	if l.BiomarkerResultList != nil {
		return json.Marshal(l.BiomarkerResultList)
	}
	if l.StringUnknownMap != nil {
		return json.Marshal(l.StringUnknownMap)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", l)
}

type LabResultsRawResultsVisitor interface {
	VisitBiomarkerResultList([]*BiomarkerResult) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (l *LabResultsRawResults) Accept(visitor LabResultsRawResultsVisitor) error {
	if l.BiomarkerResultList != nil {
		return visitor.VisitBiomarkerResultList(l.BiomarkerResultList)
	}
	if l.StringUnknownMap != nil {
		return visitor.VisitStringUnknownMap(l.StringUnknownMap)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", l)
}

// The method used to perform a lab test.
type LabTestCollectionMethod string

const (
	LabTestCollectionMethodTestkit          LabTestCollectionMethod = "testkit"
	LabTestCollectionMethodWalkInTest       LabTestCollectionMethod = "walk_in_test"
	LabTestCollectionMethodAtHomePhlebotomy LabTestCollectionMethod = "at_home_phlebotomy"
)

func NewLabTestCollectionMethodFromString(s string) (LabTestCollectionMethod, error) {
	switch s {
	case "testkit":
		return LabTestCollectionMethodTestkit, nil
	case "walk_in_test":
		return LabTestCollectionMethodWalkInTest, nil
	case "at_home_phlebotomy":
		return LabTestCollectionMethodAtHomePhlebotomy, nil
	}
	var t LabTestCollectionMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestCollectionMethod) Ptr() *LabTestCollectionMethod {
	return &l
}

type LabTestGenerationMethodFilter string

const (
	LabTestGenerationMethodFilterAuto   LabTestGenerationMethodFilter = "auto"
	LabTestGenerationMethodFilterManual LabTestGenerationMethodFilter = "manual"
	LabTestGenerationMethodFilterAll    LabTestGenerationMethodFilter = "all"
)

func NewLabTestGenerationMethodFilterFromString(s string) (LabTestGenerationMethodFilter, error) {
	switch s {
	case "auto":
		return LabTestGenerationMethodFilterAuto, nil
	case "manual":
		return LabTestGenerationMethodFilterManual, nil
	case "all":
		return LabTestGenerationMethodFilterAll, nil
	}
	var t LabTestGenerationMethodFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestGenerationMethodFilter) Ptr() *LabTestGenerationMethodFilter {
	return &l
}

type LabTestResourcesResponse struct {
	Data []*ClientFacingLabTest `json:"data,omitempty" url:"data,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabTestResourcesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabTestResourcesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LabTestResourcesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabTestResourcesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabTestResourcesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The type of sample used to perform a lab test.
type LabTestSampleType string

const (
	LabTestSampleTypeDriedBloodSpot LabTestSampleType = "dried_blood_spot"
	LabTestSampleTypeArmCollector   LabTestSampleType = "arm_collector"
	LabTestSampleTypeSerum          LabTestSampleType = "serum"
	LabTestSampleTypeSaliva         LabTestSampleType = "saliva"
	LabTestSampleTypeUrine          LabTestSampleType = "urine"
)

func NewLabTestSampleTypeFromString(s string) (LabTestSampleType, error) {
	switch s {
	case "dried_blood_spot":
		return LabTestSampleTypeDriedBloodSpot, nil
	case "arm_collector":
		return LabTestSampleTypeArmCollector, nil
	case "serum":
		return LabTestSampleTypeSerum, nil
	case "saliva":
		return LabTestSampleTypeSaliva, nil
	case "urine":
		return LabTestSampleTypeUrine, nil
	}
	var t LabTestSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestSampleType) Ptr() *LabTestSampleType {
	return &l
}

type LabTestStatus string

const (
	LabTestStatusActive          LabTestStatus = "active"
	LabTestStatusPendingApproval LabTestStatus = "pending_approval"
	LabTestStatusInactive        LabTestStatus = "inactive"
)

func NewLabTestStatusFromString(s string) (LabTestStatus, error) {
	switch s {
	case "active":
		return LabTestStatusActive, nil
	case "pending_approval":
		return LabTestStatusPendingApproval, nil
	case "inactive":
		return LabTestStatusInactive, nil
	}
	var t LabTestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestStatus) Ptr() *LabTestStatus {
	return &l
}

type Labs string

const (
	LabsAyumetrix    Labs = "ayumetrix"
	LabsSpiriplex    Labs = "spiriplex"
	LabsUssl         Labs = "ussl"
	LabsQuest        Labs = "quest"
	LabsLabcorp      Labs = "labcorp"
	LabsBioreference Labs = "bioreference"
	LabsUsBiotek     Labs = "us_biotek"
	LabsManual       Labs = "manual"
	LabsSanocardio   Labs = "sanocardio"
	LabsIhd          Labs = "ihd"
)

func NewLabsFromString(s string) (Labs, error) {
	switch s {
	case "ayumetrix":
		return LabsAyumetrix, nil
	case "spiriplex":
		return LabsSpiriplex, nil
	case "ussl":
		return LabsUssl, nil
	case "quest":
		return LabsQuest, nil
	case "labcorp":
		return LabsLabcorp, nil
	case "bioreference":
		return LabsBioreference, nil
	case "us_biotek":
		return LabsUsBiotek, nil
	case "manual":
		return LabsManual, nil
	case "sanocardio":
		return LabsSanocardio, nil
	case "ihd":
		return LabsIhd, nil
	}
	var t Labs
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l Labs) Ptr() *Labs {
	return &l
}

type LastAttempt struct {
	Timestamp time.Time     `json:"timestamp" url:"timestamp"`
	Status    AttemptStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LastAttempt) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LastAttempt) UnmarshalJSON(data []byte) error {
	type embed LastAttempt
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LastAttempt(unmarshaler.embed)
	l.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LastAttempt) MarshalJSON() ([]byte, error) {
	type embed LastAttempt
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*l),
		Timestamp: core.NewDateTime(l.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (l *LastAttempt) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LibreConfig struct {
	PracticeId map[string]interface{} `json:"practice_id,omitempty" url:"practice_id,omitempty"`
	StripTz    *bool                  `json:"strip_tz,omitempty" url:"strip_tz,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LibreConfig) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LibreConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LibreConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LibreConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LibreConfig) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LinkTokenExchangeResponse struct {
	// A short-lived Vital Link token for your Custom Link Widget to communicate with the Vital API.
	LinkToken string `json:"link_token" url:"link_token"`
	// The web browser link to launch the default Vital Link experience. If you requested the token for one specific provider, the link would redirect directly to the provider authentication flow. Otherwise, the user would be presented with a list of providers based on your team and token configurations.
	LinkWebUrl string `json:"link_web_url" url:"link_web_url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LinkTokenExchangeResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkTokenExchangeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkTokenExchangeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkTokenExchangeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkTokenExchangeResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LngLat struct {
	Lng float64 `json:"lng" url:"lng"`
	Lat float64 `json:"lat" url:"lat"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LngLat) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LngLat) UnmarshalJSON(data []byte) error {
	type unmarshaler LngLat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LngLat(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LngLat) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Macros struct {
	// Amount of carbohydrates in grams (g)
	Carbs *float64 `json:"carbs,omitempty" url:"carbs,omitempty"`
	// Amount of protein in grams (g)
	Protein *float64 `json:"protein,omitempty" url:"protein,omitempty"`
	// Details of fat content
	Fats *Fats `json:"fats,omitempty" url:"fats,omitempty"`
	// Amount of alcohol in grams (g)
	Alcohol *float64 `json:"alcohol,omitempty" url:"alcohol,omitempty"`
	// Amount of water in grams (g)
	Water *float64 `json:"water,omitempty" url:"water,omitempty"`
	// Amount of dietary fiber in grams (g)
	Fibre *float64 `json:"fibre,omitempty" url:"fibre,omitempty"`
	// Amount of sugar in grams (g)
	Sugar *float64 `json:"sugar,omitempty" url:"sugar,omitempty"`
	// Amount of cholesterol in grams (g)
	Cholesterol *float64 `json:"cholesterol,omitempty" url:"cholesterol,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Macros) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Macros) UnmarshalJSON(data []byte) error {
	type unmarshaler Macros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Macros(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Macros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ManualProviders string

const (
	ManualProvidersBeurerBle         ManualProviders = "beurer_ble"
	ManualProvidersOmronBle          ManualProviders = "omron_ble"
	ManualProvidersAccuchekBle       ManualProviders = "accuchek_ble"
	ManualProvidersContourBle        ManualProviders = "contour_ble"
	ManualProvidersFreestyleLibreBle ManualProviders = "freestyle_libre_ble"
	ManualProvidersOnetouchBle       ManualProviders = "onetouch_ble"
	ManualProvidersAppleHealthKit    ManualProviders = "apple_health_kit"
	ManualProvidersManual            ManualProviders = "manual"
	ManualProvidersHealthConnect     ManualProviders = "health_connect"
)

func NewManualProvidersFromString(s string) (ManualProviders, error) {
	switch s {
	case "beurer_ble":
		return ManualProvidersBeurerBle, nil
	case "omron_ble":
		return ManualProvidersOmronBle, nil
	case "accuchek_ble":
		return ManualProvidersAccuchekBle, nil
	case "contour_ble":
		return ManualProvidersContourBle, nil
	case "freestyle_libre_ble":
		return ManualProvidersFreestyleLibreBle, nil
	case "onetouch_ble":
		return ManualProvidersOnetouchBle, nil
	case "apple_health_kit":
		return ManualProvidersAppleHealthKit, nil
	case "manual":
		return ManualProvidersManual, nil
	case "health_connect":
		return ManualProvidersHealthConnect, nil
	}
	var t ManualProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManualProviders) Ptr() *ManualProviders {
	return &m
}

type MarkerType string

const (
	MarkerTypeBiomarker MarkerType = "biomarker"
	MarkerTypePanel     MarkerType = "panel"
)

func NewMarkerTypeFromString(s string) (MarkerType, error) {
	switch s {
	case "biomarker":
		return MarkerTypeBiomarker, nil
	case "panel":
		return MarkerTypePanel, nil
	}
	var t MarkerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MarkerType) Ptr() *MarkerType {
	return &m
}

type MealInDbBaseClientFacingSource struct {
	Id     string `json:"id" url:"id"`
	UserId string `json:"user_id" url:"user_id"`
	// This value has no meaning.
	PriorityId int `json:"priority_id" url:"priority_id"`
	// This value has no meaning.
	SourceId int `json:"source_id" url:"source_id"`
	// This value is identical to `id`.
	ProviderId string                       `json:"provider_id" url:"provider_id"`
	Timestamp  time.Time                    `json:"timestamp" url:"timestamp"`
	Name       string                       `json:"name" url:"name"`
	Energy     *Energy                      `json:"energy,omitempty" url:"energy,omitempty"`
	Macros     *Macros                      `json:"macros,omitempty" url:"macros,omitempty"`
	Micros     *Micros                      `json:"micros,omitempty" url:"micros,omitempty"`
	Data       map[string]*ClientFacingFood `json:"data,omitempty" url:"data,omitempty"`
	Source     *ClientFacingSource          `json:"source,omitempty" url:"source,omitempty"`
	// This value is identical to `timestamp`.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// This value is identical to `timestamp`.
	UpdatedAt   time.Time `json:"updated_at" url:"updated_at"`
	SourceAppId *string   `json:"source_app_id,omitempty" url:"source_app_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MealInDbBaseClientFacingSource) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MealInDbBaseClientFacingSource) UnmarshalJSON(data []byte) error {
	type embed MealInDbBaseClientFacingSource
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MealInDbBaseClientFacingSource(unmarshaler.embed)
	m.Timestamp = unmarshaler.Timestamp.Time()
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MealInDbBaseClientFacingSource) MarshalJSON() ([]byte, error) {
	type embed MealInDbBaseClientFacingSource
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*m),
		Timestamp: core.NewDateTime(m.Timestamp),
		CreatedAt: core.NewDateTime(m.CreatedAt),
		UpdatedAt: core.NewDateTime(m.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (m *MealInDbBaseClientFacingSource) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualCycleResponse struct {
	MenstrualCycle []*ClientFacingMenstrualCycle `json:"menstrual_cycle,omitempty" url:"menstrual_cycle,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MenstrualCycleResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MenstrualCycleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualCycleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualCycleResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualCycleResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualFlowEntry struct {
	Date string                 `json:"date" url:"date"`
	Flow MenstrualFlowEntryFlow `json:"flow" url:"flow"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MenstrualFlowEntry) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MenstrualFlowEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualFlowEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualFlowEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualFlowEntry) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualFlowEntryFlow string

const (
	MenstrualFlowEntryFlowUnspecified MenstrualFlowEntryFlow = "unspecified"
	MenstrualFlowEntryFlowNone        MenstrualFlowEntryFlow = "none"
	MenstrualFlowEntryFlowLight       MenstrualFlowEntryFlow = "light"
	MenstrualFlowEntryFlowMedium      MenstrualFlowEntryFlow = "medium"
	MenstrualFlowEntryFlowHeavy       MenstrualFlowEntryFlow = "heavy"
)

func NewMenstrualFlowEntryFlowFromString(s string) (MenstrualFlowEntryFlow, error) {
	switch s {
	case "unspecified":
		return MenstrualFlowEntryFlowUnspecified, nil
	case "none":
		return MenstrualFlowEntryFlowNone, nil
	case "light":
		return MenstrualFlowEntryFlowLight, nil
	case "medium":
		return MenstrualFlowEntryFlowMedium, nil
	case "heavy":
		return MenstrualFlowEntryFlowHeavy, nil
	}
	var t MenstrualFlowEntryFlow
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MenstrualFlowEntryFlow) Ptr() *MenstrualFlowEntryFlow {
	return &m
}

type MetricsResult struct {
	TeamId                          string                   `json:"team_id" url:"team_id"`
	NumberOfConnectedSources        *int                     `json:"number_of_connected_sources,omitempty" url:"number_of_connected_sources,omitempty"`
	NumberOfUsers                   *int                     `json:"number_of_users,omitempty" url:"number_of_users,omitempty"`
	NumberOfErroredConnectedSources *int                     `json:"number_of_errored_connected_sources,omitempty" url:"number_of_errored_connected_sources,omitempty"`
	NumberOfConnectedSourcesByWeek  []*TimeseriesMetricPoint `json:"number_of_connected_sources_by_week,omitempty" url:"number_of_connected_sources_by_week,omitempty"`
	NumberOfOrderedTests            *int                     `json:"number_of_ordered_tests,omitempty" url:"number_of_ordered_tests,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetricsResult) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetricsResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsResult) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Micros struct {
	// Amount of each mineral in grams (g)
	Minerals map[string]*float64 `json:"minerals,omitempty" url:"minerals,omitempty"`
	// Amount of each trace element in grams (g)
	TraceElements map[string]*float64 `json:"trace_elements,omitempty" url:"trace_elements,omitempty"`
	// Amount of each vitamin in grams (g)
	Vitamins map[string]*float64 `json:"vitamins,omitempty" url:"vitamins,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Micros) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Micros) UnmarshalJSON(data []byte) error {
	type unmarshaler Micros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Micros(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Micros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Minerals string

const (
	MineralsSodium     Minerals = "sodium"
	MineralsPotassium  Minerals = "potassium"
	MineralsCalcium    Minerals = "calcium"
	MineralsPhosphorus Minerals = "phosphorus"
	MineralsMagnesium  Minerals = "magnesium"
	MineralsIron       Minerals = "iron"
	MineralsZinc       Minerals = "zinc"
	MineralsFluoride   Minerals = "fluoride"
	MineralsChloride   Minerals = "chloride"
)

func NewMineralsFromString(s string) (Minerals, error) {
	switch s {
	case "sodium":
		return MineralsSodium, nil
	case "potassium":
		return MineralsPotassium, nil
	case "calcium":
		return MineralsCalcium, nil
	case "phosphorus":
		return MineralsPhosphorus, nil
	case "magnesium":
		return MineralsMagnesium, nil
	case "iron":
		return MineralsIron, nil
	case "zinc":
		return MineralsZinc, nil
	case "fluoride":
		return MineralsFluoride, nil
	case "chloride":
		return MineralsChloride, nil
	}
	var t Minerals
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m Minerals) Ptr() *Minerals {
	return &m
}

type MissingBiomarkerResult struct {
	Name                string                 `json:"name" url:"name"`
	Slug                string                 `json:"slug" url:"slug"`
	InferredFailureType FailureType            `json:"inferred_failure_type" url:"inferred_failure_type"`
	Note                *string                `json:"note,omitempty" url:"note,omitempty"`
	Loinc               *string                `json:"loinc,omitempty" url:"loinc,omitempty"`
	LoincSlug           *string                `json:"loinc_slug,omitempty" url:"loinc_slug,omitempty"`
	ProviderId          *string                `json:"provider_id,omitempty" url:"provider_id,omitempty"`
	SourceMarkers       []*ParentBiomarkerData `json:"source_markers,omitempty" url:"source_markers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MissingBiomarkerResult) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MissingBiomarkerResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MissingBiomarkerResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MissingBiomarkerResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MissingBiomarkerResult) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OAuthProviders string

const (
	OAuthProvidersOura           OAuthProviders = "oura"
	OAuthProvidersFitbit         OAuthProviders = "fitbit"
	OAuthProvidersGarmin         OAuthProviders = "garmin"
	OAuthProvidersStrava         OAuthProviders = "strava"
	OAuthProvidersWahoo          OAuthProviders = "wahoo"
	OAuthProvidersIhealth        OAuthProviders = "ihealth"
	OAuthProvidersWithings       OAuthProviders = "withings"
	OAuthProvidersGoogleFit      OAuthProviders = "google_fit"
	OAuthProvidersDexcomV3       OAuthProviders = "dexcom_v3"
	OAuthProvidersPolar          OAuthProviders = "polar"
	OAuthProvidersCronometer     OAuthProviders = "cronometer"
	OAuthProvidersOmron          OAuthProviders = "omron"
	OAuthProvidersWhoopV2        OAuthProviders = "whoop_v2"
	OAuthProvidersMyFitnessPalV2 OAuthProviders = "my_fitness_pal_v2"
	OAuthProvidersUltrahuman     OAuthProviders = "ultrahuman"
)

func NewOAuthProvidersFromString(s string) (OAuthProviders, error) {
	switch s {
	case "oura":
		return OAuthProvidersOura, nil
	case "fitbit":
		return OAuthProvidersFitbit, nil
	case "garmin":
		return OAuthProvidersGarmin, nil
	case "strava":
		return OAuthProvidersStrava, nil
	case "wahoo":
		return OAuthProvidersWahoo, nil
	case "ihealth":
		return OAuthProvidersIhealth, nil
	case "withings":
		return OAuthProvidersWithings, nil
	case "google_fit":
		return OAuthProvidersGoogleFit, nil
	case "dexcom_v3":
		return OAuthProvidersDexcomV3, nil
	case "polar":
		return OAuthProvidersPolar, nil
	case "cronometer":
		return OAuthProvidersCronometer, nil
	case "omron":
		return OAuthProvidersOmron, nil
	case "whoop_v2":
		return OAuthProvidersWhoopV2, nil
	case "my_fitness_pal_v2":
		return OAuthProvidersMyFitnessPalV2, nil
	case "ultrahuman":
		return OAuthProvidersUltrahuman, nil
	}
	var t OAuthProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OAuthProviders) Ptr() *OAuthProviders {
	return &o
}

type OrderSetRequest struct {
	LabTestIds []string    `json:"lab_test_ids,omitempty" url:"lab_test_ids,omitempty"`
	AddOn      *AddOnOrder `json:"add_on,omitempty" url:"add_on,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderSetRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderSetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderSetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderSetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderSetRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderStatus string

const (
	OrderStatusReceivedWalkInTestOrdered                            OrderStatus = "received.walk_in_test.ordered"
	OrderStatusReceivedWalkInTestRequisitionCreated                 OrderStatus = "received.walk_in_test.requisition_created"
	OrderStatusReceivedWalkInTestRequisitionBypassed                OrderStatus = "received.walk_in_test.requisition_bypassed"
	OrderStatusCompletedWalkInTestCompleted                         OrderStatus = "completed.walk_in_test.completed"
	OrderStatusSampleWithLabWalkInTestPartialResults                OrderStatus = "sample_with_lab.walk_in_test.partial_results"
	OrderStatusFailedWalkInTestSampleError                          OrderStatus = "failed.walk_in_test.sample_error"
	OrderStatusCancelledWalkInTestCancelled                         OrderStatus = "cancelled.walk_in_test.cancelled"
	OrderStatusCollectingSampleWalkInTestAppointmentPending         OrderStatus = "collecting_sample.walk_in_test.appointment_pending"
	OrderStatusCollectingSampleWalkInTestAppointmentScheduled       OrderStatus = "collecting_sample.walk_in_test.appointment_scheduled"
	OrderStatusCollectingSampleWalkInTestAppointmentCancelled       OrderStatus = "collecting_sample.walk_in_test.appointment_cancelled"
	OrderStatusReceivedAtHomePhlebotomyOrdered                      OrderStatus = "received.at_home_phlebotomy.ordered"
	OrderStatusReceivedAtHomePhlebotomyRequisitionCreated           OrderStatus = "received.at_home_phlebotomy.requisition_created"
	OrderStatusReceivedAtHomePhlebotomyRequisitionBypassed          OrderStatus = "received.at_home_phlebotomy.requisition_bypassed"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentPending   OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_pending"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_scheduled"
	OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted        OrderStatus = "collecting_sample.at_home_phlebotomy.draw_completed"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_cancelled"
	OrderStatusCompletedAtHomePhlebotomyCompleted                   OrderStatus = "completed.at_home_phlebotomy.completed"
	OrderStatusSampleWithLabAtHomePhlebotomyPartialResults          OrderStatus = "sample_with_lab.at_home_phlebotomy.partial_results"
	OrderStatusCancelledAtHomePhlebotomyCancelled                   OrderStatus = "cancelled.at_home_phlebotomy.cancelled"
	OrderStatusFailedAtHomePhlebotomySampleError                    OrderStatus = "failed.at_home_phlebotomy.sample_error"
	OrderStatusReceivedTestkitOrdered                               OrderStatus = "received.testkit.ordered"
	OrderStatusReceivedTestkitAwaitingRegistration                  OrderStatus = "received.testkit.awaiting_registration"
	OrderStatusReceivedTestkitRequisitionCreated                    OrderStatus = "received.testkit.requisition_created"
	OrderStatusReceivedTestkitRequisitionBypassed                   OrderStatus = "received.testkit.requisition_bypassed"
	OrderStatusReceivedTestkitRegistered                            OrderStatus = "received.testkit.registered"
	OrderStatusCollectingSampleTestkitTransitCustomer               OrderStatus = "collecting_sample.testkit.transit_customer"
	OrderStatusCollectingSampleTestkitOutForDelivery                OrderStatus = "collecting_sample.testkit.out_for_delivery"
	OrderStatusCollectingSampleTestkitWithCustomer                  OrderStatus = "collecting_sample.testkit.with_customer"
	OrderStatusCollectingSampleTestkitTransitLab                    OrderStatus = "collecting_sample.testkit.transit_lab"
	OrderStatusSampleWithLabTestkitDeliveredToLab                   OrderStatus = "sample_with_lab.testkit.delivered_to_lab"
	OrderStatusCompletedTestkitCompleted                            OrderStatus = "completed.testkit.completed"
	OrderStatusFailedTestkitFailureToDeliverToCustomer              OrderStatus = "failed.testkit.failure_to_deliver_to_customer"
	OrderStatusFailedTestkitFailureToDeliverToLab                   OrderStatus = "failed.testkit.failure_to_deliver_to_lab"
	OrderStatusFailedTestkitSampleError                             OrderStatus = "failed.testkit.sample_error"
	OrderStatusFailedTestkitLost                                    OrderStatus = "failed.testkit.lost"
	OrderStatusCancelledTestkitCancelled                            OrderStatus = "cancelled.testkit.cancelled"
	OrderStatusCancelledTestkitDoNotProcess                         OrderStatus = "cancelled.testkit.do_not_process"
	OrderStatusCollectingSampleTestkitProblemInTransitCustomer      OrderStatus = "collecting_sample.testkit.problem_in_transit_customer"
	OrderStatusCollectingSampleTestkitProblemInTransitLab           OrderStatus = "collecting_sample.testkit.problem_in_transit_lab"
)

func NewOrderStatusFromString(s string) (OrderStatus, error) {
	switch s {
	case "received.walk_in_test.ordered":
		return OrderStatusReceivedWalkInTestOrdered, nil
	case "received.walk_in_test.requisition_created":
		return OrderStatusReceivedWalkInTestRequisitionCreated, nil
	case "received.walk_in_test.requisition_bypassed":
		return OrderStatusReceivedWalkInTestRequisitionBypassed, nil
	case "completed.walk_in_test.completed":
		return OrderStatusCompletedWalkInTestCompleted, nil
	case "sample_with_lab.walk_in_test.partial_results":
		return OrderStatusSampleWithLabWalkInTestPartialResults, nil
	case "failed.walk_in_test.sample_error":
		return OrderStatusFailedWalkInTestSampleError, nil
	case "cancelled.walk_in_test.cancelled":
		return OrderStatusCancelledWalkInTestCancelled, nil
	case "collecting_sample.walk_in_test.appointment_pending":
		return OrderStatusCollectingSampleWalkInTestAppointmentPending, nil
	case "collecting_sample.walk_in_test.appointment_scheduled":
		return OrderStatusCollectingSampleWalkInTestAppointmentScheduled, nil
	case "collecting_sample.walk_in_test.appointment_cancelled":
		return OrderStatusCollectingSampleWalkInTestAppointmentCancelled, nil
	case "received.at_home_phlebotomy.ordered":
		return OrderStatusReceivedAtHomePhlebotomyOrdered, nil
	case "received.at_home_phlebotomy.requisition_created":
		return OrderStatusReceivedAtHomePhlebotomyRequisitionCreated, nil
	case "received.at_home_phlebotomy.requisition_bypassed":
		return OrderStatusReceivedAtHomePhlebotomyRequisitionBypassed, nil
	case "collecting_sample.at_home_phlebotomy.appointment_pending":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentPending, nil
	case "collecting_sample.at_home_phlebotomy.appointment_scheduled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled, nil
	case "collecting_sample.at_home_phlebotomy.draw_completed":
		return OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted, nil
	case "collecting_sample.at_home_phlebotomy.appointment_cancelled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled, nil
	case "completed.at_home_phlebotomy.completed":
		return OrderStatusCompletedAtHomePhlebotomyCompleted, nil
	case "sample_with_lab.at_home_phlebotomy.partial_results":
		return OrderStatusSampleWithLabAtHomePhlebotomyPartialResults, nil
	case "cancelled.at_home_phlebotomy.cancelled":
		return OrderStatusCancelledAtHomePhlebotomyCancelled, nil
	case "failed.at_home_phlebotomy.sample_error":
		return OrderStatusFailedAtHomePhlebotomySampleError, nil
	case "received.testkit.ordered":
		return OrderStatusReceivedTestkitOrdered, nil
	case "received.testkit.awaiting_registration":
		return OrderStatusReceivedTestkitAwaitingRegistration, nil
	case "received.testkit.requisition_created":
		return OrderStatusReceivedTestkitRequisitionCreated, nil
	case "received.testkit.requisition_bypassed":
		return OrderStatusReceivedTestkitRequisitionBypassed, nil
	case "received.testkit.registered":
		return OrderStatusReceivedTestkitRegistered, nil
	case "collecting_sample.testkit.transit_customer":
		return OrderStatusCollectingSampleTestkitTransitCustomer, nil
	case "collecting_sample.testkit.out_for_delivery":
		return OrderStatusCollectingSampleTestkitOutForDelivery, nil
	case "collecting_sample.testkit.with_customer":
		return OrderStatusCollectingSampleTestkitWithCustomer, nil
	case "collecting_sample.testkit.transit_lab":
		return OrderStatusCollectingSampleTestkitTransitLab, nil
	case "sample_with_lab.testkit.delivered_to_lab":
		return OrderStatusSampleWithLabTestkitDeliveredToLab, nil
	case "completed.testkit.completed":
		return OrderStatusCompletedTestkitCompleted, nil
	case "failed.testkit.failure_to_deliver_to_customer":
		return OrderStatusFailedTestkitFailureToDeliverToCustomer, nil
	case "failed.testkit.failure_to_deliver_to_lab":
		return OrderStatusFailedTestkitFailureToDeliverToLab, nil
	case "failed.testkit.sample_error":
		return OrderStatusFailedTestkitSampleError, nil
	case "failed.testkit.lost":
		return OrderStatusFailedTestkitLost, nil
	case "cancelled.testkit.cancelled":
		return OrderStatusCancelledTestkitCancelled, nil
	case "cancelled.testkit.do_not_process":
		return OrderStatusCancelledTestkitDoNotProcess, nil
	case "collecting_sample.testkit.problem_in_transit_customer":
		return OrderStatusCollectingSampleTestkitProblemInTransitCustomer, nil
	case "collecting_sample.testkit.problem_in_transit_lab":
		return OrderStatusCollectingSampleTestkitProblemInTransitLab, nil
	}
	var t OrderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderStatus) Ptr() *OrderStatus {
	return &o
}

type OrderTopLevelStatus string

const (
	OrderTopLevelStatusReceived         OrderTopLevelStatus = "received"
	OrderTopLevelStatusCollectingSample OrderTopLevelStatus = "collecting_sample"
	OrderTopLevelStatusSampleWithLab    OrderTopLevelStatus = "sample_with_lab"
	OrderTopLevelStatusCompleted        OrderTopLevelStatus = "completed"
	OrderTopLevelStatusCancelled        OrderTopLevelStatus = "cancelled"
	OrderTopLevelStatusFailed           OrderTopLevelStatus = "failed"
)

func NewOrderTopLevelStatusFromString(s string) (OrderTopLevelStatus, error) {
	switch s {
	case "received":
		return OrderTopLevelStatusReceived, nil
	case "collecting_sample":
		return OrderTopLevelStatusCollectingSample, nil
	case "sample_with_lab":
		return OrderTopLevelStatusSampleWithLab, nil
	case "completed":
		return OrderTopLevelStatusCompleted, nil
	case "cancelled":
		return OrderTopLevelStatusCancelled, nil
	case "failed":
		return OrderTopLevelStatusFailed, nil
	}
	var t OrderTopLevelStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderTopLevelStatus) Ptr() *OrderTopLevelStatus {
	return &o
}

type OvulationTestEntry struct {
	Date       string                       `json:"date" url:"date"`
	TestResult OvulationTestEntryTestResult `json:"test_result" url:"test_result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OvulationTestEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OvulationTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OvulationTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OvulationTestEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OvulationTestEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OvulationTestEntryTestResult string

const (
	OvulationTestEntryTestResultNegative                OvulationTestEntryTestResult = "negative"
	OvulationTestEntryTestResultPositive                OvulationTestEntryTestResult = "positive"
	OvulationTestEntryTestResultLuteinizingHormoneSurge OvulationTestEntryTestResult = "luteinizing_hormone_surge"
	OvulationTestEntryTestResultEstrogenSurge           OvulationTestEntryTestResult = "estrogen_surge"
	OvulationTestEntryTestResultIndeterminate           OvulationTestEntryTestResult = "indeterminate"
)

func NewOvulationTestEntryTestResultFromString(s string) (OvulationTestEntryTestResult, error) {
	switch s {
	case "negative":
		return OvulationTestEntryTestResultNegative, nil
	case "positive":
		return OvulationTestEntryTestResultPositive, nil
	case "luteinizing_hormone_surge":
		return OvulationTestEntryTestResultLuteinizingHormoneSurge, nil
	case "estrogen_surge":
		return OvulationTestEntryTestResultEstrogenSurge, nil
	case "indeterminate":
		return OvulationTestEntryTestResultIndeterminate, nil
	}
	var t OvulationTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OvulationTestEntryTestResult) Ptr() *OvulationTestEntryTestResult {
	return &o
}

type PaginatedUsersResponse struct {
	Users  []*ClientFacingUser `json:"users,omitempty" url:"users,omitempty"`
	Total  int                 `json:"total" url:"total"`
	Offset int                 `json:"offset" url:"offset"`
	Limit  int                 `json:"limit" url:"limit"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginatedUsersResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedUsersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedUsersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedUsersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedUsersResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ParentBiomarkerData struct {
	MarkerId   int     `json:"marker_id" url:"marker_id"`
	Name       string  `json:"name" url:"name"`
	Slug       string  `json:"slug" url:"slug"`
	ProviderId *string `json:"provider_id,omitempty" url:"provider_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ParentBiomarkerData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ParentBiomarkerData) UnmarshalJSON(data []byte) error {
	type unmarshaler ParentBiomarkerData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParentBiomarkerData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParentBiomarkerData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PasswordProviders string

const (
	PasswordProvidersWhoop           PasswordProviders = "whoop"
	PasswordProvidersRenpho          PasswordProviders = "renpho"
	PasswordProvidersPeloton         PasswordProviders = "peloton"
	PasswordProvidersZwift           PasswordProviders = "zwift"
	PasswordProvidersEightSleep      PasswordProviders = "eight_sleep"
	PasswordProvidersBeurerApi       PasswordProviders = "beurer_api"
	PasswordProvidersDexcom          PasswordProviders = "dexcom"
	PasswordProvidersHammerhead      PasswordProviders = "hammerhead"
	PasswordProvidersMyFitnessPal    PasswordProviders = "my_fitness_pal"
	PasswordProvidersKardia          PasswordProviders = "kardia"
	PasswordProvidersAbbottLibreview PasswordProviders = "abbott_libreview"
)

func NewPasswordProvidersFromString(s string) (PasswordProviders, error) {
	switch s {
	case "whoop":
		return PasswordProvidersWhoop, nil
	case "renpho":
		return PasswordProvidersRenpho, nil
	case "peloton":
		return PasswordProvidersPeloton, nil
	case "zwift":
		return PasswordProvidersZwift, nil
	case "eight_sleep":
		return PasswordProvidersEightSleep, nil
	case "beurer_api":
		return PasswordProvidersBeurerApi, nil
	case "dexcom":
		return PasswordProvidersDexcom, nil
	case "hammerhead":
		return PasswordProvidersHammerhead, nil
	case "my_fitness_pal":
		return PasswordProvidersMyFitnessPal, nil
	case "kardia":
		return PasswordProvidersKardia, nil
	case "abbott_libreview":
		return PasswordProvidersAbbottLibreview, nil
	}
	var t PasswordProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PasswordProviders) Ptr() *PasswordProviders {
	return &p
}

type PatientAddress struct {
	ReceiverName string  `json:"receiver_name" url:"receiver_name"`
	FirstLine    string  `json:"first_line" url:"first_line"`
	SecondLine   *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City         string  `json:"city" url:"city"`
	State        string  `json:"state" url:"state"`
	Zip          string  `json:"zip" url:"zip"`
	Country      string  `json:"country" url:"country"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatientAddress) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatientAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientAddress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientAddress) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatientAddressCompatible struct {
	ReceiverName *string `json:"receiver_name,omitempty" url:"receiver_name,omitempty"`
	FirstLine    string  `json:"first_line" url:"first_line"`
	SecondLine   *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City         string  `json:"city" url:"city"`
	State        string  `json:"state" url:"state"`
	Zip          string  `json:"zip" url:"zip"`
	Country      string  `json:"country" url:"country"`
	PhoneNumber  *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatientAddressCompatible) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatientAddressCompatible) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientAddressCompatible
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientAddressCompatible(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientAddressCompatible) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatientAddressWithValidation struct {
	ReceiverName *string `json:"receiver_name,omitempty" url:"receiver_name,omitempty"`
	FirstLine    string  `json:"first_line" url:"first_line"`
	SecondLine   *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City         string  `json:"city" url:"city"`
	State        string  `json:"state" url:"state"`
	Zip          string  `json:"zip" url:"zip"`
	Country      string  `json:"country" url:"country"`
	PhoneNumber  *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatientAddressWithValidation) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatientAddressWithValidation) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientAddressWithValidation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientAddressWithValidation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientAddressWithValidation) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Patient details with validation for first_name, last_name, email, and dob.
type PatientDetailsWithValidation struct {
	FirstName   string    `json:"first_name" url:"first_name"`
	LastName    string    `json:"last_name" url:"last_name"`
	Dob         time.Time `json:"dob" url:"dob"`
	Gender      Gender    `json:"gender" url:"gender"`
	PhoneNumber string    `json:"phone_number" url:"phone_number"`
	Email       string    `json:"email" url:"email"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatientDetailsWithValidation) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatientDetailsWithValidation) UnmarshalJSON(data []byte) error {
	type embed PatientDetailsWithValidation
	var unmarshaler = struct {
		embed
		Dob *core.DateTime `json:"dob"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PatientDetailsWithValidation(unmarshaler.embed)
	p.Dob = unmarshaler.Dob.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientDetailsWithValidation) MarshalJSON() ([]byte, error) {
	type embed PatientDetailsWithValidation
	var marshaler = struct {
		embed
		Dob *core.DateTime `json:"dob"`
	}{
		embed: embed(*p),
		Dob:   core.NewDateTime(p.Dob),
	}
	return json.Marshal(marshaler)
}

func (p *PatientDetailsWithValidation) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayorCodeExternalProvider string

const (
	PayorCodeExternalProviderChangeHealthcare PayorCodeExternalProvider = "change_healthcare"
	PayorCodeExternalProviderAvaility         PayorCodeExternalProvider = "availity"
)

func NewPayorCodeExternalProviderFromString(s string) (PayorCodeExternalProvider, error) {
	switch s {
	case "change_healthcare":
		return PayorCodeExternalProviderChangeHealthcare, nil
	case "availity":
		return PayorCodeExternalProviderAvaility, nil
	}
	var t PayorCodeExternalProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayorCodeExternalProvider) Ptr() *PayorCodeExternalProvider {
	return &p
}

type Period struct {
	Value *int       `json:"value,omitempty" url:"value,omitempty"`
	Unit  PeriodUnit `json:"unit" url:"unit"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Period) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Period) UnmarshalJSON(data []byte) error {
	type unmarshaler Period
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Period(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Period) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PeriodUnit string

const (
	PeriodUnitMinute PeriodUnit = "minute"
	PeriodUnitHour   PeriodUnit = "hour"
	PeriodUnitDay    PeriodUnit = "day"
	PeriodUnitWeek   PeriodUnit = "week"
	PeriodUnitMonth  PeriodUnit = "month"
	PeriodUnitYear   PeriodUnit = "year"
)

func NewPeriodUnitFromString(s string) (PeriodUnit, error) {
	switch s {
	case "minute":
		return PeriodUnitMinute, nil
	case "hour":
		return PeriodUnitHour, nil
	case "day":
		return PeriodUnitDay, nil
	case "week":
		return PeriodUnitWeek, nil
	case "month":
		return PeriodUnitMonth, nil
	case "year":
		return PeriodUnitYear, nil
	}
	var t PeriodUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PeriodUnit) Ptr() *PeriodUnit {
	return &p
}

type PhlebotomyAreaInfo struct {
	IsServed  bool                      `json:"is_served" url:"is_served"`
	Providers []*PhlebotomyProviderInfo `json:"providers,omitempty" url:"providers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhlebotomyAreaInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhlebotomyAreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhlebotomyAreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhlebotomyAreaInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhlebotomyAreaInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhlebotomyProviderInfo struct {
	Name         AppointmentProvider      `json:"name" url:"name"`
	ServiceTypes []AppointmentServiceType `json:"service_types,omitempty" url:"service_types,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhlebotomyProviderInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhlebotomyProviderInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhlebotomyProviderInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhlebotomyProviderInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhlebotomyProviderInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequest struct {
	FirstName      string   `json:"first_name" url:"first_name"`
	LastName       string   `json:"last_name" url:"last_name"`
	Email          *string  `json:"email,omitempty" url:"email,omitempty"`
	Npi            string   `json:"npi" url:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty" url:"licensed_states,omitempty"`
	// An image of the physician signature for health insurance billing
	SignatureImage *PhysicianCreateRequestSignatureImage `json:"signature_image,omitempty" url:"signature_image,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhysicianCreateRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhysicianCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequestBase struct {
	FirstName      string   `json:"first_name" url:"first_name"`
	LastName       string   `json:"last_name" url:"last_name"`
	Email          *string  `json:"email,omitempty" url:"email,omitempty"`
	Npi            string   `json:"npi" url:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty" url:"licensed_states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhysicianCreateRequestBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhysicianCreateRequestBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequestBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequestBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequestBase) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An image of the physician signature for health insurance billing
type PhysicianCreateRequestSignatureImage struct {
	Jpeg *Jpeg
	Png  *Png
}

func NewPhysicianCreateRequestSignatureImageFromJpeg(value *Jpeg) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{Jpeg: value}
}

func NewPhysicianCreateRequestSignatureImageFromPng(value *Png) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{Png: value}
}

func (p *PhysicianCreateRequestSignatureImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		p.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		p.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhysicianCreateRequestSignatureImage) MarshalJSON() ([]byte, error) {
	if p.Jpeg != nil {
		return json.Marshal(p.Jpeg)
	}
	if p.Png != nil {
		return json.Marshal(p.Png)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PhysicianCreateRequestSignatureImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (p *PhysicianCreateRequestSignatureImage) Accept(visitor PhysicianCreateRequestSignatureImageVisitor) error {
	if p.Jpeg != nil {
		return visitor.VisitJpeg(p.Jpeg)
	}
	if p.Png != nil {
		return visitor.VisitPng(p.Png)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type Placeholder struct {
	Placeholder bool `json:"placeholder" url:"placeholder"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Placeholder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Placeholder) UnmarshalJSON(data []byte) error {
	type unmarshaler Placeholder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Placeholder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Placeholder) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Png struct {
	Content     string `json:"content" url:"content"`
	contentType string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Png) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Png) ContentType() string {
	return p.contentType
}

func (p *Png) UnmarshalJSON(data []byte) error {
	type embed Png
	var unmarshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Png(unmarshaler.embed)
	if unmarshaler.ContentType != "image/png" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "image/png", unmarshaler.ContentType)
	}
	p.contentType = unmarshaler.ContentType

	extraProperties, err := core.ExtractExtraProperties(data, *p, "content_type")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Png) MarshalJSON() ([]byte, error) {
	type embed Png
	var marshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed:       embed(*p),
		ContentType: "image/png",
	}
	return json.Marshal(marshaler)
}

func (p *Png) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostOrderResponse struct {
	Order   *ClientFacingOrder `json:"order,omitempty" url:"order,omitempty"`
	Status  string             `json:"status" url:"status"`
	Message string             `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PostOrderResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostOrderResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileInDb struct {
	Data       string                `json:"data" url:"data"`
	UserId     string                `json:"user_id" url:"user_id"`
	SourceId   int                   `json:"source_id" url:"source_id"`
	PriorityId *int                  `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                `json:"id" url:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty" url:"source,omitempty"`
	UpdatedAt  *time.Time            `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProfileInDb) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProfileInDb) UnmarshalJSON(data []byte) error {
	type embed ProfileInDb
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = ProfileInDb(unmarshaler.embed)
	p.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileInDb) MarshalJSON() ([]byte, error) {
	type embed ProfileInDb
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*p),
		UpdatedAt: core.NewOptionalDateTime(p.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *ProfileInDb) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderConnectionCreated struct {
	UserId string `json:"user_id" url:"user_id"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Source               *ClientFacingProvider            `json:"source,omitempty" url:"source,omitempty"`
	Provider             *ClientFacingProvider            `json:"provider,omitempty" url:"provider,omitempty"`
	ResourceAvailability map[string]*ResourceAvailability `json:"resource_availability,omitempty" url:"resource_availability,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderConnectionCreated) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderConnectionCreated) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderConnectionCreated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderConnectionCreated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderConnectionCreated) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderConnectionError struct {
	Provider     string `json:"provider" url:"provider"`
	UserId       string `json:"user_id" url:"user_id"`
	Message      string `json:"message" url:"message"`
	ErrorType    string `json:"error_type" url:"error_type"`
	ErrorDetails string `json:"error_details" url:"error_details"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderConnectionError) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderConnectionError) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderConnectionError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderConnectionError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderConnectionError) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderLinkResponse struct {
	State       ProviderLinkResponseState `json:"state" url:"state"`
	RedirectUrl *string                   `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	ErrorType   *string                   `json:"error_type,omitempty" url:"error_type,omitempty"`
	Error       *string                   `json:"error,omitempty" url:"error,omitempty"`
	ProviderMfa *ProviderMfaRequest       `json:"provider_mfa,omitempty" url:"provider_mfa,omitempty"`
	Provider    PasswordProviders         `json:"provider" url:"provider"`
	Connected   bool                      `json:"connected" url:"connected"`
	ProviderId  *string                   `json:"provider_id,omitempty" url:"provider_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderLinkResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderLinkResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderLinkResponseState string

const (
	ProviderLinkResponseStateSuccess            ProviderLinkResponseState = "success"
	ProviderLinkResponseStateError              ProviderLinkResponseState = "error"
	ProviderLinkResponseStatePendingProviderMfa ProviderLinkResponseState = "pending_provider_mfa"
)

func NewProviderLinkResponseStateFromString(s string) (ProviderLinkResponseState, error) {
	switch s {
	case "success":
		return ProviderLinkResponseStateSuccess, nil
	case "error":
		return ProviderLinkResponseStateError, nil
	case "pending_provider_mfa":
		return ProviderLinkResponseStatePendingProviderMfa, nil
	}
	var t ProviderLinkResponseState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderLinkResponseState) Ptr() *ProviderLinkResponseState {
	return &p
}

type ProviderMfaRequest struct {
	Method ProviderMfaRequestMethod `json:"method" url:"method"`
	Hint   string                   `json:"hint" url:"hint"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderMfaRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderMfaRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderMfaRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderMfaRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderMfaRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderMfaRequestMethod string

const (
	ProviderMfaRequestMethodSms   ProviderMfaRequestMethod = "sms"
	ProviderMfaRequestMethodEmail ProviderMfaRequestMethod = "email"
)

func NewProviderMfaRequestMethodFromString(s string) (ProviderMfaRequestMethod, error) {
	switch s {
	case "sms":
		return ProviderMfaRequestMethodSms, nil
	case "email":
		return ProviderMfaRequestMethodEmail, nil
	}
	var t ProviderMfaRequestMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderMfaRequestMethod) Ptr() *ProviderMfaRequestMethod {
	return &p
}

type Providers string

const (
	ProvidersOura              Providers = "oura"
	ProvidersFitbit            Providers = "fitbit"
	ProvidersGarmin            Providers = "garmin"
	ProvidersWhoop             Providers = "whoop"
	ProvidersStrava            Providers = "strava"
	ProvidersRenpho            Providers = "renpho"
	ProvidersPeloton           Providers = "peloton"
	ProvidersWahoo             Providers = "wahoo"
	ProvidersZwift             Providers = "zwift"
	ProvidersFreestyleLibre    Providers = "freestyle_libre"
	ProvidersAbbottLibreview   Providers = "abbott_libreview"
	ProvidersFreestyleLibreBle Providers = "freestyle_libre_ble"
	ProvidersEightSleep        Providers = "eight_sleep"
	ProvidersWithings          Providers = "withings"
	ProvidersAppleHealthKit    Providers = "apple_health_kit"
	ProvidersManual            Providers = "manual"
	ProvidersIhealth           Providers = "ihealth"
	ProvidersGoogleFit         Providers = "google_fit"
	ProvidersBeurerApi         Providers = "beurer_api"
	ProvidersBeurerBle         Providers = "beurer_ble"
	ProvidersOmron             Providers = "omron"
	ProvidersOmronBle          Providers = "omron_ble"
	ProvidersOnetouchBle       Providers = "onetouch_ble"
	ProvidersAccuchekBle       Providers = "accuchek_ble"
	ProvidersContourBle        Providers = "contour_ble"
	ProvidersDexcom            Providers = "dexcom"
	ProvidersDexcomV3          Providers = "dexcom_v3"
	ProvidersHammerhead        Providers = "hammerhead"
	ProvidersMyFitnessPal      Providers = "my_fitness_pal"
	ProvidersHealthConnect     Providers = "health_connect"
	ProvidersPolar             Providers = "polar"
	ProvidersCronometer        Providers = "cronometer"
	ProvidersKardia            Providers = "kardia"
	ProvidersWhoopV2           Providers = "whoop_v2"
	ProvidersUltrahuman        Providers = "ultrahuman"
	ProvidersMyFitnessPalV2    Providers = "my_fitness_pal_v2"
	ProvidersMapMyFitness      Providers = "map_my_fitness"
)

func NewProvidersFromString(s string) (Providers, error) {
	switch s {
	case "oura":
		return ProvidersOura, nil
	case "fitbit":
		return ProvidersFitbit, nil
	case "garmin":
		return ProvidersGarmin, nil
	case "whoop":
		return ProvidersWhoop, nil
	case "strava":
		return ProvidersStrava, nil
	case "renpho":
		return ProvidersRenpho, nil
	case "peloton":
		return ProvidersPeloton, nil
	case "wahoo":
		return ProvidersWahoo, nil
	case "zwift":
		return ProvidersZwift, nil
	case "freestyle_libre":
		return ProvidersFreestyleLibre, nil
	case "abbott_libreview":
		return ProvidersAbbottLibreview, nil
	case "freestyle_libre_ble":
		return ProvidersFreestyleLibreBle, nil
	case "eight_sleep":
		return ProvidersEightSleep, nil
	case "withings":
		return ProvidersWithings, nil
	case "apple_health_kit":
		return ProvidersAppleHealthKit, nil
	case "manual":
		return ProvidersManual, nil
	case "ihealth":
		return ProvidersIhealth, nil
	case "google_fit":
		return ProvidersGoogleFit, nil
	case "beurer_api":
		return ProvidersBeurerApi, nil
	case "beurer_ble":
		return ProvidersBeurerBle, nil
	case "omron":
		return ProvidersOmron, nil
	case "omron_ble":
		return ProvidersOmronBle, nil
	case "onetouch_ble":
		return ProvidersOnetouchBle, nil
	case "accuchek_ble":
		return ProvidersAccuchekBle, nil
	case "contour_ble":
		return ProvidersContourBle, nil
	case "dexcom":
		return ProvidersDexcom, nil
	case "dexcom_v3":
		return ProvidersDexcomV3, nil
	case "hammerhead":
		return ProvidersHammerhead, nil
	case "my_fitness_pal":
		return ProvidersMyFitnessPal, nil
	case "health_connect":
		return ProvidersHealthConnect, nil
	case "polar":
		return ProvidersPolar, nil
	case "cronometer":
		return ProvidersCronometer, nil
	case "kardia":
		return ProvidersKardia, nil
	case "whoop_v2":
		return ProvidersWhoopV2, nil
	case "ultrahuman":
		return ProvidersUltrahuman, nil
	case "my_fitness_pal_v2":
		return ProvidersMyFitnessPalV2, nil
	case "map_my_fitness":
		return ProvidersMapMyFitness, nil
	}
	var t Providers
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Providers) Ptr() *Providers {
	return &p
}

type PscAreaInfo struct {
	PatientServiceCenters *PscAreaInfoDetails `json:"patient_service_centers,omitempty" url:"patient_service_centers,omitempty"`
	SupportedBillTypes    []Billing           `json:"supported_bill_types,omitempty" url:"supported_bill_types,omitempty"`
	LabId                 int                 `json:"lab_id" url:"lab_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PscAreaInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PscAreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PscAreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscAreaInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscAreaInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PscAreaInfoDetails struct {
	AppointmentWithVital bool   `json:"appointment_with_vital" url:"appointment_with_vital"`
	WithinRadius         int    `json:"within_radius" url:"within_radius"`
	Radius               string `json:"radius" url:"radius"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PscAreaInfoDetails) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PscAreaInfoDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PscAreaInfoDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscAreaInfoDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscAreaInfoDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PscInfo struct {
	LabId                 int                        `json:"lab_id" url:"lab_id"`
	Slug                  Labs                       `json:"slug" url:"slug"`
	PatientServiceCenters []*ClientFacingLabLocation `json:"patient_service_centers,omitempty" url:"patient_service_centers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PscInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PscInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PscInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Query struct {
	Select        []*QuerySelectItem  `json:"select,omitempty" url:"select,omitempty"`
	GroupBy       []*QueryGroupByItem `json:"group_by,omitempty" url:"group_by,omitempty"`
	SplitBySource *bool               `json:"split_by_source,omitempty" url:"split_by_source,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *Query) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *Query) UnmarshalJSON(data []byte) error {
	type unmarshaler Query
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = Query(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *Query) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryConfig struct {
	ProviderPriorityOverrides []*QueryConfigProviderPriorityOverridesItem `json:"provider_priority_overrides,omitempty" url:"provider_priority_overrides,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryConfig) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryConfig) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryConfigProviderPriorityOverridesItem struct {
	Providers Providers
	Labs      Labs
}

func NewQueryConfigProviderPriorityOverridesItemFromProviders(value Providers) *QueryConfigProviderPriorityOverridesItem {
	return &QueryConfigProviderPriorityOverridesItem{Providers: value}
}

func NewQueryConfigProviderPriorityOverridesItemFromLabs(value Labs) *QueryConfigProviderPriorityOverridesItem {
	return &QueryConfigProviderPriorityOverridesItem{Labs: value}
}

func (q *QueryConfigProviderPriorityOverridesItem) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		q.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		q.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryConfigProviderPriorityOverridesItem) MarshalJSON() ([]byte, error) {
	if q.Providers != "" {
		return json.Marshal(q.Providers)
	}
	if q.Labs != "" {
		return json.Marshal(q.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryConfigProviderPriorityOverridesItemVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (q *QueryConfigProviderPriorityOverridesItem) Accept(visitor QueryConfigProviderPriorityOverridesItemVisitor) error {
	if q.Providers != "" {
		return visitor.VisitProviders(q.Providers)
	}
	if q.Labs != "" {
		return visitor.VisitLabs(q.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryGroupByItem struct {
	DateTruncExpr *DateTruncExpr
	DatePartExpr  *DatePartExpr
}

func NewQueryGroupByItemFromDateTruncExpr(value *DateTruncExpr) *QueryGroupByItem {
	return &QueryGroupByItem{DateTruncExpr: value}
}

func NewQueryGroupByItemFromDatePartExpr(value *DatePartExpr) *QueryGroupByItem {
	return &QueryGroupByItem{DatePartExpr: value}
}

func (q *QueryGroupByItem) UnmarshalJSON(data []byte) error {
	valueDateTruncExpr := new(DateTruncExpr)
	if err := json.Unmarshal(data, &valueDateTruncExpr); err == nil {
		q.DateTruncExpr = valueDateTruncExpr
		return nil
	}
	valueDatePartExpr := new(DatePartExpr)
	if err := json.Unmarshal(data, &valueDatePartExpr); err == nil {
		q.DatePartExpr = valueDatePartExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryGroupByItem) MarshalJSON() ([]byte, error) {
	if q.DateTruncExpr != nil {
		return json.Marshal(q.DateTruncExpr)
	}
	if q.DatePartExpr != nil {
		return json.Marshal(q.DatePartExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryGroupByItemVisitor interface {
	VisitDateTruncExpr(*DateTruncExpr) error
	VisitDatePartExpr(*DatePartExpr) error
}

func (q *QueryGroupByItem) Accept(visitor QueryGroupByItemVisitor) error {
	if q.DateTruncExpr != nil {
		return visitor.VisitDateTruncExpr(q.DateTruncExpr)
	}
	if q.DatePartExpr != nil {
		return visitor.VisitDatePartExpr(q.DatePartExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QuerySelectItem struct {
	AggregateExpr              *AggregateExpr
	GroupKeyColumnExpr         *GroupKeyColumnExpr
	SleepColumnExpr            *SleepColumnExpr
	ActivityColumnExpr         *ActivityColumnExpr
	WorkoutColumnExpr          *WorkoutColumnExpr
	BodyColumnExpr             *BodyColumnExpr
	IndexColumnExpr            *IndexColumnExpr
	SleepScoreValueMacroExpr   *SleepScoreValueMacroExpr
	ChronotypeValueMacroExpr   *ChronotypeValueMacroExpr
	UnrecognizedValueMacroExpr *UnrecognizedValueMacroExpr
}

func NewQuerySelectItemFromAggregateExpr(value *AggregateExpr) *QuerySelectItem {
	return &QuerySelectItem{AggregateExpr: value}
}

func NewQuerySelectItemFromGroupKeyColumnExpr(value *GroupKeyColumnExpr) *QuerySelectItem {
	return &QuerySelectItem{GroupKeyColumnExpr: value}
}

func NewQuerySelectItemFromSleepColumnExpr(value *SleepColumnExpr) *QuerySelectItem {
	return &QuerySelectItem{SleepColumnExpr: value}
}

func NewQuerySelectItemFromActivityColumnExpr(value *ActivityColumnExpr) *QuerySelectItem {
	return &QuerySelectItem{ActivityColumnExpr: value}
}

func NewQuerySelectItemFromWorkoutColumnExpr(value *WorkoutColumnExpr) *QuerySelectItem {
	return &QuerySelectItem{WorkoutColumnExpr: value}
}

func NewQuerySelectItemFromBodyColumnExpr(value *BodyColumnExpr) *QuerySelectItem {
	return &QuerySelectItem{BodyColumnExpr: value}
}

func NewQuerySelectItemFromIndexColumnExpr(value *IndexColumnExpr) *QuerySelectItem {
	return &QuerySelectItem{IndexColumnExpr: value}
}

func NewQuerySelectItemFromSleepScoreValueMacroExpr(value *SleepScoreValueMacroExpr) *QuerySelectItem {
	return &QuerySelectItem{SleepScoreValueMacroExpr: value}
}

func NewQuerySelectItemFromChronotypeValueMacroExpr(value *ChronotypeValueMacroExpr) *QuerySelectItem {
	return &QuerySelectItem{ChronotypeValueMacroExpr: value}
}

func NewQuerySelectItemFromUnrecognizedValueMacroExpr(value *UnrecognizedValueMacroExpr) *QuerySelectItem {
	return &QuerySelectItem{UnrecognizedValueMacroExpr: value}
}

func (q *QuerySelectItem) UnmarshalJSON(data []byte) error {
	valueAggregateExpr := new(AggregateExpr)
	if err := json.Unmarshal(data, &valueAggregateExpr); err == nil {
		q.AggregateExpr = valueAggregateExpr
		return nil
	}
	valueGroupKeyColumnExpr := new(GroupKeyColumnExpr)
	if err := json.Unmarshal(data, &valueGroupKeyColumnExpr); err == nil {
		q.GroupKeyColumnExpr = valueGroupKeyColumnExpr
		return nil
	}
	valueSleepColumnExpr := new(SleepColumnExpr)
	if err := json.Unmarshal(data, &valueSleepColumnExpr); err == nil {
		q.SleepColumnExpr = valueSleepColumnExpr
		return nil
	}
	valueActivityColumnExpr := new(ActivityColumnExpr)
	if err := json.Unmarshal(data, &valueActivityColumnExpr); err == nil {
		q.ActivityColumnExpr = valueActivityColumnExpr
		return nil
	}
	valueWorkoutColumnExpr := new(WorkoutColumnExpr)
	if err := json.Unmarshal(data, &valueWorkoutColumnExpr); err == nil {
		q.WorkoutColumnExpr = valueWorkoutColumnExpr
		return nil
	}
	valueBodyColumnExpr := new(BodyColumnExpr)
	if err := json.Unmarshal(data, &valueBodyColumnExpr); err == nil {
		q.BodyColumnExpr = valueBodyColumnExpr
		return nil
	}
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		q.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valueSleepScoreValueMacroExpr := new(SleepScoreValueMacroExpr)
	if err := json.Unmarshal(data, &valueSleepScoreValueMacroExpr); err == nil {
		q.SleepScoreValueMacroExpr = valueSleepScoreValueMacroExpr
		return nil
	}
	valueChronotypeValueMacroExpr := new(ChronotypeValueMacroExpr)
	if err := json.Unmarshal(data, &valueChronotypeValueMacroExpr); err == nil {
		q.ChronotypeValueMacroExpr = valueChronotypeValueMacroExpr
		return nil
	}
	valueUnrecognizedValueMacroExpr := new(UnrecognizedValueMacroExpr)
	if err := json.Unmarshal(data, &valueUnrecognizedValueMacroExpr); err == nil {
		q.UnrecognizedValueMacroExpr = valueUnrecognizedValueMacroExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QuerySelectItem) MarshalJSON() ([]byte, error) {
	if q.AggregateExpr != nil {
		return json.Marshal(q.AggregateExpr)
	}
	if q.GroupKeyColumnExpr != nil {
		return json.Marshal(q.GroupKeyColumnExpr)
	}
	if q.SleepColumnExpr != nil {
		return json.Marshal(q.SleepColumnExpr)
	}
	if q.ActivityColumnExpr != nil {
		return json.Marshal(q.ActivityColumnExpr)
	}
	if q.WorkoutColumnExpr != nil {
		return json.Marshal(q.WorkoutColumnExpr)
	}
	if q.BodyColumnExpr != nil {
		return json.Marshal(q.BodyColumnExpr)
	}
	if q.IndexColumnExpr != nil {
		return json.Marshal(q.IndexColumnExpr)
	}
	if q.SleepScoreValueMacroExpr != nil {
		return json.Marshal(q.SleepScoreValueMacroExpr)
	}
	if q.ChronotypeValueMacroExpr != nil {
		return json.Marshal(q.ChronotypeValueMacroExpr)
	}
	if q.UnrecognizedValueMacroExpr != nil {
		return json.Marshal(q.UnrecognizedValueMacroExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QuerySelectItemVisitor interface {
	VisitAggregateExpr(*AggregateExpr) error
	VisitGroupKeyColumnExpr(*GroupKeyColumnExpr) error
	VisitSleepColumnExpr(*SleepColumnExpr) error
	VisitActivityColumnExpr(*ActivityColumnExpr) error
	VisitWorkoutColumnExpr(*WorkoutColumnExpr) error
	VisitBodyColumnExpr(*BodyColumnExpr) error
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitSleepScoreValueMacroExpr(*SleepScoreValueMacroExpr) error
	VisitChronotypeValueMacroExpr(*ChronotypeValueMacroExpr) error
	VisitUnrecognizedValueMacroExpr(*UnrecognizedValueMacroExpr) error
}

func (q *QuerySelectItem) Accept(visitor QuerySelectItemVisitor) error {
	if q.AggregateExpr != nil {
		return visitor.VisitAggregateExpr(q.AggregateExpr)
	}
	if q.GroupKeyColumnExpr != nil {
		return visitor.VisitGroupKeyColumnExpr(q.GroupKeyColumnExpr)
	}
	if q.SleepColumnExpr != nil {
		return visitor.VisitSleepColumnExpr(q.SleepColumnExpr)
	}
	if q.ActivityColumnExpr != nil {
		return visitor.VisitActivityColumnExpr(q.ActivityColumnExpr)
	}
	if q.WorkoutColumnExpr != nil {
		return visitor.VisitWorkoutColumnExpr(q.WorkoutColumnExpr)
	}
	if q.BodyColumnExpr != nil {
		return visitor.VisitBodyColumnExpr(q.BodyColumnExpr)
	}
	if q.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(q.IndexColumnExpr)
	}
	if q.SleepScoreValueMacroExpr != nil {
		return visitor.VisitSleepScoreValueMacroExpr(q.SleepScoreValueMacroExpr)
	}
	if q.ChronotypeValueMacroExpr != nil {
		return visitor.VisitChronotypeValueMacroExpr(q.ChronotypeValueMacroExpr)
	}
	if q.UnrecognizedValueMacroExpr != nil {
		return visitor.VisitUnrecognizedValueMacroExpr(q.UnrecognizedValueMacroExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type Question struct {
	Id         int          `json:"id" url:"id"`
	Required   bool         `json:"required" url:"required"`
	Code       string       `json:"code" url:"code"`
	Value      string       `json:"value" url:"value"`
	Type       QuestionType `json:"type" url:"type"`
	Sequence   int          `json:"sequence" url:"sequence"`
	Answers    []*Answer    `json:"answers,omitempty" url:"answers,omitempty"`
	Constraint *string      `json:"constraint,omitempty" url:"constraint,omitempty"`
	Default    *string      `json:"default,omitempty" url:"default,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *Question) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *Question) UnmarshalJSON(data []byte) error {
	type unmarshaler Question
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = Question(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *Question) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QuestionType string

const (
	QuestionTypeChoice      QuestionType = "choice"
	QuestionTypeText        QuestionType = "text"
	QuestionTypeNumeric     QuestionType = "numeric"
	QuestionTypeMultiChoice QuestionType = "multi_choice"
)

func NewQuestionTypeFromString(s string) (QuestionType, error) {
	switch s {
	case "choice":
		return QuestionTypeChoice, nil
	case "text":
		return QuestionTypeText, nil
	case "numeric":
		return QuestionTypeNumeric, nil
	case "multi_choice":
		return QuestionTypeMultiChoice, nil
	}
	var t QuestionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QuestionType) Ptr() *QuestionType {
	return &q
}

type RawActivity struct {
	Activity []*ActivityV2InDb `json:"activity,omitempty" url:"activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawActivity) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler RawActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawActivity(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawActivity) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawBody struct {
	Body []*BodyV2InDb `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawBody) UnmarshalJSON(data []byte) error {
	type unmarshaler RawBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawDevices struct {
	Devices []*DeviceV2InDb `json:"devices,omitempty" url:"devices,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawDevices) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawDevices) UnmarshalJSON(data []byte) error {
	type unmarshaler RawDevices
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawDevices(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawDevices) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawProfile struct {
	Profile *ProfileInDb `json:"profile,omitempty" url:"profile,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawProfile) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler RawProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawProfile) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawSleep struct {
	Sleep []*SleepV2InDb `json:"sleep,omitempty" url:"sleep,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawSleep) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawSleep) UnmarshalJSON(data []byte) error {
	type unmarshaler RawSleep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawSleep(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawSleep) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawWorkout struct {
	Workouts []*WorkoutV2InDb `json:"workouts,omitempty" url:"workouts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RawWorkout) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawWorkout) UnmarshalJSON(data []byte) error {
	type unmarshaler RawWorkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawWorkout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawWorkout) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Region string

const (
	RegionUs Region = "us"
	RegionEu Region = "eu"
	RegionDe Region = "de"
	RegionFr Region = "fr"
	RegionCa Region = "ca"
	RegionBr Region = "br"
	RegionAr Region = "ar"
	RegionCl Region = "cl"
	RegionCo Region = "co"
	RegionMx Region = "mx"
	RegionGb Region = "gb"
	RegionIe Region = "ie"
	RegionAu Region = "au"
	RegionNz Region = "nz"
	RegionNl Region = "nl"
	RegionAt Region = "at"
	RegionBe Region = "be"
	RegionBh Region = "bh"
	RegionCh Region = "ch"
	RegionCz Region = "cz"
	RegionDk Region = "dk"
	RegionEg Region = "eg"
	RegionEs Region = "es"
	RegionFi Region = "fi"
	RegionGr Region = "gr"
	RegionHr Region = "hr"
	RegionIl Region = "il"
	RegionIt Region = "it"
	RegionJo Region = "jo"
	RegionKw Region = "kw"
	RegionLb Region = "lb"
	RegionLu Region = "lu"
	RegionNo Region = "no"
	RegionOm Region = "om"
	RegionPl Region = "pl"
	RegionPt Region = "pt"
	RegionQa Region = "qa"
	RegionSa Region = "sa"
	RegionSe Region = "se"
	RegionSi Region = "si"
	RegionSk Region = "sk"
	RegionTr Region = "tr"
	RegionZa Region = "za"
	RegionIn Region = "in"
	RegionSg Region = "sg"
	RegionHk Region = "hk"
	RegionKr Region = "kr"
	RegionPh Region = "ph"
	RegionTw Region = "tw"
)

func NewRegionFromString(s string) (Region, error) {
	switch s {
	case "us":
		return RegionUs, nil
	case "eu":
		return RegionEu, nil
	case "de":
		return RegionDe, nil
	case "fr":
		return RegionFr, nil
	case "ca":
		return RegionCa, nil
	case "br":
		return RegionBr, nil
	case "ar":
		return RegionAr, nil
	case "cl":
		return RegionCl, nil
	case "co":
		return RegionCo, nil
	case "mx":
		return RegionMx, nil
	case "gb":
		return RegionGb, nil
	case "ie":
		return RegionIe, nil
	case "au":
		return RegionAu, nil
	case "nz":
		return RegionNz, nil
	case "nl":
		return RegionNl, nil
	case "at":
		return RegionAt, nil
	case "be":
		return RegionBe, nil
	case "bh":
		return RegionBh, nil
	case "ch":
		return RegionCh, nil
	case "cz":
		return RegionCz, nil
	case "dk":
		return RegionDk, nil
	case "eg":
		return RegionEg, nil
	case "es":
		return RegionEs, nil
	case "fi":
		return RegionFi, nil
	case "gr":
		return RegionGr, nil
	case "hr":
		return RegionHr, nil
	case "il":
		return RegionIl, nil
	case "it":
		return RegionIt, nil
	case "jo":
		return RegionJo, nil
	case "kw":
		return RegionKw, nil
	case "lb":
		return RegionLb, nil
	case "lu":
		return RegionLu, nil
	case "no":
		return RegionNo, nil
	case "om":
		return RegionOm, nil
	case "pl":
		return RegionPl, nil
	case "pt":
		return RegionPt, nil
	case "qa":
		return RegionQa, nil
	case "sa":
		return RegionSa, nil
	case "se":
		return RegionSe, nil
	case "si":
		return RegionSi, nil
	case "sk":
		return RegionSk, nil
	case "tr":
		return RegionTr, nil
	case "za":
		return RegionZa, nil
	case "in":
		return RegionIn, nil
	case "sg":
		return RegionSg, nil
	case "hk":
		return RegionHk, nil
	case "kr":
		return RegionKr, nil
	case "ph":
		return RegionPh, nil
	case "tw":
		return RegionTw, nil
	}
	var t Region
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Region) Ptr() *Region {
	return &r
}

type RelativeTimeframe struct {
	Anchor string  `json:"anchor" url:"anchor"`
	Past   *Period `json:"past,omitempty" url:"past,omitempty"`
	type_  string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RelativeTimeframe) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RelativeTimeframe) Type() string {
	return r.type_
}

func (r *RelativeTimeframe) UnmarshalJSON(data []byte) error {
	type embed RelativeTimeframe
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RelativeTimeframe(unmarshaler.embed)
	if unmarshaler.Type != "relative" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "relative", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelativeTimeframe) MarshalJSON() ([]byte, error) {
	type embed RelativeTimeframe
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "relative",
	}
	return json.Marshal(marshaler)
}

func (r *RelativeTimeframe) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResendWebhookResponse struct {
	OrderIds []string `json:"order_ids,omitempty" url:"order_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResendWebhookResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResendWebhookResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResendWebhookResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResendWebhookResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResendWebhookResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceAvailability struct {
	Status            Availability             `json:"status" url:"status"`
	ScopeRequirements *ScopeRequirementsGrants `json:"scope_requirements,omitempty" url:"scope_requirements,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResourceAvailability) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResourceAvailability) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceAvailability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceAvailability(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceAvailability) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponsibleRelationship string

const (
	ResponsibleRelationshipSelf   ResponsibleRelationship = "Self"
	ResponsibleRelationshipSpouse ResponsibleRelationship = "Spouse"
	ResponsibleRelationshipOther  ResponsibleRelationship = "Other"
)

func NewResponsibleRelationshipFromString(s string) (ResponsibleRelationship, error) {
	switch s {
	case "Self":
		return ResponsibleRelationshipSelf, nil
	case "Spouse":
		return ResponsibleRelationshipSpouse, nil
	case "Other":
		return ResponsibleRelationshipOther, nil
	}
	var t ResponsibleRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponsibleRelationship) Ptr() *ResponsibleRelationship {
	return &r
}

type ResultType string

const (
	ResultTypeNumeric ResultType = "numeric"
	ResultTypeRange   ResultType = "range"
	ResultTypeComment ResultType = "comment"
)

func NewResultTypeFromString(s string) (ResultType, error) {
	switch s {
	case "numeric":
		return ResultTypeNumeric, nil
	case "range":
		return ResultTypeRange, nil
	case "comment":
		return ResultTypeComment, nil
	}
	var t ResultType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResultType) Ptr() *ResultType {
	return &r
}

type ScopeRequirementsGrants struct {
	UserGranted *ScopeRequirementsStr `json:"user_granted,omitempty" url:"user_granted,omitempty"`
	UserDenied  *ScopeRequirementsStr `json:"user_denied,omitempty" url:"user_denied,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScopeRequirementsGrants) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopeRequirementsGrants) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsGrants
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsGrants(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsGrants) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScopeRequirementsStr struct {
	Required []string `json:"required,omitempty" url:"required,omitempty"`
	Optional []string `json:"optional,omitempty" url:"optional,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScopeRequirementsStr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopeRequirementsStr) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsStr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsStr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsStr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Select string

const (
	SelectSelectAll Select = "*"
)

func NewSelectFromString(s string) (Select, error) {
	switch s {
	case "*":
		return SelectSelectAll, nil
	}
	var t Select
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Select) Ptr() *Select {
	return &s
}

type SexualActivityEntry struct {
	Date           string `json:"date" url:"date"`
	ProtectionUsed *bool  `json:"protection_used,omitempty" url:"protection_used,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SexualActivityEntry) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SexualActivityEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler SexualActivityEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SexualActivityEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SexualActivityEntry) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ShippingAddress struct {
	ReceiverName string  `json:"receiver_name" url:"receiver_name"`
	FirstLine    string  `json:"first_line" url:"first_line"`
	SecondLine   *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City         string  `json:"city" url:"city"`
	State        string  `json:"state" url:"state"`
	Zip          string  `json:"zip" url:"zip"`
	Country      string  `json:"country" url:"country"`
	PhoneNumber  string  `json:"phone_number" url:"phone_number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShippingAddress) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShippingAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingAddress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingAddress) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ShippingAddressWithValidation struct {
	ReceiverName string  `json:"receiver_name" url:"receiver_name"`
	FirstLine    string  `json:"first_line" url:"first_line"`
	SecondLine   *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City         string  `json:"city" url:"city"`
	State        string  `json:"state" url:"state"`
	Zip          string  `json:"zip" url:"zip"`
	Country      string  `json:"country" url:"country"`
	PhoneNumber  string  `json:"phone_number" url:"phone_number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShippingAddressWithValidation) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShippingAddressWithValidation) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingAddressWithValidation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingAddressWithValidation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingAddressWithValidation) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleHistoricalPullStatistics struct {
	Status       HistoricalPullStatus    `json:"status" url:"status"`
	RangeStart   *time.Time              `json:"range_start,omitempty" url:"range_start,omitempty"`
	RangeEnd     *time.Time              `json:"range_end,omitempty" url:"range_end,omitempty"`
	Timeline     *HistoricalPullTimeline `json:"timeline,omitempty" url:"timeline,omitempty"`
	DaysWithData *int                    `json:"days_with_data,omitempty" url:"days_with_data,omitempty"`
	Release      string                  `json:"release" url:"release"`
	TraceId      *string                 `json:"trace_id,omitempty" url:"trace_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleHistoricalPullStatistics) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleHistoricalPullStatistics) UnmarshalJSON(data []byte) error {
	type embed SingleHistoricalPullStatistics
	var unmarshaler = struct {
		embed
		RangeStart *core.DateTime `json:"range_start,omitempty"`
		RangeEnd   *core.DateTime `json:"range_end,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SingleHistoricalPullStatistics(unmarshaler.embed)
	s.RangeStart = unmarshaler.RangeStart.TimePtr()
	s.RangeEnd = unmarshaler.RangeEnd.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleHistoricalPullStatistics) MarshalJSON() ([]byte, error) {
	type embed SingleHistoricalPullStatistics
	var marshaler = struct {
		embed
		RangeStart *core.DateTime `json:"range_start,omitempty"`
		RangeEnd   *core.DateTime `json:"range_end,omitempty"`
	}{
		embed:      embed(*s),
		RangeStart: core.NewOptionalDateTime(s.RangeStart),
		RangeEnd:   core.NewOptionalDateTime(s.RangeEnd),
	}
	return json.Marshal(marshaler)
}

func (s *SingleHistoricalPullStatistics) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleProviderHistoricalPullResponse struct {
	Pulled    map[string]*SingleHistoricalPullStatistics `json:"pulled,omitempty" url:"pulled,omitempty"`
	NotPulled []ClientFacingResource                     `json:"not_pulled,omitempty" url:"not_pulled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleProviderHistoricalPullResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleProviderHistoricalPullResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleProviderHistoricalPullResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleProviderHistoricalPullResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleProviderHistoricalPullResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleResourceStatistics struct {
	LastAttempt *LastAttempt `json:"last_attempt,omitempty" url:"last_attempt,omitempty"`
	OldestData  *time.Time   `json:"oldest_data,omitempty" url:"oldest_data,omitempty"`
	NewestData  *time.Time   `json:"newest_data,omitempty" url:"newest_data,omitempty"`
	SentCount   *int         `json:"sent_count,omitempty" url:"sent_count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleResourceStatistics) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleResourceStatistics) UnmarshalJSON(data []byte) error {
	type embed SingleResourceStatistics
	var unmarshaler = struct {
		embed
		OldestData *core.DateTime `json:"oldest_data,omitempty"`
		NewestData *core.DateTime `json:"newest_data,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SingleResourceStatistics(unmarshaler.embed)
	s.OldestData = unmarshaler.OldestData.TimePtr()
	s.NewestData = unmarshaler.NewestData.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleResourceStatistics) MarshalJSON() ([]byte, error) {
	type embed SingleResourceStatistics
	var marshaler = struct {
		embed
		OldestData *core.DateTime `json:"oldest_data,omitempty"`
		NewestData *core.DateTime `json:"newest_data,omitempty"`
	}{
		embed:      embed(*s),
		OldestData: core.NewOptionalDateTime(s.OldestData),
		NewestData: core.NewOptionalDateTime(s.NewestData),
	}
	return json.Marshal(marshaler)
}

func (s *SingleResourceStatistics) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUserHistoricalPullResponse struct {
	UserId   string                                           `json:"user_id" url:"user_id"`
	Provider map[string]*SingleProviderHistoricalPullResponse `json:"provider,omitempty" url:"provider,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleUserHistoricalPullResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUserHistoricalPullResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUserHistoricalPullResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUserHistoricalPullResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUserHistoricalPullResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUserResourceResponse struct {
	UserId   string                                          `json:"user_id" url:"user_id"`
	Provider map[string]map[string]*SingleResourceStatistics `json:"provider,omitempty" url:"provider,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleUserResourceResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUserResourceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUserResourceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUserResourceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUserResourceResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepColumnExpr struct {
	Sleep SleepColumnExprSleep `json:"sleep" url:"sleep"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SleepColumnExpr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler SleepColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SleepColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepColumnExpr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepColumnExprSleep string

const (
	SleepColumnExprSleepSessionStart         SleepColumnExprSleep = "session_start"
	SleepColumnExprSleepSessionEnd           SleepColumnExprSleep = "session_end"
	SleepColumnExprSleepState                SleepColumnExprSleep = "state"
	SleepColumnExprSleepType                 SleepColumnExprSleep = "type"
	SleepColumnExprSleepDurationSecond       SleepColumnExprSleep = "duration_second"
	SleepColumnExprSleepStageAsleepSecond    SleepColumnExprSleep = "stage_asleep_second"
	SleepColumnExprSleepStageAwakeSecond     SleepColumnExprSleep = "stage_awake_second"
	SleepColumnExprSleepStageLightSecond     SleepColumnExprSleep = "stage_light_second"
	SleepColumnExprSleepStageRemSecond       SleepColumnExprSleep = "stage_rem_second"
	SleepColumnExprSleepStageDeepSecond      SleepColumnExprSleep = "stage_deep_second"
	SleepColumnExprSleepStageUnknownSecond   SleepColumnExprSleep = "stage_unknown_second"
	SleepColumnExprSleepLatencySecond        SleepColumnExprSleep = "latency_second"
	SleepColumnExprSleepHeartRateMinimum     SleepColumnExprSleep = "heart_rate_minimum"
	SleepColumnExprSleepHeartRateMean        SleepColumnExprSleep = "heart_rate_mean"
	SleepColumnExprSleepHeartRateMaximum     SleepColumnExprSleep = "heart_rate_maximum"
	SleepColumnExprSleepHeartRateDip         SleepColumnExprSleep = "heart_rate_dip"
	SleepColumnExprSleepHeartRateResting     SleepColumnExprSleep = "heart_rate_resting"
	SleepColumnExprSleepEfficiency           SleepColumnExprSleep = "efficiency"
	SleepColumnExprSleepHrvMeanRmssd         SleepColumnExprSleep = "hrv_mean_rmssd"
	SleepColumnExprSleepHrvMeanSdnn          SleepColumnExprSleep = "hrv_mean_sdnn"
	SleepColumnExprSleepSkinTemperature      SleepColumnExprSleep = "skin_temperature"
	SleepColumnExprSleepSkinTemperatureDelta SleepColumnExprSleep = "skin_temperature_delta"
	SleepColumnExprSleepRespiratoryRate      SleepColumnExprSleep = "respiratory_rate"
	SleepColumnExprSleepScore                SleepColumnExprSleep = "score"
	SleepColumnExprSleepSourceType           SleepColumnExprSleep = "source_type"
	SleepColumnExprSleepSourceProvider       SleepColumnExprSleep = "source_provider"
	SleepColumnExprSleepSourceAppId          SleepColumnExprSleep = "source_app_id"
	SleepColumnExprSleepTimeZone             SleepColumnExprSleep = "time_zone"
)

func NewSleepColumnExprSleepFromString(s string) (SleepColumnExprSleep, error) {
	switch s {
	case "session_start":
		return SleepColumnExprSleepSessionStart, nil
	case "session_end":
		return SleepColumnExprSleepSessionEnd, nil
	case "state":
		return SleepColumnExprSleepState, nil
	case "type":
		return SleepColumnExprSleepType, nil
	case "duration_second":
		return SleepColumnExprSleepDurationSecond, nil
	case "stage_asleep_second":
		return SleepColumnExprSleepStageAsleepSecond, nil
	case "stage_awake_second":
		return SleepColumnExprSleepStageAwakeSecond, nil
	case "stage_light_second":
		return SleepColumnExprSleepStageLightSecond, nil
	case "stage_rem_second":
		return SleepColumnExprSleepStageRemSecond, nil
	case "stage_deep_second":
		return SleepColumnExprSleepStageDeepSecond, nil
	case "stage_unknown_second":
		return SleepColumnExprSleepStageUnknownSecond, nil
	case "latency_second":
		return SleepColumnExprSleepLatencySecond, nil
	case "heart_rate_minimum":
		return SleepColumnExprSleepHeartRateMinimum, nil
	case "heart_rate_mean":
		return SleepColumnExprSleepHeartRateMean, nil
	case "heart_rate_maximum":
		return SleepColumnExprSleepHeartRateMaximum, nil
	case "heart_rate_dip":
		return SleepColumnExprSleepHeartRateDip, nil
	case "heart_rate_resting":
		return SleepColumnExprSleepHeartRateResting, nil
	case "efficiency":
		return SleepColumnExprSleepEfficiency, nil
	case "hrv_mean_rmssd":
		return SleepColumnExprSleepHrvMeanRmssd, nil
	case "hrv_mean_sdnn":
		return SleepColumnExprSleepHrvMeanSdnn, nil
	case "skin_temperature":
		return SleepColumnExprSleepSkinTemperature, nil
	case "skin_temperature_delta":
		return SleepColumnExprSleepSkinTemperatureDelta, nil
	case "respiratory_rate":
		return SleepColumnExprSleepRespiratoryRate, nil
	case "score":
		return SleepColumnExprSleepScore, nil
	case "source_type":
		return SleepColumnExprSleepSourceType, nil
	case "source_provider":
		return SleepColumnExprSleepSourceProvider, nil
	case "source_app_id":
		return SleepColumnExprSleepSourceAppId, nil
	case "time_zone":
		return SleepColumnExprSleepTimeZone, nil
	}
	var t SleepColumnExprSleep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepColumnExprSleep) Ptr() *SleepColumnExprSleep {
	return &s
}

type SleepScoreValueMacroExpr struct {
	Version    *string `json:"version,omitempty" url:"version,omitempty"`
	valueMacro string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SleepScoreValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepScoreValueMacroExpr) ValueMacro() string {
	return s.valueMacro
}

func (s *SleepScoreValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed SleepScoreValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SleepScoreValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "sleep_score" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "sleep_score", unmarshaler.ValueMacro)
	}
	s.valueMacro = unmarshaler.ValueMacro

	extraProperties, err := core.ExtractExtraProperties(data, *s, "value_macro")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepScoreValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed SleepScoreValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*s),
		ValueMacro: "sleep_score",
	}
	return json.Marshal(marshaler)
}

func (s *SleepScoreValueMacroExpr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepSummaryState string

const (
	SleepSummaryStateTentative SleepSummaryState = "tentative"
	SleepSummaryStateConfirmed SleepSummaryState = "confirmed"
)

func NewSleepSummaryStateFromString(s string) (SleepSummaryState, error) {
	switch s {
	case "tentative":
		return SleepSummaryStateTentative, nil
	case "confirmed":
		return SleepSummaryStateConfirmed, nil
	}
	var t SleepSummaryState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepSummaryState) Ptr() *SleepSummaryState {
	return &s
}

type SleepType string

const (
	SleepTypeLongSleep       SleepType = "long_sleep"
	SleepTypeShortSleep      SleepType = "short_sleep"
	SleepTypeAcknowledgedNap SleepType = "acknowledged_nap"
	SleepTypeUnknown         SleepType = "unknown"
)

func NewSleepTypeFromString(s string) (SleepType, error) {
	switch s {
	case "long_sleep":
		return SleepTypeLongSleep, nil
	case "short_sleep":
		return SleepTypeShortSleep, nil
	case "acknowledged_nap":
		return SleepTypeAcknowledgedNap, nil
	case "unknown":
		return SleepTypeUnknown, nil
	}
	var t SleepType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepType) Ptr() *SleepType {
	return &s
}

type SleepV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                 `json:"id" url:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`
	Priority   *int                   `json:"priority,omitempty" url:"priority,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SleepV2InDb) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepV2InDb) UnmarshalJSON(data []byte) error {
	type embed SleepV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SleepV2InDb(unmarshaler.embed)
	s.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepV2InDb) MarshalJSON() ([]byte, error) {
	type embed SleepV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*s),
		Timestamp: core.NewDateTime(s.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (s *SleepV2InDb) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Source struct {
	Name            string          `json:"name" url:"name"`
	Slug            string          `json:"slug" url:"slug"`
	Description     string          `json:"description" url:"description"`
	Logo            string          `json:"logo" url:"logo"`
	Group           *string         `json:"group,omitempty" url:"group,omitempty"`
	OauthUrl        *string         `json:"oauth_url,omitempty" url:"oauth_url,omitempty"`
	AuthType        *SourceAuthType `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	SourceType      *SourceType     `json:"source_type,omitempty" url:"source_type,omitempty"`
	IsActive        *bool           `json:"is_active,omitempty" url:"is_active,omitempty"`
	BackfillNumDays *int            `json:"backfill_num_days,omitempty" url:"backfill_num_days,omitempty"`
	Id              int             `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Source) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceAuthType string

const (
	SourceAuthTypeOauth     SourceAuthType = "oauth"
	SourceAuthTypeTeamOauth SourceAuthType = "team_oauth"
	SourceAuthTypeSdk       SourceAuthType = "sdk"
	SourceAuthTypePassword  SourceAuthType = "password"
	SourceAuthTypeEmail     SourceAuthType = "email"
	SourceAuthTypeApp       SourceAuthType = "app"
	SourceAuthTypeEmpty     SourceAuthType = ""
)

func NewSourceAuthTypeFromString(s string) (SourceAuthType, error) {
	switch s {
	case "oauth":
		return SourceAuthTypeOauth, nil
	case "team_oauth":
		return SourceAuthTypeTeamOauth, nil
	case "sdk":
		return SourceAuthTypeSdk, nil
	case "password":
		return SourceAuthTypePassword, nil
	case "email":
		return SourceAuthTypeEmail, nil
	case "app":
		return SourceAuthTypeApp, nil
	case "":
		return SourceAuthTypeEmpty, nil
	}
	var t SourceAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAuthType) Ptr() *SourceAuthType {
	return &s
}

type SourceLink struct {
	Id             int                    `json:"id" url:"id"`
	Name           string                 `json:"name" url:"name"`
	Slug           string                 `json:"slug" url:"slug"`
	Description    string                 `json:"description" url:"description"`
	Logo           string                 `json:"logo" url:"logo"`
	OauthUrl       *string                `json:"oauth_url,omitempty" url:"oauth_url,omitempty"`
	AuthType       *SourceAuthType        `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	FormComponents map[string]interface{} `json:"form_components,omitempty" url:"form_components,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SourceLink) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceLink) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceLink(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceLink) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceType string

const (
	SourceTypeApp      SourceType = "app"
	SourceTypeBle      SourceType = "ble"
	SourceTypeDevice   SourceType = "device"
	SourceTypeLab      SourceType = "lab"
	SourceTypeProvider SourceType = "provider"
)

func NewSourceTypeFromString(s string) (SourceType, error) {
	switch s {
	case "app":
		return SourceTypeApp, nil
	case "ble":
		return SourceTypeBle, nil
	case "device":
		return SourceTypeDevice, nil
	case "lab":
		return SourceTypeLab, nil
	case "provider":
		return SourceTypeProvider, nil
	}
	var t SourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceType) Ptr() *SourceType {
	return &s
}

type TeamConfig struct {
	Libreview                      *LibreConfig                 `json:"libreview,omitempty" url:"libreview,omitempty"`
	TextsEnabled                   *bool                        `json:"texts_enabled,omitempty" url:"texts_enabled,omitempty"`
	PushHistoricalData             *bool                        `json:"push_historical_data,omitempty" url:"push_historical_data,omitempty"`
	ProviderRawData                *bool                        `json:"provider_raw_data,omitempty" url:"provider_raw_data,omitempty"`
	RejectDuplicateConnection      *bool                        `json:"reject_duplicate_connection,omitempty" url:"reject_duplicate_connection,omitempty"`
	SdkPerDeviceActivityTimeseries *bool                        `json:"sdk_per_device_activity_timeseries,omitempty" url:"sdk_per_device_activity_timeseries,omitempty"`
	EdsPreferences                 *EventDestinationPreferences `json:"eds_preferences,omitempty" url:"eds_preferences,omitempty"`
	EventTypePrefixes              []string                     `json:"event_type_prefixes,omitempty" url:"event_type_prefixes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamConfig) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamConfig) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeSlot struct {
	BookingKey *string `json:"booking_key,omitempty" url:"booking_key,omitempty"`
	// Time is in UTC
	Start time.Time `json:"start" url:"start"`
	// Time is in UTC
	End                      time.Time  `json:"end" url:"end"`
	ExpiresAt                *time.Time `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	Price                    float64    `json:"price" url:"price"`
	IsPriority               bool       `json:"is_priority" url:"is_priority"`
	NumAppointmentsAvailable int        `json:"num_appointments_available" url:"num_appointments_available"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeSlot) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeSlot) UnmarshalJSON(data []byte) error {
	type embed TimeSlot
	var unmarshaler = struct {
		embed
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		ExpiresAt *core.DateTime `json:"expires_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeSlot(unmarshaler.embed)
	t.Start = unmarshaler.Start.Time()
	t.End = unmarshaler.End.Time()
	t.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeSlot) MarshalJSON() ([]byte, error) {
	type embed TimeSlot
	var marshaler = struct {
		embed
		Start     *core.DateTime `json:"start"`
		End       *core.DateTime `json:"end"`
		ExpiresAt *core.DateTime `json:"expires_at,omitempty"`
	}{
		embed:     embed(*t),
		Start:     core.NewDateTime(t.Start),
		End:       core.NewDateTime(t.End),
		ExpiresAt: core.NewOptionalDateTime(t.ExpiresAt),
	}
	return json.Marshal(marshaler)
}

func (t *TimeSlot) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeseriesMetricPoint struct {
	Date  time.Time `json:"date" url:"date"`
	Value float64   `json:"value" url:"value"`
	All   float64   `json:"all" url:"all"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeseriesMetricPoint) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeseriesMetricPoint) UnmarshalJSON(data []byte) error {
	type embed TimeseriesMetricPoint
	var unmarshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeseriesMetricPoint(unmarshaler.embed)
	t.Date = unmarshaler.Date.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeseriesMetricPoint) MarshalJSON() ([]byte, error) {
	type embed TimeseriesMetricPoint
	var marshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*t),
		Date:  core.NewDateTime(t.Date),
	}
	return json.Marshal(marshaler)
}

func (t *TimeseriesMetricPoint) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeseriesResource string

const (
	TimeseriesResourceCaloriesActive            TimeseriesResource = "calories_active"
	TimeseriesResourceCaloriesBasal             TimeseriesResource = "calories_basal"
	TimeseriesResourceDistance                  TimeseriesResource = "distance"
	TimeseriesResourceBloodOxygen               TimeseriesResource = "blood_oxygen"
	TimeseriesResourceBloodPressure             TimeseriesResource = "blood_pressure"
	TimeseriesResourceBodyFat                   TimeseriesResource = "body_fat"
	TimeseriesResourceBodyWeight                TimeseriesResource = "body_weight"
	TimeseriesResourceBodyTemperature           TimeseriesResource = "body_temperature"
	TimeseriesResourceBodyTemperatureDelta      TimeseriesResource = "body_temperature_delta"
	TimeseriesResourceCholesterol               TimeseriesResource = "cholesterol"
	TimeseriesResourceCholesterolLdl            TimeseriesResource = "cholesterol/ldl"
	TimeseriesResourceCholesterolHdl            TimeseriesResource = "cholesterol/hdl"
	TimeseriesResourceCholesterolTotal          TimeseriesResource = "cholesterol/total"
	TimeseriesResourceCholesterolTriglycerides  TimeseriesResource = "cholesterol/triglycerides"
	TimeseriesResourceElectrocardiogramVoltage  TimeseriesResource = "electrocardiogram_voltage"
	TimeseriesResourceFloorsClimbed             TimeseriesResource = "floors_climbed"
	TimeseriesResourceGlucose                   TimeseriesResource = "glucose"
	TimeseriesResourceHeartrate                 TimeseriesResource = "heartrate"
	TimeseriesResourceHrv                       TimeseriesResource = "hrv"
	TimeseriesResourceHypnogram                 TimeseriesResource = "hypnogram"
	TimeseriesResourceIge                       TimeseriesResource = "ige"
	TimeseriesResourceIgg                       TimeseriesResource = "igg"
	TimeseriesResourceRespiratoryRate           TimeseriesResource = "respiratory_rate"
	TimeseriesResourceSteps                     TimeseriesResource = "steps"
	TimeseriesResourceStressLevel               TimeseriesResource = "stress_level"
	TimeseriesResourceVo2Max                    TimeseriesResource = "vo2_max"
	TimeseriesResourceWater                     TimeseriesResource = "water"
	TimeseriesResourceCaffeine                  TimeseriesResource = "caffeine"
	TimeseriesResourceMindfulnessMinutes        TimeseriesResource = "mindfulness_minutes"
	TimeseriesResourceAfibBurden                TimeseriesResource = "afib_burden"
	TimeseriesResourceHeartRateAlert            TimeseriesResource = "heart_rate_alert"
	TimeseriesResourceStandHour                 TimeseriesResource = "stand_hour"
	TimeseriesResourceStandDuration             TimeseriesResource = "stand_duration"
	TimeseriesResourceSleepApneaAlert           TimeseriesResource = "sleep_apnea_alert"
	TimeseriesResourceSleepBreathingDisturbance TimeseriesResource = "sleep_breathing_disturbance"
	TimeseriesResourceWheelchairPush            TimeseriesResource = "wheelchair_push"
	TimeseriesResourceForcedExpiratoryVolume1   TimeseriesResource = "forced_expiratory_volume_1"
	TimeseriesResourceForcedVitalCapacity       TimeseriesResource = "forced_vital_capacity"
	TimeseriesResourcePeakExpiratoryFlowRate    TimeseriesResource = "peak_expiratory_flow_rate"
	TimeseriesResourceInhalerUsage              TimeseriesResource = "inhaler_usage"
	TimeseriesResourceFall                      TimeseriesResource = "fall"
	TimeseriesResourceUvExposure                TimeseriesResource = "uv_exposure"
	TimeseriesResourceDaylightExposure          TimeseriesResource = "daylight_exposure"
	TimeseriesResourceHandwashing               TimeseriesResource = "handwashing"
	TimeseriesResourceBasalBodyTemperature      TimeseriesResource = "basal_body_temperature"
	TimeseriesResourceWorkoutDuration           TimeseriesResource = "workout_duration"
	TimeseriesResourceInsulinInjection          TimeseriesResource = "insulin_injection"
	TimeseriesResourceCarbohydrates             TimeseriesResource = "carbohydrates"
	TimeseriesResourceNote                      TimeseriesResource = "note"
)

func NewTimeseriesResourceFromString(s string) (TimeseriesResource, error) {
	switch s {
	case "calories_active":
		return TimeseriesResourceCaloriesActive, nil
	case "calories_basal":
		return TimeseriesResourceCaloriesBasal, nil
	case "distance":
		return TimeseriesResourceDistance, nil
	case "blood_oxygen":
		return TimeseriesResourceBloodOxygen, nil
	case "blood_pressure":
		return TimeseriesResourceBloodPressure, nil
	case "body_fat":
		return TimeseriesResourceBodyFat, nil
	case "body_weight":
		return TimeseriesResourceBodyWeight, nil
	case "body_temperature":
		return TimeseriesResourceBodyTemperature, nil
	case "body_temperature_delta":
		return TimeseriesResourceBodyTemperatureDelta, nil
	case "cholesterol":
		return TimeseriesResourceCholesterol, nil
	case "cholesterol/ldl":
		return TimeseriesResourceCholesterolLdl, nil
	case "cholesterol/hdl":
		return TimeseriesResourceCholesterolHdl, nil
	case "cholesterol/total":
		return TimeseriesResourceCholesterolTotal, nil
	case "cholesterol/triglycerides":
		return TimeseriesResourceCholesterolTriglycerides, nil
	case "electrocardiogram_voltage":
		return TimeseriesResourceElectrocardiogramVoltage, nil
	case "floors_climbed":
		return TimeseriesResourceFloorsClimbed, nil
	case "glucose":
		return TimeseriesResourceGlucose, nil
	case "heartrate":
		return TimeseriesResourceHeartrate, nil
	case "hrv":
		return TimeseriesResourceHrv, nil
	case "hypnogram":
		return TimeseriesResourceHypnogram, nil
	case "ige":
		return TimeseriesResourceIge, nil
	case "igg":
		return TimeseriesResourceIgg, nil
	case "respiratory_rate":
		return TimeseriesResourceRespiratoryRate, nil
	case "steps":
		return TimeseriesResourceSteps, nil
	case "stress_level":
		return TimeseriesResourceStressLevel, nil
	case "vo2_max":
		return TimeseriesResourceVo2Max, nil
	case "water":
		return TimeseriesResourceWater, nil
	case "caffeine":
		return TimeseriesResourceCaffeine, nil
	case "mindfulness_minutes":
		return TimeseriesResourceMindfulnessMinutes, nil
	case "afib_burden":
		return TimeseriesResourceAfibBurden, nil
	case "heart_rate_alert":
		return TimeseriesResourceHeartRateAlert, nil
	case "stand_hour":
		return TimeseriesResourceStandHour, nil
	case "stand_duration":
		return TimeseriesResourceStandDuration, nil
	case "sleep_apnea_alert":
		return TimeseriesResourceSleepApneaAlert, nil
	case "sleep_breathing_disturbance":
		return TimeseriesResourceSleepBreathingDisturbance, nil
	case "wheelchair_push":
		return TimeseriesResourceWheelchairPush, nil
	case "forced_expiratory_volume_1":
		return TimeseriesResourceForcedExpiratoryVolume1, nil
	case "forced_vital_capacity":
		return TimeseriesResourceForcedVitalCapacity, nil
	case "peak_expiratory_flow_rate":
		return TimeseriesResourcePeakExpiratoryFlowRate, nil
	case "inhaler_usage":
		return TimeseriesResourceInhalerUsage, nil
	case "fall":
		return TimeseriesResourceFall, nil
	case "uv_exposure":
		return TimeseriesResourceUvExposure, nil
	case "daylight_exposure":
		return TimeseriesResourceDaylightExposure, nil
	case "handwashing":
		return TimeseriesResourceHandwashing, nil
	case "basal_body_temperature":
		return TimeseriesResourceBasalBodyTemperature, nil
	case "workout_duration":
		return TimeseriesResourceWorkoutDuration, nil
	case "insulin_injection":
		return TimeseriesResourceInsulinInjection, nil
	case "carbohydrates":
		return TimeseriesResourceCarbohydrates, nil
	case "note":
		return TimeseriesResourceNote, nil
	}
	var t TimeseriesResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeseriesResource) Ptr() *TimeseriesResource {
	return &t
}

type TraceElements string

const (
	TraceElementsChromium   TraceElements = "chromium"
	TraceElementsCopper     TraceElements = "copper"
	TraceElementsIodine     TraceElements = "iodine"
	TraceElementsManganese  TraceElements = "manganese"
	TraceElementsMolybdenum TraceElements = "molybdenum"
	TraceElementsSelenium   TraceElements = "selenium"
)

func NewTraceElementsFromString(s string) (TraceElements, error) {
	switch s {
	case "chromium":
		return TraceElementsChromium, nil
	case "copper":
		return TraceElementsCopper, nil
	case "iodine":
		return TraceElementsIodine, nil
	case "manganese":
		return TraceElementsManganese, nil
	case "molybdenum":
		return TraceElementsMolybdenum, nil
	case "selenium":
		return TraceElementsSelenium, nil
	}
	var t TraceElements
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TraceElements) Ptr() *TraceElements {
	return &t
}

type UnrecognizedValueMacroExpr struct {
	ValueMacro string `json:"value_macro" url:"value_macro"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UnrecognizedValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnrecognizedValueMacroExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler UnrecognizedValueMacroExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnrecognizedValueMacroExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnrecognizedValueMacroExpr) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsAddress struct {
	FirstLine  string  `json:"first_line" url:"first_line"`
	SecondLine *string `json:"second_line,omitempty" url:"second_line,omitempty"`
	City       string  `json:"city" url:"city"`
	State      string  `json:"state" url:"state"`
	ZipCode    string  `json:"zip_code" url:"zip_code"`
	// Deprecated. Use `second_line` instead to provide the unit number. Subject to removal after 20 Nov 2023.
	Unit *string `json:"unit,omitempty" url:"unit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UsAddress) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler UsAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsAddress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsAddress) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserHistoricalPullsResponse struct {
	Data []*SingleUserHistoricalPullResponse `json:"data,omitempty" url:"data,omitempty"`
	Next *string                             `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserHistoricalPullsResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserHistoricalPullsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserHistoricalPullsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserHistoricalPullsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserHistoricalPullsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserInfo struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Email       string   `json:"email" url:"email"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`
	Gender      string   `json:"gender" url:"gender"`
	Dob         string   `json:"dob" url:"dob"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserInfo) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler UserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserInfo) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshErrorResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId        string   `json:"user_id" url:"user_id"`
	Error         string   `json:"error" url:"error"`
	FailedSources []string `json:"failed_sources,omitempty" url:"failed_sources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserRefreshErrorResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserRefreshErrorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshErrorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshErrorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshErrorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId            string   `json:"user_id" url:"user_id"`
	RefreshedSources  []string `json:"refreshed_sources,omitempty" url:"refreshed_sources,omitempty"`
	InProgressSources []string `json:"in_progress_sources,omitempty" url:"in_progress_sources,omitempty"`
	FailedSources     []string `json:"failed_sources,omitempty" url:"failed_sources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserRefreshSuccessResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserRefreshSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshSuccessResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserResourcesResponse struct {
	Data []*SingleUserResourceResponse `json:"data,omitempty" url:"data,omitempty"`
	Next *string                       `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserResourcesResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserResourcesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserResourcesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserResourcesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserResourcesResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSignInTokenResponse struct {
	UserId      string `json:"user_id" url:"user_id"`
	SignInToken string `json:"sign_in_token" url:"sign_in_token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserSignInTokenResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserSignInTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSignInTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSignInTokenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSignInTokenResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserSuccessResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSuccessResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty" url:"loc,omitempty"`
	Msg  string                    `json:"msg" url:"msg"`
	Type string                    `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *ValidationError) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	String  string
	Integer int
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{Integer: value}
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	if v.String != "" {
		return json.Marshal(v.String)
	}
	if v.Integer != 0 {
		return json.Marshal(v.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	if v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.Integer != 0 {
		return visitor.VisitInteger(v.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

type VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`
	PhoneType   *string  `json:"phone_type,omitempty" url:"phone_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Gender      Gender   `json:"gender" url:"gender"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`
	Dob         string   `json:"dob" url:"dob"`
	Email       string   `json:"email" url:"email"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VitalSleepStage = int

type VitalTokenCreatedResponse struct {
	Code        string    `json:"code" url:"code"`
	ExchangeUrl string    `json:"exchange_url" url:"exchange_url"`
	ExpiresAt   time.Time `json:"expires_at" url:"expires_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VitalTokenCreatedResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VitalTokenCreatedResponse) UnmarshalJSON(data []byte) error {
	type embed VitalTokenCreatedResponse
	var unmarshaler = struct {
		embed
		ExpiresAt *core.DateTime `json:"expires_at"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VitalTokenCreatedResponse(unmarshaler.embed)
	v.ExpiresAt = unmarshaler.ExpiresAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalTokenCreatedResponse) MarshalJSON() ([]byte, error) {
	type embed VitalTokenCreatedResponse
	var marshaler = struct {
		embed
		ExpiresAt *core.DateTime `json:"expires_at"`
	}{
		embed:     embed(*v),
		ExpiresAt: core.NewDateTime(v.ExpiresAt),
	}
	return json.Marshal(marshaler)
}

func (v *VitalTokenCreatedResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type Vitamins string

const (
	VitaminsVitaminA        Vitamins = "vitamin_a"
	VitaminsVitaminB1       Vitamins = "vitamin_b1"
	VitaminsRiboflavin      Vitamins = "riboflavin"
	VitaminsNiacin          Vitamins = "niacin"
	VitaminsPantothenicAcid Vitamins = "pantothenic_acid"
	VitaminsVitaminB6       Vitamins = "vitamin_b6"
	VitaminsBiotin          Vitamins = "biotin"
	VitaminsVitaminB12      Vitamins = "vitamin_b12"
	VitaminsVitaminC        Vitamins = "vitamin_c"
	VitaminsVitaminD        Vitamins = "vitamin_d"
	VitaminsVitaminE        Vitamins = "vitamin_e"
	VitaminsVitaminK        Vitamins = "vitamin_k"
	VitaminsFolicAcid       Vitamins = "folic_acid"
)

func NewVitaminsFromString(s string) (Vitamins, error) {
	switch s {
	case "vitamin_a":
		return VitaminsVitaminA, nil
	case "vitamin_b1":
		return VitaminsVitaminB1, nil
	case "riboflavin":
		return VitaminsRiboflavin, nil
	case "niacin":
		return VitaminsNiacin, nil
	case "pantothenic_acid":
		return VitaminsPantothenicAcid, nil
	case "vitamin_b6":
		return VitaminsVitaminB6, nil
	case "biotin":
		return VitaminsBiotin, nil
	case "vitamin_b12":
		return VitaminsVitaminB12, nil
	case "vitamin_c":
		return VitaminsVitaminC, nil
	case "vitamin_d":
		return VitaminsVitaminD, nil
	case "vitamin_e":
		return VitaminsVitaminE, nil
	case "vitamin_k":
		return VitaminsVitaminK, nil
	case "folic_acid":
		return VitaminsFolicAcid, nil
	}
	var t Vitamins
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v Vitamins) Ptr() *Vitamins {
	return &v
}

type WorkoutColumnExpr struct {
	Workout WorkoutColumnExprWorkout `json:"workout" url:"workout"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkoutColumnExpr) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkoutColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkoutColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkoutColumnExpr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutColumnExpr) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WorkoutColumnExprWorkout string

const (
	WorkoutColumnExprWorkoutSessionStart          WorkoutColumnExprWorkout = "session_start"
	WorkoutColumnExprWorkoutSessionEnd            WorkoutColumnExprWorkout = "session_end"
	WorkoutColumnExprWorkoutTitle                 WorkoutColumnExprWorkout = "title"
	WorkoutColumnExprWorkoutSportName             WorkoutColumnExprWorkout = "sport_name"
	WorkoutColumnExprWorkoutSportSlug             WorkoutColumnExprWorkout = "sport_slug"
	WorkoutColumnExprWorkoutDurationActiveSecond  WorkoutColumnExprWorkout = "duration_active_second"
	WorkoutColumnExprWorkoutHeartRateMean         WorkoutColumnExprWorkout = "heart_rate_mean"
	WorkoutColumnExprWorkoutHeartRateMinimum      WorkoutColumnExprWorkout = "heart_rate_minimum"
	WorkoutColumnExprWorkoutHeartRateMaximum      WorkoutColumnExprWorkout = "heart_rate_maximum"
	WorkoutColumnExprWorkoutHeartRateZone1        WorkoutColumnExprWorkout = "heart_rate_zone_1"
	WorkoutColumnExprWorkoutHeartRateZone2        WorkoutColumnExprWorkout = "heart_rate_zone_2"
	WorkoutColumnExprWorkoutHeartRateZone3        WorkoutColumnExprWorkout = "heart_rate_zone_3"
	WorkoutColumnExprWorkoutHeartRateZone4        WorkoutColumnExprWorkout = "heart_rate_zone_4"
	WorkoutColumnExprWorkoutHeartRateZone5        WorkoutColumnExprWorkout = "heart_rate_zone_5"
	WorkoutColumnExprWorkoutHeartRateZone6        WorkoutColumnExprWorkout = "heart_rate_zone_6"
	WorkoutColumnExprWorkoutDistanceMeter         WorkoutColumnExprWorkout = "distance_meter"
	WorkoutColumnExprWorkoutCalories              WorkoutColumnExprWorkout = "calories"
	WorkoutColumnExprWorkoutElevationGainMeter    WorkoutColumnExprWorkout = "elevation_gain_meter"
	WorkoutColumnExprWorkoutElevationMaximumMeter WorkoutColumnExprWorkout = "elevation_maximum_meter"
	WorkoutColumnExprWorkoutElevationMinimumMeter WorkoutColumnExprWorkout = "elevation_minimum_meter"
	WorkoutColumnExprWorkoutSpeedMean             WorkoutColumnExprWorkout = "speed_mean"
	WorkoutColumnExprWorkoutSpeedMaximum          WorkoutColumnExprWorkout = "speed_maximum"
	WorkoutColumnExprWorkoutPowerSource           WorkoutColumnExprWorkout = "power_source"
	WorkoutColumnExprWorkoutPowerMean             WorkoutColumnExprWorkout = "power_mean"
	WorkoutColumnExprWorkoutPowerMaximum          WorkoutColumnExprWorkout = "power_maximum"
	WorkoutColumnExprWorkoutPowerWeightedMean     WorkoutColumnExprWorkout = "power_weighted_mean"
	WorkoutColumnExprWorkoutSteps                 WorkoutColumnExprWorkout = "steps"
	WorkoutColumnExprWorkoutMapPolyline           WorkoutColumnExprWorkout = "map_polyline"
	WorkoutColumnExprWorkoutMapSummaryPolyline    WorkoutColumnExprWorkout = "map_summary_polyline"
	WorkoutColumnExprWorkoutSourceType            WorkoutColumnExprWorkout = "source_type"
	WorkoutColumnExprWorkoutSourceProvider        WorkoutColumnExprWorkout = "source_provider"
	WorkoutColumnExprWorkoutSourceAppId           WorkoutColumnExprWorkout = "source_app_id"
	WorkoutColumnExprWorkoutSourceWorkoutId       WorkoutColumnExprWorkout = "source_workout_id"
	WorkoutColumnExprWorkoutTimeZone              WorkoutColumnExprWorkout = "time_zone"
)

func NewWorkoutColumnExprWorkoutFromString(s string) (WorkoutColumnExprWorkout, error) {
	switch s {
	case "session_start":
		return WorkoutColumnExprWorkoutSessionStart, nil
	case "session_end":
		return WorkoutColumnExprWorkoutSessionEnd, nil
	case "title":
		return WorkoutColumnExprWorkoutTitle, nil
	case "sport_name":
		return WorkoutColumnExprWorkoutSportName, nil
	case "sport_slug":
		return WorkoutColumnExprWorkoutSportSlug, nil
	case "duration_active_second":
		return WorkoutColumnExprWorkoutDurationActiveSecond, nil
	case "heart_rate_mean":
		return WorkoutColumnExprWorkoutHeartRateMean, nil
	case "heart_rate_minimum":
		return WorkoutColumnExprWorkoutHeartRateMinimum, nil
	case "heart_rate_maximum":
		return WorkoutColumnExprWorkoutHeartRateMaximum, nil
	case "heart_rate_zone_1":
		return WorkoutColumnExprWorkoutHeartRateZone1, nil
	case "heart_rate_zone_2":
		return WorkoutColumnExprWorkoutHeartRateZone2, nil
	case "heart_rate_zone_3":
		return WorkoutColumnExprWorkoutHeartRateZone3, nil
	case "heart_rate_zone_4":
		return WorkoutColumnExprWorkoutHeartRateZone4, nil
	case "heart_rate_zone_5":
		return WorkoutColumnExprWorkoutHeartRateZone5, nil
	case "heart_rate_zone_6":
		return WorkoutColumnExprWorkoutHeartRateZone6, nil
	case "distance_meter":
		return WorkoutColumnExprWorkoutDistanceMeter, nil
	case "calories":
		return WorkoutColumnExprWorkoutCalories, nil
	case "elevation_gain_meter":
		return WorkoutColumnExprWorkoutElevationGainMeter, nil
	case "elevation_maximum_meter":
		return WorkoutColumnExprWorkoutElevationMaximumMeter, nil
	case "elevation_minimum_meter":
		return WorkoutColumnExprWorkoutElevationMinimumMeter, nil
	case "speed_mean":
		return WorkoutColumnExprWorkoutSpeedMean, nil
	case "speed_maximum":
		return WorkoutColumnExprWorkoutSpeedMaximum, nil
	case "power_source":
		return WorkoutColumnExprWorkoutPowerSource, nil
	case "power_mean":
		return WorkoutColumnExprWorkoutPowerMean, nil
	case "power_maximum":
		return WorkoutColumnExprWorkoutPowerMaximum, nil
	case "power_weighted_mean":
		return WorkoutColumnExprWorkoutPowerWeightedMean, nil
	case "steps":
		return WorkoutColumnExprWorkoutSteps, nil
	case "map_polyline":
		return WorkoutColumnExprWorkoutMapPolyline, nil
	case "map_summary_polyline":
		return WorkoutColumnExprWorkoutMapSummaryPolyline, nil
	case "source_type":
		return WorkoutColumnExprWorkoutSourceType, nil
	case "source_provider":
		return WorkoutColumnExprWorkoutSourceProvider, nil
	case "source_app_id":
		return WorkoutColumnExprWorkoutSourceAppId, nil
	case "source_workout_id":
		return WorkoutColumnExprWorkoutSourceWorkoutId, nil
	case "time_zone":
		return WorkoutColumnExprWorkoutTimeZone, nil
	}
	var t WorkoutColumnExprWorkout
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkoutColumnExprWorkout) Ptr() *WorkoutColumnExprWorkout {
	return &w
}

type WorkoutV2InDb struct {
	Timestamp  time.Time              `json:"timestamp" url:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty" url:"data,omitempty"`
	ProviderId string                 `json:"provider_id" url:"provider_id"`
	UserId     string                 `json:"user_id" url:"user_id"`
	SourceId   int                    `json:"source_id" url:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty" url:"priority_id,omitempty"`
	Id         string                 `json:"id" url:"id"`
	SportId    int                    `json:"sport_id" url:"sport_id"`
	Source     *ClientFacingProvider  `json:"source,omitempty" url:"source,omitempty"`
	Sport      *ClientFacingSport     `json:"sport,omitempty" url:"sport,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkoutV2InDb) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkoutV2InDb) UnmarshalJSON(data []byte) error {
	type embed WorkoutV2InDb
	var unmarshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WorkoutV2InDb(unmarshaler.embed)
	w.Timestamp = unmarshaler.Timestamp.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutV2InDb) MarshalJSON() ([]byte, error) {
	type embed WorkoutV2InDb
	var marshaler = struct {
		embed
		Timestamp *core.DateTime `json:"timestamp"`
	}{
		embed:     embed(*w),
		Timestamp: core.NewDateTime(w.Timestamp),
	}
	return json.Marshal(marshaler)
}

func (w *WorkoutV2InDb) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
