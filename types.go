// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/tryVital/vital-go/core"
	time "time"
)

type ActivitySelector struct {
	Activity ActivitySelectorActivity `json:"activity,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActivitySelector) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivitySelector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivitySelector(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivitySelector) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActivitySelectorActivity string

const (
	ActivitySelectorActivityDate                     ActivitySelectorActivity = "date"
	ActivitySelectorActivityCaloriesTotal            ActivitySelectorActivity = "calories_total"
	ActivitySelectorActivityCaloriesActive           ActivitySelectorActivity = "calories_active"
	ActivitySelectorActivitySteps                    ActivitySelectorActivity = "steps"
	ActivitySelectorActivityDistanceMeter            ActivitySelectorActivity = "distance_meter"
	ActivitySelectorActivityFloorsClimbed            ActivitySelectorActivity = "floors_climbed"
	ActivitySelectorActivityDurationActiveSecond     ActivitySelectorActivity = "duration_active_second"
	ActivitySelectorActivityIntensitySedentarySecond ActivitySelectorActivity = "intensity_sedentary_second"
	ActivitySelectorActivityIntensityLowSecond       ActivitySelectorActivity = "intensity_low_second"
	ActivitySelectorActivityIntensityMediumSecond    ActivitySelectorActivity = "intensity_medium_second"
	ActivitySelectorActivityIntensityHighSecond      ActivitySelectorActivity = "intensity_high_second"
	ActivitySelectorActivityHeartRateMean            ActivitySelectorActivity = "heart_rate_mean"
	ActivitySelectorActivityHeartRateMin             ActivitySelectorActivity = "heart_rate_min"
	ActivitySelectorActivityHeartRateMax             ActivitySelectorActivity = "heart_rate_max"
	ActivitySelectorActivityHeartRateResting         ActivitySelectorActivity = "heart_rate_resting"
	ActivitySelectorActivitySourceType               ActivitySelectorActivity = "source_type"
	ActivitySelectorActivitySourceProvider           ActivitySelectorActivity = "source_provider"
	ActivitySelectorActivitySourceAppId              ActivitySelectorActivity = "source_app_id"
)

func NewActivitySelectorActivityFromString(s string) (ActivitySelectorActivity, error) {
	switch s {
	case "date":
		return ActivitySelectorActivityDate, nil
	case "calories_total":
		return ActivitySelectorActivityCaloriesTotal, nil
	case "calories_active":
		return ActivitySelectorActivityCaloriesActive, nil
	case "steps":
		return ActivitySelectorActivitySteps, nil
	case "distance_meter":
		return ActivitySelectorActivityDistanceMeter, nil
	case "floors_climbed":
		return ActivitySelectorActivityFloorsClimbed, nil
	case "duration_active_second":
		return ActivitySelectorActivityDurationActiveSecond, nil
	case "intensity_sedentary_second":
		return ActivitySelectorActivityIntensitySedentarySecond, nil
	case "intensity_low_second":
		return ActivitySelectorActivityIntensityLowSecond, nil
	case "intensity_medium_second":
		return ActivitySelectorActivityIntensityMediumSecond, nil
	case "intensity_high_second":
		return ActivitySelectorActivityIntensityHighSecond, nil
	case "heart_rate_mean":
		return ActivitySelectorActivityHeartRateMean, nil
	case "heart_rate_min":
		return ActivitySelectorActivityHeartRateMin, nil
	case "heart_rate_max":
		return ActivitySelectorActivityHeartRateMax, nil
	case "heart_rate_resting":
		return ActivitySelectorActivityHeartRateResting, nil
	case "source_type":
		return ActivitySelectorActivitySourceType, nil
	case "source_provider":
		return ActivitySelectorActivitySourceProvider, nil
	case "source_app_id":
		return ActivitySelectorActivitySourceAppId, nil
	}
	var t ActivitySelectorActivity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActivitySelectorActivity) Ptr() *ActivitySelectorActivity {
	return &a
}

type ActivityV2InDb struct {
	Timestamp  time.Time              `json:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty"`
	ProviderId string                 `json:"provider_id"`
	UserId     string                 `json:"user_id"`
	SourceId   int                    `json:"source_id"`
	PriorityId int                    `json:"priority_id"`
	Id         string                 `json:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActivityV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivityV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivityV2InDb(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityV2InDb) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Address struct {
	FirstLine  string  `json:"first_line"`
	SecondLine *string `json:"second_line,omitempty"`
	Country    string  `json:"country"`
	Zip        string  `json:"zip"`
	City       string  `json:"city"`
	State      string  `json:"state"`

	_rawJSON json.RawMessage
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Maps miles to meters
type AllowedRadius string

const (
	AllowedRadiusTen        AllowedRadius = "10"
	AllowedRadiusTwenty     AllowedRadius = "20"
	AllowedRadiusTwentyFive AllowedRadius = "25"
	AllowedRadiusFifty      AllowedRadius = "50"
)

func NewAllowedRadiusFromString(s string) (AllowedRadius, error) {
	switch s {
	case "10":
		return AllowedRadiusTen, nil
	case "20":
		return AllowedRadiusTwenty, nil
	case "25":
		return AllowedRadiusTwentyFive, nil
	case "50":
		return AllowedRadiusFifty, nil
	}
	var t AllowedRadius
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AllowedRadius) Ptr() *AllowedRadius {
	return &a
}

type Answer struct {
	Id    int    `json:"id"`
	Code  string `json:"code"`
	Value string `json:"value"`

	_rawJSON json.RawMessage
}

func (a *Answer) UnmarshalJSON(data []byte) error {
	type unmarshaler Answer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Answer(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Answer) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AoE struct {
	Questions []*Question `json:"questions,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AoE) UnmarshalJSON(data []byte) error {
	type unmarshaler AoE
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AoE(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AoE) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AoEAnswer struct {
	MarkerId   int    `json:"marker_id"`
	QuestionId int    `json:"question_id"`
	Answer     string `json:"answer"`

	_rawJSON json.RawMessage
}

func (a *AoEAnswer) UnmarshalJSON(data []byte) error {
	type unmarshaler AoEAnswer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AoEAnswer(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AoEAnswer) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentAvailabilitySlots struct {
	Slots    []*DaySlots `json:"slots,omitempty"`
	Timezone *string     `json:"timezone,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AppointmentAvailabilitySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentAvailabilitySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentAvailabilitySlots(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentAvailabilitySlots) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppointmentEventStatus string

const (
	AppointmentEventStatusPending    AppointmentEventStatus = "pending"
	AppointmentEventStatusScheduled  AppointmentEventStatus = "scheduled"
	AppointmentEventStatusCompleted  AppointmentEventStatus = "completed"
	AppointmentEventStatusCancelled  AppointmentEventStatus = "cancelled"
	AppointmentEventStatusInProgress AppointmentEventStatus = "in_progress"
)

func NewAppointmentEventStatusFromString(s string) (AppointmentEventStatus, error) {
	switch s {
	case "pending":
		return AppointmentEventStatusPending, nil
	case "scheduled":
		return AppointmentEventStatusScheduled, nil
	case "completed":
		return AppointmentEventStatusCompleted, nil
	case "cancelled":
		return AppointmentEventStatusCancelled, nil
	case "in_progress":
		return AppointmentEventStatusInProgress, nil
	}
	var t AppointmentEventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentEventStatus) Ptr() *AppointmentEventStatus {
	return &a
}

type AppointmentProvider string

const (
	AppointmentProviderGetlabs      AppointmentProvider = "getlabs"
	AppointmentProviderAxlehealth   AppointmentProvider = "axlehealth"
	AppointmentProviderPhlebfinders AppointmentProvider = "phlebfinders"
)

func NewAppointmentProviderFromString(s string) (AppointmentProvider, error) {
	switch s {
	case "getlabs":
		return AppointmentProviderGetlabs, nil
	case "axlehealth":
		return AppointmentProviderAxlehealth, nil
	case "phlebfinders":
		return AppointmentProviderPhlebfinders, nil
	}
	var t AppointmentProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentProvider) Ptr() *AppointmentProvider {
	return &a
}

type AppointmentServiceType string

const (
	AppointmentServiceTypeAppointmentReady   AppointmentServiceType = "appointment-ready"
	AppointmentServiceTypeAppointmentRequest AppointmentServiceType = "appointment-request"
)

func NewAppointmentServiceTypeFromString(s string) (AppointmentServiceType, error) {
	switch s {
	case "appointment-ready":
		return AppointmentServiceTypeAppointmentReady, nil
	case "appointment-request":
		return AppointmentServiceTypeAppointmentRequest, nil
	}
	var t AppointmentServiceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentServiceType) Ptr() *AppointmentServiceType {
	return &a
}

type AppointmentStatus string

const (
	AppointmentStatusConfirmed  AppointmentStatus = "confirmed"
	AppointmentStatusPending    AppointmentStatus = "pending"
	AppointmentStatusInProgress AppointmentStatus = "in_progress"
	AppointmentStatusCompleted  AppointmentStatus = "completed"
	AppointmentStatusCancelled  AppointmentStatus = "cancelled"
)

func NewAppointmentStatusFromString(s string) (AppointmentStatus, error) {
	switch s {
	case "confirmed":
		return AppointmentStatusConfirmed, nil
	case "pending":
		return AppointmentStatusPending, nil
	case "in_progress":
		return AppointmentStatusInProgress, nil
	case "completed":
		return AppointmentStatusCompleted, nil
	case "cancelled":
		return AppointmentStatusCancelled, nil
	}
	var t AppointmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentStatus) Ptr() *AppointmentStatus {
	return &a
}

type AppointmentType = string

type AreaInfo struct {
	ZipCode     string                  `json:"zip_code"`
	Phlebotomy  *PhlebotomyAreaInfo     `json:"phlebotomy,omitempty"`
	CentralLabs map[string]*PscAreaInfo `json:"central_labs,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler AreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AreaInfo(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AreaInfo) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttemptStatus string

const (
	AttemptStatusSuccess AttemptStatus = "success"
	AttemptStatusFailure AttemptStatus = "failure"
)

func NewAttemptStatusFromString(s string) (AttemptStatus, error) {
	switch s {
	case "success":
		return AttemptStatusSuccess, nil
	case "failure":
		return AttemptStatusFailure, nil
	}
	var t AttemptStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptStatus) Ptr() *AttemptStatus {
	return &a
}

type AuthType string

const (
	AuthTypePassword AuthType = "password"
	AuthTypeOauth    AuthType = "oauth"
	AuthTypeEmail    AuthType = "email"
)

func NewAuthTypeFromString(s string) (AuthType, error) {
	switch s {
	case "password":
		return AuthTypePassword, nil
	case "oauth":
		return AuthTypeOauth, nil
	case "email":
		return AuthTypeEmail, nil
	}
	var t AuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthType) Ptr() *AuthType {
	return &a
}

type Availability string

const (
	AvailabilityAvailable   Availability = "available"
	AvailabilityUnavailable Availability = "unavailable"
)

func NewAvailabilityFromString(s string) (Availability, error) {
	switch s {
	case "available":
		return AvailabilityAvailable, nil
	case "unavailable":
		return AvailabilityUnavailable, nil
	}
	var t Availability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a Availability) Ptr() *Availability {
	return &a
}

type BasalBodyTemperatureEntry struct {
	Date  string  `json:"date"`
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (b *BasalBodyTemperatureEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler BasalBodyTemperatureEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasalBodyTemperatureEntry(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasalBodyTemperatureEntry) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Billing string

const (
	BillingClientBill             Billing = "client_bill"
	BillingCommercialInsurance    Billing = "commercial_insurance"
	BillingPatientBillPassthrough Billing = "patient_bill_passthrough"
)

func NewBillingFromString(s string) (Billing, error) {
	switch s {
	case "client_bill":
		return BillingClientBill, nil
	case "commercial_insurance":
		return BillingCommercialInsurance, nil
	case "patient_bill_passthrough":
		return BillingPatientBillPassthrough, nil
	}
	var t Billing
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b Billing) Ptr() *Billing {
	return &b
}

// Represent the schema for an individual biomarker result.
type BiomarkerResult struct {
	Name            string     `json:"name"`
	Slug            *string    `json:"slug,omitempty"`
	Value           float64    `json:"value"`
	Result          string     `json:"result"`
	Type            ResultType `json:"type,omitempty"`
	Unit            *string    `json:"unit,omitempty"`
	Timestamp       *time.Time `json:"timestamp,omitempty"`
	Notes           *string    `json:"notes,omitempty"`
	MinRangeValue   *float64   `json:"min_range_value,omitempty"`
	MaxRangeValue   *float64   `json:"max_range_value,omitempty"`
	IsAboveMaxRange *bool      `json:"is_above_max_range,omitempty"`
	IsBelowMinRange *bool      `json:"is_below_min_range,omitempty"`
	Interpretation  *string    `json:"interpretation,omitempty"`
	Loinc           *string    `json:"loinc,omitempty"`
	LoincSlug       *string    `json:"loinc_slug,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BiomarkerResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BiomarkerResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BiomarkerResult(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BiomarkerResult) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BodyV2InDb struct {
	Timestamp  time.Time              `json:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty"`
	ProviderId string                 `json:"provider_id"`
	UserId     string                 `json:"user_id"`
	SourceId   int                    `json:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty"`
	Id         string                 `json:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty"`
	Priority   *int                   `json:"priority,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BodyV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyV2InDb(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyV2InDb) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CervicalMucusEntry struct {
	Date    string                    `json:"date"`
	Quality CervicalMucusEntryQuality `json:"quality,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CervicalMucusEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler CervicalMucusEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CervicalMucusEntry(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CervicalMucusEntry) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CervicalMucusEntryQuality string

const (
	CervicalMucusEntryQualityDry      CervicalMucusEntryQuality = "dry"
	CervicalMucusEntryQualitySticky   CervicalMucusEntryQuality = "sticky"
	CervicalMucusEntryQualityCreamy   CervicalMucusEntryQuality = "creamy"
	CervicalMucusEntryQualityWatery   CervicalMucusEntryQuality = "watery"
	CervicalMucusEntryQualityEggWhite CervicalMucusEntryQuality = "egg_white"
)

func NewCervicalMucusEntryQualityFromString(s string) (CervicalMucusEntryQuality, error) {
	switch s {
	case "dry":
		return CervicalMucusEntryQualityDry, nil
	case "sticky":
		return CervicalMucusEntryQualitySticky, nil
	case "creamy":
		return CervicalMucusEntryQualityCreamy, nil
	case "watery":
		return CervicalMucusEntryQualityWatery, nil
	case "egg_white":
		return CervicalMucusEntryQualityEggWhite, nil
	}
	var t CervicalMucusEntryQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CervicalMucusEntryQuality) Ptr() *CervicalMucusEntryQuality {
	return &c
}

type ClientActivityResponse struct {
	Activity []*ClientFacingActivity `json:"activity,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientActivityResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientActivityResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientBodyResponse struct {
	Body []*ClientFacingBody `json:"body,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientBodyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientBodyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientBodyResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientBodyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingActivity struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate   string   `json:"calendar_date"`
	CaloriesTotal  *float64 `json:"calories_total,omitempty"`
	CaloriesActive *float64 `json:"calories_active,omitempty"`
	Steps          *int     `json:"steps,omitempty"`
	DailyMovement  *float64 `json:"daily_movement,omitempty"`
	Distance       *float64 `json:"distance,omitempty"`
	Low            *float64 `json:"low,omitempty"`
	Medium         *float64 `json:"medium,omitempty"`
	High           *float64 `json:"high,omitempty"`
	// Source the data has come from.
	Source         *ClientFacingSource    `json:"source,omitempty"`
	FloorsClimbed  *int                   `json:"floors_climbed,omitempty"`
	TimeZone       *string                `json:"time_zone,omitempty"`
	TimezoneOffset *int                   `json:"timezone_offset,omitempty"`
	HeartRate      *ClientFacingHeartRate `json:"heart_rate,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingActivity(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingActivity) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingApiKey struct {
	Label     string     `json:"label"`
	Value     string     `json:"value"`
	TeamId    *string    `json:"team_id,omitempty"`
	Id        string     `json:"id"`
	CreatedAt time.Time  `json:"created_at"`
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingApiKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingApiKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingApiKey(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingApiKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointment struct {
	Id            string                          `json:"id"`
	UserId        string                          `json:"user_id"`
	OrderId       string                          `json:"order_id"`
	Address       *UsAddress                      `json:"address,omitempty"`
	Location      *LngLat                         `json:"location,omitempty"`
	StartAt       *time.Time                      `json:"start_at,omitempty"`
	EndAt         *time.Time                      `json:"end_at,omitempty"`
	IanaTimezone  *string                         `json:"iana_timezone,omitempty"`
	Type          AppointmentType                 `json:"type,omitempty"`
	Provider      AppointmentProvider             `json:"provider,omitempty"`
	Status        AppointmentStatus               `json:"status,omitempty"`
	ProviderId    string                          `json:"provider_id"`
	CanReschedule bool                            `json:"can_reschedule"`
	EventStatus   AppointmentEventStatus          `json:"event_status,omitempty"`
	EventData     map[string]interface{}          `json:"event_data,omitempty"`
	Events        []*ClientFacingAppointmentEvent `json:"events,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAppointment) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointment(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentCancellationReason struct {
	Id           string `json:"id"`
	Name         string `json:"name"`
	IsRefundable bool   `json:"is_refundable"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAppointmentCancellationReason) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentCancellationReason
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentCancellationReason(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentCancellationReason) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAppointmentEvent struct {
	CreatedAt time.Time              `json:"created_at"`
	Status    AppointmentEventStatus `json:"status,omitempty"`
	Data      map[string]interface{} `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAppointmentEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAppointmentEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAppointmentEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAppointmentEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a at-home-phlebotomy test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingAtHomePhlebotomyOrder struct {
	// The Vital at-home phlebotomy Order ID
	Id            string    `json:"id"`
	AppointmentId *string   `json:"appointment_id,omitempty"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAtHomePhlebotomyOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingAtHomePhlebotomyOrderDetails struct {
	Data *ClientFacingAtHomePhlebotomyOrder `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingAtHomePhlebotomyOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingAtHomePhlebotomyOrderDetails(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAtHomePhlebotomyOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodOxygenTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in percentage (spo2).
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBloodOxygenTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodOxygenTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBloodPressureTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// The unit of the value. We use SI units where possible, e.g. mmol/L for glucose/cholesterol, bpm for heart rate, etc.
	Unit      string    `json:"unit"`
	Timestamp time.Time `json:"timestamp"`
	Systolic  float64   `json:"systolic"`
	Diastolic float64   `json:"diastolic"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBloodPressureTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBloodPressureTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBody struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string              `json:"calendar_date"`
	Weight       *float64            `json:"weight,omitempty"`
	Fat          *float64            `json:"fat,omitempty"`
	Source       *ClientFacingSource `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBody(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBody) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyFatTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBodyFatTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyFatTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyFatTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyFatTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSample struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The recorded value for the interval.
	Value          float64                                               `json:"value"`
	SensorLocation *ClientFacingBodyTemperatureDeltaSampleSensorLocation `json:"sensor_location,omitempty"`
	unit           string

	_rawJSON json.RawMessage
}

func (c *ClientFacingBodyTemperatureDeltaSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyTemperatureDeltaSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureDeltaSample(value)
	c.unit = "°C"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureDeltaSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureDeltaSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "°C",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSampleSensorLocation string

const (
	ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationBody             ClientFacingBodyTemperatureDeltaSampleSensorLocation = "body"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEar              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureDeltaSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationToe              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum          ClientFacingBodyTemperatureDeltaSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureDeltaSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead         ClientFacingBodyTemperatureDeltaSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureDeltaSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureDeltaSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureDeltaSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureDeltaSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureDeltaSampleSensorLocation {
	return &c
}

type ClientFacingBodyTemperatureSample struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The recorded value for the interval.
	Value          float64                                          `json:"value"`
	SensorLocation *ClientFacingBodyTemperatureSampleSensorLocation `json:"sensor_location,omitempty"`
	unit           string

	_rawJSON json.RawMessage
}

func (c *ClientFacingBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyTemperatureSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureSample(value)
	c.unit = "°C"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "°C",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureSampleSensorLocation string

const (
	ClientFacingBodyTemperatureSampleSensorLocationArmpit           ClientFacingBodyTemperatureSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureSampleSensorLocationBody             ClientFacingBodyTemperatureSampleSensorLocation = "body"
	ClientFacingBodyTemperatureSampleSensorLocationEar              ClientFacingBodyTemperatureSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureSampleSensorLocationFinger           ClientFacingBodyTemperatureSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureSampleSensorLocationMouth            ClientFacingBodyTemperatureSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureSampleSensorLocationRectum           ClientFacingBodyTemperatureSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureSampleSensorLocationToe              ClientFacingBodyTemperatureSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureSampleSensorLocationEardrum          ClientFacingBodyTemperatureSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureSampleSensorLocationForehead         ClientFacingBodyTemperatureSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureSampleSensorLocationWrist            ClientFacingBodyTemperatureSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureSampleSensorLocation {
	return &c
}

type ClientFacingBodyWeightTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in kilograms (kg).
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingBodyWeightTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingBodyWeightTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingBodyWeightTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyWeightTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaffeineTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Quantity of caffeine consumed during the time period.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingCaffeineTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaffeineTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaffeineTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesActiveTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Energy consumption caused by the physical activity at the time or interval::kilocalories
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingCaloriesActiveTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesActiveTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesActiveTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveTimeseries(value)
	c.unit = "kcal"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesActiveTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCaloriesBasalTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Basal Metabolic Rate at the time or interval::kilocalories
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingCaloriesBasalTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesBasalTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesBasalTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalTimeseries(value)
	c.unit = "kcal"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingCaloriesBasalTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCarbohydratesSample struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCarbohydratesSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCarbohydratesSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCarbohydratesSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingCholesterolTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingCholesterolTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCholesterolTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCholesterolTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDiagnosisInformation struct {
	// Diagnosis code for insurance information.
	DiagnosisCode string `json:"diagnosis_code"`
	// Diagnosis description insurance information.
	Description string `json:"description"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingDiagnosisInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDiagnosisInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDiagnosisInformation(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDiagnosisInformation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingDistanceTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in meters (m)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Distance traveled during activities at the time or interval::steps
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingDistanceTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingDistanceTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDistanceTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDistanceTimeseries(value)
	c.unit = "m"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "m",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingDistanceTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingElectrocardiogramVoltageTimeseries struct {
	Id             *int `json:"id,omitempty"`
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The lead of the measurement.
	Type *string `json:"type,omitempty"`
	// Measured in mV.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp string `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingElectrocardiogramVoltageTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFloorsClimbedTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in counts
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Number of floors climbed at the time or interval::count
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingFloorsClimbedTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingFloorsClimbedTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFloorsClimbedTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedTimeseries(value)
	c.unit = "count"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingFloorsClimbedTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingFood struct {
	Energy *Energy `json:"energy,omitempty"`
	Macros *Macros `json:"macros,omitempty"`
	Micros *Micros `json:"micros,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingFood) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFood
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFood(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFood) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGlucoseTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGlucoseTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGlucoseTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGlucoseTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample `json:"groups,omitempty"`
	Next       *string                                                                         `json:"next,omitempty"`
	NextCursor *string                                                                         `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample `json:"groups,omitempty"`
	Next       *string                                                                    `json:"next,omitempty"`
	NextCursor *string                                                                    `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*ClientFacingTimeseriesGroupClientFacingCarbohydratesSample `json:"groups,omitempty"`
	Next       *string                                                                  `json:"next,omitempty"`
	NextCursor *string                                                                  `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingCarbohydratesSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample `json:"groups,omitempty"`
	Next       *string                                                                     `json:"next,omitempty"`
	NextCursor *string                                                                     `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingInsulinInjectionSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingNoteSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*ClientFacingTimeseriesGroupClientFacingNoteSample `json:"groups,omitempty"`
	Next       *string                                                         `json:"next,omitempty"`
	NextCursor *string                                                         `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingNoteSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingNoteSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingNoteSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample `json:"groups,omitempty"`
	Next       *string                                                                    `json:"next,omitempty"`
	NextCursor *string                                                                    `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGroupedTimeseriesResponseClientFacingWorkoutDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRate struct {
	AvgBpm     *float64 `json:"avg_bpm,omitempty"`
	MinBpm     *float64 `json:"min_bpm,omitempty"`
	MaxBpm     *float64 `json:"max_bpm,omitempty"`
	RestingBpm *float64 `json:"resting_bpm,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRate(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHeartRateTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Heart rate in bpm
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHeartRateTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHeartRateTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHeartRateTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHrvTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in rmssd.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// HRV calculated using rmssd during sleep
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHrvTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHrvTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHrvTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHrvTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingHypnogramTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// enum: 1: deep, 2: light, 3: rem, 4: awake, -1: missing_data.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Hypnogram for sleep stages {"deep": 1, "light": 2, "rem": 3, "awake": 4, "manual": 5, "missing_data": -1}
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingHypnogramTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingHypnogramTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingHypnogramTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHypnogramTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIgeTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingIgeTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIgeTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIgeTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingIggTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingIggTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingIggTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingIggTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingInsulinInjectionSample struct {
	Id             *int `json:"id,omitempty"`
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Insulin type: rapid vs long acting
	Type ClientFacingInsulinInjectionSampleType `json:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingInsulinInjectionSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingInsulinInjectionSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingInsulinInjectionSample(value)
	c.unit = "unit"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsulinInjectionSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInsulinInjectionSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "unit",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingInsulinInjectionSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Insulin type: rapid vs long acting
type ClientFacingInsulinInjectionSampleType string

const (
	ClientFacingInsulinInjectionSampleTypeRapidActing ClientFacingInsulinInjectionSampleType = "rapid_acting"
	ClientFacingInsulinInjectionSampleTypeLongActing  ClientFacingInsulinInjectionSampleType = "long_acting"
)

func NewClientFacingInsulinInjectionSampleTypeFromString(s string) (ClientFacingInsulinInjectionSampleType, error) {
	switch s {
	case "rapid_acting":
		return ClientFacingInsulinInjectionSampleTypeRapidActing, nil
	case "long_acting":
		return ClientFacingInsulinInjectionSampleTypeLongActing, nil
	}
	var t ClientFacingInsulinInjectionSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingInsulinInjectionSampleType) Ptr() *ClientFacingInsulinInjectionSampleType {
	return &c
}

type ClientFacingInsurance struct {
	MemberId     string                  `json:"member_id"`
	PayorCode    string                  `json:"payor_code"`
	Relationship ResponsibleRelationship `json:"relationship,omitempty"`
	Insured      *PersonDetailsOutput    `json:"insured,omitempty"`
	Company      *CompanyDetails         `json:"company,omitempty"`
	GroupId      *string                 `json:"group_id,omitempty"`
	Guarantor    *PersonDetailsOutput    `json:"guarantor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingInsurance) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingInsurance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingInsurance(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsurance) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLab struct {
	Id                int                       `json:"id"`
	Slug              string                    `json:"slug"`
	Name              string                    `json:"name"`
	FirstLineAddress  string                    `json:"first_line_address"`
	City              string                    `json:"city"`
	Zipcode           string                    `json:"zipcode"`
	CollectionMethods []LabTestCollectionMethod `json:"collection_methods,omitempty"`
	SampleTypes       []LabTestSampleType       `json:"sample_types,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingLab) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLab(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLab) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabLocation struct {
	Metadata *LabLocationMetadata `json:"metadata,omitempty"`
	Distance int                  `json:"distance"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingLabLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLabLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLabLocation(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLabLocation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabTest struct {
	Id         string                  `json:"id"`
	Slug       string                  `json:"slug"`
	Name       string                  `json:"name"`
	SampleType LabTestSampleType       `json:"sample_type,omitempty"`
	Method     LabTestCollectionMethod `json:"method,omitempty"`
	Price      float64                 `json:"price"`
	// Deprecated. Use status instead.
	IsActive bool          `json:"is_active"`
	Status   LabTestStatus `json:"status,omitempty"`
	// Defines whether a lab test requires fasting.
	Fasting *bool                 `json:"fasting,omitempty"`
	Lab     *ClientFacingLab      `json:"lab,omitempty"`
	Markers []*ClientFacingMarker `json:"markers,omitempty"`
	// Denotes whether a lab test requires using non-Vital physician networks. If it does then it's delegated - no otherwise.
	IsDelegated *bool `json:"is_delegated,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingLabTest) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLabTest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLabTest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLabTest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingLabs string

const (
	ClientFacingLabsQuest        ClientFacingLabs = "quest"
	ClientFacingLabsLabcorp      ClientFacingLabs = "labcorp"
	ClientFacingLabsBioreference ClientFacingLabs = "bioreference"
)

func NewClientFacingLabsFromString(s string) (ClientFacingLabs, error) {
	switch s {
	case "quest":
		return ClientFacingLabsQuest, nil
	case "labcorp":
		return ClientFacingLabsLabcorp, nil
	case "bioreference":
		return ClientFacingLabsBioreference, nil
	}
	var t ClientFacingLabs
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingLabs) Ptr() *ClientFacingLabs {
	return &c
}

type ClientFacingLoinc struct {
	Id   int     `json:"id"`
	Name string  `json:"name"`
	Slug string  `json:"slug"`
	Code string  `json:"code"`
	Unit *string `json:"unit,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingLoinc) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingLoinc
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingLoinc(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLoinc) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarker struct {
	Id          int         `json:"id"`
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	Description *string     `json:"description,omitempty"`
	LabId       *int        `json:"lab_id,omitempty"`
	ProviderId  *string     `json:"provider_id,omitempty"`
	Type        *MarkerType `json:"type,omitempty"`
	Unit        *string     `json:"unit,omitempty"`
	Price       *string     `json:"price,omitempty"`
	Aoe         *AoE        `json:"aoe,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMarker) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarker
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarker(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarker) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMarkerComplete struct {
	Id              int                   `json:"id"`
	Name            string                `json:"name"`
	Slug            string                `json:"slug"`
	Description     *string               `json:"description,omitempty"`
	LabId           *int                  `json:"lab_id,omitempty"`
	ProviderId      *string               `json:"provider_id,omitempty"`
	Type            *MarkerType           `json:"type,omitempty"`
	Unit            *string               `json:"unit,omitempty"`
	Price           *string               `json:"price,omitempty"`
	Aoe             *AoE                  `json:"aoe,omitempty"`
	ExpectedResults []*ClientFacingResult `json:"expected_results,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMarkerComplete) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMarkerComplete
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMarkerComplete(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMarkerComplete) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMealResponse struct {
	Meals []*MealInDbBaseClientFacingSource `json:"meals,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMealResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMealResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMealResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMealResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMindfulnessMinutesTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in minutes.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// Number of minutes spent in a mindful state.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingMindfulnessMinutesTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSample struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// User notes as text.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The recorded value for the interval.
	Value string                           `json:"value"`
	Tags  []ClientFacingNoteSampleTagsItem `json:"tags,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingNoteSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingNoteSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingNoteSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSampleTagsItem string

const (
	ClientFacingNoteSampleTagsItemFood             ClientFacingNoteSampleTagsItem = "food"
	ClientFacingNoteSampleTagsItemExercise         ClientFacingNoteSampleTagsItem = "exercise"
	ClientFacingNoteSampleTagsItemInsulinInjection ClientFacingNoteSampleTagsItem = "insulin_injection"
	ClientFacingNoteSampleTagsItemUnspecified      ClientFacingNoteSampleTagsItem = "unspecified"
)

func NewClientFacingNoteSampleTagsItemFromString(s string) (ClientFacingNoteSampleTagsItem, error) {
	switch s {
	case "food":
		return ClientFacingNoteSampleTagsItemFood, nil
	case "exercise":
		return ClientFacingNoteSampleTagsItemExercise, nil
	case "insulin_injection":
		return ClientFacingNoteSampleTagsItemInsulinInjection, nil
	case "unspecified":
		return ClientFacingNoteSampleTagsItemUnspecified, nil
	}
	var t ClientFacingNoteSampleTagsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingNoteSampleTagsItem) Ptr() *ClientFacingNoteSampleTagsItem {
	return &c
}

type ClientFacingOrder struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// The Vital Order ID
	Id string `json:"id"`
	// Your team id.
	TeamId         string                                `json:"team_id"`
	PatientDetails *ClientFacingPatientDetailsCompatible `json:"patient_details,omitempty"`
	PatientAddress *PatientAddressCompatible             `json:"patient_address,omitempty"`
	// The Vital Test associated with the order
	LabTest  *ClientFacingLabTest      `json:"lab_test,omitempty"`
	Details  *ClientFacingOrderDetails `json:"details,omitempty"`
	SampleId *string                   `json:"sample_id,omitempty"`
	Notes    *string                   `json:"notes,omitempty"`
	// When your order was created
	CreatedAt time.Time `json:"created_at"`
	// When your order was last updated.
	UpdatedAt          time.Time                 `json:"updated_at"`
	Events             []*ClientFacingOrderEvent `json:"events,omitempty"`
	Status             *OrderTopLevelStatus      `json:"status,omitempty"`
	Physician          *ClientFacingPhysician    `json:"physician,omitempty"`
	HealthInsuranceId  *string                   `json:"health_insurance_id,omitempty"`
	RequisitionFormUrl *string                   `json:"requisition_form_url,omitempty"`
	// Defines whether order is priority or not. For some labs, this refers to a STAT order.
	Priority        *bool            `json:"priority,omitempty"`
	ShippingDetails *ShippingAddress `json:"shipping_details,omitempty"`
	ActivateBy      *string          `json:"activate_by,omitempty"`
	Passthrough     *string          `json:"passthrough,omitempty"`
	BillingType     *Billing         `json:"billing_type,omitempty"`
	IcdCodes        []string         `json:"icd_codes,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingOrderDetails struct {
	Type             string
	WalkInTest       *ClientFacingWalkInOrderDetails
	Testkit          *ClientFacingTestKitOrderDetails
	AtHomePhlebotomy *ClientFacingAtHomePhlebotomyOrderDetails
}

func NewClientFacingOrderDetailsFromWalkInTest(value *ClientFacingWalkInOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "walk_in_test", WalkInTest: value}
}

func NewClientFacingOrderDetailsFromTestkit(value *ClientFacingTestKitOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "testkit", Testkit: value}
}

func NewClientFacingOrderDetailsFromAtHomePhlebotomy(value *ClientFacingAtHomePhlebotomyOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "at_home_phlebotomy", AtHomePhlebotomy: value}
}

func (c *ClientFacingOrderDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "walk_in_test":
		value := new(ClientFacingWalkInOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.WalkInTest = value
	case "testkit":
		value := new(ClientFacingTestKitOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Testkit = value
	case "at_home_phlebotomy":
		value := new(ClientFacingAtHomePhlebotomyOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.AtHomePhlebotomy = value
	}
	return nil
}

func (c ClientFacingOrderDetails) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingWalkInOrderDetails
		}{
			Type:                           c.Type,
			ClientFacingWalkInOrderDetails: c.WalkInTest,
		}
		return json.Marshal(marshaler)
	case "testkit":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingTestKitOrderDetails
		}{
			Type:                            c.Type,
			ClientFacingTestKitOrderDetails: c.Testkit,
		}
		return json.Marshal(marshaler)
	case "at_home_phlebotomy":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingAtHomePhlebotomyOrderDetails
		}{
			Type:                                     c.Type,
			ClientFacingAtHomePhlebotomyOrderDetails: c.AtHomePhlebotomy,
		}
		return json.Marshal(marshaler)
	}
}

type ClientFacingOrderDetailsVisitor interface {
	VisitWalkInTest(*ClientFacingWalkInOrderDetails) error
	VisitTestkit(*ClientFacingTestKitOrderDetails) error
	VisitAtHomePhlebotomy(*ClientFacingAtHomePhlebotomyOrderDetails) error
}

func (c *ClientFacingOrderDetails) Accept(visitor ClientFacingOrderDetailsVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		return visitor.VisitWalkInTest(c.WalkInTest)
	case "testkit":
		return visitor.VisitTestkit(c.Testkit)
	case "at_home_phlebotomy":
		return visitor.VisitAtHomePhlebotomy(c.AtHomePhlebotomy)
	}
}

type ClientFacingOrderEvent struct {
	Id        int         `json:"id"`
	CreatedAt time.Time   `json:"created_at"`
	Status    OrderStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingOrderEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingOrderEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingOrderEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingOrderEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPatientDetailsCompatible struct {
	FirstName   *string   `json:"first_name,omitempty"`
	LastName    *string   `json:"last_name,omitempty"`
	Dob         time.Time `json:"dob"`
	Gender      string    `json:"gender"`
	PhoneNumber *string   `json:"phone_number,omitempty"`
	Email       *string   `json:"email,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingPatientDetailsCompatible) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPatientDetailsCompatible
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPatientDetailsCompatible(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPatientDetailsCompatible) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPayorSearchResponse struct {
	// Payor code returned for the insurance information.
	Code string `json:"code"`
	// Insurance name returned for the insurance information.
	Name string `json:"name"`
	// Insurance name aliases returned for the insurance information.
	Aliases []string `json:"aliases,omitempty"`
	// Insurance business address returned for the insurance information.
	OrgAddress *Address `json:"org_address,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingPayorSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPayorSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPayorSearchResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPayorSearchResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingPhysician struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Npi       string `json:"npi"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingPhysician) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingPhysician
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingPhysician(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPhysician) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProfile struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string              `json:"user_id"`
	Id     string              `json:"id"`
	Height *int                `json:"height,omitempty"`
	Source *ClientFacingSource `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProfile(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProfile) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A vendor, a service, or a platform which Vital can connect with.
type ClientFacingProvider struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// URL for source logo
	Logo string `json:"logo"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProvider) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProvider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProvider(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProvider) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderDetailed struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// Description of source of information
	Description        string                 `json:"description"`
	Logo               *string                `json:"logo,omitempty"`
	AuthType           *SourceAuthType        `json:"auth_type,omitempty"`
	SupportedResources []ClientFacingResource `json:"supported_resources,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProviderDetailed) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProviderDetailed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProviderDetailed(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderDetailed) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderWithStatus struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// URL for source logo
	Logo string `json:"logo"`
	// Status of source, either error or connected
	Status               string                           `json:"status"`
	ResourceAvailability map[string]*ResourceAvailability `json:"resource_availability,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingProviderWithStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingProviderWithStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingProviderWithStatus(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderWithStatus) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingResource string

const (
	ClientFacingResourceProfile                  ClientFacingResource = "profile"
	ClientFacingResourceActivity                 ClientFacingResource = "activity"
	ClientFacingResourceSleep                    ClientFacingResource = "sleep"
	ClientFacingResourceBody                     ClientFacingResource = "body"
	ClientFacingResourceWorkouts                 ClientFacingResource = "workouts"
	ClientFacingResourceWorkoutStream            ClientFacingResource = "workout_stream"
	ClientFacingResourceConnection               ClientFacingResource = "connection"
	ClientFacingResourceOrder                    ClientFacingResource = "order"
	ClientFacingResourceResult                   ClientFacingResource = "result"
	ClientFacingResourceAppointment              ClientFacingResource = "appointment"
	ClientFacingResourceGlucose                  ClientFacingResource = "glucose"
	ClientFacingResourceHeartrate                ClientFacingResource = "heartrate"
	ClientFacingResourceHrv                      ClientFacingResource = "hrv"
	ClientFacingResourceHypnogram                ClientFacingResource = "hypnogram"
	ClientFacingResourceIge                      ClientFacingResource = "ige"
	ClientFacingResourceIgg                      ClientFacingResource = "igg"
	ClientFacingResourceBloodOxygen              ClientFacingResource = "blood_oxygen"
	ClientFacingResourceBloodPressure            ClientFacingResource = "blood_pressure"
	ClientFacingResourceCholesterol              ClientFacingResource = "cholesterol"
	ClientFacingResourceDevice                   ClientFacingResource = "device"
	ClientFacingResourceWeight                   ClientFacingResource = "weight"
	ClientFacingResourceFat                      ClientFacingResource = "fat"
	ClientFacingResourceBodyTemperature          ClientFacingResource = "body_temperature"
	ClientFacingResourceBodyTemperatureDelta     ClientFacingResource = "body_temperature_delta"
	ClientFacingResourceMeal                     ClientFacingResource = "meal"
	ClientFacingResourceWater                    ClientFacingResource = "water"
	ClientFacingResourceCaffeine                 ClientFacingResource = "caffeine"
	ClientFacingResourceMindfulnessMinutes       ClientFacingResource = "mindfulness_minutes"
	ClientFacingResourceSteps                    ClientFacingResource = "steps"
	ClientFacingResourceCaloriesActive           ClientFacingResource = "calories_active"
	ClientFacingResourceDistance                 ClientFacingResource = "distance"
	ClientFacingResourceFloorsClimbed            ClientFacingResource = "floors_climbed"
	ClientFacingResourceRespiratoryRate          ClientFacingResource = "respiratory_rate"
	ClientFacingResourceVo2Max                   ClientFacingResource = "vo2_max"
	ClientFacingResourceCaloriesBasal            ClientFacingResource = "calories_basal"
	ClientFacingResourceStressLevel              ClientFacingResource = "stress_level"
	ClientFacingResourceMenstrualCycle           ClientFacingResource = "menstrual_cycle"
	ClientFacingResourceElectrocardiogramVoltage ClientFacingResource = "electrocardiogram_voltage"
	ClientFacingResourceWorkoutDuration          ClientFacingResource = "workout_duration"
	ClientFacingResourceInsulinInjection         ClientFacingResource = "insulin_injection"
	ClientFacingResourceCarbohydrates            ClientFacingResource = "carbohydrates"
	ClientFacingResourceNote                     ClientFacingResource = "note"
	ClientFacingResourceSleepStream              ClientFacingResource = "sleep_stream"
)

func NewClientFacingResourceFromString(s string) (ClientFacingResource, error) {
	switch s {
	case "profile":
		return ClientFacingResourceProfile, nil
	case "activity":
		return ClientFacingResourceActivity, nil
	case "sleep":
		return ClientFacingResourceSleep, nil
	case "body":
		return ClientFacingResourceBody, nil
	case "workouts":
		return ClientFacingResourceWorkouts, nil
	case "workout_stream":
		return ClientFacingResourceWorkoutStream, nil
	case "connection":
		return ClientFacingResourceConnection, nil
	case "order":
		return ClientFacingResourceOrder, nil
	case "result":
		return ClientFacingResourceResult, nil
	case "appointment":
		return ClientFacingResourceAppointment, nil
	case "glucose":
		return ClientFacingResourceGlucose, nil
	case "heartrate":
		return ClientFacingResourceHeartrate, nil
	case "hrv":
		return ClientFacingResourceHrv, nil
	case "hypnogram":
		return ClientFacingResourceHypnogram, nil
	case "ige":
		return ClientFacingResourceIge, nil
	case "igg":
		return ClientFacingResourceIgg, nil
	case "blood_oxygen":
		return ClientFacingResourceBloodOxygen, nil
	case "blood_pressure":
		return ClientFacingResourceBloodPressure, nil
	case "cholesterol":
		return ClientFacingResourceCholesterol, nil
	case "device":
		return ClientFacingResourceDevice, nil
	case "weight":
		return ClientFacingResourceWeight, nil
	case "fat":
		return ClientFacingResourceFat, nil
	case "body_temperature":
		return ClientFacingResourceBodyTemperature, nil
	case "body_temperature_delta":
		return ClientFacingResourceBodyTemperatureDelta, nil
	case "meal":
		return ClientFacingResourceMeal, nil
	case "water":
		return ClientFacingResourceWater, nil
	case "caffeine":
		return ClientFacingResourceCaffeine, nil
	case "mindfulness_minutes":
		return ClientFacingResourceMindfulnessMinutes, nil
	case "steps":
		return ClientFacingResourceSteps, nil
	case "calories_active":
		return ClientFacingResourceCaloriesActive, nil
	case "distance":
		return ClientFacingResourceDistance, nil
	case "floors_climbed":
		return ClientFacingResourceFloorsClimbed, nil
	case "respiratory_rate":
		return ClientFacingResourceRespiratoryRate, nil
	case "vo2_max":
		return ClientFacingResourceVo2Max, nil
	case "calories_basal":
		return ClientFacingResourceCaloriesBasal, nil
	case "stress_level":
		return ClientFacingResourceStressLevel, nil
	case "menstrual_cycle":
		return ClientFacingResourceMenstrualCycle, nil
	case "electrocardiogram_voltage":
		return ClientFacingResourceElectrocardiogramVoltage, nil
	case "workout_duration":
		return ClientFacingResourceWorkoutDuration, nil
	case "insulin_injection":
		return ClientFacingResourceInsulinInjection, nil
	case "carbohydrates":
		return ClientFacingResourceCarbohydrates, nil
	case "note":
		return ClientFacingResourceNote, nil
	case "sleep_stream":
		return ClientFacingResourceSleepStream, nil
	}
	var t ClientFacingResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingResource) Ptr() *ClientFacingResource {
	return &c
}

type ClientFacingRespiratoryRateTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Average respiratory rate::breaths per minute
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingRespiratoryRateTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingRespiratoryRateTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingRespiratoryRateTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingRespiratoryRateTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingResult struct {
	Id         int                `json:"id"`
	Name       string             `json:"name"`
	Slug       string             `json:"slug"`
	LabId      *int               `json:"lab_id,omitempty"`
	ProviderId *string            `json:"provider_id,omitempty"`
	Required   bool               `json:"required"`
	Loinc      *ClientFacingLoinc `json:"loinc,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingResult(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSampleGroupingKeys = []interface{}

// Schema for a Shipment in the client facing API.
//
// To be used as part of a ClientFacingTestkitOrder.
type ClientFacingShipment struct {
	// The Vital Shipment ID
	Id                     string  `json:"id"`
	OutboundTrackingNumber *string `json:"outbound_tracking_number,omitempty"`
	OutboundTrackingUrl    *string `json:"outbound_tracking_url,omitempty"`
	InboundTrackingNumber  *string `json:"inbound_tracking_number,omitempty"`
	InboundTrackingUrl     *string `json:"inbound_tracking_url,omitempty"`
	OutboundCourier        *string `json:"outbound_courier,omitempty"`
	InboundCourier         *string `json:"inbound_courier,omitempty"`
	Notes                  *string `json:"notes,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingShipment) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingShipment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingShipment(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingShipment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleep struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the sleep summary in the YYYY-mm-dd format. This generally matches the sleep end date.
	CalendarDate string `json:"calendar_date"`
	// UTC Time when the sleep period started
	BedtimeStart time.Time `json:"bedtime_start"`
	// UTC Time when the sleep period ended
	BedtimeStop    time.Time `json:"bedtime_stop"`
	TimezoneOffset *int      `json:"timezone_offset,omitempty"`
	// Total duration of the sleep period (sleep.duration = sleep.bedtime_end - sleep.bedtime_start)::seconds
	Duration int `json:"duration"`
	// Total amount of sleep registered during the sleep period (sleep.total = sleep.rem + sleep.light + sleep.deep)::seconds
	Total int `json:"total"`
	// Total amount of awake time registered during the sleep period::seconds
	Awake int `json:"awake"`
	// Total amount of light sleep registered during the sleep period::seconds
	Light int `json:"light"`
	// Total amount of REM sleep registered during the sleep period, minutes::seconds
	Rem int `json:"rem"`
	// Total amount of deep (N3) sleep registered during the sleep period::seconds
	Deep             int                `json:"deep"`
	Score            *int               `json:"score,omitempty"`
	HrLowest         *int               `json:"hr_lowest,omitempty"`
	HrAverage        *int               `json:"hr_average,omitempty"`
	Efficiency       *float64           `json:"efficiency,omitempty"`
	Latency          *int               `json:"latency,omitempty"`
	TemperatureDelta *float64           `json:"temperature_delta,omitempty"`
	SkinTemperature  *float64           `json:"skin_temperature,omitempty"`
	HrDip            *float64           `json:"hr_dip,omitempty"`
	State            *SleepSummaryState `json:"state,omitempty"`
	AverageHrv       *float64           `json:"average_hrv,omitempty"`
	RespiratoryRate  *float64           `json:"respiratory_rate,omitempty"`
	// Source the data has come from.
	Source      *ClientFacingSource      `json:"source,omitempty"`
	SleepStream *ClientFacingSleepStream `json:"sleep_stream,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSleep) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleep(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleep) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepStream struct {
	Hrv             []*ClientFacingHrvTimeseries             `json:"hrv,omitempty"`
	Heartrate       []*ClientFacingHeartRateTimeseries       `json:"heartrate,omitempty"`
	Hypnogram       []*ClientFacingHypnogramTimeseries       `json:"hypnogram,omitempty"`
	RespiratoryRate []*ClientFacingRespiratoryRateTimeseries `json:"respiratory_rate,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSleepStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSleepStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSleepStream(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Source summarizes where a sample or a summary is sourced from.
// At minimum, the source provider is always included.
type ClientFacingSource struct {
	// Provider slug. e.g., `oura`, `fitbit`, `garmin`.
	Provider string `json:"provider"`
	// The type of the data source (app or device) by which the summary or the timeseries data were recorded. This defaults to `unknown` when Vital cannot extract or infer that information
	Type  *string `json:"type,omitempty"`
	AppId *string `json:"app_id,omitempty"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Name *string `json:"name,omitempty"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Slug *string `json:"slug,omitempty"`
	// Deprecated. Subject to removal after 1 Jan 2024.
	Logo *string `json:"logo,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSource(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSource) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSport struct {
	Id int `json:"id"`
	// Sport's name
	Name string `json:"name"`
	// Slug for designated sport
	Slug string `json:"slug"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingSport) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingSport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingSport(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSport) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStepsTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in counts
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The number of steps sampled at the time or interval::count
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (c *ClientFacingStepsTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingStepsTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStepsTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStepsTimeseries(value)
	c.unit = "count"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStepsTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingStepsTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingStream struct {
	// RPM for cycling, Steps per minute for running
	Cadence *ClientFacingStreamCadence `json:"cadence,omitempty"`
	Time    []int                      `json:"time,omitempty"`
	// Data points for altitude
	Altitude *ClientFacingStreamAltitude `json:"altitude,omitempty"`
	// Velocity in m/s
	VelocitySmooth *ClientFacingStreamVelocitySmooth `json:"velocity_smooth,omitempty"`
	// Heart rate in bpm
	Heartrate *ClientFacingStreamHeartrate `json:"heartrate,omitempty"`
	// Latitude for data point
	Lat *ClientFacingStreamLat `json:"lat,omitempty"`
	// Longitude for data point
	Lng *ClientFacingStreamLng `json:"lng,omitempty"`
	// Cumulated distance for exercise
	Distance *ClientFacingStreamDistance `json:"distance,omitempty"`
	// Power in watts
	Power *ClientFacingStreamPower `json:"power,omitempty"`
	// Resistance on bike
	Resistance *ClientFacingStreamResistance `json:"resistance,omitempty"`
	// Temperature stream measured by device in Celsius
	Temperature *ClientFacingStreamTemperature `json:"temperature,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingStream) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStream(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStream) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Data points for altitude
type ClientFacingStreamAltitude struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamAltitudeFromDoubleOptionalList(value []*float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamAltitudeFromDoubleList(value []float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamAltitude) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamAltitude) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamAltitudeVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamAltitude) Accept(visitor ClientFacingStreamAltitudeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// RPM for cycling, Steps per minute for running
type ClientFacingStreamCadence struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamCadenceFromDoubleOptionalList(value []*float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamCadenceFromDoubleList(value []float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamCadence) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamCadence) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamCadenceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamCadence) Accept(visitor ClientFacingStreamCadenceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Cumulated distance for exercise
type ClientFacingStreamDistance struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamDistanceFromDoubleOptionalList(value []*float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamDistanceFromDoubleList(value []float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamDistance) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamDistance) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamDistanceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamDistance) Accept(visitor ClientFacingStreamDistanceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Heart rate in bpm
type ClientFacingStreamHeartrate struct {
	typeName            string
	IntegerOptionalList []*int
	IntegerList         []int
}

func NewClientFacingStreamHeartrateFromIntegerOptionalList(value []*int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{typeName: "integerOptionalList", IntegerOptionalList: value}
}

func NewClientFacingStreamHeartrateFromIntegerList(value []int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{typeName: "integerList", IntegerList: value}
}

func (c *ClientFacingStreamHeartrate) UnmarshalJSON(data []byte) error {
	var valueIntegerOptionalList []*int
	if err := json.Unmarshal(data, &valueIntegerOptionalList); err == nil {
		c.typeName = "integerOptionalList"
		c.IntegerOptionalList = valueIntegerOptionalList
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.typeName = "integerList"
		c.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamHeartrate) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integerOptionalList":
		return json.Marshal(c.IntegerOptionalList)
	case "integerList":
		return json.Marshal(c.IntegerList)
	}
}

type ClientFacingStreamHeartrateVisitor interface {
	VisitIntegerOptionalList([]*int) error
	VisitIntegerList([]int) error
}

func (c *ClientFacingStreamHeartrate) Accept(visitor ClientFacingStreamHeartrateVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integerOptionalList":
		return visitor.VisitIntegerOptionalList(c.IntegerOptionalList)
	case "integerList":
		return visitor.VisitIntegerList(c.IntegerList)
	}
}

// Latitude for data point
type ClientFacingStreamLat struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamLatFromDoubleOptionalList(value []*float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamLatFromDoubleList(value []float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamLat) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLat) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamLatVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLat) Accept(visitor ClientFacingStreamLatVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Longitude for data point
type ClientFacingStreamLng struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamLngFromDoubleOptionalList(value []*float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamLngFromDoubleList(value []float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamLng) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLng) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamLngVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLng) Accept(visitor ClientFacingStreamLngVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Power in watts
type ClientFacingStreamPower struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamPowerFromDoubleOptionalList(value []*float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamPowerFromDoubleList(value []float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamPower) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamPower) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamPowerVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamPower) Accept(visitor ClientFacingStreamPowerVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Resistance on bike
type ClientFacingStreamResistance struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamResistanceFromDoubleOptionalList(value []*float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamResistanceFromDoubleList(value []float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamResistance) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamResistance) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamResistanceVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamResistance) Accept(visitor ClientFacingStreamResistanceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Temperature stream measured by device in Celsius
type ClientFacingStreamTemperature struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamTemperatureFromDoubleOptionalList(value []*float64) *ClientFacingStreamTemperature {
	return &ClientFacingStreamTemperature{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamTemperatureFromDoubleList(value []float64) *ClientFacingStreamTemperature {
	return &ClientFacingStreamTemperature{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamTemperature) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamTemperature) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamTemperatureVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamTemperature) Accept(visitor ClientFacingStreamTemperatureVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Velocity in m/s
type ClientFacingStreamVelocitySmooth struct {
	typeName           string
	DoubleOptionalList []*float64
	DoubleList         []float64
}

func NewClientFacingStreamVelocitySmoothFromDoubleOptionalList(value []*float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{typeName: "doubleOptionalList", DoubleOptionalList: value}
}

func NewClientFacingStreamVelocitySmoothFromDoubleList(value []float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamVelocitySmooth) UnmarshalJSON(data []byte) error {
	var valueDoubleOptionalList []*float64
	if err := json.Unmarshal(data, &valueDoubleOptionalList); err == nil {
		c.typeName = "doubleOptionalList"
		c.DoubleOptionalList = valueDoubleOptionalList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamVelocitySmooth) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return json.Marshal(c.DoubleOptionalList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamVelocitySmoothVisitor interface {
	VisitDoubleOptionalList([]*float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamVelocitySmooth) Accept(visitor ClientFacingStreamVelocitySmoothVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleOptionalList":
		return visitor.VisitDoubleOptionalList(c.DoubleOptionalList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

type ClientFacingStressLevelTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	Value     float64   `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingStressLevelTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingStressLevelTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingStressLevelTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStressLevelTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// [Deprecated] GET /v2/team is in the process of being removed.
// Neither customers nor Dashboard should retrieve team settings and metadata directly.
//
// All must migrate to the Team endpoints of the Org Management API.
type ClientFacingTeam struct {
	Id                                       string                `json:"id"`
	OrgId                                    string                `json:"org_id"`
	Name                                     string                `json:"name"`
	SvixAppId                                *string               `json:"svix_app_id,omitempty"`
	ClientId                                 *string               `json:"client_id,omitempty"`
	ClientSecret                             *string               `json:"client_secret,omitempty"`
	AirtableApiKey                           *string               `json:"airtable_api_key,omitempty"`
	AirtableBaseId                           *string               `json:"airtable_base_id,omitempty"`
	WebhookSecret                            *string               `json:"webhook_secret,omitempty"`
	ApiKey                                   *string               `json:"api_key,omitempty"`
	ApiKeys                                  []*ClientFacingApiKey `json:"api_keys,omitempty"`
	Configuration                            *TeamConfig           `json:"configuration,omitempty"`
	TestkitsTextsEnabled                     bool                  `json:"testkits_texts_enabled"`
	LabTestsPatientCommunicationEnabled      bool                  `json:"lab_tests_patient_communication_enabled"`
	LabTestsPatientSmsCommunicationEnabled   bool                  `json:"lab_tests_patient_sms_communication_enabled"`
	LabTestsPatientEmailCommunicationEnabled bool                  `json:"lab_tests_patient_email_communication_enabled"`
	LogoUrl                                  *string               `json:"logo_url,omitempty"`
	DelegatedFlow                            DelegatedFlowType     `json:"delegated_flow,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTeam) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTeam
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTeam(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTeam) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTestKitOrderDetails struct {
	Data *ClientFacingTestkitOrder `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTestKitOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTestKitOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTestKitOrderDetails(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestKitOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a testkit order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingTestkitOrder struct {
	// The Vital TestKit Order ID
	Id        string                `json:"id"`
	Shipment  *ClientFacingShipment `json:"shipment,omitempty"`
	CreatedAt time.Time             `json:"created_at"`
	UpdatedAt time.Time             `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTestkitOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTestkitOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTestkitOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTestkitOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample struct {
	Source *ClientFacingSource                       `json:"source,omitempty"`
	Data   []*ClientFacingBodyTemperatureDeltaSample `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample struct {
	Source *ClientFacingSource                  `json:"source,omitempty"`
	Data   []*ClientFacingBodyTemperatureSample `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingBodyTemperatureSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingCarbohydratesSample struct {
	Source *ClientFacingSource                `json:"source,omitempty"`
	Data   []*ClientFacingCarbohydratesSample `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingCarbohydratesSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingCarbohydratesSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingCarbohydratesSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample struct {
	Source *ClientFacingSource                   `json:"source,omitempty"`
	Data   []*ClientFacingInsulinInjectionSample `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingInsulinInjectionSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingNoteSample struct {
	Source *ClientFacingSource       `json:"source,omitempty"`
	Data   []*ClientFacingNoteSample `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingNoteSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingNoteSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingNoteSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample struct {
	Source *ClientFacingSource                  `json:"source,omitempty"`
	Data   []*ClientFacingWorkoutDurationSample `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingTimeseriesGroupClientFacingWorkoutDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUser struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// Your team id.
	TeamId string `json:"team_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id"`
	// When your item is created
	CreatedOn time.Time `json:"created_on"`
	// A list of the users connected sources.
	ConnectedSources  []*ConnectedSourceClientFacing `json:"connected_sources,omitempty"`
	FallbackTimeZone  *FallbackTimeZone              `json:"fallback_time_zone,omitempty"`
	FallbackBirthDate *FallbackBirthDate             `json:"fallback_birth_date,omitempty"`
	IngestionStart    *string                        `json:"ingestion_start,omitempty"`
	IngestionEnd      *string                        `json:"ingestion_end,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingUser) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUser(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUser) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUserKey struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingUserKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUserKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUserKey(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUserKey) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingVo2MaxTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in mL/kg/min.
	Unit string `json:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingVo2MaxTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingVo2MaxTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingVo2MaxTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingVo2MaxTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWalkInOrderDetails struct {
	Data *ClientFacingWalkInTestOrder `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWalkInOrderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWalkInOrderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWalkInOrderDetails(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInOrderDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Schema for a walk-in test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingWalkInTestOrder struct {
	// The Vital walk-in test Order ID
	Id        string    `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWalkInTestOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWalkInTestOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWalkInTestOrder(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWalkInTestOrder) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWaterTimeseries struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Measured in milliters.
	Unit string `json:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Quantity of water drank during the time period.
	Value float64 `json:"value"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWaterTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWaterTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWaterTimeseries(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterTimeseries) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkout struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId         string   `json:"user_id"`
	Id             string   `json:"id"`
	Title          *string  `json:"title,omitempty"`
	TimezoneOffset *int     `json:"timezone_offset,omitempty"`
	AverageHr      *int     `json:"average_hr,omitempty"`
	MaxHr          *int     `json:"max_hr,omitempty"`
	Distance       *float64 `json:"distance,omitempty"`
	// Date of the workout summary in the YYYY-mm-dd format. This generally matches the workout start date.
	CalendarDate string `json:"calendar_date"`
	// Start time of the workout::time
	TimeStart time.Time `json:"time_start"`
	// End time of the workout::time
	TimeEnd  time.Time `json:"time_end"`
	Calories *float64  `json:"calories,omitempty"`
	// Sport's name
	Sport                *ClientFacingSport     `json:"sport,omitempty"`
	HrZones              []int                  `json:"hr_zones,omitempty"`
	MovingTime           *int                   `json:"moving_time,omitempty"`
	TotalElevationGain   *float64               `json:"total_elevation_gain,omitempty"`
	ElevHigh             *float64               `json:"elev_high,omitempty"`
	ElevLow              *float64               `json:"elev_low,omitempty"`
	AverageSpeed         *float64               `json:"average_speed,omitempty"`
	MaxSpeed             *float64               `json:"max_speed,omitempty"`
	AverageWatts         *float64               `json:"average_watts,omitempty"`
	DeviceWatts          *float64               `json:"device_watts,omitempty"`
	MaxWatts             *float64               `json:"max_watts,omitempty"`
	WeightedAverageWatts *float64               `json:"weighted_average_watts,omitempty"`
	Steps                *int                   `json:"steps,omitempty"`
	Map                  map[string]interface{} `json:"map,omitempty"`
	// Provider ID given for that specific workout
	ProviderId string `json:"provider_id"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientFacingWorkout) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkout(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkout) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSample struct {
	Id             *int    `json:"id,omitempty"`
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Type           *string `json:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end"`
	// The recorded value for the interval.
	Value     float64                                     `json:"value"`
	Intensity *ClientFacingWorkoutDurationSampleIntensity `json:"intensity,omitempty"`
	unit      string

	_rawJSON json.RawMessage
}

func (c *ClientFacingWorkoutDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingWorkoutDurationSample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDurationSample(value)
	c.unit = "min"
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDurationSample
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "min",
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingWorkoutDurationSample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSampleIntensity string

const (
	ClientFacingWorkoutDurationSampleIntensityLow    ClientFacingWorkoutDurationSampleIntensity = "low"
	ClientFacingWorkoutDurationSampleIntensityMedium ClientFacingWorkoutDurationSampleIntensity = "medium"
	ClientFacingWorkoutDurationSampleIntensityHigh   ClientFacingWorkoutDurationSampleIntensity = "high"
)

func NewClientFacingWorkoutDurationSampleIntensityFromString(s string) (ClientFacingWorkoutDurationSampleIntensity, error) {
	switch s {
	case "low":
		return ClientFacingWorkoutDurationSampleIntensityLow, nil
	case "medium":
		return ClientFacingWorkoutDurationSampleIntensityMedium, nil
	case "high":
		return ClientFacingWorkoutDurationSampleIntensityHigh, nil
	}
	var t ClientFacingWorkoutDurationSampleIntensity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutDurationSampleIntensity) Ptr() *ClientFacingWorkoutDurationSampleIntensity {
	return &c
}

type ClientSleepResponse struct {
	Sleep []*ClientFacingSleep `json:"sleep,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientSleepResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientSleepResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientSleepResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientSleepResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientUserIdConflict struct {
	ErrorType    string    `json:"error_type"`
	ErrorMessage string    `json:"error_message"`
	UserId       string    `json:"user_id"`
	CreatedOn    time.Time `json:"created_on"`

	_rawJSON json.RawMessage
}

func (c *ClientUserIdConflict) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientUserIdConflict
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientUserIdConflict(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientUserIdConflict) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientWorkoutResponse struct {
	Workouts []*ClientFacingWorkout `json:"workouts,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClientWorkoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientWorkoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientWorkoutResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientWorkoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompanyDetails struct {
	Name    string   `json:"name"`
	Address *Address `json:"address,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CompanyDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyDetails(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectedSourceClientFacing struct {
	// The provider of this connected source.
	Provider *ClientFacingProvider `json:"provider,omitempty"`
	// When your item is created
	CreatedOn time.Time `json:"created_on"`
	// Deprecated. Use `provider` instead. Subject to removal after 1 Jan 2024.
	Source *ClientFacingProvider `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectedSourceClientFacing) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectedSourceClientFacing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectedSourceClientFacing(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectedSourceClientFacing) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionStatus struct {
	State       ConnectionStatusState `json:"state,omitempty"`
	RedirectUrl *string               `json:"redirect_url,omitempty"`
	ErrorType   *string               `json:"error_type,omitempty"`
	Error       *string               `json:"error,omitempty"`
	ProviderMfa *ProviderMfaRequest   `json:"provider_mfa,omitempty"`
	Success     bool                  `json:"success"`

	_rawJSON json.RawMessage
}

func (c *ConnectionStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionStatus(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionStatus) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionStatusState string

const (
	ConnectionStatusStateSuccess            ConnectionStatusState = "success"
	ConnectionStatusStateError              ConnectionStatusState = "error"
	ConnectionStatusStatePendingProviderMfa ConnectionStatusState = "pending_provider_mfa"
)

func NewConnectionStatusStateFromString(s string) (ConnectionStatusState, error) {
	switch s {
	case "success":
		return ConnectionStatusStateSuccess, nil
	case "error":
		return ConnectionStatusStateError, nil
	case "pending_provider_mfa":
		return ConnectionStatusStatePendingProviderMfa, nil
	}
	var t ConnectionStatusState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionStatusState) Ptr() *ConnectionStatusState {
	return &c
}

type Consent struct {
	ConsentType   ConsentType `json:"consentType,omitempty"`
	Version       *string     `json:"version,omitempty"`
	TimeOfConsent *time.Time  `json:"timeOfConsent,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Consent) UnmarshalJSON(data []byte) error {
	type unmarshaler Consent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Consent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Consent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConsentType string

const (
	ConsentTypeTermsOfUse                ConsentType = "terms-of-use"
	ConsentTypeTelehealthInformedConsent ConsentType = "telehealth-informed-consent"
	ConsentTypeMobileTermsAndConditions  ConsentType = "mobile-terms-and-conditions"
	ConsentTypeNoticeOfPrivacyPractices  ConsentType = "notice-of-privacy-practices"
	ConsentTypePrivacyPolicy             ConsentType = "privacy-policy"
	ConsentTypeHipaaAuthorization        ConsentType = "hipaa-authorization"
)

func NewConsentTypeFromString(s string) (ConsentType, error) {
	switch s {
	case "terms-of-use":
		return ConsentTypeTermsOfUse, nil
	case "telehealth-informed-consent":
		return ConsentTypeTelehealthInformedConsent, nil
	case "mobile-terms-and-conditions":
		return ConsentTypeMobileTermsAndConditions, nil
	case "notice-of-privacy-practices":
		return ConsentTypeNoticeOfPrivacyPractices, nil
	case "privacy-policy":
		return ConsentTypePrivacyPolicy, nil
	case "hipaa-authorization":
		return ConsentTypeHipaaAuthorization, nil
	}
	var t ConsentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsentType) Ptr() *ConsentType {
	return &c
}

type ContraceptiveEntry struct {
	Date string                 `json:"date"`
	Type ContraceptiveEntryType `json:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ContraceptiveEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ContraceptiveEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContraceptiveEntry(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContraceptiveEntry) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContraceptiveEntryType string

const (
	ContraceptiveEntryTypeUnspecified      ContraceptiveEntryType = "unspecified"
	ContraceptiveEntryTypeImplant          ContraceptiveEntryType = "implant"
	ContraceptiveEntryTypeInjection        ContraceptiveEntryType = "injection"
	ContraceptiveEntryTypeIud              ContraceptiveEntryType = "iud"
	ContraceptiveEntryTypeIntravaginalRing ContraceptiveEntryType = "intravaginal_ring"
	ContraceptiveEntryTypeOral             ContraceptiveEntryType = "oral"
	ContraceptiveEntryTypePatch            ContraceptiveEntryType = "patch"
)

func NewContraceptiveEntryTypeFromString(s string) (ContraceptiveEntryType, error) {
	switch s {
	case "unspecified":
		return ContraceptiveEntryTypeUnspecified, nil
	case "implant":
		return ContraceptiveEntryTypeImplant, nil
	case "injection":
		return ContraceptiveEntryTypeInjection, nil
	case "iud":
		return ContraceptiveEntryTypeIud, nil
	case "intravaginal_ring":
		return ContraceptiveEntryTypeIntravaginalRing, nil
	case "oral":
		return ContraceptiveEntryTypeOral, nil
	case "patch":
		return ContraceptiveEntryTypePatch, nil
	}
	var t ContraceptiveEntryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContraceptiveEntryType) Ptr() *ContraceptiveEntryType {
	return &c
}

type DateTimeUnit string

const (
	DateTimeUnitMinute DateTimeUnit = "minute"
	DateTimeUnitHour   DateTimeUnit = "hour"
	DateTimeUnitDay    DateTimeUnit = "day"
	DateTimeUnitWeek   DateTimeUnit = "week"
	DateTimeUnitMonth  DateTimeUnit = "month"
	DateTimeUnitYear   DateTimeUnit = "year"
)

func NewDateTimeUnitFromString(s string) (DateTimeUnit, error) {
	switch s {
	case "minute":
		return DateTimeUnitMinute, nil
	case "hour":
		return DateTimeUnitHour, nil
	case "day":
		return DateTimeUnitDay, nil
	case "week":
		return DateTimeUnitWeek, nil
	case "month":
		return DateTimeUnitMonth, nil
	case "year":
		return DateTimeUnitYear, nil
	}
	var t DateTimeUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DateTimeUnit) Ptr() *DateTimeUnit {
	return &d
}

type DaySlots struct {
	Date  string      `json:"date"`
	Slots []*TimeSlot `json:"slots,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DaySlots) UnmarshalJSON(data []byte) error {
	type unmarshaler DaySlots
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DaySlots(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DaySlots) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DelegatedFlowType string

const (
	DelegatedFlowTypeOrderAndResultsWithCustomerPhysicianNetwork DelegatedFlowType = "order_and_results_with_customer_physician_network"
	DelegatedFlowTypeOrderWithVitalPhysicianNetwork              DelegatedFlowType = "order_with_vital_physician_network"
	DelegatedFlowTypeOrderAndResultsWithVitalPhysicianNetwork    DelegatedFlowType = "order_and_results_with_vital_physician_network"
)

func NewDelegatedFlowTypeFromString(s string) (DelegatedFlowType, error) {
	switch s {
	case "order_and_results_with_customer_physician_network":
		return DelegatedFlowTypeOrderAndResultsWithCustomerPhysicianNetwork, nil
	case "order_with_vital_physician_network":
		return DelegatedFlowTypeOrderWithVitalPhysicianNetwork, nil
	case "order_and_results_with_vital_physician_network":
		return DelegatedFlowTypeOrderAndResultsWithVitalPhysicianNetwork, nil
	}
	var t DelegatedFlowType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DelegatedFlowType) Ptr() *DelegatedFlowType {
	return &d
}

type DemoConnectionStatus struct {
	Success bool   `json:"success"`
	Detail  string `json:"detail"`

	_rawJSON json.RawMessage
}

func (d *DemoConnectionStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler DemoConnectionStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DemoConnectionStatus(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DemoConnectionStatus) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DemoProviders string

const (
	DemoProvidersAppleHealthKit DemoProviders = "apple_health_kit"
	DemoProvidersFitbit         DemoProviders = "fitbit"
	DemoProvidersFreestyleLibre DemoProviders = "freestyle_libre"
	DemoProvidersOura           DemoProviders = "oura"
)

func NewDemoProvidersFromString(s string) (DemoProviders, error) {
	switch s {
	case "apple_health_kit":
		return DemoProvidersAppleHealthKit, nil
	case "fitbit":
		return DemoProvidersFitbit, nil
	case "freestyle_libre":
		return DemoProvidersFreestyleLibre, nil
	case "oura":
		return DemoProvidersOura, nil
	}
	var t DemoProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DemoProviders) Ptr() *DemoProviders {
	return &d
}

type DetectedDeviationEntry struct {
	Date      string                          `json:"date"`
	Deviation DetectedDeviationEntryDeviation `json:"deviation,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DetectedDeviationEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler DetectedDeviationEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetectedDeviationEntry(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetectedDeviationEntry) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DetectedDeviationEntryDeviation string

const (
	DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding DetectedDeviationEntryDeviation = "persistent_intermenstrual_bleeding"
	DetectedDeviationEntryDeviationProlongedMenstrualPeriods        DetectedDeviationEntryDeviation = "prolonged_menstrual_periods"
	DetectedDeviationEntryDeviationIrregularMenstrualCycles         DetectedDeviationEntryDeviation = "irregular_menstrual_cycles"
	DetectedDeviationEntryDeviationInfrequentMenstrualCycles        DetectedDeviationEntryDeviation = "infrequent_menstrual_cycles"
)

func NewDetectedDeviationEntryDeviationFromString(s string) (DetectedDeviationEntryDeviation, error) {
	switch s {
	case "persistent_intermenstrual_bleeding":
		return DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding, nil
	case "prolonged_menstrual_periods":
		return DetectedDeviationEntryDeviationProlongedMenstrualPeriods, nil
	case "irregular_menstrual_cycles":
		return DetectedDeviationEntryDeviationIrregularMenstrualCycles, nil
	case "infrequent_menstrual_cycles":
		return DetectedDeviationEntryDeviationInfrequentMenstrualCycles, nil
	}
	var t DetectedDeviationEntryDeviation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DetectedDeviationEntryDeviation) Ptr() *DetectedDeviationEntryDeviation {
	return &d
}

type DeviceV2InDb struct {
	Data       map[string]interface{} `json:"data,omitempty"`
	ProviderId string                 `json:"provider_id"`
	UserId     string                 `json:"user_id"`
	SourceId   int                    `json:"source_id"`
	Id         string                 `json:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeviceV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceV2InDb(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceV2InDb) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmailProviders = string

type Energy struct {
	Value float64 `json:"value"`
	unit  string

	_rawJSON json.RawMessage
}

func (e *Energy) Unit() string {
	return e.unit
}

func (e *Energy) UnmarshalJSON(data []byte) error {
	type unmarshaler Energy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Energy(value)
	e.unit = "kcal"
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Energy) MarshalJSON() ([]byte, error) {
	type embed Energy
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*e),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

func (e *Energy) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventDestinationPreferences struct {
	Preferred EventDestinationPreferencesPreferred     `json:"preferred,omitempty"`
	Enabled   []EventDestinationPreferencesEnabledItem `json:"enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EventDestinationPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler EventDestinationPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventDestinationPreferences(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventDestinationPreferences) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventDestinationPreferencesEnabledItem string

const (
	EventDestinationPreferencesEnabledItemCloudPubsub EventDestinationPreferencesEnabledItem = "cloud_pubsub"
	EventDestinationPreferencesEnabledItemRabbitmq    EventDestinationPreferencesEnabledItem = "rabbitmq"
	EventDestinationPreferencesEnabledItemSvix        EventDestinationPreferencesEnabledItem = "svix"
	EventDestinationPreferencesEnabledItemAzureAmqp   EventDestinationPreferencesEnabledItem = "azure_amqp"
)

func NewEventDestinationPreferencesEnabledItemFromString(s string) (EventDestinationPreferencesEnabledItem, error) {
	switch s {
	case "cloud_pubsub":
		return EventDestinationPreferencesEnabledItemCloudPubsub, nil
	case "rabbitmq":
		return EventDestinationPreferencesEnabledItemRabbitmq, nil
	case "svix":
		return EventDestinationPreferencesEnabledItemSvix, nil
	case "azure_amqp":
		return EventDestinationPreferencesEnabledItemAzureAmqp, nil
	}
	var t EventDestinationPreferencesEnabledItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventDestinationPreferencesEnabledItem) Ptr() *EventDestinationPreferencesEnabledItem {
	return &e
}

type EventDestinationPreferencesPreferred string

const (
	EventDestinationPreferencesPreferredCloudPubsub EventDestinationPreferencesPreferred = "cloud_pubsub"
	EventDestinationPreferencesPreferredRabbitmq    EventDestinationPreferencesPreferred = "rabbitmq"
	EventDestinationPreferencesPreferredSvix        EventDestinationPreferencesPreferred = "svix"
	EventDestinationPreferencesPreferredAzureAmqp   EventDestinationPreferencesPreferred = "azure_amqp"
)

func NewEventDestinationPreferencesPreferredFromString(s string) (EventDestinationPreferencesPreferred, error) {
	switch s {
	case "cloud_pubsub":
		return EventDestinationPreferencesPreferredCloudPubsub, nil
	case "rabbitmq":
		return EventDestinationPreferencesPreferredRabbitmq, nil
	case "svix":
		return EventDestinationPreferencesPreferredSvix, nil
	case "azure_amqp":
		return EventDestinationPreferencesPreferredAzureAmqp, nil
	}
	var t EventDestinationPreferencesPreferred
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventDestinationPreferencesPreferred) Ptr() *EventDestinationPreferencesPreferred {
	return &e
}

type FallbackBirthDate struct {
	// Fallback date of birth of the user, in YYYY-mm-dd format. Used for calculating max heartrate for providers that don not provide users' age.
	Value string `json:"value"`
	// Slug for designated source
	SourceSlug string    `json:"source_slug"`
	UpdatedAt  time.Time `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (f *FallbackBirthDate) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackBirthDate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackBirthDate(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackBirthDate) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FallbackTimeZone struct {
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	Id string `json:"id"`
	// Slug for designated source
	SourceSlug string    `json:"source_slug"`
	UpdatedAt  time.Time `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (f *FallbackTimeZone) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackTimeZone
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackTimeZone(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackTimeZone) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Fats struct {
	Saturated       *float64 `json:"saturated,omitempty"`
	Monounsaturated *float64 `json:"monounsaturated,omitempty"`
	Polyunsaturated *float64 `json:"polyunsaturated,omitempty"`
	Omega3          *float64 `json:"omega3,omitempty"`
	Omega6          *float64 `json:"omega6,omitempty"`
	Total           *float64 `json:"total,omitempty"`

	_rawJSON json.RawMessage
}

func (f *Fats) UnmarshalJSON(data []byte) error {
	type unmarshaler Fats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fats(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fats) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Gender string

const (
	GenderFemale  Gender = "female"
	GenderMale    Gender = "male"
	GenderOther   Gender = "other"
	GenderUnknown Gender = "unknown"
)

func NewGenderFromString(s string) (Gender, error) {
	switch s {
	case "female":
		return GenderFemale, nil
	case "male":
		return GenderMale, nil
	case "other":
		return GenderOther, nil
	case "unknown":
		return GenderUnknown, nil
	}
	var t Gender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g Gender) Ptr() *Gender {
	return &g
}

type GetMarkersResponse struct {
	Markers []*ClientFacingMarkerComplete `json:"markers,omitempty"`
	Total   *int                          `json:"total,omitempty"`
	Page    *int                          `json:"page,omitempty"`
	Size    *int                          `json:"size,omitempty"`
	Pages   *int                          `json:"pages,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetMarkersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetMarkersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetMarkersResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetMarkersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetOrdersResponse struct {
	Orders []*ClientFacingOrder `json:"orders,omitempty"`
	Total  *int                 `json:"total,omitempty"`
	Page   *int                 `json:"page,omitempty"`
	Size   *int                 `json:"size,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrdersResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrdersResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodOxygen struct {
	Source *ClientFacingSource                  `json:"source,omitempty"`
	Data   []*ClientFacingBloodOxygenTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBloodOxygen) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygen(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygen) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodOxygenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedBloodOxygen `json:"groups,omitempty"`
	Next       *string                          `json:"next,omitempty"`
	NextCursor *string                          `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBloodOxygenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygenResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygenResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodPressure struct {
	Source *ClientFacingSource                    `json:"source,omitempty"`
	Data   []*ClientFacingBloodPressureTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBloodPressure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressure(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressure) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBloodPressureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedBloodPressure `json:"groups,omitempty"`
	Next       *string                            `json:"next,omitempty"`
	NextCursor *string                            `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBloodPressureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressureResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressureResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyFat struct {
	Source *ClientFacingSource              `json:"source,omitempty"`
	Data   []*ClientFacingBodyFatTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBodyFat) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFat(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFat) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyFatResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedBodyFat `json:"groups,omitempty"`
	Next       *string                      `json:"next,omitempty"`
	NextCursor *string                      `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBodyFatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFatResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFatResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyWeight struct {
	Source *ClientFacingSource                 `json:"source,omitempty"`
	Data   []*ClientFacingBodyWeightTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBodyWeight) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeight
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeight(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeight) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedBodyWeightResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedBodyWeight `json:"groups,omitempty"`
	Next       *string                         `json:"next,omitempty"`
	NextCursor *string                         `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedBodyWeightResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeightResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeightResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeightResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaffeine struct {
	Source *ClientFacingSource               `json:"source,omitempty"`
	Data   []*ClientFacingCaffeineTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCaffeine) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeine(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeine) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaffeineResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedCaffeine `json:"groups,omitempty"`
	Next       *string                       `json:"next,omitempty"`
	NextCursor *string                       `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCaffeineResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeineResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeineResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeineResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesActive struct {
	Source *ClientFacingSource                     `json:"source,omitempty"`
	Data   []*ClientFacingCaloriesActiveTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCaloriesActive) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActive(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActive) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesActiveResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedCaloriesActive `json:"groups,omitempty"`
	Next       *string                             `json:"next,omitempty"`
	NextCursor *string                             `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCaloriesActiveResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActiveResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActiveResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActiveResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesBasal struct {
	Source *ClientFacingSource                    `json:"source,omitempty"`
	Data   []*ClientFacingCaloriesBasalTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCaloriesBasal) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasal(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasal) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCaloriesBasalResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedCaloriesBasal `json:"groups,omitempty"`
	Next       *string                            `json:"next,omitempty"`
	NextCursor *string                            `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCaloriesBasalResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasalResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasalResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasalResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCholesterol struct {
	Source *ClientFacingSource                  `json:"source,omitempty"`
	Data   []*ClientFacingCholesterolTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCholesterol) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterol
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterol(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterol) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedCholesterolResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedCholesterol `json:"groups,omitempty"`
	Next       *string                          `json:"next,omitempty"`
	NextCursor *string                          `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedCholesterolResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterolResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterolResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterolResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDistance struct {
	Source *ClientFacingSource               `json:"source,omitempty"`
	Data   []*ClientFacingDistanceTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedDistance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistance(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistance) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedDistanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedDistance `json:"groups,omitempty"`
	Next       *string                       `json:"next,omitempty"`
	NextCursor *string                       `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedDistanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistanceResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistanceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedElectrocardiogramVoltage struct {
	Source *ClientFacingSource                               `json:"source,omitempty"`
	Data   []*ClientFacingElectrocardiogramVoltageTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedElectrocardiogramVoltage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltage(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltage) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedElectrocardiogramVoltageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedElectrocardiogramVoltage `json:"groups,omitempty"`
	Next       *string                                       `json:"next,omitempty"`
	NextCursor *string                                       `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedElectrocardiogramVoltageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltageResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFloorsClimbed struct {
	Source *ClientFacingSource                    `json:"source,omitempty"`
	Data   []*ClientFacingFloorsClimbedTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedFloorsClimbed) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbed(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbed) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedFloorsClimbedResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedFloorsClimbed `json:"groups,omitempty"`
	Next       *string                            `json:"next,omitempty"`
	NextCursor *string                            `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedFloorsClimbedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbedResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbedResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedGlucose struct {
	Source *ClientFacingSource              `json:"source,omitempty"`
	Data   []*ClientFacingGlucoseTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedGlucose) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucose(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucose) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedGlucoseResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedGlucose `json:"groups,omitempty"`
	Next       *string                      `json:"next,omitempty"`
	NextCursor *string                      `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedGlucoseResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucoseResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucoseResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucoseResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRate struct {
	Source *ClientFacingSource                `json:"source,omitempty"`
	Data   []*ClientFacingHeartRateTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRate(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHeartRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedHeartRate `json:"groups,omitempty"`
	Next       *string                        `json:"next,omitempty"`
	NextCursor *string                        `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedHeartRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHrv struct {
	Source *ClientFacingSource          `json:"source,omitempty"`
	Data   []*ClientFacingHrvTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedHrv) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrv
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrv(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrv) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHrvResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedHrv `json:"groups,omitempty"`
	Next       *string                  `json:"next,omitempty"`
	NextCursor *string                  `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedHrvResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrvResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrvResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrvResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHypnogram struct {
	Source *ClientFacingSource                `json:"source,omitempty"`
	Data   []*ClientFacingHypnogramTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedHypnogram) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogram(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogram) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedHypnogramResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedHypnogram `json:"groups,omitempty"`
	Next       *string                        `json:"next,omitempty"`
	NextCursor *string                        `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedHypnogramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogramResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogramResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIge struct {
	Source *ClientFacingSource          `json:"source,omitempty"`
	Data   []*ClientFacingIgeTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedIge) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIge(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIge) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIgeResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedIge `json:"groups,omitempty"`
	Next       *string                  `json:"next,omitempty"`
	NextCursor *string                  `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedIgeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgeResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIgg struct {
	Source *ClientFacingSource          `json:"source,omitempty"`
	Data   []*ClientFacingIggTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedIgg) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgg(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgg) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedIggResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedIgg `json:"groups,omitempty"`
	Next       *string                  `json:"next,omitempty"`
	NextCursor *string                  `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedIggResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIggResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIggResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIggResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedMindfulnessMinutes struct {
	Source *ClientFacingSource                         `json:"source,omitempty"`
	Data   []*ClientFacingMindfulnessMinutesTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedMindfulnessMinutes) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutes(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutes) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedMindfulnessMinutesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedMindfulnessMinutes `json:"groups,omitempty"`
	Next       *string                                 `json:"next,omitempty"`
	NextCursor *string                                 `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedMindfulnessMinutesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutesResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedRespiratoryRate struct {
	Source *ClientFacingSource                      `json:"source,omitempty"`
	Data   []*ClientFacingRespiratoryRateTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedRespiratoryRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRate(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedRespiratoryRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedRespiratoryRate `json:"groups,omitempty"`
	Next       *string                              `json:"next,omitempty"`
	NextCursor *string                              `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedRespiratoryRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRateResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRateResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedSteps struct {
	Source *ClientFacingSource            `json:"source,omitempty"`
	Data   []*ClientFacingStepsTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedSteps) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSteps
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSteps(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSteps) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStepsResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedSteps `json:"groups,omitempty"`
	Next       *string                    `json:"next,omitempty"`
	NextCursor *string                    `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedStepsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStepsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStepsResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStepsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStressLevel struct {
	Source *ClientFacingSource                  `json:"source,omitempty"`
	Data   []*ClientFacingStressLevelTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedStressLevel) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevel(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevel) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedStressLevelResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedStressLevel `json:"groups,omitempty"`
	Next       *string                          `json:"next,omitempty"`
	NextCursor *string                          `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedStressLevelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevelResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevelResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedVo2Max struct {
	Source *ClientFacingSource             `json:"source,omitempty"`
	Data   []*ClientFacingVo2MaxTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedVo2Max) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2Max
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2Max(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2Max) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedVo2MaxResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedVo2Max `json:"groups,omitempty"`
	Next       *string                     `json:"next,omitempty"`
	NextCursor *string                     `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedVo2MaxResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2MaxResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2MaxResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2MaxResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWater struct {
	Source *ClientFacingSource            `json:"source,omitempty"`
	Data   []*ClientFacingWaterTimeseries `json:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedWater) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWater
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWater(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWater) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupedWaterResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups     map[string][]*GroupedWater `json:"groups,omitempty"`
	Next       *string                    `json:"next,omitempty"`
	NextCursor *string                    `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GroupedWaterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaterResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaterResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HealthInsuranceCreateRequest struct {
	// An image of the front of the patient insurance card.
	FrontImage *HealthInsuranceCreateRequestFrontImage `json:"front_image,omitempty"`
	// An image of the back of the patient insurance card.
	BackImage *HealthInsuranceCreateRequestBackImage `json:"back_image,omitempty"`
	// An image of the patient signature for health insurance billing.
	PatientSignatureImage   *HealthInsuranceCreateRequestPatientSignatureImage            `json:"patient_signature_image,omitempty"`
	Subjective              *string                                                       `json:"subjective,omitempty"`
	AssessmentPlan          *string                                                       `json:"assessment_plan,omitempty"`
	PayorCode               *string                                                       `json:"payor_code,omitempty"`
	InsuranceId             *string                                                       `json:"insurance_id,omitempty"`
	ResponsibleRelationship *ResponsibleRelationship                                      `json:"responsible_relationship,omitempty"`
	ResponsibleDetails      *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails `json:"responsible_details,omitempty"`
	DiagnosisCodes          []string                                                      `json:"diagnosis_codes,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HealthInsuranceCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HealthInsuranceCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HealthInsuranceCreateRequest(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HealthInsuranceCreateRequest) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// An image of the back of the patient insurance card.
type HealthInsuranceCreateRequestBackImage struct {
	typeName string
	Jpeg     *Jpeg
	Png      *Png
}

func NewHealthInsuranceCreateRequestBackImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{typeName: "jpeg", Jpeg: value}
}

func NewHealthInsuranceCreateRequestBackImageFromPng(value *Png) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{typeName: "png", Png: value}
}

func (h *HealthInsuranceCreateRequestBackImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.typeName = "jpeg"
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.typeName = "png"
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestBackImage) MarshalJSON() ([]byte, error) {
	switch h.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.typeName, h)
	case "jpeg":
		return json.Marshal(h.Jpeg)
	case "png":
		return json.Marshal(h.Png)
	}
}

type HealthInsuranceCreateRequestBackImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestBackImage) Accept(visitor HealthInsuranceCreateRequestBackImageVisitor) error {
	switch h.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", h.typeName, h)
	case "jpeg":
		return visitor.VisitJpeg(h.Jpeg)
	case "png":
		return visitor.VisitPng(h.Png)
	}
}

// An image of the front of the patient insurance card.
type HealthInsuranceCreateRequestFrontImage struct {
	typeName string
	Jpeg     *Jpeg
	Png      *Png
}

func NewHealthInsuranceCreateRequestFrontImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{typeName: "jpeg", Jpeg: value}
}

func NewHealthInsuranceCreateRequestFrontImageFromPng(value *Png) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{typeName: "png", Png: value}
}

func (h *HealthInsuranceCreateRequestFrontImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.typeName = "jpeg"
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.typeName = "png"
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestFrontImage) MarshalJSON() ([]byte, error) {
	switch h.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.typeName, h)
	case "jpeg":
		return json.Marshal(h.Jpeg)
	case "png":
		return json.Marshal(h.Png)
	}
}

type HealthInsuranceCreateRequestFrontImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestFrontImage) Accept(visitor HealthInsuranceCreateRequestFrontImageVisitor) error {
	switch h.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", h.typeName, h)
	case "jpeg":
		return visitor.VisitJpeg(h.Jpeg)
	case "png":
		return visitor.VisitPng(h.Png)
	}
}

// An image of the patient signature for health insurance billing.
type HealthInsuranceCreateRequestPatientSignatureImage struct {
	typeName string
	Jpeg     *Jpeg
	Png      *Png
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromJpeg(value *Jpeg) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{typeName: "jpeg", Jpeg: value}
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromPng(value *Png) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{typeName: "png", Png: value}
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		h.typeName = "jpeg"
		h.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		h.typeName = "png"
		h.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, h)
}

func (h HealthInsuranceCreateRequestPatientSignatureImage) MarshalJSON() ([]byte, error) {
	switch h.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.typeName, h)
	case "jpeg":
		return json.Marshal(h.Jpeg)
	case "png":
		return json.Marshal(h.Png)
	}
}

type HealthInsuranceCreateRequestPatientSignatureImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) Accept(visitor HealthInsuranceCreateRequestPatientSignatureImageVisitor) error {
	switch h.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", h.typeName, h)
	case "jpeg":
		return visitor.VisitJpeg(h.Jpeg)
	case "png":
		return visitor.VisitPng(h.Png)
	}
}

type HistoricalPullStatus string

const (
	HistoricalPullStatusSuccess    HistoricalPullStatus = "success"
	HistoricalPullStatusFailure    HistoricalPullStatus = "failure"
	HistoricalPullStatusInProgress HistoricalPullStatus = "in_progress"
	HistoricalPullStatusScheduled  HistoricalPullStatus = "scheduled"
)

func NewHistoricalPullStatusFromString(s string) (HistoricalPullStatus, error) {
	switch s {
	case "success":
		return HistoricalPullStatusSuccess, nil
	case "failure":
		return HistoricalPullStatusFailure, nil
	case "in_progress":
		return HistoricalPullStatusInProgress, nil
	case "scheduled":
		return HistoricalPullStatusScheduled, nil
	}
	var t HistoricalPullStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HistoricalPullStatus) Ptr() *HistoricalPullStatus {
	return &h
}

type HistoricalPullTimeline struct {
	ScheduledAt time.Time  `json:"scheduled_at"`
	StartedAt   *time.Time `json:"started_at,omitempty"`
	EndedAt     *time.Time `json:"ended_at,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HistoricalPullTimeline) UnmarshalJSON(data []byte) error {
	type unmarshaler HistoricalPullTimeline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HistoricalPullTimeline(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HistoricalPullTimeline) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomePregnancyTestEntry struct {
	Date       string                           `json:"date"`
	TestResult HomePregnancyTestEntryTestResult `json:"test_result,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HomePregnancyTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomePregnancyTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomePregnancyTestEntry(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomePregnancyTestEntry) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomePregnancyTestEntryTestResult string

const (
	HomePregnancyTestEntryTestResultNegative      HomePregnancyTestEntryTestResult = "negative"
	HomePregnancyTestEntryTestResultPositive      HomePregnancyTestEntryTestResult = "positive"
	HomePregnancyTestEntryTestResultIndeterminate HomePregnancyTestEntryTestResult = "indeterminate"
)

func NewHomePregnancyTestEntryTestResultFromString(s string) (HomePregnancyTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomePregnancyTestEntryTestResultNegative, nil
	case "positive":
		return HomePregnancyTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomePregnancyTestEntryTestResultIndeterminate, nil
	}
	var t HomePregnancyTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomePregnancyTestEntryTestResult) Ptr() *HomePregnancyTestEntryTestResult {
	return &h
}

type HomeProgesteroneTestEntry struct {
	Date       string                              `json:"date"`
	TestResult HomeProgesteroneTestEntryTestResult `json:"test_result,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HomeProgesteroneTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomeProgesteroneTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomeProgesteroneTestEntry(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomeProgesteroneTestEntry) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HomeProgesteroneTestEntryTestResult string

const (
	HomeProgesteroneTestEntryTestResultNegative      HomeProgesteroneTestEntryTestResult = "negative"
	HomeProgesteroneTestEntryTestResultPositive      HomeProgesteroneTestEntryTestResult = "positive"
	HomeProgesteroneTestEntryTestResultIndeterminate HomeProgesteroneTestEntryTestResult = "indeterminate"
)

func NewHomeProgesteroneTestEntryTestResultFromString(s string) (HomeProgesteroneTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomeProgesteroneTestEntryTestResultNegative, nil
	case "positive":
		return HomeProgesteroneTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomeProgesteroneTestEntryTestResultIndeterminate, nil
	}
	var t HomeProgesteroneTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomeProgesteroneTestEntryTestResult) Ptr() *HomeProgesteroneTestEntryTestResult {
	return &h
}

type HttpValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpValidationError) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type IntermenstrualBleedingEntry struct {
	Date string `json:"date"`

	_rawJSON json.RawMessage
}

func (i *IntermenstrualBleedingEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler IntermenstrualBleedingEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntermenstrualBleedingEntry(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntermenstrualBleedingEntry) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Jpeg struct {
	Content     string `json:"content"`
	contentType string

	_rawJSON json.RawMessage
}

func (j *Jpeg) ContentType() string {
	return j.contentType
}

func (j *Jpeg) UnmarshalJSON(data []byte) error {
	type unmarshaler Jpeg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = Jpeg(value)
	j.contentType = "image/jpeg"
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *Jpeg) MarshalJSON() ([]byte, error) {
	type embed Jpeg
	var marshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed:       embed(*j),
		ContentType: "image/jpeg",
	}
	return json.Marshal(marshaler)
}

func (j *Jpeg) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type LabLocationMetadata struct {
	Name        string                 `json:"name"`
	State       string                 `json:"state"`
	City        string                 `json:"city"`
	ZipCode     string                 `json:"zip_code"`
	FirstLine   string                 `json:"first_line"`
	SecondLine  *string                `json:"second_line,omitempty"`
	PhoneNumber *string                `json:"phone_number,omitempty"`
	FaxNumber   *string                `json:"fax_number,omitempty"`
	Hours       map[string]interface{} `json:"hours,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LabLocationMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LabLocationMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabLocationMetadata(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabLocationMetadata) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsMetadata struct {
	Age            string  `json:"age"`
	Dob            string  `json:"dob"`
	Clia           *string `json:"clia_#,omitempty"`
	Patient        string  `json:"patient"`
	Provider       *string `json:"provider,omitempty"`
	Laboratory     *string `json:"laboratory,omitempty"`
	DateReported   string  `json:"date_reported"`
	DateCollected  *string `json:"date_collected,omitempty"`
	SpecimenNumber string  `json:"specimen_number"`
	DateReceived   *string `json:"date_received,omitempty"`
	Status         *string `json:"status,omitempty"`
	Interpretation *string `json:"interpretation,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LabResultsMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsMetadata(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsMetadata) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRaw struct {
	Metadata *LabResultsMetadata   `json:"metadata,omitempty"`
	Results  *LabResultsRawResults `json:"results,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LabResultsRaw) UnmarshalJSON(data []byte) error {
	type unmarshaler LabResultsRaw
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabResultsRaw(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabResultsRaw) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LabResultsRawResults struct {
	typeName            string
	BiomarkerResultList []*BiomarkerResult
	StringUnknownMap    map[string]interface{}
}

func NewLabResultsRawResultsFromBiomarkerResultList(value []*BiomarkerResult) *LabResultsRawResults {
	return &LabResultsRawResults{typeName: "biomarkerResultList", BiomarkerResultList: value}
}

func NewLabResultsRawResultsFromStringUnknownMap(value map[string]interface{}) *LabResultsRawResults {
	return &LabResultsRawResults{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (l *LabResultsRawResults) UnmarshalJSON(data []byte) error {
	var valueBiomarkerResultList []*BiomarkerResult
	if err := json.Unmarshal(data, &valueBiomarkerResultList); err == nil {
		l.typeName = "biomarkerResultList"
		l.BiomarkerResultList = valueBiomarkerResultList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		l.typeName = "stringUnknownMap"
		l.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LabResultsRawResults) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "biomarkerResultList":
		return json.Marshal(l.BiomarkerResultList)
	case "stringUnknownMap":
		return json.Marshal(l.StringUnknownMap)
	}
}

type LabResultsRawResultsVisitor interface {
	VisitBiomarkerResultList([]*BiomarkerResult) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (l *LabResultsRawResults) Accept(visitor LabResultsRawResultsVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "biomarkerResultList":
		return visitor.VisitBiomarkerResultList(l.BiomarkerResultList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(l.StringUnknownMap)
	}
}

// The method used to perform a lab test.
type LabTestCollectionMethod string

const (
	LabTestCollectionMethodTestkit          LabTestCollectionMethod = "testkit"
	LabTestCollectionMethodWalkInTest       LabTestCollectionMethod = "walk_in_test"
	LabTestCollectionMethodAtHomePhlebotomy LabTestCollectionMethod = "at_home_phlebotomy"
)

func NewLabTestCollectionMethodFromString(s string) (LabTestCollectionMethod, error) {
	switch s {
	case "testkit":
		return LabTestCollectionMethodTestkit, nil
	case "walk_in_test":
		return LabTestCollectionMethodWalkInTest, nil
	case "at_home_phlebotomy":
		return LabTestCollectionMethodAtHomePhlebotomy, nil
	}
	var t LabTestCollectionMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestCollectionMethod) Ptr() *LabTestCollectionMethod {
	return &l
}

// The type of sample used to perform a lab test.
type LabTestSampleType string

const (
	LabTestSampleTypeDriedBloodSpot LabTestSampleType = "dried_blood_spot"
	LabTestSampleTypeSerum          LabTestSampleType = "serum"
	LabTestSampleTypeSaliva         LabTestSampleType = "saliva"
	LabTestSampleTypeUrine          LabTestSampleType = "urine"
)

func NewLabTestSampleTypeFromString(s string) (LabTestSampleType, error) {
	switch s {
	case "dried_blood_spot":
		return LabTestSampleTypeDriedBloodSpot, nil
	case "serum":
		return LabTestSampleTypeSerum, nil
	case "saliva":
		return LabTestSampleTypeSaliva, nil
	case "urine":
		return LabTestSampleTypeUrine, nil
	}
	var t LabTestSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestSampleType) Ptr() *LabTestSampleType {
	return &l
}

type LabTestStatus string

const (
	LabTestStatusActive          LabTestStatus = "active"
	LabTestStatusPendingApproval LabTestStatus = "pending_approval"
	LabTestStatusInactive        LabTestStatus = "inactive"
)

func NewLabTestStatusFromString(s string) (LabTestStatus, error) {
	switch s {
	case "active":
		return LabTestStatusActive, nil
	case "pending_approval":
		return LabTestStatusPendingApproval, nil
	case "inactive":
		return LabTestStatusInactive, nil
	}
	var t LabTestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestStatus) Ptr() *LabTestStatus {
	return &l
}

type Labs string

const (
	LabsAyumetrix    Labs = "ayumetrix"
	LabsSpiriplex    Labs = "spiriplex"
	LabsUssl         Labs = "ussl"
	LabsQuest        Labs = "quest"
	LabsLabcorp      Labs = "labcorp"
	LabsBioreference Labs = "bioreference"
	LabsManual       Labs = "manual"
)

func NewLabsFromString(s string) (Labs, error) {
	switch s {
	case "ayumetrix":
		return LabsAyumetrix, nil
	case "spiriplex":
		return LabsSpiriplex, nil
	case "ussl":
		return LabsUssl, nil
	case "quest":
		return LabsQuest, nil
	case "labcorp":
		return LabsLabcorp, nil
	case "bioreference":
		return LabsBioreference, nil
	case "manual":
		return LabsManual, nil
	}
	var t Labs
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l Labs) Ptr() *Labs {
	return &l
}

type LastAttempt struct {
	Timestamp time.Time     `json:"timestamp"`
	Status    AttemptStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LastAttempt) UnmarshalJSON(data []byte) error {
	type unmarshaler LastAttempt
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LastAttempt(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LastAttempt) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LibreConfig struct {
	PracticeId map[string]interface{} `json:"practice_id,omitempty"`
	StripTz    *bool                  `json:"strip_tz,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LibreConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LibreConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LibreConfig(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LibreConfig) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LinkTokenExchangeResponse struct {
	// A short-lived Vital Link token for your Custom Link Widget to communicate with the Vital API.
	LinkToken string `json:"link_token"`
	// The web browser link to launch the default Vital Link experience. If you requested the token for one specific provider, the link would redirect directly to the provider authentication flow. Otherwise, the user would be presented with a list of providers based on your team and token configurations.
	LinkWebUrl string `json:"link_web_url"`

	_rawJSON json.RawMessage
}

func (l *LinkTokenExchangeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkTokenExchangeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkTokenExchangeResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkTokenExchangeResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LngLat struct {
	Lng float64 `json:"lng"`
	Lat float64 `json:"lat"`

	_rawJSON json.RawMessage
}

func (l *LngLat) UnmarshalJSON(data []byte) error {
	type unmarshaler LngLat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LngLat(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LngLat) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Macros struct {
	Carbs   *float64 `json:"carbs,omitempty"`
	Protein *float64 `json:"protein,omitempty"`
	// Details of fat content
	Fats    *Fats    `json:"fats,omitempty"`
	Alcohol *float64 `json:"alcohol,omitempty"`
	Water   *float64 `json:"water,omitempty"`
	Fibre   *float64 `json:"fibre,omitempty"`
	Sugar   *float64 `json:"sugar,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Macros) UnmarshalJSON(data []byte) error {
	type unmarshaler Macros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Macros(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Macros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ManualProviders string

const (
	ManualProvidersBeurerBle         ManualProviders = "beurer_ble"
	ManualProvidersOmronBle          ManualProviders = "omron_ble"
	ManualProvidersAccuchekBle       ManualProviders = "accuchek_ble"
	ManualProvidersContourBle        ManualProviders = "contour_ble"
	ManualProvidersFreestyleLibreBle ManualProviders = "freestyle_libre_ble"
	ManualProvidersOnetouchBle       ManualProviders = "onetouch_ble"
	ManualProvidersAppleHealthKit    ManualProviders = "apple_health_kit"
	ManualProvidersManual            ManualProviders = "manual"
	ManualProvidersHealthConnect     ManualProviders = "health_connect"
)

func NewManualProvidersFromString(s string) (ManualProviders, error) {
	switch s {
	case "beurer_ble":
		return ManualProvidersBeurerBle, nil
	case "omron_ble":
		return ManualProvidersOmronBle, nil
	case "accuchek_ble":
		return ManualProvidersAccuchekBle, nil
	case "contour_ble":
		return ManualProvidersContourBle, nil
	case "freestyle_libre_ble":
		return ManualProvidersFreestyleLibreBle, nil
	case "onetouch_ble":
		return ManualProvidersOnetouchBle, nil
	case "apple_health_kit":
		return ManualProvidersAppleHealthKit, nil
	case "manual":
		return ManualProvidersManual, nil
	case "health_connect":
		return ManualProvidersHealthConnect, nil
	}
	var t ManualProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManualProviders) Ptr() *ManualProviders {
	return &m
}

type MarkerType string

const (
	MarkerTypeBiomarker MarkerType = "biomarker"
	MarkerTypePanel     MarkerType = "panel"
)

func NewMarkerTypeFromString(s string) (MarkerType, error) {
	switch s {
	case "biomarker":
		return MarkerTypeBiomarker, nil
	case "panel":
		return MarkerTypePanel, nil
	}
	var t MarkerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MarkerType) Ptr() *MarkerType {
	return &m
}

type MealInDbBaseClientFacingSource struct {
	Id         string                       `json:"id"`
	UserId     string                       `json:"user_id"`
	PriorityId int                          `json:"priority_id"`
	SourceId   int                          `json:"source_id"`
	ProviderId string                       `json:"provider_id"`
	Timestamp  time.Time                    `json:"timestamp"`
	Name       string                       `json:"name"`
	Energy     *Energy                      `json:"energy,omitempty"`
	Macros     *Macros                      `json:"macros,omitempty"`
	Micros     *Micros                      `json:"micros,omitempty"`
	Data       map[string]*ClientFacingFood `json:"data,omitempty"`
	Source     *ClientFacingSource          `json:"source,omitempty"`
	CreatedAt  time.Time                    `json:"created_at"`
	UpdatedAt  time.Time                    `json:"updated_at"`

	_rawJSON json.RawMessage
}

func (m *MealInDbBaseClientFacingSource) UnmarshalJSON(data []byte) error {
	type unmarshaler MealInDbBaseClientFacingSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MealInDbBaseClientFacingSource(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MealInDbBaseClientFacingSource) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualCycle struct {
	PeriodStart            string                         `json:"period_start"`
	PeriodEnd              *string                        `json:"period_end,omitempty"`
	CycleEnd               *string                        `json:"cycle_end,omitempty"`
	IsPredicted            *bool                          `json:"is_predicted,omitempty"`
	MenstrualFlow          []*MenstrualFlowEntry          `json:"menstrual_flow,omitempty"`
	CervicalMucus          []*CervicalMucusEntry          `json:"cervical_mucus,omitempty"`
	IntermenstrualBleeding []*IntermenstrualBleedingEntry `json:"intermenstrual_bleeding,omitempty"`
	Contraceptive          []*ContraceptiveEntry          `json:"contraceptive,omitempty"`
	DetectedDeviations     []*DetectedDeviationEntry      `json:"detected_deviations,omitempty"`
	OvulationTest          []*OvulationTestEntry          `json:"ovulation_test,omitempty"`
	HomePregnancyTest      []*HomePregnancyTestEntry      `json:"home_pregnancy_test,omitempty"`
	HomeProgesteroneTest   []*HomeProgesteroneTestEntry   `json:"home_progesterone_test,omitempty"`
	SexualActivity         []*SexualActivityEntry         `json:"sexual_activity,omitempty"`
	BasalBodyTemperature   []*BasalBodyTemperatureEntry   `json:"basal_body_temperature,omitempty"`
	Source                 *ClientFacingSource            `json:"source,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MenstrualCycle) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualCycle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualCycle(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualCycle) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualCycleResponse struct {
	MenstrualCycle []*MenstrualCycle `json:"menstrual_cycle,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MenstrualCycleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualCycleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualCycleResponse(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualCycleResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualFlowEntry struct {
	Date string                 `json:"date"`
	Flow MenstrualFlowEntryFlow `json:"flow,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MenstrualFlowEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualFlowEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualFlowEntry(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualFlowEntry) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MenstrualFlowEntryFlow string

const (
	MenstrualFlowEntryFlowUnspecified MenstrualFlowEntryFlow = "unspecified"
	MenstrualFlowEntryFlowNone        MenstrualFlowEntryFlow = "none"
	MenstrualFlowEntryFlowLight       MenstrualFlowEntryFlow = "light"
	MenstrualFlowEntryFlowMedium      MenstrualFlowEntryFlow = "medium"
	MenstrualFlowEntryFlowHeavy       MenstrualFlowEntryFlow = "heavy"
)

func NewMenstrualFlowEntryFlowFromString(s string) (MenstrualFlowEntryFlow, error) {
	switch s {
	case "unspecified":
		return MenstrualFlowEntryFlowUnspecified, nil
	case "none":
		return MenstrualFlowEntryFlowNone, nil
	case "light":
		return MenstrualFlowEntryFlowLight, nil
	case "medium":
		return MenstrualFlowEntryFlowMedium, nil
	case "heavy":
		return MenstrualFlowEntryFlowHeavy, nil
	}
	var t MenstrualFlowEntryFlow
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MenstrualFlowEntryFlow) Ptr() *MenstrualFlowEntryFlow {
	return &m
}

type MetricsResult struct {
	TeamId                          string                   `json:"team_id"`
	NumberOfConnectedSources        *int                     `json:"number_of_connected_sources,omitempty"`
	NumberOfUsers                   *int                     `json:"number_of_users,omitempty"`
	NumberOfErroredConnectedSources *int                     `json:"number_of_errored_connected_sources,omitempty"`
	NumberOfConnectedSourcesByWeek  []*TimeseriesMetricPoint `json:"number_of_connected_sources_by_week,omitempty"`
	NumberOfOrderedTests            *int                     `json:"number_of_ordered_tests,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MetricsResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsResult(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsResult) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Micros struct {
	Minerals      map[string]*float64 `json:"minerals,omitempty"`
	TraceElements map[string]*float64 `json:"trace_elements,omitempty"`
	Vitamins      map[string]*float64 `json:"vitamins,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Micros) UnmarshalJSON(data []byte) error {
	type unmarshaler Micros
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Micros(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Micros) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OAuthProviders string

const (
	OAuthProvidersOura       OAuthProviders = "oura"
	OAuthProvidersFitbit     OAuthProviders = "fitbit"
	OAuthProvidersGarmin     OAuthProviders = "garmin"
	OAuthProvidersStrava     OAuthProviders = "strava"
	OAuthProvidersWahoo      OAuthProviders = "wahoo"
	OAuthProvidersIhealth    OAuthProviders = "ihealth"
	OAuthProvidersWithings   OAuthProviders = "withings"
	OAuthProvidersGoogleFit  OAuthProviders = "google_fit"
	OAuthProvidersDexcomV3   OAuthProviders = "dexcom_v3"
	OAuthProvidersPolar      OAuthProviders = "polar"
	OAuthProvidersCronometer OAuthProviders = "cronometer"
	OAuthProvidersOmron      OAuthProviders = "omron"
	OAuthProvidersWhoopV2    OAuthProviders = "whoop_v2"
)

func NewOAuthProvidersFromString(s string) (OAuthProviders, error) {
	switch s {
	case "oura":
		return OAuthProvidersOura, nil
	case "fitbit":
		return OAuthProvidersFitbit, nil
	case "garmin":
		return OAuthProvidersGarmin, nil
	case "strava":
		return OAuthProvidersStrava, nil
	case "wahoo":
		return OAuthProvidersWahoo, nil
	case "ihealth":
		return OAuthProvidersIhealth, nil
	case "withings":
		return OAuthProvidersWithings, nil
	case "google_fit":
		return OAuthProvidersGoogleFit, nil
	case "dexcom_v3":
		return OAuthProvidersDexcomV3, nil
	case "polar":
		return OAuthProvidersPolar, nil
	case "cronometer":
		return OAuthProvidersCronometer, nil
	case "omron":
		return OAuthProvidersOmron, nil
	case "whoop_v2":
		return OAuthProvidersWhoopV2, nil
	}
	var t OAuthProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OAuthProviders) Ptr() *OAuthProviders {
	return &o
}

type OrderStatus string

const (
	OrderStatusReceivedWalkInTestOrdered                            OrderStatus = "received.walk_in_test.ordered"
	OrderStatusReceivedWalkInTestRequisitionCreated                 OrderStatus = "received.walk_in_test.requisition_created"
	OrderStatusCompletedWalkInTestCompleted                         OrderStatus = "completed.walk_in_test.completed"
	OrderStatusSampleWithLabWalkInTestPartialResults                OrderStatus = "sample_with_lab.walk_in_test.partial_results"
	OrderStatusFailedWalkInTestSampleError                          OrderStatus = "failed.walk_in_test.sample_error"
	OrderStatusCancelledWalkInTestCancelled                         OrderStatus = "cancelled.walk_in_test.cancelled"
	OrderStatusReceivedAtHomePhlebotomyOrdered                      OrderStatus = "received.at_home_phlebotomy.ordered"
	OrderStatusReceivedAtHomePhlebotomyRequisitionCreated           OrderStatus = "received.at_home_phlebotomy.requisition_created"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentPending   OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_pending"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_scheduled"
	OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted        OrderStatus = "collecting_sample.at_home_phlebotomy.draw_completed"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_cancelled"
	OrderStatusCompletedAtHomePhlebotomyCompleted                   OrderStatus = "completed.at_home_phlebotomy.completed"
	OrderStatusSampleWithLabAtHomePhlebotomyPartialResults          OrderStatus = "sample_with_lab.at_home_phlebotomy.partial_results"
	OrderStatusCancelledAtHomePhlebotomyCancelled                   OrderStatus = "cancelled.at_home_phlebotomy.cancelled"
	OrderStatusFailedAtHomePhlebotomySampleError                    OrderStatus = "failed.at_home_phlebotomy.sample_error"
	OrderStatusReceivedTestkitOrdered                               OrderStatus = "received.testkit.ordered"
	OrderStatusReceivedTestkitAwaitingRegistration                  OrderStatus = "received.testkit.awaiting_registration"
	OrderStatusReceivedTestkitRequisitionCreated                    OrderStatus = "received.testkit.requisition_created"
	OrderStatusReceivedTestkitRegistered                            OrderStatus = "received.testkit.registered"
	OrderStatusCollectingSampleTestkitTransitCustomer               OrderStatus = "collecting_sample.testkit.transit_customer"
	OrderStatusCollectingSampleTestkitOutForDelivery                OrderStatus = "collecting_sample.testkit.out_for_delivery"
	OrderStatusCollectingSampleTestkitWithCustomer                  OrderStatus = "collecting_sample.testkit.with_customer"
	OrderStatusCollectingSampleTestkitTransitLab                    OrderStatus = "collecting_sample.testkit.transit_lab"
	OrderStatusSampleWithLabTestkitDeliveredToLab                   OrderStatus = "sample_with_lab.testkit.delivered_to_lab"
	OrderStatusCompletedTestkitCompleted                            OrderStatus = "completed.testkit.completed"
	OrderStatusFailedTestkitFailureToDeliverToCustomer              OrderStatus = "failed.testkit.failure_to_deliver_to_customer"
	OrderStatusFailedTestkitFailureToDeliverToLab                   OrderStatus = "failed.testkit.failure_to_deliver_to_lab"
	OrderStatusFailedTestkitSampleError                             OrderStatus = "failed.testkit.sample_error"
	OrderStatusFailedTestkitLost                                    OrderStatus = "failed.testkit.lost"
	OrderStatusCancelledTestkitCancelled                            OrderStatus = "cancelled.testkit.cancelled"
	OrderStatusCancelledTestkitDoNotProcess                         OrderStatus = "cancelled.testkit.do_not_process"
)

func NewOrderStatusFromString(s string) (OrderStatus, error) {
	switch s {
	case "received.walk_in_test.ordered":
		return OrderStatusReceivedWalkInTestOrdered, nil
	case "received.walk_in_test.requisition_created":
		return OrderStatusReceivedWalkInTestRequisitionCreated, nil
	case "completed.walk_in_test.completed":
		return OrderStatusCompletedWalkInTestCompleted, nil
	case "sample_with_lab.walk_in_test.partial_results":
		return OrderStatusSampleWithLabWalkInTestPartialResults, nil
	case "failed.walk_in_test.sample_error":
		return OrderStatusFailedWalkInTestSampleError, nil
	case "cancelled.walk_in_test.cancelled":
		return OrderStatusCancelledWalkInTestCancelled, nil
	case "received.at_home_phlebotomy.ordered":
		return OrderStatusReceivedAtHomePhlebotomyOrdered, nil
	case "received.at_home_phlebotomy.requisition_created":
		return OrderStatusReceivedAtHomePhlebotomyRequisitionCreated, nil
	case "collecting_sample.at_home_phlebotomy.appointment_pending":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentPending, nil
	case "collecting_sample.at_home_phlebotomy.appointment_scheduled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled, nil
	case "collecting_sample.at_home_phlebotomy.draw_completed":
		return OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted, nil
	case "collecting_sample.at_home_phlebotomy.appointment_cancelled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled, nil
	case "completed.at_home_phlebotomy.completed":
		return OrderStatusCompletedAtHomePhlebotomyCompleted, nil
	case "sample_with_lab.at_home_phlebotomy.partial_results":
		return OrderStatusSampleWithLabAtHomePhlebotomyPartialResults, nil
	case "cancelled.at_home_phlebotomy.cancelled":
		return OrderStatusCancelledAtHomePhlebotomyCancelled, nil
	case "failed.at_home_phlebotomy.sample_error":
		return OrderStatusFailedAtHomePhlebotomySampleError, nil
	case "received.testkit.ordered":
		return OrderStatusReceivedTestkitOrdered, nil
	case "received.testkit.awaiting_registration":
		return OrderStatusReceivedTestkitAwaitingRegistration, nil
	case "received.testkit.requisition_created":
		return OrderStatusReceivedTestkitRequisitionCreated, nil
	case "received.testkit.registered":
		return OrderStatusReceivedTestkitRegistered, nil
	case "collecting_sample.testkit.transit_customer":
		return OrderStatusCollectingSampleTestkitTransitCustomer, nil
	case "collecting_sample.testkit.out_for_delivery":
		return OrderStatusCollectingSampleTestkitOutForDelivery, nil
	case "collecting_sample.testkit.with_customer":
		return OrderStatusCollectingSampleTestkitWithCustomer, nil
	case "collecting_sample.testkit.transit_lab":
		return OrderStatusCollectingSampleTestkitTransitLab, nil
	case "sample_with_lab.testkit.delivered_to_lab":
		return OrderStatusSampleWithLabTestkitDeliveredToLab, nil
	case "completed.testkit.completed":
		return OrderStatusCompletedTestkitCompleted, nil
	case "failed.testkit.failure_to_deliver_to_customer":
		return OrderStatusFailedTestkitFailureToDeliverToCustomer, nil
	case "failed.testkit.failure_to_deliver_to_lab":
		return OrderStatusFailedTestkitFailureToDeliverToLab, nil
	case "failed.testkit.sample_error":
		return OrderStatusFailedTestkitSampleError, nil
	case "failed.testkit.lost":
		return OrderStatusFailedTestkitLost, nil
	case "cancelled.testkit.cancelled":
		return OrderStatusCancelledTestkitCancelled, nil
	case "cancelled.testkit.do_not_process":
		return OrderStatusCancelledTestkitDoNotProcess, nil
	}
	var t OrderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderStatus) Ptr() *OrderStatus {
	return &o
}

type OrderTopLevelStatus string

const (
	OrderTopLevelStatusReceived         OrderTopLevelStatus = "received"
	OrderTopLevelStatusCollectingSample OrderTopLevelStatus = "collecting_sample"
	OrderTopLevelStatusSampleWithLab    OrderTopLevelStatus = "sample_with_lab"
	OrderTopLevelStatusCompleted        OrderTopLevelStatus = "completed"
	OrderTopLevelStatusCancelled        OrderTopLevelStatus = "cancelled"
	OrderTopLevelStatusFailed           OrderTopLevelStatus = "failed"
)

func NewOrderTopLevelStatusFromString(s string) (OrderTopLevelStatus, error) {
	switch s {
	case "received":
		return OrderTopLevelStatusReceived, nil
	case "collecting_sample":
		return OrderTopLevelStatusCollectingSample, nil
	case "sample_with_lab":
		return OrderTopLevelStatusSampleWithLab, nil
	case "completed":
		return OrderTopLevelStatusCompleted, nil
	case "cancelled":
		return OrderTopLevelStatusCancelled, nil
	case "failed":
		return OrderTopLevelStatusFailed, nil
	}
	var t OrderTopLevelStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderTopLevelStatus) Ptr() *OrderTopLevelStatus {
	return &o
}

type OvulationTestEntry struct {
	Date       string                       `json:"date"`
	TestResult OvulationTestEntryTestResult `json:"test_result,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OvulationTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OvulationTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OvulationTestEntry(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OvulationTestEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OvulationTestEntryTestResult string

const (
	OvulationTestEntryTestResultNegative                OvulationTestEntryTestResult = "negative"
	OvulationTestEntryTestResultPositive                OvulationTestEntryTestResult = "positive"
	OvulationTestEntryTestResultLuteinizingHormoneSurge OvulationTestEntryTestResult = "luteinizing_hormone_surge"
	OvulationTestEntryTestResultEstrogenSurge           OvulationTestEntryTestResult = "estrogen_surge"
	OvulationTestEntryTestResultIndeterminate           OvulationTestEntryTestResult = "indeterminate"
)

func NewOvulationTestEntryTestResultFromString(s string) (OvulationTestEntryTestResult, error) {
	switch s {
	case "negative":
		return OvulationTestEntryTestResultNegative, nil
	case "positive":
		return OvulationTestEntryTestResultPositive, nil
	case "luteinizing_hormone_surge":
		return OvulationTestEntryTestResultLuteinizingHormoneSurge, nil
	case "estrogen_surge":
		return OvulationTestEntryTestResultEstrogenSurge, nil
	case "indeterminate":
		return OvulationTestEntryTestResultIndeterminate, nil
	}
	var t OvulationTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OvulationTestEntryTestResult) Ptr() *OvulationTestEntryTestResult {
	return &o
}

type PaginatedUsersResponse struct {
	Users  []*ClientFacingUser `json:"users,omitempty"`
	Total  int                 `json:"total"`
	Offset int                 `json:"offset"`
	Limit  int                 `json:"limit"`

	_rawJSON json.RawMessage
}

func (p *PaginatedUsersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedUsersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedUsersResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedUsersResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PasswordProviders string

const (
	PasswordProvidersWhoop           PasswordProviders = "whoop"
	PasswordProvidersRenpho          PasswordProviders = "renpho"
	PasswordProvidersPeloton         PasswordProviders = "peloton"
	PasswordProvidersZwift           PasswordProviders = "zwift"
	PasswordProvidersEightSleep      PasswordProviders = "eight_sleep"
	PasswordProvidersBeurerApi       PasswordProviders = "beurer_api"
	PasswordProvidersDexcom          PasswordProviders = "dexcom"
	PasswordProvidersHammerhead      PasswordProviders = "hammerhead"
	PasswordProvidersMyFitnessPal    PasswordProviders = "my_fitness_pal"
	PasswordProvidersKardia          PasswordProviders = "kardia"
	PasswordProvidersAbbottLibreview PasswordProviders = "abbott_libreview"
)

func NewPasswordProvidersFromString(s string) (PasswordProviders, error) {
	switch s {
	case "whoop":
		return PasswordProvidersWhoop, nil
	case "renpho":
		return PasswordProvidersRenpho, nil
	case "peloton":
		return PasswordProvidersPeloton, nil
	case "zwift":
		return PasswordProvidersZwift, nil
	case "eight_sleep":
		return PasswordProvidersEightSleep, nil
	case "beurer_api":
		return PasswordProvidersBeurerApi, nil
	case "dexcom":
		return PasswordProvidersDexcom, nil
	case "hammerhead":
		return PasswordProvidersHammerhead, nil
	case "my_fitness_pal":
		return PasswordProvidersMyFitnessPal, nil
	case "kardia":
		return PasswordProvidersKardia, nil
	case "abbott_libreview":
		return PasswordProvidersAbbottLibreview, nil
	}
	var t PasswordProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PasswordProviders) Ptr() *PasswordProviders {
	return &p
}

type PatientAddressCompatible struct {
	ReceiverName *string `json:"receiver_name,omitempty"`
	FirstLine    string  `json:"first_line"`
	SecondLine   *string `json:"second_line,omitempty"`
	City         string  `json:"city"`
	State        string  `json:"state"`
	Zip          string  `json:"zip"`
	Country      string  `json:"country"`
	PhoneNumber  *string `json:"phone_number,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatientAddressCompatible) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientAddressCompatible
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientAddressCompatible(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientAddressCompatible) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatientDetails struct {
	FirstName   string    `json:"first_name"`
	LastName    string    `json:"last_name"`
	Dob         time.Time `json:"dob"`
	Gender      Gender    `json:"gender,omitempty"`
	PhoneNumber string    `json:"phone_number"`
	Email       string    `json:"email"`

	_rawJSON json.RawMessage
}

func (p *PatientDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PatientDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatientDetails(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatientDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Period struct {
	Value *int         `json:"value,omitempty"`
	Unit  DateTimeUnit `json:"unit,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Period) UnmarshalJSON(data []byte) error {
	type unmarshaler Period
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Period(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Period) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PersonDetailsOutput struct {
	FirstName   string   `json:"first_name"`
	LastName    string   `json:"last_name"`
	Gender      Gender   `json:"gender,omitempty"`
	Address     *Address `json:"address,omitempty"`
	Dob         string   `json:"dob"`
	Email       string   `json:"email"`
	PhoneNumber string   `json:"phone_number"`

	_rawJSON json.RawMessage
}

func (p *PersonDetailsOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler PersonDetailsOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PersonDetailsOutput(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PersonDetailsOutput) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhlebotomyAreaInfo struct {
	IsServed  bool                      `json:"is_served"`
	Providers []*PhlebotomyProviderInfo `json:"providers,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PhlebotomyAreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhlebotomyAreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhlebotomyAreaInfo(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhlebotomyAreaInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhlebotomyProviderInfo struct {
	Name         AppointmentProvider      `json:"name,omitempty"`
	ServiceTypes []AppointmentServiceType `json:"service_types,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PhlebotomyProviderInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PhlebotomyProviderInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhlebotomyProviderInfo(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhlebotomyProviderInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequest struct {
	FirstName      string   `json:"first_name"`
	LastName       string   `json:"last_name"`
	Email          *string  `json:"email,omitempty"`
	Npi            string   `json:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty"`
	// An image of the physician signature for health insurance billing
	SignatureImage *PhysicianCreateRequestSignatureImage `json:"signature_image,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PhysicianCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PhysicianCreateRequestBase struct {
	FirstName      string   `json:"first_name"`
	LastName       string   `json:"last_name"`
	Email          *string  `json:"email,omitempty"`
	Npi            string   `json:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PhysicianCreateRequestBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PhysicianCreateRequestBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhysicianCreateRequestBase(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhysicianCreateRequestBase) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An image of the physician signature for health insurance billing
type PhysicianCreateRequestSignatureImage struct {
	typeName string
	Jpeg     *Jpeg
	Png      *Png
}

func NewPhysicianCreateRequestSignatureImageFromJpeg(value *Jpeg) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{typeName: "jpeg", Jpeg: value}
}

func NewPhysicianCreateRequestSignatureImageFromPng(value *Png) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{typeName: "png", Png: value}
}

func (p *PhysicianCreateRequestSignatureImage) UnmarshalJSON(data []byte) error {
	valueJpeg := new(Jpeg)
	if err := json.Unmarshal(data, &valueJpeg); err == nil {
		p.typeName = "jpeg"
		p.Jpeg = valueJpeg
		return nil
	}
	valuePng := new(Png)
	if err := json.Unmarshal(data, &valuePng); err == nil {
		p.typeName = "png"
		p.Png = valuePng
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PhysicianCreateRequestSignatureImage) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "jpeg":
		return json.Marshal(p.Jpeg)
	case "png":
		return json.Marshal(p.Png)
	}
}

type PhysicianCreateRequestSignatureImageVisitor interface {
	VisitJpeg(*Jpeg) error
	VisitPng(*Png) error
}

func (p *PhysicianCreateRequestSignatureImage) Accept(visitor PhysicianCreateRequestSignatureImageVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "jpeg":
		return visitor.VisitJpeg(p.Jpeg)
	case "png":
		return visitor.VisitPng(p.Png)
	}
}

type Png struct {
	Content     string `json:"content"`
	contentType string

	_rawJSON json.RawMessage
}

func (p *Png) ContentType() string {
	return p.contentType
}

func (p *Png) UnmarshalJSON(data []byte) error {
	type unmarshaler Png
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Png(value)
	p.contentType = "image/png"
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Png) MarshalJSON() ([]byte, error) {
	type embed Png
	var marshaler = struct {
		embed
		ContentType string `json:"content_type"`
	}{
		embed:       embed(*p),
		ContentType: "image/png",
	}
	return json.Marshal(marshaler)
}

func (p *Png) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostOrderResponse struct {
	Order   *ClientFacingOrder `json:"order,omitempty"`
	Status  string             `json:"status"`
	Message string             `json:"message"`

	_rawJSON json.RawMessage
}

func (p *PostOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostOrderResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostOrderResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileInDb struct {
	Data       interface{}           `json:"data,omitempty"`
	UserId     string                `json:"user_id"`
	SourceId   int                   `json:"source_id"`
	PriorityId *int                  `json:"priority_id,omitempty"`
	Id         string                `json:"id"`
	Source     *ClientFacingProvider `json:"source,omitempty"`
	UpdatedAt  *time.Time            `json:"updated_at,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ProfileInDb) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileInDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileInDb(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileInDb) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderLinkResponse struct {
	State       ProviderLinkResponseState `json:"state,omitempty"`
	RedirectUrl *string                   `json:"redirect_url,omitempty"`
	ErrorType   *string                   `json:"error_type,omitempty"`
	Error       *string                   `json:"error,omitempty"`
	ProviderMfa *ProviderMfaRequest       `json:"provider_mfa,omitempty"`
	Provider    PasswordProviders         `json:"provider,omitempty"`
	Connected   bool                      `json:"connected"`
	ProviderId  *string                   `json:"provider_id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ProviderLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderLinkResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderLinkResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderLinkResponseState string

const (
	ProviderLinkResponseStateSuccess            ProviderLinkResponseState = "success"
	ProviderLinkResponseStateError              ProviderLinkResponseState = "error"
	ProviderLinkResponseStatePendingProviderMfa ProviderLinkResponseState = "pending_provider_mfa"
)

func NewProviderLinkResponseStateFromString(s string) (ProviderLinkResponseState, error) {
	switch s {
	case "success":
		return ProviderLinkResponseStateSuccess, nil
	case "error":
		return ProviderLinkResponseStateError, nil
	case "pending_provider_mfa":
		return ProviderLinkResponseStatePendingProviderMfa, nil
	}
	var t ProviderLinkResponseState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderLinkResponseState) Ptr() *ProviderLinkResponseState {
	return &p
}

type ProviderMfaRequest struct {
	Method ProviderMfaRequestMethod `json:"method,omitempty"`
	Hint   string                   `json:"hint"`

	_rawJSON json.RawMessage
}

func (p *ProviderMfaRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderMfaRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderMfaRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProviderMfaRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderMfaRequestMethod string

const (
	ProviderMfaRequestMethodSms   ProviderMfaRequestMethod = "sms"
	ProviderMfaRequestMethodEmail ProviderMfaRequestMethod = "email"
)

func NewProviderMfaRequestMethodFromString(s string) (ProviderMfaRequestMethod, error) {
	switch s {
	case "sms":
		return ProviderMfaRequestMethodSms, nil
	case "email":
		return ProviderMfaRequestMethodEmail, nil
	}
	var t ProviderMfaRequestMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderMfaRequestMethod) Ptr() *ProviderMfaRequestMethod {
	return &p
}

type Providers string

const (
	ProvidersOura              Providers = "oura"
	ProvidersFitbit            Providers = "fitbit"
	ProvidersGarmin            Providers = "garmin"
	ProvidersWhoop             Providers = "whoop"
	ProvidersStrava            Providers = "strava"
	ProvidersRenpho            Providers = "renpho"
	ProvidersPeloton           Providers = "peloton"
	ProvidersWahoo             Providers = "wahoo"
	ProvidersZwift             Providers = "zwift"
	ProvidersFreestyleLibre    Providers = "freestyle_libre"
	ProvidersAbbottLibreview   Providers = "abbott_libreview"
	ProvidersFreestyleLibreBle Providers = "freestyle_libre_ble"
	ProvidersEightSleep        Providers = "eight_sleep"
	ProvidersWithings          Providers = "withings"
	ProvidersAppleHealthKit    Providers = "apple_health_kit"
	ProvidersManual            Providers = "manual"
	ProvidersIhealth           Providers = "ihealth"
	ProvidersGoogleFit         Providers = "google_fit"
	ProvidersBeurerApi         Providers = "beurer_api"
	ProvidersBeurerBle         Providers = "beurer_ble"
	ProvidersOmron             Providers = "omron"
	ProvidersOmronBle          Providers = "omron_ble"
	ProvidersOnetouchBle       Providers = "onetouch_ble"
	ProvidersAccuchekBle       Providers = "accuchek_ble"
	ProvidersContourBle        Providers = "contour_ble"
	ProvidersDexcom            Providers = "dexcom"
	ProvidersDexcomV3          Providers = "dexcom_v3"
	ProvidersHammerhead        Providers = "hammerhead"
	ProvidersMyFitnessPal      Providers = "my_fitness_pal"
	ProvidersHealthConnect     Providers = "health_connect"
	ProvidersPolar             Providers = "polar"
	ProvidersCronometer        Providers = "cronometer"
	ProvidersKardia            Providers = "kardia"
	ProvidersWhoopV2           Providers = "whoop_v2"
)

func NewProvidersFromString(s string) (Providers, error) {
	switch s {
	case "oura":
		return ProvidersOura, nil
	case "fitbit":
		return ProvidersFitbit, nil
	case "garmin":
		return ProvidersGarmin, nil
	case "whoop":
		return ProvidersWhoop, nil
	case "strava":
		return ProvidersStrava, nil
	case "renpho":
		return ProvidersRenpho, nil
	case "peloton":
		return ProvidersPeloton, nil
	case "wahoo":
		return ProvidersWahoo, nil
	case "zwift":
		return ProvidersZwift, nil
	case "freestyle_libre":
		return ProvidersFreestyleLibre, nil
	case "abbott_libreview":
		return ProvidersAbbottLibreview, nil
	case "freestyle_libre_ble":
		return ProvidersFreestyleLibreBle, nil
	case "eight_sleep":
		return ProvidersEightSleep, nil
	case "withings":
		return ProvidersWithings, nil
	case "apple_health_kit":
		return ProvidersAppleHealthKit, nil
	case "manual":
		return ProvidersManual, nil
	case "ihealth":
		return ProvidersIhealth, nil
	case "google_fit":
		return ProvidersGoogleFit, nil
	case "beurer_api":
		return ProvidersBeurerApi, nil
	case "beurer_ble":
		return ProvidersBeurerBle, nil
	case "omron":
		return ProvidersOmron, nil
	case "omron_ble":
		return ProvidersOmronBle, nil
	case "onetouch_ble":
		return ProvidersOnetouchBle, nil
	case "accuchek_ble":
		return ProvidersAccuchekBle, nil
	case "contour_ble":
		return ProvidersContourBle, nil
	case "dexcom":
		return ProvidersDexcom, nil
	case "dexcom_v3":
		return ProvidersDexcomV3, nil
	case "hammerhead":
		return ProvidersHammerhead, nil
	case "my_fitness_pal":
		return ProvidersMyFitnessPal, nil
	case "health_connect":
		return ProvidersHealthConnect, nil
	case "polar":
		return ProvidersPolar, nil
	case "cronometer":
		return ProvidersCronometer, nil
	case "kardia":
		return ProvidersKardia, nil
	case "whoop_v2":
		return ProvidersWhoopV2, nil
	}
	var t Providers
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Providers) Ptr() *Providers {
	return &p
}

type PscAreaInfo struct {
	PatientServiceCenters *PscAreaInfoDetails `json:"patient_service_centers,omitempty"`
	SupportedBillTypes    []Billing           `json:"supported_bill_types,omitempty"`
	LabId                 int                 `json:"lab_id"`

	_rawJSON json.RawMessage
}

func (p *PscAreaInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PscAreaInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscAreaInfo(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscAreaInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PscAreaInfoDetails struct {
	WithinRadius int    `json:"within_radius"`
	Radius       string `json:"radius"`

	_rawJSON json.RawMessage
}

func (p *PscAreaInfoDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PscAreaInfoDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscAreaInfoDetails(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscAreaInfoDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PscInfo struct {
	LabId                 int                        `json:"lab_id"`
	Slug                  Labs                       `json:"slug,omitempty"`
	PatientServiceCenters []*ClientFacingLabLocation `json:"patient_service_centers,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PscInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PscInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PscInfo(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PscInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type QueryConfig struct {
	WeekStartsOn              *QueryConfigWeekStartsOn                    `json:"week_starts_on,omitempty"`
	ProviderPriorityOverrides []*QueryConfigProviderPriorityOverridesItem `json:"provider_priority_overrides,omitempty"`

	_rawJSON json.RawMessage
}

func (q *QueryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryConfig(value)
	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryConfig) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryConfigProviderPriorityOverridesItem struct {
	typeName  string
	Providers Providers
	Labs      Labs
}

func NewQueryConfigProviderPriorityOverridesItemFromProviders(value Providers) *QueryConfigProviderPriorityOverridesItem {
	return &QueryConfigProviderPriorityOverridesItem{typeName: "providers", Providers: value}
}

func NewQueryConfigProviderPriorityOverridesItemFromLabs(value Labs) *QueryConfigProviderPriorityOverridesItem {
	return &QueryConfigProviderPriorityOverridesItem{typeName: "labs", Labs: value}
}

func (q *QueryConfigProviderPriorityOverridesItem) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		q.typeName = "providers"
		q.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		q.typeName = "labs"
		q.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryConfigProviderPriorityOverridesItem) MarshalJSON() ([]byte, error) {
	switch q.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "providers":
		return json.Marshal(q.Providers)
	case "labs":
		return json.Marshal(q.Labs)
	}
}

type QueryConfigProviderPriorityOverridesItemVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (q *QueryConfigProviderPriorityOverridesItem) Accept(visitor QueryConfigProviderPriorityOverridesItemVisitor) error {
	switch q.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "providers":
		return visitor.VisitProviders(q.Providers)
	case "labs":
		return visitor.VisitLabs(q.Labs)
	}
}

type QueryConfigWeekStartsOn string

const (
	QueryConfigWeekStartsOnSunday QueryConfigWeekStartsOn = "sunday"
	QueryConfigWeekStartsOnMonday QueryConfigWeekStartsOn = "monday"
)

func NewQueryConfigWeekStartsOnFromString(s string) (QueryConfigWeekStartsOn, error) {
	switch s {
	case "sunday":
		return QueryConfigWeekStartsOnSunday, nil
	case "monday":
		return QueryConfigWeekStartsOnMonday, nil
	}
	var t QueryConfigWeekStartsOn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryConfigWeekStartsOn) Ptr() *QueryConfigWeekStartsOn {
	return &q
}

type QueryInstruction struct {
	Select        *QueryInstructionSelect      `json:"select,omitempty"`
	PartitionBy   *QueryInstructionPartitionBy `json:"partition_by,omitempty"`
	SwizzleBy     *QueryInstructionSwizzleBy   `json:"swizzle_by,omitempty"`
	ReduceBy      []*Reducer                   `json:"reduce_by,omitempty"`
	PrioritizeBy  []string                     `json:"prioritize_by,omitempty"`
	SplitBySource *bool                        `json:"split_by_source,omitempty"`

	_rawJSON json.RawMessage
}

func (q *QueryInstruction) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryInstruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryInstruction(value)
	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryInstruction) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryInstructionPartitionBy struct {
	typeName            string
	Period              *Period
	SessionPartitioning *SessionPartitioning
}

func NewQueryInstructionPartitionByFromPeriod(value *Period) *QueryInstructionPartitionBy {
	return &QueryInstructionPartitionBy{typeName: "period", Period: value}
}

func NewQueryInstructionPartitionByFromSessionPartitioning(value *SessionPartitioning) *QueryInstructionPartitionBy {
	return &QueryInstructionPartitionBy{typeName: "sessionPartitioning", SessionPartitioning: value}
}

func (q *QueryInstructionPartitionBy) UnmarshalJSON(data []byte) error {
	valuePeriod := new(Period)
	if err := json.Unmarshal(data, &valuePeriod); err == nil {
		q.typeName = "period"
		q.Period = valuePeriod
		return nil
	}
	valueSessionPartitioning := new(SessionPartitioning)
	if err := json.Unmarshal(data, &valueSessionPartitioning); err == nil {
		q.typeName = "sessionPartitioning"
		q.SessionPartitioning = valueSessionPartitioning
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryInstructionPartitionBy) MarshalJSON() ([]byte, error) {
	switch q.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "period":
		return json.Marshal(q.Period)
	case "sessionPartitioning":
		return json.Marshal(q.SessionPartitioning)
	}
}

type QueryInstructionPartitionByVisitor interface {
	VisitPeriod(*Period) error
	VisitSessionPartitioning(*SessionPartitioning) error
}

func (q *QueryInstructionPartitionBy) Accept(visitor QueryInstructionPartitionByVisitor) error {
	switch q.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "period":
		return visitor.VisitPeriod(q.Period)
	case "sessionPartitioning":
		return visitor.VisitSessionPartitioning(q.SessionPartitioning)
	}
}

type QueryInstructionSelect struct {
	typeName         string
	SleepSelector    *SleepSelector
	ActivitySelector *ActivitySelector
}

func NewQueryInstructionSelectFromSleepSelector(value *SleepSelector) *QueryInstructionSelect {
	return &QueryInstructionSelect{typeName: "sleepSelector", SleepSelector: value}
}

func NewQueryInstructionSelectFromActivitySelector(value *ActivitySelector) *QueryInstructionSelect {
	return &QueryInstructionSelect{typeName: "activitySelector", ActivitySelector: value}
}

func (q *QueryInstructionSelect) UnmarshalJSON(data []byte) error {
	valueSleepSelector := new(SleepSelector)
	if err := json.Unmarshal(data, &valueSleepSelector); err == nil {
		q.typeName = "sleepSelector"
		q.SleepSelector = valueSleepSelector
		return nil
	}
	valueActivitySelector := new(ActivitySelector)
	if err := json.Unmarshal(data, &valueActivitySelector); err == nil {
		q.typeName = "activitySelector"
		q.ActivitySelector = valueActivitySelector
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryInstructionSelect) MarshalJSON() ([]byte, error) {
	switch q.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "sleepSelector":
		return json.Marshal(q.SleepSelector)
	case "activitySelector":
		return json.Marshal(q.ActivitySelector)
	}
}

type QueryInstructionSelectVisitor interface {
	VisitSleepSelector(*SleepSelector) error
	VisitActivitySelector(*ActivitySelector) error
}

func (q *QueryInstructionSelect) Accept(visitor QueryInstructionSelectVisitor) error {
	switch q.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "sleepSelector":
		return visitor.VisitSleepSelector(q.SleepSelector)
	case "activitySelector":
		return visitor.VisitActivitySelector(q.ActivitySelector)
	}
}

type QueryInstructionSwizzleBy struct {
	typeName      string
	Swizzling     *Swizzling
	stringLiteral string
}

func NewQueryInstructionSwizzleByFromSwizzling(value *Swizzling) *QueryInstructionSwizzleBy {
	return &QueryInstructionSwizzleBy{typeName: "swizzling", Swizzling: value}
}

func NewQueryInstructionSwizzleByWithStringLiteral() *QueryInstructionSwizzleBy {
	return &QueryInstructionSwizzleBy{typeName: "stringLiteral", stringLiteral: "passthrough"}
}

func (q *QueryInstructionSwizzleBy) StringLiteral() string {
	return q.stringLiteral
}

func (q *QueryInstructionSwizzleBy) UnmarshalJSON(data []byte) error {
	valueSwizzling := new(Swizzling)
	if err := json.Unmarshal(data, &valueSwizzling); err == nil {
		q.typeName = "swizzling"
		q.Swizzling = valueSwizzling
		return nil
	}
	var valueStringLiteral string
	if err := json.Unmarshal(data, &valueStringLiteral); err == nil {
		if valueStringLiteral == "passthrough" {
			q.typeName = "stringLiteral"
			q.stringLiteral = valueStringLiteral
			return nil
		}
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryInstructionSwizzleBy) MarshalJSON() ([]byte, error) {
	switch q.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "swizzling":
		return json.Marshal(q.Swizzling)
	case "stringLiteral":
		return json.Marshal("passthrough")
	}
}

type QueryInstructionSwizzleByVisitor interface {
	VisitSwizzling(*Swizzling) error
	VisitStringLiteral(string) error
}

func (q *QueryInstructionSwizzleBy) Accept(visitor QueryInstructionSwizzleByVisitor) error {
	switch q.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", q.typeName, q)
	case "swizzling":
		return visitor.VisitSwizzling(q.Swizzling)
	case "stringLiteral":
		return visitor.VisitStringLiteral(q.stringLiteral)
	}
}

type Question struct {
	Id         int          `json:"id"`
	Required   bool         `json:"required"`
	Code       string       `json:"code"`
	Value      string       `json:"value"`
	Type       QuestionType `json:"type,omitempty"`
	Sequence   int          `json:"sequence"`
	Answers    []*Answer    `json:"answers,omitempty"`
	Constraint *string      `json:"constraint,omitempty"`

	_rawJSON json.RawMessage
}

func (q *Question) UnmarshalJSON(data []byte) error {
	type unmarshaler Question
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = Question(value)
	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *Question) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QuestionType string

const (
	QuestionTypeChoice      QuestionType = "choice"
	QuestionTypeText        QuestionType = "text"
	QuestionTypeNumeric     QuestionType = "numeric"
	QuestionTypeMultiChoice QuestionType = "multi_choice"
)

func NewQuestionTypeFromString(s string) (QuestionType, error) {
	switch s {
	case "choice":
		return QuestionTypeChoice, nil
	case "text":
		return QuestionTypeText, nil
	case "numeric":
		return QuestionTypeNumeric, nil
	case "multi_choice":
		return QuestionTypeMultiChoice, nil
	}
	var t QuestionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QuestionType) Ptr() *QuestionType {
	return &q
}

type RawActivity struct {
	Activity []*ActivityV2InDb `json:"activity,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler RawActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawActivity(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawActivity) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawBody struct {
	Body []*BodyV2InDb `json:"body,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawBody) UnmarshalJSON(data []byte) error {
	type unmarshaler RawBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawBody(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawDevices struct {
	Devices []*DeviceV2InDb `json:"devices,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawDevices) UnmarshalJSON(data []byte) error {
	type unmarshaler RawDevices
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawDevices(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawDevices) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawProfile struct {
	Profile *ProfileInDb `json:"profile,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler RawProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawProfile(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawProfile) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawSleep struct {
	Sleep []*SleepV2InDb `json:"sleep,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawSleep) UnmarshalJSON(data []byte) error {
	type unmarshaler RawSleep
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawSleep(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawSleep) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RawWorkout struct {
	Workouts []*WorkoutV2InDb `json:"workouts,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RawWorkout) UnmarshalJSON(data []byte) error {
	type unmarshaler RawWorkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawWorkout(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawWorkout) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Reducer struct {
	Function ReducerFunction `json:"function,omitempty"`

	_rawJSON json.RawMessage
}

func (r *Reducer) UnmarshalJSON(data []byte) error {
	type unmarshaler Reducer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Reducer(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Reducer) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReducerFunction string

const (
	ReducerFunctionMean   ReducerFunction = "mean"
	ReducerFunctionMin    ReducerFunction = "min"
	ReducerFunctionMax    ReducerFunction = "max"
	ReducerFunctionSum    ReducerFunction = "sum"
	ReducerFunctionCount  ReducerFunction = "count"
	ReducerFunctionMedian ReducerFunction = "median"
	ReducerFunctionStddev ReducerFunction = "stddev"
	ReducerFunctionOldest ReducerFunction = "oldest"
	ReducerFunctionNewest ReducerFunction = "newest"
)

func NewReducerFunctionFromString(s string) (ReducerFunction, error) {
	switch s {
	case "mean":
		return ReducerFunctionMean, nil
	case "min":
		return ReducerFunctionMin, nil
	case "max":
		return ReducerFunctionMax, nil
	case "sum":
		return ReducerFunctionSum, nil
	case "count":
		return ReducerFunctionCount, nil
	case "median":
		return ReducerFunctionMedian, nil
	case "stddev":
		return ReducerFunctionStddev, nil
	case "oldest":
		return ReducerFunctionOldest, nil
	case "newest":
		return ReducerFunctionNewest, nil
	}
	var t ReducerFunction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReducerFunction) Ptr() *ReducerFunction {
	return &r
}

type Region string

const (
	RegionUs Region = "us"
	RegionEu Region = "eu"
	RegionSg Region = "sg"
	RegionDe Region = "de"
	RegionAu Region = "au"
	RegionBr Region = "br"
	RegionNl Region = "nl"
	RegionFr Region = "fr"
	RegionCa Region = "ca"
	RegionIn Region = "in"
)

func NewRegionFromString(s string) (Region, error) {
	switch s {
	case "us":
		return RegionUs, nil
	case "eu":
		return RegionEu, nil
	case "sg":
		return RegionSg, nil
	case "de":
		return RegionDe, nil
	case "au":
		return RegionAu, nil
	case "br":
		return RegionBr, nil
	case "nl":
		return RegionNl, nil
	case "fr":
		return RegionFr, nil
	case "ca":
		return RegionCa, nil
	case "in":
		return RegionIn, nil
	}
	var t Region
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Region) Ptr() *Region {
	return &r
}

type RelativeTimeframe struct {
	Anchor string  `json:"anchor"`
	Past   *Period `json:"past,omitempty"`
	type_  string

	_rawJSON json.RawMessage
}

func (r *RelativeTimeframe) Type() string {
	return r.type_
}

func (r *RelativeTimeframe) UnmarshalJSON(data []byte) error {
	type unmarshaler RelativeTimeframe
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RelativeTimeframe(value)
	r.type_ = "relative"
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelativeTimeframe) MarshalJSON() ([]byte, error) {
	type embed RelativeTimeframe
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "relative",
	}
	return json.Marshal(marshaler)
}

func (r *RelativeTimeframe) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceAvailability struct {
	Status            Availability             `json:"status,omitempty"`
	ScopeRequirements *ScopeRequirementsGrants `json:"scope_requirements,omitempty"`

	_rawJSON json.RawMessage
}

func (r *ResourceAvailability) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceAvailability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceAvailability(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceAvailability) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponsibleRelationship string

const (
	ResponsibleRelationshipSelf   ResponsibleRelationship = "Self"
	ResponsibleRelationshipSpouse ResponsibleRelationship = "Spouse"
	ResponsibleRelationshipOther  ResponsibleRelationship = "Other"
)

func NewResponsibleRelationshipFromString(s string) (ResponsibleRelationship, error) {
	switch s {
	case "Self":
		return ResponsibleRelationshipSelf, nil
	case "Spouse":
		return ResponsibleRelationshipSpouse, nil
	case "Other":
		return ResponsibleRelationshipOther, nil
	}
	var t ResponsibleRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponsibleRelationship) Ptr() *ResponsibleRelationship {
	return &r
}

type ResultType string

const (
	ResultTypeNumeric ResultType = "numeric"
	ResultTypeRange   ResultType = "range"
	ResultTypeComment ResultType = "comment"
)

func NewResultTypeFromString(s string) (ResultType, error) {
	switch s {
	case "numeric":
		return ResultTypeNumeric, nil
	case "range":
		return ResultTypeRange, nil
	case "comment":
		return ResultTypeComment, nil
	}
	var t ResultType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResultType) Ptr() *ResultType {
	return &r
}

type ScopeRequirementsGrants struct {
	UserGranted *ScopeRequirementsStr `json:"user_granted,omitempty"`
	UserDenied  *ScopeRequirementsStr `json:"user_denied,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ScopeRequirementsGrants) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsGrants
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsGrants(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsGrants) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScopeRequirementsStr struct {
	Required []string `json:"required,omitempty"`
	Optional []string `json:"optional,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ScopeRequirementsStr) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsStr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsStr(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsStr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SessionPartitioning struct {
	Session SessionPartitioningSession `json:"session,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SessionPartitioning) UnmarshalJSON(data []byte) error {
	type unmarshaler SessionPartitioning
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SessionPartitioning(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionPartitioning) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SessionPartitioningSession string

const (
	SessionPartitioningSessionMenstrualCycle SessionPartitioningSession = "menstrual_cycle"
	SessionPartitioningSessionWorkout        SessionPartitioningSession = "workout"
)

func NewSessionPartitioningSessionFromString(s string) (SessionPartitioningSession, error) {
	switch s {
	case "menstrual_cycle":
		return SessionPartitioningSessionMenstrualCycle, nil
	case "workout":
		return SessionPartitioningSessionWorkout, nil
	}
	var t SessionPartitioningSession
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SessionPartitioningSession) Ptr() *SessionPartitioningSession {
	return &s
}

type SexualActivityEntry struct {
	Date           string `json:"date"`
	ProtectionUsed *bool  `json:"protection_used,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SexualActivityEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler SexualActivityEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SexualActivityEntry(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SexualActivityEntry) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ShippingAddress struct {
	ReceiverName string  `json:"receiver_name"`
	FirstLine    string  `json:"first_line"`
	SecondLine   *string `json:"second_line,omitempty"`
	City         string  `json:"city"`
	State        string  `json:"state"`
	Zip          string  `json:"zip"`
	Country      string  `json:"country"`
	PhoneNumber  string  `json:"phone_number"`

	_rawJSON json.RawMessage
}

func (s *ShippingAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingAddress(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingAddress) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleHistoricalPullStatistics struct {
	Status       HistoricalPullStatus    `json:"status,omitempty"`
	RangeStart   *time.Time              `json:"range_start,omitempty"`
	RangeEnd     *time.Time              `json:"range_end,omitempty"`
	Timeline     *HistoricalPullTimeline `json:"timeline,omitempty"`
	DaysWithData *int                    `json:"days_with_data,omitempty"`
	Release      string                  `json:"release"`
	TraceId      *string                 `json:"trace_id,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleHistoricalPullStatistics) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleHistoricalPullStatistics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleHistoricalPullStatistics(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleHistoricalPullStatistics) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleProviderHistoricalPullResponse struct {
	Pulled    map[string]*SingleHistoricalPullStatistics `json:"pulled,omitempty"`
	NotPulled []ClientFacingResource                     `json:"not_pulled,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleProviderHistoricalPullResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleProviderHistoricalPullResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleProviderHistoricalPullResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleProviderHistoricalPullResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleResourceStatistics struct {
	LastAttempt *LastAttempt `json:"last_attempt,omitempty"`
	OldestData  *time.Time   `json:"oldest_data,omitempty"`
	NewestData  *time.Time   `json:"newest_data,omitempty"`
	SentCount   *int         `json:"sent_count,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleResourceStatistics) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleResourceStatistics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleResourceStatistics(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleResourceStatistics) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUserHistoricalPullResponse struct {
	UserId   string                                           `json:"user_id"`
	Provider map[string]*SingleProviderHistoricalPullResponse `json:"provider,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleUserHistoricalPullResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUserHistoricalPullResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUserHistoricalPullResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUserHistoricalPullResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleUserResourceResponse struct {
	UserId   string                                          `json:"user_id"`
	Provider map[string]map[string]*SingleResourceStatistics `json:"provider,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleUserResourceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUserResourceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUserResourceResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUserResourceResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepSelector struct {
	Sleep SleepSelectorSleep `json:"sleep,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SleepSelector) UnmarshalJSON(data []byte) error {
	type unmarshaler SleepSelector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SleepSelector(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepSelector) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SleepSelectorSleep string

const (
	SleepSelectorSleepSessionStart         SleepSelectorSleep = "session_start"
	SleepSelectorSleepSessionEnd           SleepSelectorSleep = "session_end"
	SleepSelectorSleepState                SleepSelectorSleep = "state"
	SleepSelectorSleepDurationSecond       SleepSelectorSleep = "duration_second"
	SleepSelectorSleepStageAsleepSecond    SleepSelectorSleep = "stage_asleep_second"
	SleepSelectorSleepStageAwakeSecond     SleepSelectorSleep = "stage_awake_second"
	SleepSelectorSleepStageLightSecond     SleepSelectorSleep = "stage_light_second"
	SleepSelectorSleepStageRemSecond       SleepSelectorSleep = "stage_rem_second"
	SleepSelectorSleepStageDeepSecond      SleepSelectorSleep = "stage_deep_second"
	SleepSelectorSleepStageUnknownSecond   SleepSelectorSleep = "stage_unknown_second"
	SleepSelectorSleepLatencySecond        SleepSelectorSleep = "latency_second"
	SleepSelectorSleepHeartRateMinimum     SleepSelectorSleep = "heart_rate_minimum"
	SleepSelectorSleepHeartRateMean        SleepSelectorSleep = "heart_rate_mean"
	SleepSelectorSleepHeartRateMaximum     SleepSelectorSleep = "heart_rate_maximum"
	SleepSelectorSleepHeartRateDip         SleepSelectorSleep = "heart_rate_dip"
	SleepSelectorSleepEfficiency           SleepSelectorSleep = "efficiency"
	SleepSelectorSleepHrvMeanRmssd         SleepSelectorSleep = "hrv_mean_rmssd"
	SleepSelectorSleepHrvMeanSdnn          SleepSelectorSleep = "hrv_mean_sdnn"
	SleepSelectorSleepSkinTemperatureDelta SleepSelectorSleep = "skin_temperature_delta"
	SleepSelectorSleepRespiratoryRate      SleepSelectorSleep = "respiratory_rate"
	SleepSelectorSleepScore                SleepSelectorSleep = "score"
	SleepSelectorSleepSourceType           SleepSelectorSleep = "source_type"
	SleepSelectorSleepSourceProvider       SleepSelectorSleep = "source_provider"
	SleepSelectorSleepSourceAppId          SleepSelectorSleep = "source_app_id"
)

func NewSleepSelectorSleepFromString(s string) (SleepSelectorSleep, error) {
	switch s {
	case "session_start":
		return SleepSelectorSleepSessionStart, nil
	case "session_end":
		return SleepSelectorSleepSessionEnd, nil
	case "state":
		return SleepSelectorSleepState, nil
	case "duration_second":
		return SleepSelectorSleepDurationSecond, nil
	case "stage_asleep_second":
		return SleepSelectorSleepStageAsleepSecond, nil
	case "stage_awake_second":
		return SleepSelectorSleepStageAwakeSecond, nil
	case "stage_light_second":
		return SleepSelectorSleepStageLightSecond, nil
	case "stage_rem_second":
		return SleepSelectorSleepStageRemSecond, nil
	case "stage_deep_second":
		return SleepSelectorSleepStageDeepSecond, nil
	case "stage_unknown_second":
		return SleepSelectorSleepStageUnknownSecond, nil
	case "latency_second":
		return SleepSelectorSleepLatencySecond, nil
	case "heart_rate_minimum":
		return SleepSelectorSleepHeartRateMinimum, nil
	case "heart_rate_mean":
		return SleepSelectorSleepHeartRateMean, nil
	case "heart_rate_maximum":
		return SleepSelectorSleepHeartRateMaximum, nil
	case "heart_rate_dip":
		return SleepSelectorSleepHeartRateDip, nil
	case "efficiency":
		return SleepSelectorSleepEfficiency, nil
	case "hrv_mean_rmssd":
		return SleepSelectorSleepHrvMeanRmssd, nil
	case "hrv_mean_sdnn":
		return SleepSelectorSleepHrvMeanSdnn, nil
	case "skin_temperature_delta":
		return SleepSelectorSleepSkinTemperatureDelta, nil
	case "respiratory_rate":
		return SleepSelectorSleepRespiratoryRate, nil
	case "score":
		return SleepSelectorSleepScore, nil
	case "source_type":
		return SleepSelectorSleepSourceType, nil
	case "source_provider":
		return SleepSelectorSleepSourceProvider, nil
	case "source_app_id":
		return SleepSelectorSleepSourceAppId, nil
	}
	var t SleepSelectorSleep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepSelectorSleep) Ptr() *SleepSelectorSleep {
	return &s
}

type SleepSummaryState string

const (
	SleepSummaryStateTentative SleepSummaryState = "tentative"
	SleepSummaryStateConfirmed SleepSummaryState = "confirmed"
)

func NewSleepSummaryStateFromString(s string) (SleepSummaryState, error) {
	switch s {
	case "tentative":
		return SleepSummaryStateTentative, nil
	case "confirmed":
		return SleepSummaryStateConfirmed, nil
	}
	var t SleepSummaryState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepSummaryState) Ptr() *SleepSummaryState {
	return &s
}

type SleepV2InDb struct {
	Timestamp  time.Time              `json:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty"`
	ProviderId string                 `json:"provider_id"`
	UserId     string                 `json:"user_id"`
	SourceId   int                    `json:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty"`
	Id         string                 `json:"id"`
	Source     *ClientFacingProvider  `json:"source,omitempty"`
	Priority   *int                   `json:"priority,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SleepV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler SleepV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SleepV2InDb(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepV2InDb) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Source struct {
	Name            string          `json:"name"`
	Slug            string          `json:"slug"`
	Description     string          `json:"description"`
	Logo            string          `json:"logo"`
	Group           *string         `json:"group,omitempty"`
	OauthUrl        *string         `json:"oauth_url,omitempty"`
	AuthType        *SourceAuthType `json:"auth_type,omitempty"`
	SourceType      *SourceType     `json:"source_type,omitempty"`
	IsActive        *bool           `json:"is_active,omitempty"`
	BackfillNumDays *int            `json:"backfill_num_days,omitempty"`
	Id              int             `json:"id"`

	_rawJSON json.RawMessage
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceAuthType string

const (
	SourceAuthTypeOauth     SourceAuthType = "oauth"
	SourceAuthTypeTeamOauth SourceAuthType = "team_oauth"
	SourceAuthTypeSdk       SourceAuthType = "sdk"
	SourceAuthTypePassword  SourceAuthType = "password"
	SourceAuthTypeEmail     SourceAuthType = "email"
	SourceAuthTypeApp       SourceAuthType = "app"
	SourceAuthTypeEmpty     SourceAuthType = ""
)

func NewSourceAuthTypeFromString(s string) (SourceAuthType, error) {
	switch s {
	case "oauth":
		return SourceAuthTypeOauth, nil
	case "team_oauth":
		return SourceAuthTypeTeamOauth, nil
	case "sdk":
		return SourceAuthTypeSdk, nil
	case "password":
		return SourceAuthTypePassword, nil
	case "email":
		return SourceAuthTypeEmail, nil
	case "app":
		return SourceAuthTypeApp, nil
	case "":
		return SourceAuthTypeEmpty, nil
	}
	var t SourceAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAuthType) Ptr() *SourceAuthType {
	return &s
}

type SourceLink struct {
	Id             int                    `json:"id"`
	Name           string                 `json:"name"`
	Slug           string                 `json:"slug"`
	Description    string                 `json:"description"`
	Logo           string                 `json:"logo"`
	OauthUrl       *string                `json:"oauth_url,omitempty"`
	AuthType       *SourceAuthType        `json:"auth_type,omitempty"`
	FormComponents map[string]interface{} `json:"form_components,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SourceLink) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceLink(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceLink) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceType string

const (
	SourceTypeApp      SourceType = "app"
	SourceTypeBle      SourceType = "ble"
	SourceTypeDevice   SourceType = "device"
	SourceTypeLab      SourceType = "lab"
	SourceTypeProvider SourceType = "provider"
)

func NewSourceTypeFromString(s string) (SourceType, error) {
	switch s {
	case "app":
		return SourceTypeApp, nil
	case "ble":
		return SourceTypeBle, nil
	case "device":
		return SourceTypeDevice, nil
	case "lab":
		return SourceTypeLab, nil
	case "provider":
		return SourceTypeProvider, nil
	}
	var t SourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceType) Ptr() *SourceType {
	return &s
}

// The Swizzling mode makes the reducer functions produce statistics
// based on X-of-Y granularity (e.g., day-of-week) for each and every data partition.
//
// ## Basic usages
//
// - Hour of Day — gather_every={1, hour}, bin_granularity=day, bin_count=1
// - Day of Week — gather_every={1, day}, bin_granularity=week, bin_count=1
// - Day of Month — gather_every={1, day}, bin_granularity=month, bin_count=1
//
// ## Output columns
//
// Swizzling mode adds two additional columns to the output dataframes:
//
//  1. `swizzle_bin`: The bin index of the data point post-binning (with respect to `bin_count`
//     and `bin_granularity); and 2 `swizzle_period_start`: The bin-relative period start of the data point with respect to `gather_every`.
//
// ## Supported combinations
//
// | gather_every | group_by          |
// | ------------ | ----------------- |
// | minute       | minute, hour, day |
// | hour         | hour, day, week   |
// | day          | day, week, month  |
// | week         | week, month       |
// | month        | month             |
type Swizzling struct {
	BinGranularity SwizzlingBinGranularity `json:"bin_granularity,omitempty"`
	BinCount       *int                    `json:"bin_count,omitempty"`
	GatherEvery    *Period                 `json:"gather_every,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Swizzling) UnmarshalJSON(data []byte) error {
	type unmarshaler Swizzling
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Swizzling(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Swizzling) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SwizzlingBinGranularity string

const (
	SwizzlingBinGranularityMinute SwizzlingBinGranularity = "minute"
	SwizzlingBinGranularityHour   SwizzlingBinGranularity = "hour"
	SwizzlingBinGranularityDay    SwizzlingBinGranularity = "day"
	SwizzlingBinGranularityWeek   SwizzlingBinGranularity = "week"
	SwizzlingBinGranularityMonth  SwizzlingBinGranularity = "month"
)

func NewSwizzlingBinGranularityFromString(s string) (SwizzlingBinGranularity, error) {
	switch s {
	case "minute":
		return SwizzlingBinGranularityMinute, nil
	case "hour":
		return SwizzlingBinGranularityHour, nil
	case "day":
		return SwizzlingBinGranularityDay, nil
	case "week":
		return SwizzlingBinGranularityWeek, nil
	case "month":
		return SwizzlingBinGranularityMonth, nil
	}
	var t SwizzlingBinGranularity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SwizzlingBinGranularity) Ptr() *SwizzlingBinGranularity {
	return &s
}

type TeamConfig struct {
	Libreview                      *LibreConfig                 `json:"libreview,omitempty"`
	TextsEnabled                   *bool                        `json:"texts_enabled,omitempty"`
	PushHistoricalData             *bool                        `json:"push_historical_data,omitempty"`
	ProviderRawData                *bool                        `json:"provider_raw_data,omitempty"`
	RejectDuplicateConnection      *bool                        `json:"reject_duplicate_connection,omitempty"`
	SdkPerDeviceActivityTimeseries *bool                        `json:"sdk_per_device_activity_timeseries,omitempty"`
	EdsPreferences                 *EventDestinationPreferences `json:"eds_preferences,omitempty"`
	EventTypePrefixes              []string                     `json:"event_type_prefixes,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TeamConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamConfig(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamConfig) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeSlot struct {
	BookingKey *string `json:"booking_key,omitempty"`
	// Time is in UTC
	Start time.Time `json:"start"`
	// Time is in UTC
	End                      time.Time  `json:"end"`
	ExpiresAt                *time.Time `json:"expires_at,omitempty"`
	Price                    float64    `json:"price"`
	IsPriority               bool       `json:"is_priority"`
	NumAppointmentsAvailable int        `json:"num_appointments_available"`

	_rawJSON json.RawMessage
}

func (t *TimeSlot) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeSlot
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeSlot(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeSlot) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeseriesMetricPoint struct {
	Date  time.Time `json:"date"`
	Value float64   `json:"value"`

	_rawJSON json.RawMessage
}

func (t *TimeseriesMetricPoint) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeseriesMetricPoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeseriesMetricPoint(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeseriesMetricPoint) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeseriesResource string

const (
	TimeseriesResourceCaloriesActive           TimeseriesResource = "calories_active"
	TimeseriesResourceCaloriesBasal            TimeseriesResource = "calories_basal"
	TimeseriesResourceDistance                 TimeseriesResource = "distance"
	TimeseriesResourceBloodOxygen              TimeseriesResource = "blood_oxygen"
	TimeseriesResourceBloodPressure            TimeseriesResource = "blood_pressure"
	TimeseriesResourceBodyFat                  TimeseriesResource = "body_fat"
	TimeseriesResourceBodyWeight               TimeseriesResource = "body_weight"
	TimeseriesResourceBodyTemperature          TimeseriesResource = "body_temperature"
	TimeseriesResourceBodyTemperatureDelta     TimeseriesResource = "body_temperature_delta"
	TimeseriesResourceCholesterol              TimeseriesResource = "cholesterol"
	TimeseriesResourceCholesterolLdl           TimeseriesResource = "cholesterol/ldl"
	TimeseriesResourceCholesterolHdl           TimeseriesResource = "cholesterol/hdl"
	TimeseriesResourceCholesterolTotal         TimeseriesResource = "cholesterol/total"
	TimeseriesResourceCholesterolTriglycerides TimeseriesResource = "cholesterol/triglycerides"
	TimeseriesResourceElectrocardiogramVoltage TimeseriesResource = "electrocardiogram_voltage"
	TimeseriesResourceFloorsClimbed            TimeseriesResource = "floors_climbed"
	TimeseriesResourceGlucose                  TimeseriesResource = "glucose"
	TimeseriesResourceHeartrate                TimeseriesResource = "heartrate"
	TimeseriesResourceHrv                      TimeseriesResource = "hrv"
	TimeseriesResourceHypnogram                TimeseriesResource = "hypnogram"
	TimeseriesResourceIge                      TimeseriesResource = "ige"
	TimeseriesResourceIgg                      TimeseriesResource = "igg"
	TimeseriesResourceRespiratoryRate          TimeseriesResource = "respiratory_rate"
	TimeseriesResourceSteps                    TimeseriesResource = "steps"
	TimeseriesResourceStressLevel              TimeseriesResource = "stress_level"
	TimeseriesResourceVo2Max                   TimeseriesResource = "vo2_max"
	TimeseriesResourceWater                    TimeseriesResource = "water"
	TimeseriesResourceCaffeine                 TimeseriesResource = "caffeine"
	TimeseriesResourceMindfulnessMinutes       TimeseriesResource = "mindfulness_minutes"
	TimeseriesResourceWorkoutDuration          TimeseriesResource = "workout_duration"
	TimeseriesResourceInsulinInjection         TimeseriesResource = "insulin_injection"
	TimeseriesResourceCarbohydrates            TimeseriesResource = "carbohydrates"
	TimeseriesResourceNote                     TimeseriesResource = "note"
)

func NewTimeseriesResourceFromString(s string) (TimeseriesResource, error) {
	switch s {
	case "calories_active":
		return TimeseriesResourceCaloriesActive, nil
	case "calories_basal":
		return TimeseriesResourceCaloriesBasal, nil
	case "distance":
		return TimeseriesResourceDistance, nil
	case "blood_oxygen":
		return TimeseriesResourceBloodOxygen, nil
	case "blood_pressure":
		return TimeseriesResourceBloodPressure, nil
	case "body_fat":
		return TimeseriesResourceBodyFat, nil
	case "body_weight":
		return TimeseriesResourceBodyWeight, nil
	case "body_temperature":
		return TimeseriesResourceBodyTemperature, nil
	case "body_temperature_delta":
		return TimeseriesResourceBodyTemperatureDelta, nil
	case "cholesterol":
		return TimeseriesResourceCholesterol, nil
	case "cholesterol/ldl":
		return TimeseriesResourceCholesterolLdl, nil
	case "cholesterol/hdl":
		return TimeseriesResourceCholesterolHdl, nil
	case "cholesterol/total":
		return TimeseriesResourceCholesterolTotal, nil
	case "cholesterol/triglycerides":
		return TimeseriesResourceCholesterolTriglycerides, nil
	case "electrocardiogram_voltage":
		return TimeseriesResourceElectrocardiogramVoltage, nil
	case "floors_climbed":
		return TimeseriesResourceFloorsClimbed, nil
	case "glucose":
		return TimeseriesResourceGlucose, nil
	case "heartrate":
		return TimeseriesResourceHeartrate, nil
	case "hrv":
		return TimeseriesResourceHrv, nil
	case "hypnogram":
		return TimeseriesResourceHypnogram, nil
	case "ige":
		return TimeseriesResourceIge, nil
	case "igg":
		return TimeseriesResourceIgg, nil
	case "respiratory_rate":
		return TimeseriesResourceRespiratoryRate, nil
	case "steps":
		return TimeseriesResourceSteps, nil
	case "stress_level":
		return TimeseriesResourceStressLevel, nil
	case "vo2_max":
		return TimeseriesResourceVo2Max, nil
	case "water":
		return TimeseriesResourceWater, nil
	case "caffeine":
		return TimeseriesResourceCaffeine, nil
	case "mindfulness_minutes":
		return TimeseriesResourceMindfulnessMinutes, nil
	case "workout_duration":
		return TimeseriesResourceWorkoutDuration, nil
	case "insulin_injection":
		return TimeseriesResourceInsulinInjection, nil
	case "carbohydrates":
		return TimeseriesResourceCarbohydrates, nil
	case "note":
		return TimeseriesResourceNote, nil
	}
	var t TimeseriesResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeseriesResource) Ptr() *TimeseriesResource {
	return &t
}

type UsAddress struct {
	FirstLine  string  `json:"first_line"`
	SecondLine *string `json:"second_line,omitempty"`
	City       string  `json:"city"`
	State      string  `json:"state"`
	ZipCode    string  `json:"zip_code"`
	Unit       *string `json:"unit,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UsAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler UsAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsAddress(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsAddress) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserHistoricalPullsResponse struct {
	Data       []*SingleUserHistoricalPullResponse `json:"data,omitempty"`
	Next       *string                             `json:"next,omitempty"`
	NextCursor *string                             `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserHistoricalPullsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserHistoricalPullsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserHistoricalPullsResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserHistoricalPullsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserInfo struct {
	FirstName   string   `json:"first_name"`
	LastName    string   `json:"last_name"`
	Email       string   `json:"email"`
	PhoneNumber string   `json:"phone_number"`
	Gender      string   `json:"gender"`
	Dob         string   `json:"dob"`
	Address     *Address `json:"address,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler UserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserInfo(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserInfo) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshErrorResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId        string   `json:"user_id"`
	Error         string   `json:"error"`
	FailedSources []string `json:"failed_sources,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserRefreshErrorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshErrorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshErrorResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshErrorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId            string   `json:"user_id"`
	RefreshedSources  []string `json:"refreshed_sources,omitempty"`
	InProgressSources []string `json:"in_progress_sources,omitempty"`
	FailedSources     []string `json:"failed_sources,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserRefreshSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshSuccessResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserResourcesResponse struct {
	Data       []*SingleUserResourceResponse `json:"data,omitempty"`
	Next       *string                       `json:"next,omitempty"`
	NextCursor *string                       `json:"next_cursor,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserResourcesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserResourcesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserResourcesResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserResourcesResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSignInTokenResponse struct {
	UserId      string `json:"user_id"`
	SignInToken string `json:"sign_in_token"`

	_rawJSON json.RawMessage
}

func (u *UserSignInTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSignInTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSignInTokenResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSignInTokenResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success"`

	_rawJSON json.RawMessage
}

func (u *UserSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSuccessResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSuccessResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty"`
	Msg  string                    `json:"msg"`
	Type string                    `json:"type"`

	_rawJSON json.RawMessage
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	typeName string
	String   string
	Integer  int
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "string", String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "integer", Integer: value}
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.typeName = "integer"
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "integer":
		return json.Marshal(v.Integer)
	}
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "integer":
		return visitor.VisitInteger(v.Integer)
	}
}

type VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails struct {
	FirstName   string   `json:"first_name"`
	LastName    string   `json:"last_name"`
	Address     *Address `json:"address,omitempty"`
	PhoneNumber string   `json:"phone_number"`
	PhoneType   *string  `json:"phone_type,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalCoreSchemasDbSchemasLabTestHealthInsurancePersonDetails) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails struct {
	FirstName   string   `json:"first_name"`
	LastName    string   `json:"last_name"`
	Gender      Gender   `json:"gender,omitempty"`
	Address     *Address `json:"address,omitempty"`
	Dob         string   `json:"dob"`
	Email       string   `json:"email"`
	PhoneNumber string   `json:"phone_number"`

	_rawJSON json.RawMessage
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VitalTokenCreatedResponse struct {
	Code        string `json:"code"`
	ExchangeUrl string `json:"exchange_url"`

	_rawJSON json.RawMessage
}

func (v *VitalTokenCreatedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalTokenCreatedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalTokenCreatedResponse(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalTokenCreatedResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WorkoutV2InDb struct {
	Timestamp  time.Time              `json:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty"`
	ProviderId string                 `json:"provider_id"`
	UserId     string                 `json:"user_id"`
	SourceId   int                    `json:"source_id"`
	PriorityId *int                   `json:"priority_id,omitempty"`
	Id         string                 `json:"id"`
	SportId    int                    `json:"sport_id"`
	Source     *ClientFacingProvider  `json:"source,omitempty"`
	Sport      *ClientFacingSport     `json:"sport,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WorkoutV2InDb) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkoutV2InDb
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkoutV2InDb(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutV2InDb) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
