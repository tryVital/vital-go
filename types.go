// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type ActivityV2InDb struct {
	Timestamp  time.Time           `json:"timestamp"`
	Data       *string             `json:"data,omitempty"`
	ProviderId string              `json:"provider_id"`
	UserId     string              `json:"user_id"`
	SourceId   int                 `json:"source_id"`
	PriorityId int                 `json:"priority_id"`
	Id         string              `json:"id"`
	Source     *ClientFacingSource `json:"source,omitempty"`
}

type Address struct {
	FirstLine  string  `json:"first_line"`
	SecondLine *string `json:"second_line,omitempty"`
	Country    string  `json:"country"`
	Zip        string  `json:"zip"`
	City       string  `json:"city"`
	State      string  `json:"state"`
}

type ApiKeyInDb struct {
	Label     string     `json:"label"`
	Value     string     `json:"value"`
	TeamId    string     `json:"team_id"`
	Id        string     `json:"id"`
	InApp     bool       `json:"in_app"`
	CreatedAt time.Time  `json:"created_at"`
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	Role      ApiKeyRole `json:"role,omitempty"`
}

// An enumeration.
type ApiKeyRole string

const (
	ApiKeyRoleVitalAdmin ApiKeyRole = "vital_admin"
	ApiKeyRoleDefault    ApiKeyRole = "default"
)

func NewApiKeyRoleFromString(s string) (ApiKeyRole, error) {
	switch s {
	case "vital_admin":
		return ApiKeyRoleVitalAdmin, nil
	case "default":
		return ApiKeyRoleDefault, nil
	}
	var t ApiKeyRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApiKeyRole) Ptr() *ApiKeyRole {
	return &a
}

type AppointmentAvailabilitySlots struct {
	Slots    []*DaySlots `json:"slots,omitempty"`
	Timezone *string     `json:"timezone,omitempty"`
}

// An enumeration.
type AppointmentProvider string

const (
	AppointmentProviderGetlabs    AppointmentProvider = "getlabs"
	AppointmentProviderAxlehealth AppointmentProvider = "axlehealth"
)

func NewAppointmentProviderFromString(s string) (AppointmentProvider, error) {
	switch s {
	case "getlabs":
		return AppointmentProviderGetlabs, nil
	case "axlehealth":
		return AppointmentProviderAxlehealth, nil
	}
	var t AppointmentProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentProvider) Ptr() *AppointmentProvider {
	return &a
}

// An enumeration.
type AppointmentStatus string

const (
	AppointmentStatusConfirmed  AppointmentStatus = "confirmed"
	AppointmentStatusPending    AppointmentStatus = "pending"
	AppointmentStatusInProgress AppointmentStatus = "in_progress"
	AppointmentStatusCompleted  AppointmentStatus = "completed"
	AppointmentStatusCancelled  AppointmentStatus = "cancelled"
)

func NewAppointmentStatusFromString(s string) (AppointmentStatus, error) {
	switch s {
	case "confirmed":
		return AppointmentStatusConfirmed, nil
	case "pending":
		return AppointmentStatusPending, nil
	case "in_progress":
		return AppointmentStatusInProgress, nil
	case "completed":
		return AppointmentStatusCompleted, nil
	case "cancelled":
		return AppointmentStatusCancelled, nil
	}
	var t AppointmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppointmentStatus) Ptr() *AppointmentStatus {
	return &a
}

type AppointmentType = string

type AreaInfo struct {
	ZipCode    string              `json:"zip_code"`
	Phlebotomy *PhlebotomyAreaInfo `json:"phlebotomy,omitempty"`
}

// An enumeration.
type AuthType string

const (
	AuthTypePassword AuthType = "password"
	AuthTypeOauth    AuthType = "oauth"
	AuthTypeEmail    AuthType = "email"
)

func NewAuthTypeFromString(s string) (AuthType, error) {
	switch s {
	case "password":
		return AuthTypePassword, nil
	case "oauth":
		return AuthTypeOauth, nil
	case "email":
		return AuthTypeEmail, nil
	}
	var t AuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthType) Ptr() *AuthType {
	return &a
}

// Represent the schema for an individual biomarker result.
type BiomarkerResult struct {
	Name            string     `json:"name"`
	Slug            *string    `json:"slug,omitempty"`
	Value           float64    `json:"value"`
	Unit            *string    `json:"unit,omitempty"`
	Timestamp       *time.Time `json:"timestamp,omitempty"`
	Notes           *string    `json:"notes,omitempty"`
	MinRangeValue   *float64   `json:"min_range_value,omitempty"`
	MaxRangeValue   *float64   `json:"max_range_value,omitempty"`
	IsAboveMaxRange *bool      `json:"is_above_max_range,omitempty"`
	IsBelowMinRange *bool      `json:"is_below_min_range,omitempty"`
}

type BodyV2InDb struct {
	Timestamp  time.Time           `json:"timestamp"`
	Data       *string             `json:"data,omitempty"`
	ProviderId string              `json:"provider_id"`
	UserId     string              `json:"user_id"`
	SourceId   int                 `json:"source_id"`
	PriorityId *int                `json:"priority_id,omitempty"`
	Id         string              `json:"id"`
	Source     *ClientFacingSource `json:"source,omitempty"`
	Priority   *int                `json:"priority,omitempty"`
}

type ClientActivityResponse struct {
	Activity []*ClientFacingActivity `json:"activity,omitempty"`
}

type ClientBodyResponse struct {
	Body []*ClientFacingBody `json:"body,omitempty"`
}

type ClientFacingActivity struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date"`
	// Total energy consumption during the day including Basal Metabolic Rate in kilocalories::kilocalories
	CaloriesTotal *float64 `json:"calories_total,omitempty"`
	// Energy consumption caused by the physical activity of the day in kilocalories::kilocalories
	CaloriesActive *float64 `json:"calories_active,omitempty"`
	// Total number of steps registered during the day::steps
	Steps *int `json:"steps,omitempty"`
	// Deprecated. Daily physical activity as equal meters i.e. amount of walking needed to get the same amount of activity::meters
	DailyMovement *float64 `json:"daily_movement,omitempty"`
	// Cumulated distance for exercise
	Distance *float64 `json:"distance,omitempty"`
	// Number of minutes during the day with low intensity activity (e.g. household work)::minutes
	Low *float64 `json:"low,omitempty"`
	// Number of minutes during the day with medium intensity activity (e.g. walking)::minutes
	Medium *float64 `json:"medium,omitempty"`
	// Number of minutes during the day with high intensity activity (e.g. running)::minutes
	High *float64 `json:"high,omitempty"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty"`
	// Number of floors climbed by the user::count
	FloorsClimbed *int `json:"floors_climbed,omitempty"`
	// [DEPRECATED] The time zone full identifier for the data. Example: 'Europe/London'.
	TimeZone *string `json:"time_zone,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Heart rate daily summary.
	HeartRate *ClientFacingHeartRate `json:"heart_rate,omitempty"`
}

type ClientFacingApiKey struct {
	Label     string     `json:"label"`
	Value     string     `json:"value"`
	TeamId    *string    `json:"team_id,omitempty"`
	Id        string     `json:"id"`
	CreatedAt time.Time  `json:"created_at"`
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

type ClientFacingAppointment struct {
	Id            string              `json:"id"`
	UserId        string              `json:"user_id"`
	Address       *UsAddress          `json:"address,omitempty"`
	Location      *LngLat             `json:"location,omitempty"`
	StartAt       time.Time           `json:"start_at"`
	EndAt         time.Time           `json:"end_at"`
	IanaTimezone  string              `json:"iana_timezone"`
	Type          AppointmentType     `json:"type,omitempty"`
	Provider      AppointmentProvider `json:"provider,omitempty"`
	Status        AppointmentStatus   `json:"status,omitempty"`
	ProviderId    string              `json:"provider_id"`
	CanReschedule bool                `json:"can_reschedule"`
}

type ClientFacingAppointmentCancellationReason struct {
	Id           string `json:"id"`
	Name         string `json:"name"`
	IsRefundable bool   `json:"is_refundable"`
}

// Schema for a at-home-phlebotomy test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingAtHomePhlebotomyOrder struct {
	// The Vital at-home phlebotomy Order ID
	Id            string    `json:"id"`
	AppointmentId *string   `json:"appointment_id,omitempty"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

type ClientFacingAtHomePhlebotomyOrderDetails struct {
	Data *ClientFacingAtHomePhlebotomyOrder `json:"data,omitempty"`
}

type ClientFacingBloodOxygenTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The value of the measurement.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in percentage (spo2).
	Unit string `json:"unit"`
}

type ClientFacingBloodPressureTimeseries struct {
	// Measurement id, note, this field has been deprecated and is no longer used
	Id        *int      `json:"id,omitempty"`
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int    `json:"timezone_offset,omitempty"`
	Systolic       float64 `json:"systolic"`
	Diastolic      float64 `json:"diastolic"`
	Type           *string `json:"type,omitempty"`
	Unit           string  `json:"unit"`
}

type ClientFacingBody struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the summary in the YYYY-mm-dd format.
	CalendarDate string `json:"calendar_date"`
	// Weight in kg::kg
	Weight *float64 `json:"weight,omitempty"`
	// Body fat percentage::perc
	Fat    *float64            `json:"fat,omitempty"`
	Source *ClientFacingSource `json:"source,omitempty"`
}

type ClientFacingCaffeineTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Quantity of caffeine consumed during the time period.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit"`
}

type ClientFacingCaloriesActiveTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Energy consumption caused by the physical activity at the time or interval::kilocalories
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	unit string
}

func (c *ClientFacingCaloriesActiveTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesActiveTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesActiveTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveTimeseries(value)
	c.unit = "kcal"
	return nil
}

func (c *ClientFacingCaloriesActiveTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

type ClientFacingCaloriesBasalTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Basal Metabolic Rate at the time or interval::kilocalories
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	unit string
}

func (c *ClientFacingCaloriesBasalTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesBasalTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingCaloriesBasalTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalTimeseries(value)
	c.unit = "kcal"
	return nil
}

func (c *ClientFacingCaloriesBasalTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

type ClientFacingCholesterolTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The value of the measurement.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit"`
}

type ClientFacingDiagnosisInformation struct {
	// Diagnosis code for insurance information required by Labcorp.
	DiagnosisCode string `json:"diagnosis_code"`
	// Diagnosis description insurance information required by Labcorp.
	Description string `json:"description"`
}

type ClientFacingDistanceTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Distance traveled during activities at the time or interval::steps
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	unit string
}

func (c *ClientFacingDistanceTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingDistanceTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingDistanceTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingDistanceTimeseries(value)
	c.unit = "m"
	return nil
}

func (c *ClientFacingDistanceTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "m",
	}
	return json.Marshal(marshaler)
}

type ClientFacingFloorsClimbedTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Number of floors climbed at the time or interval::count
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	unit string
}

func (c *ClientFacingFloorsClimbedTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingFloorsClimbedTimeseries) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingFloorsClimbedTimeseries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedTimeseries(value)
	c.unit = "count"
	return nil
}

func (c *ClientFacingFloorsClimbedTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedTimeseries
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*c),
		Unit:  "count",
	}
	return json.Marshal(marshaler)
}

type ClientFacingGlucoseTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The value of the measurement.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit"`
}

type ClientFacingHeartRate struct {
	// Average heart rate::bpm
	AvgBpm *float64 `json:"avg_bpm,omitempty"`
	// Minimum heart rate::bpm
	MinBpm *float64 `json:"min_bpm,omitempty"`
	// Maximum heart rate::bpm
	MaxBpm *float64 `json:"max_bpm,omitempty"`
	// Resting heart rate::bpm
	RestingBpm *float64 `json:"resting_bpm,omitempty"`
}

type ClientFacingHeartRateTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Heart rate in bpm
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit"`
}

type ClientFacingHrvTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// HRV calculated using rmssd during sleep
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in rmssd.
	Unit string `json:"unit"`
}

type ClientFacingHypnogramTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Hypnogram for sleep stages {"deep": 1, "light": 2, "rem": 3, "awake": 4, "manual": 5, "missing_data": -1}
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// enum: 1: deep, 2: light, 3: rem, 4: awake, -1: missing_data.
	Unit string `json:"unit"`
}

type ClientFacingIgeTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The value of the measurement.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit"`
}

type ClientFacingIggTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// The value of the measurement.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in FSU.
	Unit string `json:"unit"`
}

type ClientFacingLab struct {
	Id                int                       `json:"id"`
	Slug              string                    `json:"slug"`
	Name              string                    `json:"name"`
	FirstLineAddress  string                    `json:"first_line_address"`
	City              string                    `json:"city"`
	Zipcode           string                    `json:"zipcode"`
	CollectionMethods []LabTestCollectionMethod `json:"collection_methods,omitempty"`
	SampleTypes       []LabTestSampleType       `json:"sample_types,omitempty"`
}

type ClientFacingLabTest struct {
	Id         string                  `json:"id"`
	Slug       string                  `json:"slug"`
	Name       string                  `json:"name"`
	SampleType LabTestSampleType       `json:"sample_type,omitempty"`
	Method     LabTestCollectionMethod `json:"method,omitempty"`
	Price      float64                 `json:"price"`
	IsActive   bool                    `json:"is_active"`
	// Defines whether a lab test requires fasting. Only available for Labcorp.
	Fasting *bool                 `json:"fasting,omitempty"`
	Lab     *ClientFacingLab      `json:"lab,omitempty"`
	Markers []*ClientFacingMarker `json:"markers,omitempty"`
	// Denotes whether a lab test requires using non-Vital physician networks. If it does then it's delegated - no otherwise.
	IsDelegated *bool `json:"is_delegated,omitempty"`
}

type ClientFacingMarker struct {
	Id          int         `json:"id"`
	Name        string      `json:"name"`
	Slug        string      `json:"slug"`
	Description *string     `json:"description,omitempty"`
	LabId       *int        `json:"lab_id,omitempty"`
	ProviderId  *string     `json:"provider_id,omitempty"`
	Type        *MarkerType `json:"type,omitempty"`
	Unit        *string     `json:"unit,omitempty"`
	Price       *string     `json:"price,omitempty"`
}

type ClientFacingMealResponse struct {
	Meals []*MealInDbBaseClientFacingSource `json:"meals,omitempty"`
}

type ClientFacingMindfulnessMinutesTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Number of minutes spent in a mindful state.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in minutes.
	Unit string `json:"unit"`
}

type ClientFacingOrder struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// The Vital Order ID
	Id string `json:"id"`
	// Your team id.
	TeamId string `json:"team_id"`
	// Patient Details
	PatientDetails *ClientFacingPatientDetailsCompatible `json:"patient_details,omitempty"`
	// Patient Address
	PatientAddress *PatientAddressCompatible `json:"patient_address,omitempty"`
	// The Vital Test associated with the order
	LabTest *ClientFacingLabTest      `json:"lab_test,omitempty"`
	Details *ClientFacingOrderDetails `json:"details,omitempty"`
	// Sample ID
	SampleId *string `json:"sample_id,omitempty"`
	// Notes associated with the order
	Notes *string `json:"notes,omitempty"`
	// When your order was created
	CreatedAt time.Time `json:"created_at"`
	// When your order was last updated
	UpdatedAt time.Time                 `json:"updated_at"`
	Events    []*ClientFacingOrderEvent `json:"events,omitempty"`
	Status    *OrderTopLevelStatus      `json:"status,omitempty"`
	Physician *PhysicianClientFacing    `json:"physician,omitempty"`
	// Vital ID of the health insurance.
	HealthInsuranceId *string `json:"health_insurance_id,omitempty"`
	// DEPRECATED. Requistion form url.
	RequisitionFormUrl *string `json:"requisition_form_url,omitempty"`
	// Defines whether order is priority or not. Only available for Labcorp. For Labcorp, this corresponds to a STAT order.
	Priority *bool `json:"priority,omitempty"`
	// Shipping Details. For unregistered testkit orders.
	ShippingDetails *ShippingAddress `json:"shipping_details,omitempty"`
}

type ClientFacingOrderDetails struct {
	Type             string
	WalkInTest       *ClientFacingWalkInOrderDetails
	Testkit          *ClientFacingTestKitOrderDetails
	AtHomePhlebotomy *ClientFacingAtHomePhlebotomyOrderDetails
}

func NewClientFacingOrderDetailsFromWalkInTest(value *ClientFacingWalkInOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "walk_in_test", WalkInTest: value}
}

func NewClientFacingOrderDetailsFromTestkit(value *ClientFacingTestKitOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "testkit", Testkit: value}
}

func NewClientFacingOrderDetailsFromAtHomePhlebotomy(value *ClientFacingAtHomePhlebotomyOrderDetails) *ClientFacingOrderDetails {
	return &ClientFacingOrderDetails{Type: "at_home_phlebotomy", AtHomePhlebotomy: value}
}

func (c *ClientFacingOrderDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "walk_in_test":
		value := new(ClientFacingWalkInOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.WalkInTest = value
	case "testkit":
		value := new(ClientFacingTestKitOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Testkit = value
	case "at_home_phlebotomy":
		value := new(ClientFacingAtHomePhlebotomyOrderDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.AtHomePhlebotomy = value
	}
	return nil
}

func (c ClientFacingOrderDetails) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingWalkInOrderDetails
		}{
			Type:                           c.Type,
			ClientFacingWalkInOrderDetails: c.WalkInTest,
		}
		return json.Marshal(marshaler)
	case "testkit":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingTestKitOrderDetails
		}{
			Type:                            c.Type,
			ClientFacingTestKitOrderDetails: c.Testkit,
		}
		return json.Marshal(marshaler)
	case "at_home_phlebotomy":
		var marshaler = struct {
			Type string `json:"type"`
			*ClientFacingAtHomePhlebotomyOrderDetails
		}{
			Type:                                     c.Type,
			ClientFacingAtHomePhlebotomyOrderDetails: c.AtHomePhlebotomy,
		}
		return json.Marshal(marshaler)
	}
}

type ClientFacingOrderDetailsVisitor interface {
	VisitWalkInTest(*ClientFacingWalkInOrderDetails) error
	VisitTestkit(*ClientFacingTestKitOrderDetails) error
	VisitAtHomePhlebotomy(*ClientFacingAtHomePhlebotomyOrderDetails) error
}

func (c *ClientFacingOrderDetails) Accept(visitor ClientFacingOrderDetailsVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "walk_in_test":
		return visitor.VisitWalkInTest(c.WalkInTest)
	case "testkit":
		return visitor.VisitTestkit(c.Testkit)
	case "at_home_phlebotomy":
		return visitor.VisitAtHomePhlebotomy(c.AtHomePhlebotomy)
	}
}

type ClientFacingOrderEvent struct {
	Id        int         `json:"id"`
	CreatedAt time.Time   `json:"created_at"`
	Status    OrderStatus `json:"status,omitempty"`
}

type ClientFacingPatientDetailsCompatible struct {
	FirstName   *string   `json:"first_name,omitempty"`
	LastName    *string   `json:"last_name,omitempty"`
	Dob         time.Time `json:"dob"`
	Gender      string    `json:"gender"`
	PhoneNumber *string   `json:"phone_number,omitempty"`
	Email       *string   `json:"email,omitempty"`
}

type ClientFacingPayorSearchResponse struct {
	// Payor code returned for the insurance information required by Labcorp.
	Code string `json:"code"`
	// Insurance name returned for the insurance information required by Labcorp.
	Name string `json:"name"`
	// Insurance business address returned for the insurance information required by Labcorp.
	OrgAddress *Address `json:"org_address,omitempty"`
}

type ClientFacingProfile struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string              `json:"user_id"`
	Id     string              `json:"id"`
	Height *int                `json:"height,omitempty"`
	Source *ClientFacingSource `json:"source,omitempty"`
}

// An enumeration.
type ClientFacingResource string

const (
	ClientFacingResourceProfile            ClientFacingResource = "profile"
	ClientFacingResourceActivity           ClientFacingResource = "activity"
	ClientFacingResourceSleep              ClientFacingResource = "sleep"
	ClientFacingResourceBody               ClientFacingResource = "body"
	ClientFacingResourceWorkouts           ClientFacingResource = "workouts"
	ClientFacingResourceWorkoutStream      ClientFacingResource = "workout_stream"
	ClientFacingResourceConnection         ClientFacingResource = "connection"
	ClientFacingResourceOrder              ClientFacingResource = "order"
	ClientFacingResourceGlucose            ClientFacingResource = "glucose"
	ClientFacingResourceHeartrate          ClientFacingResource = "heartrate"
	ClientFacingResourceHrv                ClientFacingResource = "hrv"
	ClientFacingResourceHypnogram          ClientFacingResource = "hypnogram"
	ClientFacingResourceIge                ClientFacingResource = "ige"
	ClientFacingResourceIgg                ClientFacingResource = "igg"
	ClientFacingResourceBloodOxygen        ClientFacingResource = "blood_oxygen"
	ClientFacingResourceBloodPressure      ClientFacingResource = "blood_pressure"
	ClientFacingResourceCholesterol        ClientFacingResource = "cholesterol"
	ClientFacingResourceDevice             ClientFacingResource = "device"
	ClientFacingResourceWeight             ClientFacingResource = "weight"
	ClientFacingResourceFat                ClientFacingResource = "fat"
	ClientFacingResourceMeal               ClientFacingResource = "meal"
	ClientFacingResourceWater              ClientFacingResource = "water"
	ClientFacingResourceCaffeine           ClientFacingResource = "caffeine"
	ClientFacingResourceMindfulnessMinutes ClientFacingResource = "mindfulness_minutes"
	ClientFacingResourceSteps              ClientFacingResource = "steps"
	ClientFacingResourceCaloriesActive     ClientFacingResource = "calories_active"
	ClientFacingResourceDistance           ClientFacingResource = "distance"
	ClientFacingResourceFloorsClimbed      ClientFacingResource = "floors_climbed"
	ClientFacingResourceRespiratoryRate    ClientFacingResource = "respiratory_rate"
	ClientFacingResourceVo2Max             ClientFacingResource = "vo2_max"
	ClientFacingResourceCaloriesBasal      ClientFacingResource = "calories_basal"
	ClientFacingResourceStressLevel        ClientFacingResource = "stress_level"
	ClientFacingResourceSleepStream        ClientFacingResource = "sleep_stream"
)

func NewClientFacingResourceFromString(s string) (ClientFacingResource, error) {
	switch s {
	case "profile":
		return ClientFacingResourceProfile, nil
	case "activity":
		return ClientFacingResourceActivity, nil
	case "sleep":
		return ClientFacingResourceSleep, nil
	case "body":
		return ClientFacingResourceBody, nil
	case "workouts":
		return ClientFacingResourceWorkouts, nil
	case "workout_stream":
		return ClientFacingResourceWorkoutStream, nil
	case "connection":
		return ClientFacingResourceConnection, nil
	case "order":
		return ClientFacingResourceOrder, nil
	case "glucose":
		return ClientFacingResourceGlucose, nil
	case "heartrate":
		return ClientFacingResourceHeartrate, nil
	case "hrv":
		return ClientFacingResourceHrv, nil
	case "hypnogram":
		return ClientFacingResourceHypnogram, nil
	case "ige":
		return ClientFacingResourceIge, nil
	case "igg":
		return ClientFacingResourceIgg, nil
	case "blood_oxygen":
		return ClientFacingResourceBloodOxygen, nil
	case "blood_pressure":
		return ClientFacingResourceBloodPressure, nil
	case "cholesterol":
		return ClientFacingResourceCholesterol, nil
	case "device":
		return ClientFacingResourceDevice, nil
	case "weight":
		return ClientFacingResourceWeight, nil
	case "fat":
		return ClientFacingResourceFat, nil
	case "meal":
		return ClientFacingResourceMeal, nil
	case "water":
		return ClientFacingResourceWater, nil
	case "caffeine":
		return ClientFacingResourceCaffeine, nil
	case "mindfulness_minutes":
		return ClientFacingResourceMindfulnessMinutes, nil
	case "steps":
		return ClientFacingResourceSteps, nil
	case "calories_active":
		return ClientFacingResourceCaloriesActive, nil
	case "distance":
		return ClientFacingResourceDistance, nil
	case "floors_climbed":
		return ClientFacingResourceFloorsClimbed, nil
	case "respiratory_rate":
		return ClientFacingResourceRespiratoryRate, nil
	case "vo2_max":
		return ClientFacingResourceVo2Max, nil
	case "calories_basal":
		return ClientFacingResourceCaloriesBasal, nil
	case "stress_level":
		return ClientFacingResourceStressLevel, nil
	case "sleep_stream":
		return ClientFacingResourceSleepStream, nil
	}
	var t ClientFacingResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingResource) Ptr() *ClientFacingResource {
	return &c
}

type ClientFacingRespiratoryRateTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Average respiratory rate::breaths per minute
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in bpm.
	Unit string `json:"unit"`
}

// Schema for a Shipment in the client facing API.
//
// To be used as part of a ClientFacingTestkitOrder.
type ClientFacingShipment struct {
	// The Vital Shipment ID
	Id string `json:"id"`
	// Tracking number for delivery to customer
	OutboundTrackingNumber *string `json:"outbound_tracking_number,omitempty"`
	// Tracking url for delivery to customer
	OutboundTrackingUrl *string `json:"outbound_tracking_url,omitempty"`
	// Tracking number for delivery to lab
	InboundTrackingNumber *string `json:"inbound_tracking_number,omitempty"`
	// Tracking url for delivery to lab
	InboundTrackingUrl *string `json:"inbound_tracking_url,omitempty"`
	// Courier used for delivery to customer
	OutboundCourier *string `json:"outbound_courier,omitempty"`
	// Courier used for delivery to lab
	InboundCourier *string `json:"inbound_courier,omitempty"`
	// Notes associated to the Vital shipment
	Notes *string `json:"notes,omitempty"`
}

type ClientFacingSleep struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Date of the specified record, formatted as ISO8601 datetime string in UTC 00:00. Deprecated in favour of calendar_date.
	Date time.Time `json:"date"`
	// Date of the sleep summary in the YYYY-mm-dd format. This generally matches the sleep end date.
	CalendarDate string `json:"calendar_date"`
	// UTC Time when the sleep period started
	BedtimeStart time.Time `json:"bedtime_start"`
	// UTC Time when the sleep period ended
	BedtimeStop time.Time `json:"bedtime_stop"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Total duration of the sleep period (sleep.duration = sleep.bedtime_end - sleep.bedtime_start)::seconds
	Duration int `json:"duration"`
	// Total amount of sleep registered during the sleep period (sleep.total = sleep.rem + sleep.light + sleep.deep)::seconds
	Total int `json:"total"`
	// Total amount of awake time registered during the sleep period::seconds
	Awake int `json:"awake"`
	// Total amount of light sleep registered during the sleep period::seconds
	Light int `json:"light"`
	// Total amount of REM sleep registered during the sleep period, minutes::seconds
	Rem int `json:"rem"`
	// Total amount of deep (N3) sleep registered during the sleep period::seconds
	Deep int `json:"deep"`
	// A value between 1 and 100 representing how well the user slept. Currently only available for Withings, Oura, Whoop and Garmin::scalar
	Score *int `json:"score,omitempty"`
	// The lowest heart rate (5 minutes sliding average) registered during the sleep period::beats per minute
	HrLowest *int `json:"hr_lowest,omitempty"`
	// The average heart rate registered during the sleep period::beats per minute
	HrAverage *int `json:"hr_average,omitempty"`
	// Sleep efficiency is the percentage of the sleep period spent asleep (100% * sleep.total / sleep.duration)::perc
	Efficiency *float64 `json:"efficiency,omitempty"`
	// Detected latency from bedtime_start to the beginning of the first five minutes of persistent sleep::seconds
	Latency *int `json:"latency,omitempty"`
	// Skin temperature deviation from the long-term temperature average::celcius
	TemperatureDelta *float64 `json:"temperature_delta,omitempty"`
	// The skin temperature::celcius
	SkinTemperature *float64 `json:"skin_temperature,omitempty"`
	// The average heart rate variability registered during the sleep period::rmssd
	AverageHrv *float64 `json:"average_hrv,omitempty"`
	// Average respiratory rate::breaths per minute
	RespiratoryRate *float64 `json:"respiratory_rate,omitempty"`
	// Source the data has come from.
	Source      *ClientFacingSource      `json:"source,omitempty"`
	SleepStream *ClientFacingSleepStream `json:"sleep_stream,omitempty"`
}

type ClientFacingSleepStream struct {
	Hrv             []*ClientFacingHrvTimeseries             `json:"hrv,omitempty"`
	Heartrate       []*ClientFacingHeartRateTimeseries       `json:"heartrate,omitempty"`
	Hypnogram       []*ClientFacingHypnogramTimeseries       `json:"hypnogram,omitempty"`
	RespiratoryRate []*ClientFacingRespiratoryRateTimeseries `json:"respiratory_rate,omitempty"`
}

type ClientFacingSource struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// URL for source logo
	Logo string `json:"logo"`
}

type ClientFacingSourceDetailed struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// Description of source of information
	Description string `json:"description"`
	// URL for source logo
	Logo               *string                `json:"logo,omitempty"`
	AuthType           *SourceAuthType        `json:"auth_type,omitempty"`
	SupportedResources []ClientFacingResource `json:"supported_resources,omitempty"`
}

type ClientFacingSourceWithStatus struct {
	// Name of source of information
	Name string `json:"name"`
	// Slug for designated source
	Slug string `json:"slug"`
	// URL for source logo
	Logo string `json:"logo"`
	// Status of source, either error or connected
	Status string `json:"status"`
}

type ClientFacingSport struct {
	Id int `json:"id"`
	// Sport's name
	Name string `json:"name"`
	// Slug for designated sport
	Slug string `json:"slug"`
}

type ClientFacingStream struct {
	// RPM for cycling, Steps per minute for running
	Cadence *ClientFacingStreamCadence `json:"cadence,omitempty"`
	// Corresponding time stamp in unix time for datapoint
	Time []int `json:"time,omitempty"`
	// Data points for altitude
	Altitude *ClientFacingStreamAltitude `json:"altitude,omitempty"`
	// Velocity in m/s
	VelocitySmooth *ClientFacingStreamVelocitySmooth `json:"velocity_smooth,omitempty"`
	// Heart rate in bpm
	Heartrate *ClientFacingStreamHeartrate `json:"heartrate,omitempty"`
	// Latitude for data point
	Lat *ClientFacingStreamLat `json:"lat,omitempty"`
	// Longitude for data point
	Lng *ClientFacingStreamLng `json:"lng,omitempty"`
	// Cumulated distance for exercise
	Distance *ClientFacingStreamDistance `json:"distance,omitempty"`
	// Power in watts
	Power *ClientFacingStreamPower `json:"power,omitempty"`
	// Resistance on bike
	Resistance *ClientFacingStreamResistance `json:"resistance,omitempty"`
}

// Data points for altitude
type ClientFacingStreamAltitude struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamAltitudeFromDoubleList(value []float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamAltitudeFromDoubleList(value []float64) *ClientFacingStreamAltitude {
	return &ClientFacingStreamAltitude{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamAltitude) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamAltitude) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamAltitudeVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamAltitude) Accept(visitor ClientFacingStreamAltitudeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// RPM for cycling, Steps per minute for running
type ClientFacingStreamCadence struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamCadenceFromDoubleList(value []float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamCadenceFromDoubleList(value []float64) *ClientFacingStreamCadence {
	return &ClientFacingStreamCadence{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamCadence) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamCadence) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamCadenceVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamCadence) Accept(visitor ClientFacingStreamCadenceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Cumulated distance for exercise
type ClientFacingStreamDistance struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamDistanceFromDoubleList(value []float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamDistanceFromDoubleList(value []float64) *ClientFacingStreamDistance {
	return &ClientFacingStreamDistance{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamDistance) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamDistance) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamDistanceVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamDistance) Accept(visitor ClientFacingStreamDistanceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Heart rate in bpm
type ClientFacingStreamHeartrate struct {
	typeName    string
	IntegerList []int
	IntegerList []int
}

func NewClientFacingStreamHeartrateFromIntegerList(value []int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{typeName: "integerList", IntegerList: value}
}

func NewClientFacingStreamHeartrateFromIntegerList(value []int) *ClientFacingStreamHeartrate {
	return &ClientFacingStreamHeartrate{typeName: "integerList", IntegerList: value}
}

func (c *ClientFacingStreamHeartrate) UnmarshalJSON(data []byte) error {
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.typeName = "integerList"
		c.IntegerList = valueIntegerList
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.typeName = "integerList"
		c.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamHeartrate) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integerList":
		return json.Marshal(c.IntegerList)
	case "integerList":
		return json.Marshal(c.IntegerList)
	}
}

type ClientFacingStreamHeartrateVisitor interface {
	VisitIntegerList([]int) error
	VisitIntegerList([]int) error
}

func (c *ClientFacingStreamHeartrate) Accept(visitor ClientFacingStreamHeartrateVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integerList":
		return visitor.VisitIntegerList(c.IntegerList)
	case "integerList":
		return visitor.VisitIntegerList(c.IntegerList)
	}
}

// Latitude for data point
type ClientFacingStreamLat struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamLatFromDoubleList(value []float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamLatFromDoubleList(value []float64) *ClientFacingStreamLat {
	return &ClientFacingStreamLat{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamLat) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLat) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamLatVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLat) Accept(visitor ClientFacingStreamLatVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Longitude for data point
type ClientFacingStreamLng struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamLngFromDoubleList(value []float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamLngFromDoubleList(value []float64) *ClientFacingStreamLng {
	return &ClientFacingStreamLng{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamLng) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamLng) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamLngVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamLng) Accept(visitor ClientFacingStreamLngVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Power in watts
type ClientFacingStreamPower struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamPowerFromDoubleList(value []float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamPowerFromDoubleList(value []float64) *ClientFacingStreamPower {
	return &ClientFacingStreamPower{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamPower) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamPower) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamPowerVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamPower) Accept(visitor ClientFacingStreamPowerVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Resistance on bike
type ClientFacingStreamResistance struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamResistanceFromDoubleList(value []float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamResistanceFromDoubleList(value []float64) *ClientFacingStreamResistance {
	return &ClientFacingStreamResistance{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamResistance) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamResistance) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamResistanceVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamResistance) Accept(visitor ClientFacingStreamResistanceVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

// Velocity in m/s
type ClientFacingStreamVelocitySmooth struct {
	typeName   string
	DoubleList []float64
	DoubleList []float64
}

func NewClientFacingStreamVelocitySmoothFromDoubleList(value []float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{typeName: "doubleList", DoubleList: value}
}

func NewClientFacingStreamVelocitySmoothFromDoubleList(value []float64) *ClientFacingStreamVelocitySmooth {
	return &ClientFacingStreamVelocitySmooth{typeName: "doubleList", DoubleList: value}
}

func (c *ClientFacingStreamVelocitySmooth) UnmarshalJSON(data []byte) error {
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	var valueDoubleList []float64
	if err := json.Unmarshal(data, &valueDoubleList); err == nil {
		c.typeName = "doubleList"
		c.DoubleList = valueDoubleList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingStreamVelocitySmooth) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	case "doubleList":
		return json.Marshal(c.DoubleList)
	}
}

type ClientFacingStreamVelocitySmoothVisitor interface {
	VisitDoubleList([]float64) error
	VisitDoubleList([]float64) error
}

func (c *ClientFacingStreamVelocitySmooth) Accept(visitor ClientFacingStreamVelocitySmoothVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	case "doubleList":
		return visitor.VisitDoubleList(c.DoubleList)
	}
}

type ClientFacingTeam struct {
	Id                                  string                                 `json:"id"`
	Name                                string                                 `json:"name"`
	SvixAppId                           *string                                `json:"svix_app_id,omitempty"`
	ClientId                            *string                                `json:"client_id,omitempty"`
	ClientSecret                        *string                                `json:"client_secret,omitempty"`
	AirtableApiKey                      *string                                `json:"airtable_api_key,omitempty"`
	AirtableBaseId                      *string                                `json:"airtable_base_id,omitempty"`
	WebhookSecret                       *string                                `json:"webhook_secret,omitempty"`
	ConnectedSources                    []*ConnectedSourceClientFacingRedacted `json:"connected_sources,omitempty"`
	ApiKey                              *string                                `json:"api_key,omitempty"`
	ApiKeys                             []*ClientFacingApiKey                  `json:"api_keys,omitempty"`
	Configuration                       *TeamConfig                            `json:"configuration,omitempty"`
	TestkitsTextsEnabled                bool                                   `json:"testkits_texts_enabled"`
	LabTestsPatientCommunicationEnabled bool                                   `json:"lab_tests_patient_communication_enabled"`
	LogoUrl                             *string                                `json:"logo_url,omitempty"`
}

type ClientFacingTestKitOrderDetails struct {
	Data *ClientFacingTestkitOrder `json:"data,omitempty"`
}

// Schema for a testkit order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingTestkitOrder struct {
	// The Vital TestKit Order ID
	Id string `json:"id"`
	// Shipment object
	Shipment  *ClientFacingShipment `json:"shipment,omitempty"`
	CreatedAt time.Time             `json:"created_at"`
	UpdatedAt time.Time             `json:"updated_at"`
}

type ClientFacingUser struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// Your team id.
	TeamId string `json:"team_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id"`
	// When your item is created
	CreatedOn time.Time `json:"created_on"`
	// A list of the users connected sources.
	ConnectedSources []*ConnectedSourceClientFacing `json:"connected_sources,omitempty"`
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	FallbackTimeZone *FallbackTimeZone `json:"fallback_time_zone,omitempty"`
}

type ClientFacingUserKey struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id"`
}

type ClientFacingWalkInOrderDetails struct {
	Data *ClientFacingWalkInTestOrder `json:"data,omitempty"`
}

// Schema for a walk-in test order in the client facing API.
//
// To be used as part of a ClientFacingOrder.
type ClientFacingWalkInTestOrder struct {
	// The Vital walk-in test Order ID
	Id        string    `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type ClientFacingWaterTimeseries struct {
	// Measurement id. Note, this field has been deprecated and is no longer used
	Id *int `json:"id,omitempty"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp"`
	// Time zone UTC offset of the measurement. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Quantity of water drank during the time period.
	Value float64 `json:"value"`
	// The reading type of the measurement, e.g. cuff, scale, manual_scan, etc.
	Type *string `json:"type,omitempty"`
	// Measured in milliters.
	Unit string `json:"unit"`
}

type ClientFacingWorkout struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id"`
	Id     string `json:"id"`
	// Title given for the workout
	Title *string `json:"title,omitempty"`
	// Timezone offset from UTC as seconds. For example, EEST (Eastern European Summer Time, +3h) is 10800. PST (Pacific Standard Time, -8h) is -28800::seconds
	TimezoneOffset *int `json:"timezone_offset,omitempty"`
	// Average heart rate during workout::bpm
	AverageHr *int `json:"average_hr,omitempty"`
	// Max heart rate during workout::bpm
	MaxHr *int `json:"max_hr,omitempty"`
	// Distance travelled during workout::meters
	Distance *float64 `json:"distance,omitempty"`
	// Date of the workout summary in the YYYY-mm-dd format. This generally matches the workout start date.
	CalendarDate string `json:"calendar_date"`
	// Start time of the workout::time
	TimeStart time.Time `json:"time_start"`
	// End time of the workout::time
	TimeEnd time.Time `json:"time_end"`
	// Calories burned during the workout::kCal
	Calories *float64 `json:"calories,omitempty"`
	// Sport's name
	Sport *ClientFacingSport `json:"sport,omitempty"`
	// Time in seconds spent in different heart rate zones <50%, 50-60%, 60-70%, 70-80%, 80-90%, 90%+. Due to rounding errors, it's possible that summing all values is different than the total time of the workout. Not available for all providers::seconds
	HrZones []int `json:"hr_zones,omitempty"`
	// Time spent active during the workout::seconds
	MovingTime *int `json:"moving_time,omitempty"`
	// Elevation gain during the workout::meters
	TotalElevationGain *float64 `json:"total_elevation_gain,omitempty"`
	// Highest point of elevation::meters
	ElevHigh *float64 `json:"elev_high,omitempty"`
	// Lowest point of elevation::meters
	ElevLow *float64 `json:"elev_low,omitempty"`
	// Average speed during workout in m/s::meters/sec
	AverageSpeed *float64 `json:"average_speed,omitempty"`
	// Max speed during workout in m/s::meters/sec
	MaxSpeed *float64 `json:"max_speed,omitempty"`
	// Average watts burned during exercise::watts
	AverageWatts *float64 `json:"average_watts,omitempty"`
	// Watts burned during exercise::watts
	DeviceWatts *float64 `json:"device_watts,omitempty"`
	// Max watts burned during exercise::watts
	MaxWatts *float64 `json:"max_watts,omitempty"`
	// Weighted average watts burned during exercise::watts
	WeightedAverageWatts *float64 `json:"weighted_average_watts,omitempty"`
	// Map of workouts encoded as polyline
	Map map[string]any `json:"map,omitempty"`
	// Provider ID given for that specific workout
	ProviderId string `json:"provider_id"`
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty"`
}

type ClientSleepResponse struct {
	Sleep []*ClientFacingSleep `json:"sleep,omitempty"`
}

type ClientWorkoutResponse struct {
	Workouts []*ClientFacingWorkout `json:"workouts,omitempty"`
}

type ConnectedSourceClientFacing struct {
	// Source the data has come from.
	Source *ClientFacingSource `json:"source,omitempty"`
	// When your item is created
	CreatedOn time.Time `json:"created_on"`
}

type ConnectedSourceClientFacingRedacted struct {
	Id         string              `json:"id"`
	Source     *ClientFacingSource `json:"source,omitempty"`
	ProviderId *string             `json:"provider_id,omitempty"`
}

type ConnectionStatus struct {
	Success     bool    `json:"success"`
	RedirectUrl *string `json:"redirect_url,omitempty"`
}

type Consent struct {
	ConsentType   ConsentType `json:"consentType,omitempty"`
	Version       *string     `json:"version,omitempty"`
	TimeOfConsent *time.Time  `json:"timeOfConsent,omitempty"`
}

// An enumeration.
type ConsentType string

const (
	ConsentTypeTermsOfUse                ConsentType = "terms-of-use"
	ConsentTypeTelehealthInformedConsent ConsentType = "telehealth-informed-consent"
	ConsentTypeMobileTermsAndConditions  ConsentType = "mobile-terms-and-conditions"
	ConsentTypeNoticeOfPrivacyPractices  ConsentType = "notice-of-privacy-practices"
	ConsentTypePrivacyPolicy             ConsentType = "privacy-policy"
	ConsentTypeHipaaAuthorization        ConsentType = "hipaa-authorization"
)

func NewConsentTypeFromString(s string) (ConsentType, error) {
	switch s {
	case "terms-of-use":
		return ConsentTypeTermsOfUse, nil
	case "telehealth-informed-consent":
		return ConsentTypeTelehealthInformedConsent, nil
	case "mobile-terms-and-conditions":
		return ConsentTypeMobileTermsAndConditions, nil
	case "notice-of-privacy-practices":
		return ConsentTypeNoticeOfPrivacyPractices, nil
	case "privacy-policy":
		return ConsentTypePrivacyPolicy, nil
	case "hipaa-authorization":
		return ConsentTypeHipaaAuthorization, nil
	}
	var t ConsentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsentType) Ptr() *ConsentType {
	return &c
}

type DaySlots struct {
	Date  string      `json:"date"`
	Slots []*TimeSlot `json:"slots,omitempty"`
}

type DemoConnectionStatus struct {
	Success bool   `json:"success"`
	Detail  string `json:"detail"`
}

// An enumeration.
type DemoProviders string

const (
	DemoProvidersAppleHealthKit DemoProviders = "apple_health_kit"
	DemoProvidersFitbit         DemoProviders = "fitbit"
	DemoProvidersFreestyleLibre DemoProviders = "freestyle_libre"
	DemoProvidersOura           DemoProviders = "oura"
)

func NewDemoProvidersFromString(s string) (DemoProviders, error) {
	switch s {
	case "apple_health_kit":
		return DemoProvidersAppleHealthKit, nil
	case "fitbit":
		return DemoProvidersFitbit, nil
	case "freestyle_libre":
		return DemoProvidersFreestyleLibre, nil
	case "oura":
		return DemoProvidersOura, nil
	}
	var t DemoProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DemoProviders) Ptr() *DemoProviders {
	return &d
}

type DeviceV2InDb struct {
	Data       *string             `json:"data,omitempty"`
	ProviderId string              `json:"provider_id"`
	UserId     string              `json:"user_id"`
	SourceId   int                 `json:"source_id"`
	Id         string              `json:"id"`
	Source     *ClientFacingSource `json:"source,omitempty"`
}

type EmailProviders = string

type Energy struct {
	Value float64 `json:"value"`
	unit  string
}

func (e *Energy) Unit() string {
	return e.unit
}

func (e *Energy) UnmarshalJSON(data []byte) error {
	type unmarshaler Energy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Energy(value)
	e.unit = "kcal"
	return nil
}

func (e *Energy) MarshalJSON() ([]byte, error) {
	type embed Energy
	var marshaler = struct {
		embed
		Unit string `json:"unit"`
	}{
		embed: embed(*e),
		Unit:  "kcal",
	}
	return json.Marshal(marshaler)
}

type FallbackTimeZone struct {
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	Id string `json:"id"`
	// Slug for designated source
	SourceSlug string    `json:"source_slug"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type Fats struct {
	Saturated       *float64 `json:"saturated,omitempty"`
	Monounsaturated *float64 `json:"monounsaturated,omitempty"`
	Polyunsaturated *float64 `json:"polyunsaturated,omitempty"`
	Omega3          *float64 `json:"omega3,omitempty"`
	Omega6          *float64 `json:"omega6,omitempty"`
	Total           *float64 `json:"total,omitempty"`
}

type Fulfillment struct {
	OrderUuid   string `json:"order_uuid"`
	OrderNumber string `json:"order_number"`
}

// An enumeration.
type Gender string

const (
	GenderFemale  Gender = "female"
	GenderMale    Gender = "male"
	GenderOther   Gender = "other"
	GenderUnknown Gender = "unknown"
)

func NewGenderFromString(s string) (Gender, error) {
	switch s {
	case "female":
		return GenderFemale, nil
	case "male":
		return GenderMale, nil
	case "other":
		return GenderOther, nil
	case "unknown":
		return GenderUnknown, nil
	}
	var t Gender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g Gender) Ptr() *Gender {
	return &g
}

type GetMarkersResponse struct {
	Markers []*ClientFacingMarker `json:"markers,omitempty"`
	Total   int                   `json:"total"`
	Page    int                   `json:"page"`
	Size    int                   `json:"size"`
}

type GetOrdersResponse struct {
	Orders []*ClientFacingOrder `json:"orders,omitempty"`
	Total  int                  `json:"total"`
	Page   int                  `json:"page"`
	Size   int                  `json:"size"`
}

type HealthInsuranceCreateRequest struct {
	// An image of the front of the patient insurance card.
	FrontImage *HealthInsuranceCreateRequestFrontImage `json:"front_image,omitempty"`
	// An image of the back of the patient insurance card.
	BackImage *HealthInsuranceCreateRequestBackImage `json:"back_image,omitempty"`
	// An image of the patient signature for health insurance billing.
	PatientSignatureImage *HealthInsuranceCreateRequestPatientSignatureImage `json:"patient_signature_image,omitempty"`
	// Textual description of what are the patient symptoms and attempted treatments.
	Subjective *string `json:"subjective,omitempty"`
	// Textual description of what are the physician assessments and testing plans.
	AssessmentPlan *string `json:"assessment_plan,omitempty"`
	// Unique identifier representing a specific Health Insurance.
	PayorCode *string `json:"payor_code,omitempty"`
	// Insurance unique number assigned to a patient, usually present on the insurance card.
	InsuranceId *string `json:"insurance_id,omitempty"`
	// Relationship between the patient and the insurance contractor. Values can be (Self, Spouse, Other Relationship).
	ResponsibleRelationship *ResponsibleRelationship `json:"responsible_relationship,omitempty"`
	// Responsible details when the value of responsible_relationship is not 'Self'.
	ResponsibleDetails *PersonDetails `json:"responsible_details,omitempty"`
	// Diagnosis codes for insurance billing.
	DiagnosisCodes []string `json:"diagnosis_codes,omitempty"`
}

// An image of the back of the patient insurance card.
type HealthInsuranceCreateRequestBackImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewHealthInsuranceCreateRequestBackImageFromImageJpeg(value *Jpeg) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewHealthInsuranceCreateRequestBackImageFromImagePng(value *Png) *HealthInsuranceCreateRequestBackImage {
	return &HealthInsuranceCreateRequestBackImage{ContentType: "image/png", ImagePng: value}
}

func (h *HealthInsuranceCreateRequestBackImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImagePng = value
	}
	return nil
}

func (h HealthInsuranceCreateRequestBackImage) MarshalJSON() ([]byte, error) {
	switch h.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: h.ContentType,
			Jpeg:        h.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: h.ContentType,
			Png:         h.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type HealthInsuranceCreateRequestBackImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (h *HealthInsuranceCreateRequestBackImage) Accept(visitor HealthInsuranceCreateRequestBackImageVisitor) error {
	switch h.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		return visitor.VisitImageJpeg(h.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(h.ImagePng)
	}
}

// An image of the front of the patient insurance card.
type HealthInsuranceCreateRequestFrontImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewHealthInsuranceCreateRequestFrontImageFromImageJpeg(value *Jpeg) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewHealthInsuranceCreateRequestFrontImageFromImagePng(value *Png) *HealthInsuranceCreateRequestFrontImage {
	return &HealthInsuranceCreateRequestFrontImage{ContentType: "image/png", ImagePng: value}
}

func (h *HealthInsuranceCreateRequestFrontImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImagePng = value
	}
	return nil
}

func (h HealthInsuranceCreateRequestFrontImage) MarshalJSON() ([]byte, error) {
	switch h.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: h.ContentType,
			Jpeg:        h.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: h.ContentType,
			Png:         h.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type HealthInsuranceCreateRequestFrontImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (h *HealthInsuranceCreateRequestFrontImage) Accept(visitor HealthInsuranceCreateRequestFrontImageVisitor) error {
	switch h.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		return visitor.VisitImageJpeg(h.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(h.ImagePng)
	}
}

// An image of the patient signature for health insurance billing.
type HealthInsuranceCreateRequestPatientSignatureImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromImageJpeg(value *Jpeg) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewHealthInsuranceCreateRequestPatientSignatureImageFromImagePng(value *Png) *HealthInsuranceCreateRequestPatientSignatureImage {
	return &HealthInsuranceCreateRequestPatientSignatureImage{ContentType: "image/png", ImagePng: value}
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.ImagePng = value
	}
	return nil
}

func (h HealthInsuranceCreateRequestPatientSignatureImage) MarshalJSON() ([]byte, error) {
	switch h.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: h.ContentType,
			Jpeg:        h.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: h.ContentType,
			Png:         h.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type HealthInsuranceCreateRequestPatientSignatureImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (h *HealthInsuranceCreateRequestPatientSignatureImage) Accept(visitor HealthInsuranceCreateRequestPatientSignatureImageVisitor) error {
	switch h.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", h.ContentType, h)
	case "image/jpeg":
		return visitor.VisitImageJpeg(h.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(h.ImagePng)
	}
}

type HttpValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty"`
}

// An enumeration.
type IngestibleTimeseriesResource string

const (
	IngestibleTimeseriesResourceBloodPressure        IngestibleTimeseriesResource = "blood_pressure"
	IngestibleTimeseriesResourceBloodOxygen          IngestibleTimeseriesResource = "blood_oxygen"
	IngestibleTimeseriesResourceGlucose              IngestibleTimeseriesResource = "glucose"
	IngestibleTimeseriesResourceHeartrate            IngestibleTimeseriesResource = "heartrate"
	IngestibleTimeseriesResourceHeartrateVariability IngestibleTimeseriesResource = "heartrate_variability"
	IngestibleTimeseriesResourceWater                IngestibleTimeseriesResource = "water"
	IngestibleTimeseriesResourceCaffeine             IngestibleTimeseriesResource = "caffeine"
	IngestibleTimeseriesResourceMindfulnessMinutes   IngestibleTimeseriesResource = "mindfulness_minutes"
)

func NewIngestibleTimeseriesResourceFromString(s string) (IngestibleTimeseriesResource, error) {
	switch s {
	case "blood_pressure":
		return IngestibleTimeseriesResourceBloodPressure, nil
	case "blood_oxygen":
		return IngestibleTimeseriesResourceBloodOxygen, nil
	case "glucose":
		return IngestibleTimeseriesResourceGlucose, nil
	case "heartrate":
		return IngestibleTimeseriesResourceHeartrate, nil
	case "heartrate_variability":
		return IngestibleTimeseriesResourceHeartrateVariability, nil
	case "water":
		return IngestibleTimeseriesResourceWater, nil
	case "caffeine":
		return IngestibleTimeseriesResourceCaffeine, nil
	case "mindfulness_minutes":
		return IngestibleTimeseriesResourceMindfulnessMinutes, nil
	}
	var t IngestibleTimeseriesResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IngestibleTimeseriesResource) Ptr() *IngestibleTimeseriesResource {
	return &i
}

type Jpeg struct {
	Content string `json:"content"`
}

type LabResultsMetadata struct {
	Age            string  `json:"age"`
	Dob            string  `json:"dob"`
	Clia           *string `json:"clia_#,omitempty"`
	Patient        string  `json:"patient"`
	Provider       *string `json:"provider,omitempty"`
	Laboratory     *string `json:"laboratory,omitempty"`
	DateReported   string  `json:"date_reported"`
	DateCollected  *string `json:"date_collected,omitempty"`
	SpecimenNumber string  `json:"specimen_number"`
	DateReceived   *string `json:"date_received,omitempty"`
}

type LabResultsRaw struct {
	Metadata *LabResultsMetadata   `json:"metadata,omitempty"`
	Results  *LabResultsRawResults `json:"results,omitempty"`
}

type LabResultsRawResults struct {
	typeName            string
	BiomarkerResultList []*BiomarkerResult
	StringUnknownMap    map[string]any
}

func NewLabResultsRawResultsFromBiomarkerResultList(value []*BiomarkerResult) *LabResultsRawResults {
	return &LabResultsRawResults{typeName: "biomarkerResultList", BiomarkerResultList: value}
}

func NewLabResultsRawResultsFromStringUnknownMap(value map[string]any) *LabResultsRawResults {
	return &LabResultsRawResults{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (l *LabResultsRawResults) UnmarshalJSON(data []byte) error {
	var valueBiomarkerResultList []*BiomarkerResult
	if err := json.Unmarshal(data, &valueBiomarkerResultList); err == nil {
		l.typeName = "biomarkerResultList"
		l.BiomarkerResultList = valueBiomarkerResultList
		return nil
	}
	var valueStringUnknownMap map[string]any
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		l.typeName = "stringUnknownMap"
		l.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l LabResultsRawResults) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "biomarkerResultList":
		return json.Marshal(l.BiomarkerResultList)
	case "stringUnknownMap":
		return json.Marshal(l.StringUnknownMap)
	}
}

type LabResultsRawResultsVisitor interface {
	VisitBiomarkerResultList([]*BiomarkerResult) error
	VisitStringUnknownMap(map[string]any) error
}

func (l *LabResultsRawResults) Accept(visitor LabResultsRawResultsVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "biomarkerResultList":
		return visitor.VisitBiomarkerResultList(l.BiomarkerResultList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(l.StringUnknownMap)
	}
}

// The method used to perform a lab test.
type LabTestCollectionMethod string

const (
	LabTestCollectionMethodTestkit          LabTestCollectionMethod = "testkit"
	LabTestCollectionMethodWalkInTest       LabTestCollectionMethod = "walk_in_test"
	LabTestCollectionMethodAtHomePhlebotomy LabTestCollectionMethod = "at_home_phlebotomy"
)

func NewLabTestCollectionMethodFromString(s string) (LabTestCollectionMethod, error) {
	switch s {
	case "testkit":
		return LabTestCollectionMethodTestkit, nil
	case "walk_in_test":
		return LabTestCollectionMethodWalkInTest, nil
	case "at_home_phlebotomy":
		return LabTestCollectionMethodAtHomePhlebotomy, nil
	}
	var t LabTestCollectionMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestCollectionMethod) Ptr() *LabTestCollectionMethod {
	return &l
}

// The type of sample used to perform a lab test.
type LabTestSampleType string

const (
	LabTestSampleTypeDriedBloodSpot LabTestSampleType = "dried_blood_spot"
	LabTestSampleTypeSerum          LabTestSampleType = "serum"
	LabTestSampleTypeSaliva         LabTestSampleType = "saliva"
	LabTestSampleTypeUrine          LabTestSampleType = "urine"
)

func NewLabTestSampleTypeFromString(s string) (LabTestSampleType, error) {
	switch s {
	case "dried_blood_spot":
		return LabTestSampleTypeDriedBloodSpot, nil
	case "serum":
		return LabTestSampleTypeSerum, nil
	case "saliva":
		return LabTestSampleTypeSaliva, nil
	case "urine":
		return LabTestSampleTypeUrine, nil
	}
	var t LabTestSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabTestSampleType) Ptr() *LabTestSampleType {
	return &l
}

type LibreConfig struct {
	PracticeId map[string]any `json:"practice_id,omitempty"`
}

type LinkTokenExchangeResponse struct {
	// Link token to use to launch link widget
	LinkToken string `json:"link_token"`
}

type LngLat struct {
	Lng float64 `json:"lng"`
	Lat float64 `json:"lat"`
}

type Macros struct {
	Carbs   *float64 `json:"carbs,omitempty"`
	Protein *float64 `json:"protein,omitempty"`
	Fats    *Fats    `json:"fats,omitempty"`
	Alcohol *float64 `json:"alcohol,omitempty"`
	Water   *float64 `json:"water,omitempty"`
	Fibre   *float64 `json:"fibre,omitempty"`
	Sugar   *float64 `json:"sugar,omitempty"`
}

// An enumeration.
type ManualProviders string

const (
	ManualProvidersBeurerBle         ManualProviders = "beurer_ble"
	ManualProvidersOmronBle          ManualProviders = "omron_ble"
	ManualProvidersAccuchekBle       ManualProviders = "accuchek_ble"
	ManualProvidersContourBle        ManualProviders = "contour_ble"
	ManualProvidersFreestyleLibreBle ManualProviders = "freestyle_libre_ble"
	ManualProvidersAppleHealthKit    ManualProviders = "apple_health_kit"
	ManualProvidersManual            ManualProviders = "manual"
	ManualProvidersHealthConnect     ManualProviders = "health_connect"
)

func NewManualProvidersFromString(s string) (ManualProviders, error) {
	switch s {
	case "beurer_ble":
		return ManualProvidersBeurerBle, nil
	case "omron_ble":
		return ManualProvidersOmronBle, nil
	case "accuchek_ble":
		return ManualProvidersAccuchekBle, nil
	case "contour_ble":
		return ManualProvidersContourBle, nil
	case "freestyle_libre_ble":
		return ManualProvidersFreestyleLibreBle, nil
	case "apple_health_kit":
		return ManualProvidersAppleHealthKit, nil
	case "manual":
		return ManualProvidersManual, nil
	case "health_connect":
		return ManualProvidersHealthConnect, nil
	}
	var t ManualProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManualProviders) Ptr() *ManualProviders {
	return &m
}

// An enumeration.
type MarkerType string

const (
	MarkerTypeBiomarker MarkerType = "biomarker"
	MarkerTypePanel     MarkerType = "panel"
)

func NewMarkerTypeFromString(s string) (MarkerType, error) {
	switch s {
	case "biomarker":
		return MarkerTypeBiomarker, nil
	case "panel":
		return MarkerTypePanel, nil
	}
	var t MarkerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MarkerType) Ptr() *MarkerType {
	return &m
}

type MealData struct {
	Energy *Energy `json:"energy,omitempty"`
	Macros *Macros `json:"macros,omitempty"`
	Micros *Micros `json:"micros,omitempty"`
}

type MealInDbBaseClientFacingSource struct {
	Id         string               `json:"id"`
	UserId     string               `json:"user_id"`
	PriorityId int                  `json:"priority_id"`
	SourceId   int                  `json:"source_id"`
	ProviderId string               `json:"provider_id"`
	Timestamp  time.Time            `json:"timestamp"`
	Name       string               `json:"name"`
	Energy     *Energy              `json:"energy,omitempty"`
	Macros     *Macros              `json:"macros,omitempty"`
	Micros     *Micros              `json:"micros,omitempty"`
	Data       map[string]*MealData `json:"data,omitempty"`
	Source     *ClientFacingSource  `json:"source,omitempty"`
	CreatedAt  time.Time            `json:"created_at"`
	UpdatedAt  time.Time            `json:"updated_at"`
}

type MetricsResult struct {
	TeamId                          *MetricsResultTeamId     `json:"team_id,omitempty"`
	NumberOfConnectedSources        *int                     `json:"number_of_connected_sources,omitempty"`
	NumberOfUsers                   *int                     `json:"number_of_users,omitempty"`
	NumberOfErroredConnectedSources *int                     `json:"number_of_errored_connected_sources,omitempty"`
	NumberOfConnectedSourcesByWeek  []*TimeseriesMetricPoint `json:"number_of_connected_sources_by_week,omitempty"`
	NumberOfOrderedTests            *int                     `json:"number_of_ordered_tests,omitempty"`
}

type MetricsResultTeamId struct {
	typeName string
	String   string
	String   string
}

func NewMetricsResultTeamIdFromString(value string) *MetricsResultTeamId {
	return &MetricsResultTeamId{typeName: "string", String: value}
}

func NewMetricsResultTeamIdFromString(value string) *MetricsResultTeamId {
	return &MetricsResultTeamId{typeName: "string", String: value}
}

func (m *MetricsResultTeamId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		m.typeName = "string"
		m.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MetricsResultTeamId) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "string":
		return json.Marshal(m.String)
	case "string":
		return json.Marshal(m.String)
	}
}

type MetricsResultTeamIdVisitor interface {
	VisitString(string) error
	VisitString(string) error
}

func (m *MetricsResultTeamId) Accept(visitor MetricsResultTeamIdVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "string":
		return visitor.VisitString(m.String)
	case "string":
		return visitor.VisitString(m.String)
	}
}

type Micros struct {
	Minerals      map[string]float64 `json:"minerals,omitempty"`
	TraceElements map[string]float64 `json:"trace_elements,omitempty"`
	Vitamins      map[string]float64 `json:"vitamins,omitempty"`
}

// An enumeration.
type OAuthProviders string

const (
	OAuthProvidersOura      OAuthProviders = "oura"
	OAuthProvidersFitbit    OAuthProviders = "fitbit"
	OAuthProvidersGarmin    OAuthProviders = "garmin"
	OAuthProvidersStrava    OAuthProviders = "strava"
	OAuthProvidersWahoo     OAuthProviders = "wahoo"
	OAuthProvidersIhealth   OAuthProviders = "ihealth"
	OAuthProvidersWithings  OAuthProviders = "withings"
	OAuthProvidersGoogleFit OAuthProviders = "google_fit"
	OAuthProvidersDexcomV3  OAuthProviders = "dexcom_v3"
	OAuthProvidersPolar     OAuthProviders = "polar"
)

func NewOAuthProvidersFromString(s string) (OAuthProviders, error) {
	switch s {
	case "oura":
		return OAuthProvidersOura, nil
	case "fitbit":
		return OAuthProvidersFitbit, nil
	case "garmin":
		return OAuthProvidersGarmin, nil
	case "strava":
		return OAuthProvidersStrava, nil
	case "wahoo":
		return OAuthProvidersWahoo, nil
	case "ihealth":
		return OAuthProvidersIhealth, nil
	case "withings":
		return OAuthProvidersWithings, nil
	case "google_fit":
		return OAuthProvidersGoogleFit, nil
	case "dexcom_v3":
		return OAuthProvidersDexcomV3, nil
	case "polar":
		return OAuthProvidersPolar, nil
	}
	var t OAuthProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OAuthProviders) Ptr() *OAuthProviders {
	return &o
}

// An enumeration.
type OpenLoopResourceIdType string

const (
	OpenLoopResourceIdTypeAppointment     OpenLoopResourceIdType = "Appointment"
	OpenLoopResourceIdTypeFormAnswerGroup OpenLoopResourceIdType = "FormAnswerGroup"
	OpenLoopResourceIdTypeEntry           OpenLoopResourceIdType = "Entry"
	OpenLoopResourceIdTypeNote            OpenLoopResourceIdType = "Note"
)

func NewOpenLoopResourceIdTypeFromString(s string) (OpenLoopResourceIdType, error) {
	switch s {
	case "Appointment":
		return OpenLoopResourceIdTypeAppointment, nil
	case "FormAnswerGroup":
		return OpenLoopResourceIdTypeFormAnswerGroup, nil
	case "Entry":
		return OpenLoopResourceIdTypeEntry, nil
	case "Note":
		return OpenLoopResourceIdTypeNote, nil
	}
	var t OpenLoopResourceIdType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenLoopResourceIdType) Ptr() *OpenLoopResourceIdType {
	return &o
}

// An enumeration.
type OpenLoopWebhookType string

const (
	OpenLoopWebhookTypeAppointmentCreated             OpenLoopWebhookType = "appointment.created"
	OpenLoopWebhookTypeAppointmentUpdated             OpenLoopWebhookType = "appointment.updated"
	OpenLoopWebhookTypeAppointmentDeleted             OpenLoopWebhookType = "appointment.deleted"
	OpenLoopWebhookTypeBillingItemCreated             OpenLoopWebhookType = "billing_item.created"
	OpenLoopWebhookTypeBillingItemUpdated             OpenLoopWebhookType = "billing_item.updated"
	OpenLoopWebhookTypeCms1500Created                 OpenLoopWebhookType = "cms1500.created"
	OpenLoopWebhookTypeCms1500Updated                 OpenLoopWebhookType = "cms1500.updated"
	OpenLoopWebhookTypeCms1500Deleted                 OpenLoopWebhookType = "cms1500.deleted"
	OpenLoopWebhookTypeCommentCreated                 OpenLoopWebhookType = "comment.created"
	OpenLoopWebhookTypeCommentUpdated                 OpenLoopWebhookType = "comment.updated"
	OpenLoopWebhookTypeCommentDeleted                 OpenLoopWebhookType = "comment.deleted"
	OpenLoopWebhookTypeConversationMembershipViewed   OpenLoopWebhookType = "conversation_membership.viewed"
	OpenLoopWebhookTypeDocumentCreated                OpenLoopWebhookType = "document.created"
	OpenLoopWebhookTypeDocumentUpdated                OpenLoopWebhookType = "document.updated"
	OpenLoopWebhookTypeDocumentDeleted                OpenLoopWebhookType = "document.deleted"
	OpenLoopWebhookTypeEntryCreated                   OpenLoopWebhookType = "entry.created"
	OpenLoopWebhookTypeEntryUpdated                   OpenLoopWebhookType = "entry.updated"
	OpenLoopWebhookTypeEntryDeleted                   OpenLoopWebhookType = "entry.deleted"
	OpenLoopWebhookTypeFormAnswerGroupCreated         OpenLoopWebhookType = "form_answer_group.created"
	OpenLoopWebhookTypeFormAnswerGroupDeleted         OpenLoopWebhookType = "form_answer_group.deleted"
	OpenLoopWebhookTypeFormAnswerGroupLocked          OpenLoopWebhookType = "form_answer_group.locked"
	OpenLoopWebhookTypeGoalCreated                    OpenLoopWebhookType = "goal.created"
	OpenLoopWebhookTypeGoalUpdated                    OpenLoopWebhookType = "goal.updated"
	OpenLoopWebhookTypeGoalDeleted                    OpenLoopWebhookType = "goal.deleted"
	OpenLoopWebhookTypeGoalHistoryCreated             OpenLoopWebhookType = "goal_history.created"
	OpenLoopWebhookTypeInsuranceAuthorizationCreated  OpenLoopWebhookType = "insurance_authorization.created"
	OpenLoopWebhookTypeInsuranceAuthorizationUpdated  OpenLoopWebhookType = "insurance_authorization.updated"
	OpenLoopWebhookTypeInsuranceAuthorizationDeleted  OpenLoopWebhookType = "insurance_authorization.deleted"
	OpenLoopWebhookTypeMessageCreated                 OpenLoopWebhookType = "message.created"
	OpenLoopWebhookTypeMessageDeleted                 OpenLoopWebhookType = "message.deleted"
	OpenLoopWebhookTypeMetricEntryCreated             OpenLoopWebhookType = "metric_entry.created"
	OpenLoopWebhookTypeMetricEntryUpdated             OpenLoopWebhookType = "metric_entry.updated"
	OpenLoopWebhookTypeMetricEntryDeleted             OpenLoopWebhookType = "metric_entry.deleted"
	OpenLoopWebhookTypePatientCreated                 OpenLoopWebhookType = "patient.created"
	OpenLoopWebhookTypePatientUpdated                 OpenLoopWebhookType = "patient.updated"
	OpenLoopWebhookTypePaymentCreated                 OpenLoopWebhookType = "payment.created"
	OpenLoopWebhookTypePaymentUpdated                 OpenLoopWebhookType = "payment.updated"
	OpenLoopWebhookTypePaymentDeleted                 OpenLoopWebhookType = "payment.deleted"
	OpenLoopWebhookTypePolicyCreated                  OpenLoopWebhookType = "policy.created"
	OpenLoopWebhookTypePolicyUpdated                  OpenLoopWebhookType = "policy.updated"
	OpenLoopWebhookTypePolicyDeleted                  OpenLoopWebhookType = "policy.deleted"
	OpenLoopWebhookTypeRequestedFormCompletionCreated OpenLoopWebhookType = "requested_form_completion.created"
	OpenLoopWebhookTypeRequestedFormCompletionUpdated OpenLoopWebhookType = "requested_form_completion.updated"
	OpenLoopWebhookTypeRequestedFormCompletionDeleted OpenLoopWebhookType = "requested_form_completion.deleted"
	OpenLoopWebhookTypeTaskCreated                    OpenLoopWebhookType = "task.created"
	OpenLoopWebhookTypeTaskUpdated                    OpenLoopWebhookType = "task.updated"
	OpenLoopWebhookTypeTaskDeleted                    OpenLoopWebhookType = "task.deleted"
)

func NewOpenLoopWebhookTypeFromString(s string) (OpenLoopWebhookType, error) {
	switch s {
	case "appointment.created":
		return OpenLoopWebhookTypeAppointmentCreated, nil
	case "appointment.updated":
		return OpenLoopWebhookTypeAppointmentUpdated, nil
	case "appointment.deleted":
		return OpenLoopWebhookTypeAppointmentDeleted, nil
	case "billing_item.created":
		return OpenLoopWebhookTypeBillingItemCreated, nil
	case "billing_item.updated":
		return OpenLoopWebhookTypeBillingItemUpdated, nil
	case "cms1500.created":
		return OpenLoopWebhookTypeCms1500Created, nil
	case "cms1500.updated":
		return OpenLoopWebhookTypeCms1500Updated, nil
	case "cms1500.deleted":
		return OpenLoopWebhookTypeCms1500Deleted, nil
	case "comment.created":
		return OpenLoopWebhookTypeCommentCreated, nil
	case "comment.updated":
		return OpenLoopWebhookTypeCommentUpdated, nil
	case "comment.deleted":
		return OpenLoopWebhookTypeCommentDeleted, nil
	case "conversation_membership.viewed":
		return OpenLoopWebhookTypeConversationMembershipViewed, nil
	case "document.created":
		return OpenLoopWebhookTypeDocumentCreated, nil
	case "document.updated":
		return OpenLoopWebhookTypeDocumentUpdated, nil
	case "document.deleted":
		return OpenLoopWebhookTypeDocumentDeleted, nil
	case "entry.created":
		return OpenLoopWebhookTypeEntryCreated, nil
	case "entry.updated":
		return OpenLoopWebhookTypeEntryUpdated, nil
	case "entry.deleted":
		return OpenLoopWebhookTypeEntryDeleted, nil
	case "form_answer_group.created":
		return OpenLoopWebhookTypeFormAnswerGroupCreated, nil
	case "form_answer_group.deleted":
		return OpenLoopWebhookTypeFormAnswerGroupDeleted, nil
	case "form_answer_group.locked":
		return OpenLoopWebhookTypeFormAnswerGroupLocked, nil
	case "goal.created":
		return OpenLoopWebhookTypeGoalCreated, nil
	case "goal.updated":
		return OpenLoopWebhookTypeGoalUpdated, nil
	case "goal.deleted":
		return OpenLoopWebhookTypeGoalDeleted, nil
	case "goal_history.created":
		return OpenLoopWebhookTypeGoalHistoryCreated, nil
	case "insurance_authorization.created":
		return OpenLoopWebhookTypeInsuranceAuthorizationCreated, nil
	case "insurance_authorization.updated":
		return OpenLoopWebhookTypeInsuranceAuthorizationUpdated, nil
	case "insurance_authorization.deleted":
		return OpenLoopWebhookTypeInsuranceAuthorizationDeleted, nil
	case "message.created":
		return OpenLoopWebhookTypeMessageCreated, nil
	case "message.deleted":
		return OpenLoopWebhookTypeMessageDeleted, nil
	case "metric_entry.created":
		return OpenLoopWebhookTypeMetricEntryCreated, nil
	case "metric_entry.updated":
		return OpenLoopWebhookTypeMetricEntryUpdated, nil
	case "metric_entry.deleted":
		return OpenLoopWebhookTypeMetricEntryDeleted, nil
	case "patient.created":
		return OpenLoopWebhookTypePatientCreated, nil
	case "patient.updated":
		return OpenLoopWebhookTypePatientUpdated, nil
	case "payment.created":
		return OpenLoopWebhookTypePaymentCreated, nil
	case "payment.updated":
		return OpenLoopWebhookTypePaymentUpdated, nil
	case "payment.deleted":
		return OpenLoopWebhookTypePaymentDeleted, nil
	case "policy.created":
		return OpenLoopWebhookTypePolicyCreated, nil
	case "policy.updated":
		return OpenLoopWebhookTypePolicyUpdated, nil
	case "policy.deleted":
		return OpenLoopWebhookTypePolicyDeleted, nil
	case "requested_form_completion.created":
		return OpenLoopWebhookTypeRequestedFormCompletionCreated, nil
	case "requested_form_completion.updated":
		return OpenLoopWebhookTypeRequestedFormCompletionUpdated, nil
	case "requested_form_completion.deleted":
		return OpenLoopWebhookTypeRequestedFormCompletionDeleted, nil
	case "task.created":
		return OpenLoopWebhookTypeTaskCreated, nil
	case "task.updated":
		return OpenLoopWebhookTypeTaskUpdated, nil
	case "task.deleted":
		return OpenLoopWebhookTypeTaskDeleted, nil
	}
	var t OpenLoopWebhookType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenLoopWebhookType) Ptr() *OpenLoopWebhookType {
	return &o
}

// An enumeration.
type OrderStatus string

const (
	OrderStatusReceivedWalkInTestOrdered                            OrderStatus = "received.walk_in_test.ordered"
	OrderStatusReceivedWalkInTestRequisitionCreated                 OrderStatus = "received.walk_in_test.requisition_created"
	OrderStatusCompletedWalkInTestCompleted                         OrderStatus = "completed.walk_in_test.completed"
	OrderStatusFailedWalkInTestSampleError                          OrderStatus = "failed.walk_in_test.sample_error"
	OrderStatusCancelledWalkInTestCancelled                         OrderStatus = "cancelled.walk_in_test.cancelled"
	OrderStatusReceivedAtHomePhlebotomyOrdered                      OrderStatus = "received.at_home_phlebotomy.ordered"
	OrderStatusReceivedAtHomePhlebotomyRequisitionCreated           OrderStatus = "received.at_home_phlebotomy.requisition_created"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_scheduled"
	OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted        OrderStatus = "collecting_sample.at_home_phlebotomy.draw_completed"
	OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled OrderStatus = "collecting_sample.at_home_phlebotomy.appointment_cancelled"
	OrderStatusCompletedAtHomePhlebotomyCompleted                   OrderStatus = "completed.at_home_phlebotomy.completed"
	OrderStatusCancelledAtHomePhlebotomyCancelled                   OrderStatus = "cancelled.at_home_phlebotomy.cancelled"
	OrderStatusReceivedTestkitOrdered                               OrderStatus = "received.testkit.ordered"
	OrderStatusReceivedTestkitAwaitingRegistration                  OrderStatus = "received.testkit.awaiting_registration"
	OrderStatusReceivedTestkitRequisitionCreated                    OrderStatus = "received.testkit.requisition_created"
	OrderStatusReceivedTestkitRegistered                            OrderStatus = "received.testkit.registered"
	OrderStatusCollectingSampleTestkitTransitCustomer               OrderStatus = "collecting_sample.testkit.transit_customer"
	OrderStatusCollectingSampleTestkitOutForDelivery                OrderStatus = "collecting_sample.testkit.out_for_delivery"
	OrderStatusCollectingSampleTestkitWithCustomer                  OrderStatus = "collecting_sample.testkit.with_customer"
	OrderStatusCollectingSampleTestkitTransitLab                    OrderStatus = "collecting_sample.testkit.transit_lab"
	OrderStatusSampleWithLabTestkitDeliveredToLab                   OrderStatus = "sample_with_lab.testkit.delivered_to_lab"
	OrderStatusCompletedTestkitCompleted                            OrderStatus = "completed.testkit.completed"
	OrderStatusFailedTestkitFailureToDeliverToCustomer              OrderStatus = "failed.testkit.failure_to_deliver_to_customer"
	OrderStatusFailedTestkitFailureToDeliverToLab                   OrderStatus = "failed.testkit.failure_to_deliver_to_lab"
	OrderStatusFailedTestkitSampleError                             OrderStatus = "failed.testkit.sample_error"
	OrderStatusFailedTestkitLost                                    OrderStatus = "failed.testkit.lost"
	OrderStatusCancelledTestkitCancelled                            OrderStatus = "cancelled.testkit.cancelled"
	OrderStatusCancelledTestkitDoNotProcess                         OrderStatus = "cancelled.testkit.do_not_process"
)

func NewOrderStatusFromString(s string) (OrderStatus, error) {
	switch s {
	case "received.walk_in_test.ordered":
		return OrderStatusReceivedWalkInTestOrdered, nil
	case "received.walk_in_test.requisition_created":
		return OrderStatusReceivedWalkInTestRequisitionCreated, nil
	case "completed.walk_in_test.completed":
		return OrderStatusCompletedWalkInTestCompleted, nil
	case "failed.walk_in_test.sample_error":
		return OrderStatusFailedWalkInTestSampleError, nil
	case "cancelled.walk_in_test.cancelled":
		return OrderStatusCancelledWalkInTestCancelled, nil
	case "received.at_home_phlebotomy.ordered":
		return OrderStatusReceivedAtHomePhlebotomyOrdered, nil
	case "received.at_home_phlebotomy.requisition_created":
		return OrderStatusReceivedAtHomePhlebotomyRequisitionCreated, nil
	case "collecting_sample.at_home_phlebotomy.appointment_scheduled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentScheduled, nil
	case "collecting_sample.at_home_phlebotomy.draw_completed":
		return OrderStatusCollectingSampleAtHomePhlebotomyDrawCompleted, nil
	case "collecting_sample.at_home_phlebotomy.appointment_cancelled":
		return OrderStatusCollectingSampleAtHomePhlebotomyAppointmentCancelled, nil
	case "completed.at_home_phlebotomy.completed":
		return OrderStatusCompletedAtHomePhlebotomyCompleted, nil
	case "cancelled.at_home_phlebotomy.cancelled":
		return OrderStatusCancelledAtHomePhlebotomyCancelled, nil
	case "received.testkit.ordered":
		return OrderStatusReceivedTestkitOrdered, nil
	case "received.testkit.awaiting_registration":
		return OrderStatusReceivedTestkitAwaitingRegistration, nil
	case "received.testkit.requisition_created":
		return OrderStatusReceivedTestkitRequisitionCreated, nil
	case "received.testkit.registered":
		return OrderStatusReceivedTestkitRegistered, nil
	case "collecting_sample.testkit.transit_customer":
		return OrderStatusCollectingSampleTestkitTransitCustomer, nil
	case "collecting_sample.testkit.out_for_delivery":
		return OrderStatusCollectingSampleTestkitOutForDelivery, nil
	case "collecting_sample.testkit.with_customer":
		return OrderStatusCollectingSampleTestkitWithCustomer, nil
	case "collecting_sample.testkit.transit_lab":
		return OrderStatusCollectingSampleTestkitTransitLab, nil
	case "sample_with_lab.testkit.delivered_to_lab":
		return OrderStatusSampleWithLabTestkitDeliveredToLab, nil
	case "completed.testkit.completed":
		return OrderStatusCompletedTestkitCompleted, nil
	case "failed.testkit.failure_to_deliver_to_customer":
		return OrderStatusFailedTestkitFailureToDeliverToCustomer, nil
	case "failed.testkit.failure_to_deliver_to_lab":
		return OrderStatusFailedTestkitFailureToDeliverToLab, nil
	case "failed.testkit.sample_error":
		return OrderStatusFailedTestkitSampleError, nil
	case "failed.testkit.lost":
		return OrderStatusFailedTestkitLost, nil
	case "cancelled.testkit.cancelled":
		return OrderStatusCancelledTestkitCancelled, nil
	case "cancelled.testkit.do_not_process":
		return OrderStatusCancelledTestkitDoNotProcess, nil
	}
	var t OrderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderStatus) Ptr() *OrderStatus {
	return &o
}

// An enumeration.
type OrderTopLevelStatus string

const (
	OrderTopLevelStatusReceived         OrderTopLevelStatus = "received"
	OrderTopLevelStatusCollectingSample OrderTopLevelStatus = "collecting_sample"
	OrderTopLevelStatusSampleWithLab    OrderTopLevelStatus = "sample_with_lab"
	OrderTopLevelStatusCompleted        OrderTopLevelStatus = "completed"
	OrderTopLevelStatusCancelled        OrderTopLevelStatus = "cancelled"
	OrderTopLevelStatusFailed           OrderTopLevelStatus = "failed"
)

func NewOrderTopLevelStatusFromString(s string) (OrderTopLevelStatus, error) {
	switch s {
	case "received":
		return OrderTopLevelStatusReceived, nil
	case "collecting_sample":
		return OrderTopLevelStatusCollectingSample, nil
	case "sample_with_lab":
		return OrderTopLevelStatusSampleWithLab, nil
	case "completed":
		return OrderTopLevelStatusCompleted, nil
	case "cancelled":
		return OrderTopLevelStatusCancelled, nil
	case "failed":
		return OrderTopLevelStatusFailed, nil
	}
	var t OrderTopLevelStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderTopLevelStatus) Ptr() *OrderTopLevelStatus {
	return &o
}

type PaginatedUsersResponse struct {
	Users  []*ClientFacingUser `json:"users,omitempty"`
	Total  int                 `json:"total"`
	Offset int                 `json:"offset"`
	Limit  int                 `json:"limit"`
}

// An enumeration.
type PasswordProviders string

const (
	PasswordProvidersWhoop        PasswordProviders = "whoop"
	PasswordProvidersRenpho       PasswordProviders = "renpho"
	PasswordProvidersPeloton      PasswordProviders = "peloton"
	PasswordProvidersZwift        PasswordProviders = "zwift"
	PasswordProvidersEightSleep   PasswordProviders = "eight_sleep"
	PasswordProvidersBeurerApi    PasswordProviders = "beurer_api"
	PasswordProvidersDexcom       PasswordProviders = "dexcom"
	PasswordProvidersHammerhead   PasswordProviders = "hammerhead"
	PasswordProvidersMyFitnessPal PasswordProviders = "my_fitness_pal"
)

func NewPasswordProvidersFromString(s string) (PasswordProviders, error) {
	switch s {
	case "whoop":
		return PasswordProvidersWhoop, nil
	case "renpho":
		return PasswordProvidersRenpho, nil
	case "peloton":
		return PasswordProvidersPeloton, nil
	case "zwift":
		return PasswordProvidersZwift, nil
	case "eight_sleep":
		return PasswordProvidersEightSleep, nil
	case "beurer_api":
		return PasswordProvidersBeurerApi, nil
	case "dexcom":
		return PasswordProvidersDexcom, nil
	case "hammerhead":
		return PasswordProvidersHammerhead, nil
	case "my_fitness_pal":
		return PasswordProvidersMyFitnessPal, nil
	}
	var t PasswordProviders
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PasswordProviders) Ptr() *PasswordProviders {
	return &p
}

type PatientAddressCompatible struct {
	ReceiverName *string `json:"receiver_name,omitempty"`
	Street       string  `json:"street"`
	StreetNumber *string `json:"street_number,omitempty"`
	City         string  `json:"city"`
	State        string  `json:"state"`
	Zip          string  `json:"zip"`
	Country      string  `json:"country"`
	PhoneNumber  *string `json:"phone_number,omitempty"`
}

type PatientDetails struct {
	// <span style="white-space: nowrap">`non-empty`</span> <span style="white-space: nowrap">`<= 50 characters`</span>
	FirstName string `json:"first_name"`
	// <span style="white-space: nowrap">`non-empty`</span> <span style="white-space: nowrap">`<= 50 characters`</span>
	LastName    string    `json:"last_name"`
	Dob         time.Time `json:"dob"`
	Gender      Gender    `json:"gender,omitempty"`
	PhoneNumber string    `json:"phone_number"`
	Email       *string   `json:"email,omitempty"`
}

type PatientDetailsCompatible struct {
	FirstName   *string   `json:"first_name,omitempty"`
	LastName    *string   `json:"last_name,omitempty"`
	Dob         time.Time `json:"dob"`
	Gender      Gender    `json:"gender,omitempty"`
	PhoneNumber *string   `json:"phone_number,omitempty"`
	Email       *string   `json:"email,omitempty"`
}

type PersonDetails struct {
	FirstName   string   `json:"first_name"`
	LastName    string   `json:"last_name"`
	Address     *Address `json:"address,omitempty"`
	PhoneNumber string   `json:"phone_number"`
	PhoneType   *string  `json:"phone_type,omitempty"`
}

type PhlebotomyAreaInfo struct {
	IsServed bool `json:"is_served"`
}

type PhysicianClientFacing struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Npi       string `json:"npi"`
}

type PhysicianCreateRequest struct {
	FirstName      string   `json:"first_name"`
	LastName       string   `json:"last_name"`
	Email          *string  `json:"email,omitempty"`
	Npi            string   `json:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty"`
	// An image of the physician signature for health insurance billing
	SignatureImage *PhysicianCreateRequestSignatureImage `json:"signature_image,omitempty"`
}

type PhysicianCreateRequestBase struct {
	FirstName      string   `json:"first_name"`
	LastName       string   `json:"last_name"`
	Email          *string  `json:"email,omitempty"`
	Npi            string   `json:"npi"`
	LicensedStates []string `json:"licensed_states,omitempty"`
}

// An image of the physician signature for health insurance billing
type PhysicianCreateRequestSignatureImage struct {
	ContentType string
	ImageJpeg   *Jpeg
	ImagePng    *Png
}

func NewPhysicianCreateRequestSignatureImageFromImageJpeg(value *Jpeg) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{ContentType: "image/jpeg", ImageJpeg: value}
}

func NewPhysicianCreateRequestSignatureImageFromImagePng(value *Png) *PhysicianCreateRequestSignatureImage {
	return &PhysicianCreateRequestSignatureImage{ContentType: "image/png", ImagePng: value}
}

func (p *PhysicianCreateRequestSignatureImage) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ContentType string `json:"content_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.ContentType = unmarshaler.ContentType
	switch unmarshaler.ContentType {
	case "image/jpeg":
		value := new(Jpeg)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ImageJpeg = value
	case "image/png":
		value := new(Png)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ImagePng = value
	}
	return nil
}

func (p PhysicianCreateRequestSignatureImage) MarshalJSON() ([]byte, error) {
	switch p.ContentType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.ContentType, p)
	case "image/jpeg":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Jpeg
		}{
			ContentType: p.ContentType,
			Jpeg:        p.ImageJpeg,
		}
		return json.Marshal(marshaler)
	case "image/png":
		var marshaler = struct {
			ContentType string `json:"content_type"`
			*Png
		}{
			ContentType: p.ContentType,
			Png:         p.ImagePng,
		}
		return json.Marshal(marshaler)
	}
}

type PhysicianCreateRequestSignatureImageVisitor interface {
	VisitImageJpeg(*Jpeg) error
	VisitImagePng(*Png) error
}

func (p *PhysicianCreateRequestSignatureImage) Accept(visitor PhysicianCreateRequestSignatureImageVisitor) error {
	switch p.ContentType {
	default:
		return fmt.Errorf("invalid type %s in %T", p.ContentType, p)
	case "image/jpeg":
		return visitor.VisitImageJpeg(p.ImageJpeg)
	case "image/png":
		return visitor.VisitImagePng(p.ImagePng)
	}
}

// An enumeration.
type PhysicianNetworkT string

const (
	PhysicianNetworkTWheel    PhysicianNetworkT = "WHEEL"
	PhysicianNetworkTOpenloop PhysicianNetworkT = "OPENLOOP"
)

func NewPhysicianNetworkTFromString(s string) (PhysicianNetworkT, error) {
	switch s {
	case "WHEEL":
		return PhysicianNetworkTWheel, nil
	case "OPENLOOP":
		return PhysicianNetworkTOpenloop, nil
	}
	var t PhysicianNetworkT
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PhysicianNetworkT) Ptr() *PhysicianNetworkT {
	return &p
}

type Png struct {
	Content string `json:"content"`
}

type PostOrderResponse struct {
	Order   *ClientFacingOrder `json:"order,omitempty"`
	Status  string             `json:"status"`
	Message string             `json:"message"`
}

type Priority struct {
	Id       int     `json:"id"`
	Priority int     `json:"priority"`
	TeamId   string  `json:"team_id"`
	SourceId int     `json:"source_id"`
	DataType *string `json:"data_type,omitempty"`
}

type PriorityInDb struct {
	Id       int     `json:"id"`
	Priority int     `json:"priority"`
	TeamId   string  `json:"team_id"`
	SourceId int     `json:"source_id"`
	DataType *string `json:"data_type,omitempty"`
}

type ProfileInDb struct {
	Data       *string             `json:"data,omitempty"`
	UserId     string              `json:"user_id"`
	SourceId   int                 `json:"source_id"`
	PriorityId *int                `json:"priority_id,omitempty"`
	Id         string              `json:"id"`
	Source     *ClientFacingSource `json:"source,omitempty"`
	UpdatedAt  *time.Time          `json:"updated_at,omitempty"`
}

type ProviderLinkResponse struct {
	Provider   PasswordProviders `json:"provider,omitempty"`
	Connected  bool              `json:"connected"`
	ProviderId *string           `json:"provider_id,omitempty"`
}

// An enumeration.
type Providers string

const (
	ProvidersOura              Providers = "oura"
	ProvidersFitbit            Providers = "fitbit"
	ProvidersGarmin            Providers = "garmin"
	ProvidersWhoop             Providers = "whoop"
	ProvidersStrava            Providers = "strava"
	ProvidersRenpho            Providers = "renpho"
	ProvidersPeloton           Providers = "peloton"
	ProvidersWahoo             Providers = "wahoo"
	ProvidersZwift             Providers = "zwift"
	ProvidersFreestyleLibre    Providers = "freestyle_libre"
	ProvidersFreestyleLibreBle Providers = "freestyle_libre_ble"
	ProvidersEightSleep        Providers = "eight_sleep"
	ProvidersWithings          Providers = "withings"
	ProvidersAppleHealthKit    Providers = "apple_health_kit"
	ProvidersManual            Providers = "manual"
	ProvidersIhealth           Providers = "ihealth"
	ProvidersGoogleFit         Providers = "google_fit"
	ProvidersBeurerApi         Providers = "beurer_api"
	ProvidersBeurerBle         Providers = "beurer_ble"
	ProvidersOmronBle          Providers = "omron_ble"
	ProvidersAccuchekBle       Providers = "accuchek_ble"
	ProvidersContourBle        Providers = "contour_ble"
	ProvidersDexcom            Providers = "dexcom"
	ProvidersDexcomV3          Providers = "dexcom_v3"
	ProvidersHammerhead        Providers = "hammerhead"
	ProvidersMyFitnessPal      Providers = "my_fitness_pal"
	ProvidersHealthConnect     Providers = "health_connect"
	ProvidersPolar             Providers = "polar"
)

func NewProvidersFromString(s string) (Providers, error) {
	switch s {
	case "oura":
		return ProvidersOura, nil
	case "fitbit":
		return ProvidersFitbit, nil
	case "garmin":
		return ProvidersGarmin, nil
	case "whoop":
		return ProvidersWhoop, nil
	case "strava":
		return ProvidersStrava, nil
	case "renpho":
		return ProvidersRenpho, nil
	case "peloton":
		return ProvidersPeloton, nil
	case "wahoo":
		return ProvidersWahoo, nil
	case "zwift":
		return ProvidersZwift, nil
	case "freestyle_libre":
		return ProvidersFreestyleLibre, nil
	case "freestyle_libre_ble":
		return ProvidersFreestyleLibreBle, nil
	case "eight_sleep":
		return ProvidersEightSleep, nil
	case "withings":
		return ProvidersWithings, nil
	case "apple_health_kit":
		return ProvidersAppleHealthKit, nil
	case "manual":
		return ProvidersManual, nil
	case "ihealth":
		return ProvidersIhealth, nil
	case "google_fit":
		return ProvidersGoogleFit, nil
	case "beurer_api":
		return ProvidersBeurerApi, nil
	case "beurer_ble":
		return ProvidersBeurerBle, nil
	case "omron_ble":
		return ProvidersOmronBle, nil
	case "accuchek_ble":
		return ProvidersAccuchekBle, nil
	case "contour_ble":
		return ProvidersContourBle, nil
	case "dexcom":
		return ProvidersDexcom, nil
	case "dexcom_v3":
		return ProvidersDexcomV3, nil
	case "hammerhead":
		return ProvidersHammerhead, nil
	case "my_fitness_pal":
		return ProvidersMyFitnessPal, nil
	case "health_connect":
		return ProvidersHealthConnect, nil
	case "polar":
		return ProvidersPolar, nil
	}
	var t Providers
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Providers) Ptr() *Providers {
	return &p
}

type RawActivity struct {
	Activity []*ActivityV2InDb `json:"activity,omitempty"`
}

type RawBody struct {
	Body []*BodyV2InDb `json:"body,omitempty"`
}

type RawDevices struct {
	Devices []*DeviceV2InDb `json:"devices,omitempty"`
}

type RawProfile struct {
	Profile *ProfileInDb `json:"profile,omitempty"`
}

type RawSleep struct {
	Sleep []*SleepV2InDb `json:"sleep,omitempty"`
}

type RawWorkout struct {
	Workouts []*WorkoutV2InDb `json:"workouts,omitempty"`
}

// An enumeration.
type Region string

const (
	RegionUs Region = "us"
	RegionEu Region = "eu"
	RegionSg Region = "sg"
	RegionDe Region = "de"
	RegionAu Region = "au"
	RegionBr Region = "br"
	RegionNl Region = "nl"
)

func NewRegionFromString(s string) (Region, error) {
	switch s {
	case "us":
		return RegionUs, nil
	case "eu":
		return RegionEu, nil
	case "sg":
		return RegionSg, nil
	case "de":
		return RegionDe, nil
	case "au":
		return RegionAu, nil
	case "br":
		return RegionBr, nil
	case "nl":
		return RegionNl, nil
	}
	var t Region
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Region) Ptr() *Region {
	return &r
}

// An enumeration.
type ResponsibleRelationship string

const (
	ResponsibleRelationshipSelf              ResponsibleRelationship = "Self"
	ResponsibleRelationshipSpouse            ResponsibleRelationship = "Spouse"
	ResponsibleRelationshipOtherRelationship ResponsibleRelationship = "Other Relationship"
)

func NewResponsibleRelationshipFromString(s string) (ResponsibleRelationship, error) {
	switch s {
	case "Self":
		return ResponsibleRelationshipSelf, nil
	case "Spouse":
		return ResponsibleRelationshipSpouse, nil
	case "Other Relationship":
		return ResponsibleRelationshipOtherRelationship, nil
	}
	var t ResponsibleRelationship
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponsibleRelationship) Ptr() *ResponsibleRelationship {
	return &r
}

type ShippingAddress struct {
	ReceiverName string  `json:"receiver_name"`
	FirstLine    string  `json:"first_line"`
	SecondLine   *string `json:"second_line,omitempty"`
	City         string  `json:"city"`
	State        string  `json:"state"`
	Zip          string  `json:"zip"`
	Country      string  `json:"country"`
	PhoneNumber  string  `json:"phone_number"`
}

type SleepV2InDb struct {
	Timestamp  time.Time           `json:"timestamp"`
	Data       *string             `json:"data,omitempty"`
	ProviderId string              `json:"provider_id"`
	UserId     string              `json:"user_id"`
	SourceId   int                 `json:"source_id"`
	PriorityId *int                `json:"priority_id,omitempty"`
	Id         string              `json:"id"`
	Source     *ClientFacingSource `json:"source,omitempty"`
	Priority   *int                `json:"priority,omitempty"`
}

type Source struct {
	Name            string          `json:"name"`
	Slug            string          `json:"slug"`
	Description     string          `json:"description"`
	Logo            string          `json:"logo"`
	Group           *string         `json:"group,omitempty"`
	OauthUrl        *string         `json:"oauth_url,omitempty"`
	AuthType        *SourceAuthType `json:"auth_type,omitempty"`
	IsActive        *bool           `json:"is_active,omitempty"`
	BackfillNumDays *int            `json:"backfill_num_days,omitempty"`
	Id              int             `json:"id"`
}

// An enumeration.
type SourceAuthType string

const (
	SourceAuthTypeOauth     SourceAuthType = "oauth"
	SourceAuthTypeTeamOauth SourceAuthType = "team_oauth"
	SourceAuthTypeSdk       SourceAuthType = "sdk"
	SourceAuthTypePassword  SourceAuthType = "password"
	SourceAuthTypeEmail     SourceAuthType = "email"
	SourceAuthTypeApp       SourceAuthType = "app"
	SourceAuthTypeEmpty     SourceAuthType = ""
)

func NewSourceAuthTypeFromString(s string) (SourceAuthType, error) {
	switch s {
	case "oauth":
		return SourceAuthTypeOauth, nil
	case "team_oauth":
		return SourceAuthTypeTeamOauth, nil
	case "sdk":
		return SourceAuthTypeSdk, nil
	case "password":
		return SourceAuthTypePassword, nil
	case "email":
		return SourceAuthTypeEmail, nil
	case "app":
		return SourceAuthTypeApp, nil
	case "":
		return SourceAuthTypeEmpty, nil
	}
	var t SourceAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAuthType) Ptr() *SourceAuthType {
	return &s
}

type SourceLink struct {
	Id             int             `json:"id"`
	Name           string          `json:"name"`
	Slug           string          `json:"slug"`
	Description    string          `json:"description"`
	Logo           string          `json:"logo"`
	OauthUrl       *string         `json:"oauth_url,omitempty"`
	AuthType       *SourceAuthType `json:"auth_type,omitempty"`
	FormComponents map[string]any  `json:"form_components,omitempty"`
}

type TeamConfig struct {
	Libreview    *LibreConfig `json:"libreview,omitempty"`
	TextsEnabled *bool        `json:"texts_enabled,omitempty"`
}

type TeamInDb struct {
	SvixAppId                           *string                                `json:"svix_app_id,omitempty"`
	ClientId                            *string                                `json:"client_id,omitempty"`
	ClientSecret                        *string                                `json:"client_secret,omitempty"`
	ApiKey                              *string                                `json:"api_key,omitempty"`
	AirtableApiKey                      *string                                `json:"airtable_api_key,omitempty"`
	AirtableBaseId                      *string                                `json:"airtable_base_id,omitempty"`
	WebhookSecret                       *string                                `json:"webhook_secret,omitempty"`
	FfWheelEnabled                      *bool                                  `json:"ff_wheel_enabled,omitempty"`
	FfAppleMobileAppEnabled             *bool                                  `json:"ff_apple_mobile_app_enabled,omitempty"`
	LabTestsPatientCommunicationEnabled bool                                   `json:"lab_tests_patient_communication_enabled"`
	LabTestDelegatedFlowEnabled         *bool                                  `json:"lab_test_delegated_flow_enabled,omitempty"`
	PhysicianNetwork                    *PhysicianNetworkT                     `json:"physician_network,omitempty"`
	Id                                  string                                 `json:"id"`
	Name                                string                                 `json:"name"`
	Users                               []*TeamUser                            `json:"users,omitempty"`
	ConnectedSources                    []*ConnectedSourceClientFacingRedacted `json:"connected_sources,omitempty"`
	Configuration                       map[string]any                         `json:"configuration,omitempty"`
	Priorities                          []*PriorityInDb                        `json:"priorities,omitempty"`
	SubscriptionStatus                  *string                                `json:"subscription_status,omitempty"`
	ApiKeys                             []*ApiKeyInDb                          `json:"api_keys,omitempty"`
	LogoUrl                             *string                                `json:"logo_url,omitempty"`
}

type TeamUser struct {
	// Alias id to a specific field.
	Id string `json:"id"`
	// Your team id.
	TeamId string `json:"team_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id"`
	// When your item is created
	CreatedOn time.Time `json:"created_on"`
	// A list of the users connected sources.
	ConnectedSources []*ConnectedSourceClientFacing `json:"connected_sources,omitempty"`
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	FallbackTimeZone *FallbackTimeZone `json:"fallback_time_zone,omitempty"`
}

type TimeSlot struct {
	BookingKey               *string    `json:"booking_key,omitempty"`
	Start                    time.Time  `json:"start"`
	End                      time.Time  `json:"end"`
	ExpiresAt                *time.Time `json:"expires_at,omitempty"`
	Price                    float64    `json:"price"`
	IsPriority               bool       `json:"is_priority"`
	NumAppointmentsAvailable int        `json:"num_appointments_available"`
}

type TimeseriesMetricPoint struct {
	Date  time.Time `json:"date"`
	Value float64   `json:"value"`
}

// The REST API name of timeseries resources
// Should match vital_core.ee.schemas.webhook.ClientFacingResource unless there is a strong
// reason not to.
type TimeseriesResource string

const (
	TimeseriesResourceCaloriesActive           TimeseriesResource = "calories_active"
	TimeseriesResourceCaloriesBasal            TimeseriesResource = "calories_basal"
	TimeseriesResourceDistance                 TimeseriesResource = "distance"
	TimeseriesResourceBloodOxygen              TimeseriesResource = "blood_oxygen"
	TimeseriesResourceBloodPressure            TimeseriesResource = "blood_pressure"
	TimeseriesResourceBodyFat                  TimeseriesResource = "body/fat"
	TimeseriesResourceBodyWeight               TimeseriesResource = "body/weight"
	TimeseriesResourceCholesterol              TimeseriesResource = "cholesterol"
	TimeseriesResourceCholesterolLdl           TimeseriesResource = "cholesterol/ldl"
	TimeseriesResourceCholesterolHdl           TimeseriesResource = "cholesterol/hdl"
	TimeseriesResourceCholesterolTotal         TimeseriesResource = "cholesterol/total"
	TimeseriesResourceCholesterolTriglycerides TimeseriesResource = "cholesterol/triglycerides"
	TimeseriesResourceFloorsClimbed            TimeseriesResource = "floors_climbed"
	TimeseriesResourceGlucose                  TimeseriesResource = "glucose"
	TimeseriesResourceHeartrate                TimeseriesResource = "heartrate"
	TimeseriesResourceHrv                      TimeseriesResource = "hrv"
	TimeseriesResourceHeartrateVariability     TimeseriesResource = "heartrate_variability"
	TimeseriesResourceHypnogram                TimeseriesResource = "hypnogram"
	TimeseriesResourceIge                      TimeseriesResource = "ige"
	TimeseriesResourceIgg                      TimeseriesResource = "igg"
	TimeseriesResourceRespiratoryRate          TimeseriesResource = "respiratory_rate"
	TimeseriesResourceSteps                    TimeseriesResource = "steps"
	TimeseriesResourceStressLevel              TimeseriesResource = "stress_level"
	TimeseriesResourceVo2Max                   TimeseriesResource = "vo2_max"
	TimeseriesResourceWater                    TimeseriesResource = "water"
	TimeseriesResourceCaffeine                 TimeseriesResource = "caffeine"
	TimeseriesResourceMindfulnessMinutes       TimeseriesResource = "mindfulness_minutes"
)

func NewTimeseriesResourceFromString(s string) (TimeseriesResource, error) {
	switch s {
	case "calories_active":
		return TimeseriesResourceCaloriesActive, nil
	case "calories_basal":
		return TimeseriesResourceCaloriesBasal, nil
	case "distance":
		return TimeseriesResourceDistance, nil
	case "blood_oxygen":
		return TimeseriesResourceBloodOxygen, nil
	case "blood_pressure":
		return TimeseriesResourceBloodPressure, nil
	case "body/fat":
		return TimeseriesResourceBodyFat, nil
	case "body/weight":
		return TimeseriesResourceBodyWeight, nil
	case "cholesterol":
		return TimeseriesResourceCholesterol, nil
	case "cholesterol/ldl":
		return TimeseriesResourceCholesterolLdl, nil
	case "cholesterol/hdl":
		return TimeseriesResourceCholesterolHdl, nil
	case "cholesterol/total":
		return TimeseriesResourceCholesterolTotal, nil
	case "cholesterol/triglycerides":
		return TimeseriesResourceCholesterolTriglycerides, nil
	case "floors_climbed":
		return TimeseriesResourceFloorsClimbed, nil
	case "glucose":
		return TimeseriesResourceGlucose, nil
	case "heartrate":
		return TimeseriesResourceHeartrate, nil
	case "hrv":
		return TimeseriesResourceHrv, nil
	case "heartrate_variability":
		return TimeseriesResourceHeartrateVariability, nil
	case "hypnogram":
		return TimeseriesResourceHypnogram, nil
	case "ige":
		return TimeseriesResourceIge, nil
	case "igg":
		return TimeseriesResourceIgg, nil
	case "respiratory_rate":
		return TimeseriesResourceRespiratoryRate, nil
	case "steps":
		return TimeseriesResourceSteps, nil
	case "stress_level":
		return TimeseriesResourceStressLevel, nil
	case "vo2_max":
		return TimeseriesResourceVo2Max, nil
	case "water":
		return TimeseriesResourceWater, nil
	case "caffeine":
		return TimeseriesResourceCaffeine, nil
	case "mindfulness_minutes":
		return TimeseriesResourceMindfulnessMinutes, nil
	}
	var t TimeseriesResource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeseriesResource) Ptr() *TimeseriesResource {
	return &t
}

type UsAddress struct {
	FirstLine  string  `json:"first_line"`
	SecondLine *string `json:"second_line,omitempty"`
	City       string  `json:"city"`
	State      string  `json:"state"`
	ZipCode    string  `json:"zip_code"`
	Unit       *string `json:"unit,omitempty"`
}

type UserRefreshErrorResponse struct {
	// Whether operation was successful or not
	Success string `json:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId        string   `json:"user_id"`
	Error         string   `json:"error"`
	FailedSources []string `json:"failed_sources,omitempty"`
}

type UserRefreshSuccessResponse struct {
	// Whether operation was successful or not
	Success string `json:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId           string   `json:"user_id"`
	RefreshedSources []string `json:"refreshed_sources,omitempty"`
	FailedSources    []string `json:"failed_sources,omitempty"`
}

type UserSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success"`
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty"`
	Msg  string                    `json:"msg"`
	Type string                    `json:"type"`
}

type ValidationErrorLocItem struct {
	typeName string
	String   string
	Integer  int
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "string", String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typeName: "integer", Integer: value}
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typeName = "string"
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.typeName = "integer"
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return json.Marshal(v.String)
	case "integer":
		return json.Marshal(v.Integer)
	}
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "string":
		return visitor.VisitString(v.String)
	case "integer":
		return visitor.VisitInteger(v.Integer)
	}
}

type VitalTokenCreatedResponse struct {
	Code        string `json:"code"`
	ExchangeUrl string `json:"exchange_url"`
}

type VitalTokenExchangeResponse struct {
	ApiKey      string                          `json:"api_key"`
	Region      Region                          `json:"region,omitempty"`
	Environment string                          `json:"environment"`
	UserId      string                          `json:"user_id"`
	Team        *VitalTokenExchangeTeamResponse `json:"team,omitempty"`
}

type VitalTokenExchangeTeamResponse struct {
	Name    string  `json:"name"`
	LogoUrl *string `json:"logo_url,omitempty"`
}

type WorkoutV2InDb struct {
	Timestamp  time.Time           `json:"timestamp"`
	Data       *string             `json:"data,omitempty"`
	ProviderId string              `json:"provider_id"`
	UserId     string              `json:"user_id"`
	SourceId   int                 `json:"source_id"`
	PriorityId *int                `json:"priority_id,omitempty"`
	Id         string              `json:"id"`
	SportId    int                 `json:"sport_id"`
	Source     *ClientFacingSource `json:"source,omitempty"`
	Sport      *ClientFacingSport  `json:"sport,omitempty"`
}
