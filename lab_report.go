// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tryVital/vital-go/internal"
	io "io"
	big "math/big"
)

type BodyCreateLabReportParserJob struct {
	File             io.Reader `json:"-" url:"-"`
	NeedsHumanReview *bool     `json:"needs_human_review,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyCreateLabReportParserJob) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

var (
	parserGetJobLabReportRequestFieldJobId = big.NewInt(1 << 0)
)

type ParserGetJobLabReportRequest struct {
	JobId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *ParserGetJobLabReportRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetJobId sets the JobId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParserGetJobLabReportRequest) SetJobId(jobId string) {
	p.JobId = jobId
	p.require(parserGetJobLabReportRequestFieldJobId)
}

var (
	labReportResultFieldTestName          = big.NewInt(1 << 0)
	labReportResultFieldValue             = big.NewInt(1 << 1)
	labReportResultFieldType              = big.NewInt(1 << 2)
	labReportResultFieldUnits             = big.NewInt(1 << 3)
	labReportResultFieldMaxReferenceRange = big.NewInt(1 << 4)
	labReportResultFieldMinReferenceRange = big.NewInt(1 << 5)
	labReportResultFieldSourcePanelName   = big.NewInt(1 << 6)
	labReportResultFieldLoincMatches      = big.NewInt(1 << 7)
	labReportResultFieldInterpretation    = big.NewInt(1 << 8)
	labReportResultFieldIsAboveMaxRange   = big.NewInt(1 << 9)
	labReportResultFieldIsBelowMinRange   = big.NewInt(1 << 10)
)

type LabReportResult struct {
	TestName          string               `json:"test_name" url:"test_name"`
	Value             string               `json:"value" url:"value"`
	Type              *LabReportResultType `json:"type,omitempty" url:"type,omitempty"`
	Units             *string              `json:"units,omitempty" url:"units,omitempty"`
	MaxReferenceRange *float64             `json:"max_reference_range,omitempty" url:"max_reference_range,omitempty"`
	MinReferenceRange *float64             `json:"min_reference_range,omitempty" url:"min_reference_range,omitempty"`
	SourcePanelName   *string              `json:"source_panel_name,omitempty" url:"source_panel_name,omitempty"`
	LoincMatches      []*LoincMatch        `json:"loinc_matches,omitempty" url:"loinc_matches,omitempty"`
	Interpretation    *Interpretation      `json:"interpretation,omitempty" url:"interpretation,omitempty"`
	IsAboveMaxRange   *bool                `json:"is_above_max_range,omitempty" url:"is_above_max_range,omitempty"`
	IsBelowMinRange   *bool                `json:"is_below_min_range,omitempty" url:"is_below_min_range,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LabReportResult) GetTestName() string {
	if l == nil {
		return ""
	}
	return l.TestName
}

func (l *LabReportResult) GetValue() string {
	if l == nil {
		return ""
	}
	return l.Value
}

func (l *LabReportResult) GetType() *LabReportResultType {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LabReportResult) GetUnits() *string {
	if l == nil {
		return nil
	}
	return l.Units
}

func (l *LabReportResult) GetMaxReferenceRange() *float64 {
	if l == nil {
		return nil
	}
	return l.MaxReferenceRange
}

func (l *LabReportResult) GetMinReferenceRange() *float64 {
	if l == nil {
		return nil
	}
	return l.MinReferenceRange
}

func (l *LabReportResult) GetSourcePanelName() *string {
	if l == nil {
		return nil
	}
	return l.SourcePanelName
}

func (l *LabReportResult) GetLoincMatches() []*LoincMatch {
	if l == nil {
		return nil
	}
	return l.LoincMatches
}

func (l *LabReportResult) GetInterpretation() *Interpretation {
	if l == nil {
		return nil
	}
	return l.Interpretation
}

func (l *LabReportResult) GetIsAboveMaxRange() *bool {
	if l == nil {
		return nil
	}
	return l.IsAboveMaxRange
}

func (l *LabReportResult) GetIsBelowMinRange() *bool {
	if l == nil {
		return nil
	}
	return l.IsBelowMinRange
}

func (l *LabReportResult) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabReportResult) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetTestName sets the TestName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetTestName(testName string) {
	l.TestName = testName
	l.require(labReportResultFieldTestName)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetValue(value string) {
	l.Value = value
	l.require(labReportResultFieldValue)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetType(type_ *LabReportResultType) {
	l.Type = type_
	l.require(labReportResultFieldType)
}

// SetUnits sets the Units field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetUnits(units *string) {
	l.Units = units
	l.require(labReportResultFieldUnits)
}

// SetMaxReferenceRange sets the MaxReferenceRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetMaxReferenceRange(maxReferenceRange *float64) {
	l.MaxReferenceRange = maxReferenceRange
	l.require(labReportResultFieldMaxReferenceRange)
}

// SetMinReferenceRange sets the MinReferenceRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetMinReferenceRange(minReferenceRange *float64) {
	l.MinReferenceRange = minReferenceRange
	l.require(labReportResultFieldMinReferenceRange)
}

// SetSourcePanelName sets the SourcePanelName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetSourcePanelName(sourcePanelName *string) {
	l.SourcePanelName = sourcePanelName
	l.require(labReportResultFieldSourcePanelName)
}

// SetLoincMatches sets the LoincMatches field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetLoincMatches(loincMatches []*LoincMatch) {
	l.LoincMatches = loincMatches
	l.require(labReportResultFieldLoincMatches)
}

// SetInterpretation sets the Interpretation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetInterpretation(interpretation *Interpretation) {
	l.Interpretation = interpretation
	l.require(labReportResultFieldInterpretation)
}

// SetIsAboveMaxRange sets the IsAboveMaxRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetIsAboveMaxRange(isAboveMaxRange *bool) {
	l.IsAboveMaxRange = isAboveMaxRange
	l.require(labReportResultFieldIsAboveMaxRange)
}

// SetIsBelowMinRange sets the IsBelowMinRange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabReportResult) SetIsBelowMinRange(isBelowMinRange *bool) {
	l.IsBelowMinRange = isBelowMinRange
	l.require(labReportResultFieldIsBelowMinRange)
}

func (l *LabReportResult) UnmarshalJSON(data []byte) error {
	type unmarshaler LabReportResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabReportResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabReportResult) MarshalJSON() ([]byte, error) {
	type embed LabReportResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LabReportResult) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// ℹ️ This enum is non-exhaustive.
type LabReportResultType string

const (
	LabReportResultTypeNumeric    LabReportResultType = "numeric"
	LabReportResultTypeRange      LabReportResultType = "range"
	LabReportResultTypeComment    LabReportResultType = "comment"
	LabReportResultTypeBoolean    LabReportResultType = "boolean"
	LabReportResultTypeDuration   LabReportResultType = "duration"
	LabReportResultTypePercentage LabReportResultType = "percentage"
	LabReportResultTypeRatio      LabReportResultType = "ratio"
)

func NewLabReportResultTypeFromString(s string) (LabReportResultType, error) {
	switch s {
	case "numeric":
		return LabReportResultTypeNumeric, nil
	case "range":
		return LabReportResultTypeRange, nil
	case "comment":
		return LabReportResultTypeComment, nil
	case "boolean":
		return LabReportResultTypeBoolean, nil
	case "duration":
		return LabReportResultTypeDuration, nil
	case "percentage":
		return LabReportResultTypePercentage, nil
	case "ratio":
		return LabReportResultTypeRatio, nil
	}
	var t LabReportResultType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LabReportResultType) Ptr() *LabReportResultType {
	return &l
}

var (
	loincMatchFieldLoincCode       = big.NewInt(1 << 0)
	loincMatchFieldLoincName       = big.NewInt(1 << 1)
	loincMatchFieldLoincComponent  = big.NewInt(1 << 2)
	loincMatchFieldSampleType      = big.NewInt(1 << 3)
	loincMatchFieldConfidenceScore = big.NewInt(1 << 4)
)

type LoincMatch struct {
	LoincCode       string   `json:"loinc_code" url:"loinc_code"`
	LoincName       string   `json:"loinc_name" url:"loinc_name"`
	LoincComponent  string   `json:"loinc_component" url:"loinc_component"`
	SampleType      []string `json:"sample_type,omitempty" url:"sample_type,omitempty"`
	ConfidenceScore float64  `json:"confidence_score" url:"confidence_score"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoincMatch) GetLoincCode() string {
	if l == nil {
		return ""
	}
	return l.LoincCode
}

func (l *LoincMatch) GetLoincName() string {
	if l == nil {
		return ""
	}
	return l.LoincName
}

func (l *LoincMatch) GetLoincComponent() string {
	if l == nil {
		return ""
	}
	return l.LoincComponent
}

func (l *LoincMatch) GetSampleType() []string {
	if l == nil {
		return nil
	}
	return l.SampleType
}

func (l *LoincMatch) GetConfidenceScore() float64 {
	if l == nil {
		return 0
	}
	return l.ConfidenceScore
}

func (l *LoincMatch) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoincMatch) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetLoincCode sets the LoincCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LoincMatch) SetLoincCode(loincCode string) {
	l.LoincCode = loincCode
	l.require(loincMatchFieldLoincCode)
}

// SetLoincName sets the LoincName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LoincMatch) SetLoincName(loincName string) {
	l.LoincName = loincName
	l.require(loincMatchFieldLoincName)
}

// SetLoincComponent sets the LoincComponent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LoincMatch) SetLoincComponent(loincComponent string) {
	l.LoincComponent = loincComponent
	l.require(loincMatchFieldLoincComponent)
}

// SetSampleType sets the SampleType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LoincMatch) SetSampleType(sampleType []string) {
	l.SampleType = sampleType
	l.require(loincMatchFieldSampleType)
}

// SetConfidenceScore sets the ConfidenceScore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LoincMatch) SetConfidenceScore(confidenceScore float64) {
	l.ConfidenceScore = confidenceScore
	l.require(loincMatchFieldConfidenceScore)
}

func (l *LoincMatch) UnmarshalJSON(data []byte) error {
	type unmarshaler LoincMatch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoincMatch(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoincMatch) MarshalJSON() ([]byte, error) {
	type embed LoincMatch
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LoincMatch) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	parsedLabReportDataFieldMetadata = big.NewInt(1 << 0)
	parsedLabReportDataFieldResults  = big.NewInt(1 << 1)
)

type ParsedLabReportData struct {
	Metadata *ResultMetadata    `json:"metadata" url:"metadata"`
	Results  []*LabReportResult `json:"results" url:"results"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ParsedLabReportData) GetMetadata() *ResultMetadata {
	if p == nil {
		return nil
	}
	return p.Metadata
}

func (p *ParsedLabReportData) GetResults() []*LabReportResult {
	if p == nil {
		return nil
	}
	return p.Results
}

func (p *ParsedLabReportData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ParsedLabReportData) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParsedLabReportData) SetMetadata(metadata *ResultMetadata) {
	p.Metadata = metadata
	p.require(parsedLabReportDataFieldMetadata)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParsedLabReportData) SetResults(results []*LabReportResult) {
	p.Results = results
	p.require(parsedLabReportDataFieldResults)
}

func (p *ParsedLabReportData) UnmarshalJSON(data []byte) error {
	type unmarshaler ParsedLabReportData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParsedLabReportData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParsedLabReportData) MarshalJSON() ([]byte, error) {
	type embed ParsedLabReportData
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ParsedLabReportData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	parsingJobFieldJobId            = big.NewInt(1 << 0)
	parsingJobFieldStatus           = big.NewInt(1 << 1)
	parsingJobFieldData             = big.NewInt(1 << 2)
	parsingJobFieldNeedsHumanReview = big.NewInt(1 << 3)
	parsingJobFieldIsReviewed       = big.NewInt(1 << 4)
)

type ParsingJob struct {
	JobId            string               `json:"job_id" url:"job_id"`
	Status           ParsingJobStatus     `json:"status" url:"status"`
	Data             *ParsedLabReportData `json:"data,omitempty" url:"data,omitempty"`
	NeedsHumanReview bool                 `json:"needs_human_review" url:"needs_human_review"`
	IsReviewed       bool                 `json:"is_reviewed" url:"is_reviewed"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ParsingJob) GetJobId() string {
	if p == nil {
		return ""
	}
	return p.JobId
}

func (p *ParsingJob) GetStatus() ParsingJobStatus {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *ParsingJob) GetData() *ParsedLabReportData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *ParsingJob) GetNeedsHumanReview() bool {
	if p == nil {
		return false
	}
	return p.NeedsHumanReview
}

func (p *ParsingJob) GetIsReviewed() bool {
	if p == nil {
		return false
	}
	return p.IsReviewed
}

func (p *ParsingJob) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ParsingJob) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetJobId sets the JobId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParsingJob) SetJobId(jobId string) {
	p.JobId = jobId
	p.require(parsingJobFieldJobId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParsingJob) SetStatus(status ParsingJobStatus) {
	p.Status = status
	p.require(parsingJobFieldStatus)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParsingJob) SetData(data *ParsedLabReportData) {
	p.Data = data
	p.require(parsingJobFieldData)
}

// SetNeedsHumanReview sets the NeedsHumanReview field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParsingJob) SetNeedsHumanReview(needsHumanReview bool) {
	p.NeedsHumanReview = needsHumanReview
	p.require(parsingJobFieldNeedsHumanReview)
}

// SetIsReviewed sets the IsReviewed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ParsingJob) SetIsReviewed(isReviewed bool) {
	p.IsReviewed = isReviewed
	p.require(parsingJobFieldIsReviewed)
}

func (p *ParsingJob) UnmarshalJSON(data []byte) error {
	type unmarshaler ParsingJob
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParsingJob(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParsingJob) MarshalJSON() ([]byte, error) {
	type embed ParsingJob
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ParsingJob) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// ℹ️ This enum is non-exhaustive.
type ParsingJobStatus string

const (
	ParsingJobStatusUploadPending ParsingJobStatus = "upload_pending"
	ParsingJobStatusStarted       ParsingJobStatus = "started"
	ParsingJobStatusCompleted     ParsingJobStatus = "completed"
	ParsingJobStatusFailed        ParsingJobStatus = "failed"
)

func NewParsingJobStatusFromString(s string) (ParsingJobStatus, error) {
	switch s {
	case "upload_pending":
		return ParsingJobStatusUploadPending, nil
	case "started":
		return ParsingJobStatusStarted, nil
	case "completed":
		return ParsingJobStatusCompleted, nil
	case "failed":
		return ParsingJobStatusFailed, nil
	}
	var t ParsingJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ParsingJobStatus) Ptr() *ParsingJobStatus {
	return &p
}

var (
	resultMetadataFieldPatientFirstName = big.NewInt(1 << 0)
	resultMetadataFieldPatientLastName  = big.NewInt(1 << 1)
	resultMetadataFieldDob              = big.NewInt(1 << 2)
	resultMetadataFieldLabName          = big.NewInt(1 << 3)
	resultMetadataFieldDateReported     = big.NewInt(1 << 4)
	resultMetadataFieldDateCollected    = big.NewInt(1 << 5)
	resultMetadataFieldSpecimenNumber   = big.NewInt(1 << 6)
)

type ResultMetadata struct {
	PatientFirstName string  `json:"patient_first_name" url:"patient_first_name"`
	PatientLastName  string  `json:"patient_last_name" url:"patient_last_name"`
	Dob              string  `json:"dob" url:"dob"`
	LabName          string  `json:"lab_name" url:"lab_name"`
	DateReported     *string `json:"date_reported,omitempty" url:"date_reported,omitempty"`
	DateCollected    *string `json:"date_collected,omitempty" url:"date_collected,omitempty"`
	SpecimenNumber   *string `json:"specimen_number,omitempty" url:"specimen_number,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResultMetadata) GetPatientFirstName() string {
	if r == nil {
		return ""
	}
	return r.PatientFirstName
}

func (r *ResultMetadata) GetPatientLastName() string {
	if r == nil {
		return ""
	}
	return r.PatientLastName
}

func (r *ResultMetadata) GetDob() string {
	if r == nil {
		return ""
	}
	return r.Dob
}

func (r *ResultMetadata) GetLabName() string {
	if r == nil {
		return ""
	}
	return r.LabName
}

func (r *ResultMetadata) GetDateReported() *string {
	if r == nil {
		return nil
	}
	return r.DateReported
}

func (r *ResultMetadata) GetDateCollected() *string {
	if r == nil {
		return nil
	}
	return r.DateCollected
}

func (r *ResultMetadata) GetSpecimenNumber() *string {
	if r == nil {
		return nil
	}
	return r.SpecimenNumber
}

func (r *ResultMetadata) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResultMetadata) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetPatientFirstName sets the PatientFirstName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResultMetadata) SetPatientFirstName(patientFirstName string) {
	r.PatientFirstName = patientFirstName
	r.require(resultMetadataFieldPatientFirstName)
}

// SetPatientLastName sets the PatientLastName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResultMetadata) SetPatientLastName(patientLastName string) {
	r.PatientLastName = patientLastName
	r.require(resultMetadataFieldPatientLastName)
}

// SetDob sets the Dob field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResultMetadata) SetDob(dob string) {
	r.Dob = dob
	r.require(resultMetadataFieldDob)
}

// SetLabName sets the LabName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResultMetadata) SetLabName(labName string) {
	r.LabName = labName
	r.require(resultMetadataFieldLabName)
}

// SetDateReported sets the DateReported field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResultMetadata) SetDateReported(dateReported *string) {
	r.DateReported = dateReported
	r.require(resultMetadataFieldDateReported)
}

// SetDateCollected sets the DateCollected field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResultMetadata) SetDateCollected(dateCollected *string) {
	r.DateCollected = dateCollected
	r.require(resultMetadataFieldDateCollected)
}

// SetSpecimenNumber sets the SpecimenNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResultMetadata) SetSpecimenNumber(specimenNumber *string) {
	r.SpecimenNumber = specimenNumber
	r.require(resultMetadataFieldSpecimenNumber)
}

func (r *ResultMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ResultMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResultMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResultMetadata) MarshalJSON() ([]byte, error) {
	type embed ResultMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResultMetadata) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
