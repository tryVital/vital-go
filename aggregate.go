// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tryVital/vital-go/internal"
	big "math/big"
	time "time"
)

var (
	getResultTableForContinuousQueryAggregateRequestFieldUserId        = big.NewInt(1 << 0)
	getResultTableForContinuousQueryAggregateRequestFieldQueryIdOrSlug = big.NewInt(1 << 1)
)

type GetResultTableForContinuousQueryAggregateRequest struct {
	UserId        string `json:"-" url:"-"`
	QueryIdOrSlug string `json:"-" url:"-"`
	accept        string

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetResultTableForContinuousQueryAggregateRequest) Accept() string {
	return g.accept
}

func (g *GetResultTableForContinuousQueryAggregateRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetResultTableForContinuousQueryAggregateRequest) SetUserId(userId string) {
	g.UserId = userId
	g.require(getResultTableForContinuousQueryAggregateRequestFieldUserId)
}

// SetQueryIdOrSlug sets the QueryIdOrSlug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetResultTableForContinuousQueryAggregateRequest) SetQueryIdOrSlug(queryIdOrSlug string) {
	g.QueryIdOrSlug = queryIdOrSlug
	g.require(getResultTableForContinuousQueryAggregateRequestFieldQueryIdOrSlug)
}

var (
	getTaskHistoryForContinuousQueryAggregateRequestFieldUserId        = big.NewInt(1 << 0)
	getTaskHistoryForContinuousQueryAggregateRequestFieldQueryIdOrSlug = big.NewInt(1 << 1)
	getTaskHistoryForContinuousQueryAggregateRequestFieldNextCursor    = big.NewInt(1 << 2)
	getTaskHistoryForContinuousQueryAggregateRequestFieldLimit         = big.NewInt(1 << 3)
)

type GetTaskHistoryForContinuousQueryAggregateRequest struct {
	UserId        string  `json:"-" url:"-"`
	QueryIdOrSlug string  `json:"-" url:"-"`
	NextCursor    *string `json:"-" url:"next_cursor,omitempty"`
	Limit         *int    `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetTaskHistoryForContinuousQueryAggregateRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetTaskHistoryForContinuousQueryAggregateRequest) SetUserId(userId string) {
	g.UserId = userId
	g.require(getTaskHistoryForContinuousQueryAggregateRequestFieldUserId)
}

// SetQueryIdOrSlug sets the QueryIdOrSlug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetTaskHistoryForContinuousQueryAggregateRequest) SetQueryIdOrSlug(queryIdOrSlug string) {
	g.QueryIdOrSlug = queryIdOrSlug
	g.require(getTaskHistoryForContinuousQueryAggregateRequestFieldQueryIdOrSlug)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetTaskHistoryForContinuousQueryAggregateRequest) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(getTaskHistoryForContinuousQueryAggregateRequestFieldNextCursor)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetTaskHistoryForContinuousQueryAggregateRequest) SetLimit(limit *int) {
	g.Limit = limit
	g.require(getTaskHistoryForContinuousQueryAggregateRequestFieldLimit)
}

var (
	queryBatchFieldUserId    = big.NewInt(1 << 0)
	queryBatchFieldTimeframe = big.NewInt(1 << 1)
	queryBatchFieldQueries   = big.NewInt(1 << 2)
	queryBatchFieldConfig    = big.NewInt(1 << 3)
)

type QueryBatch struct {
	UserId    string               `json:"-" url:"-"`
	Timeframe *QueryBatchTimeframe `json:"timeframe,omitempty" url:"-"`
	Queries   []*Query             `json:"queries,omitempty" url:"-"`
	Config    *QueryConfig         `json:"config,omitempty" url:"-"`
	accept    string

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (q *QueryBatch) Accept() string {
	return q.accept
}

func (q *QueryBatch) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryBatch) SetUserId(userId string) {
	q.UserId = userId
	q.require(queryBatchFieldUserId)
}

// SetTimeframe sets the Timeframe field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryBatch) SetTimeframe(timeframe *QueryBatchTimeframe) {
	q.Timeframe = timeframe
	q.require(queryBatchFieldTimeframe)
}

// SetQueries sets the Queries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryBatch) SetQueries(queries []*Query) {
	q.Queries = queries
	q.require(queryBatchFieldQueries)
}

// SetConfig sets the Config field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryBatch) SetConfig(config *QueryConfig) {
	q.Config = config
	q.require(queryBatchFieldConfig)
}

func (q *QueryBatch) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryBatch
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*q = QueryBatch(body)
	q.accept = "*/*"
	return nil
}

func (q *QueryBatch) MarshalJSON() ([]byte, error) {
	type embed QueryBatch
	var marshaler = struct {
		embed
		Accept string `json:"accept"`
	}{
		embed:  embed(*q),
		Accept: "*/*",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, q.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	activityColumnExprFieldActivity = big.NewInt(1 << 0)
)

type ActivityColumnExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Activity ActivityColumnExprActivity `json:"activity" url:"activity"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActivityColumnExpr) GetActivity() ActivityColumnExprActivity {
	if a == nil {
		return ""
	}
	return a.Activity
}

func (a *ActivityColumnExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActivityColumnExpr) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetActivity sets the Activity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityColumnExpr) SetActivity(activity ActivityColumnExprActivity) {
	a.Activity = activity
	a.require(activityColumnExprFieldActivity)
}

func (a *ActivityColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivityColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivityColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityColumnExpr) MarshalJSON() ([]byte, error) {
	type embed ActivityColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActivityColumnExpr) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// ℹ️ This enum is non-exhaustive.
type ActivityColumnExprActivity string

const (
	ActivityColumnExprActivityDate                     ActivityColumnExprActivity = "date"
	ActivityColumnExprActivityCaloriesTotal            ActivityColumnExprActivity = "calories_total"
	ActivityColumnExprActivityCaloriesActive           ActivityColumnExprActivity = "calories_active"
	ActivityColumnExprActivitySteps                    ActivityColumnExprActivity = "steps"
	ActivityColumnExprActivityDistanceMeter            ActivityColumnExprActivity = "distance_meter"
	ActivityColumnExprActivityFloorsClimbed            ActivityColumnExprActivity = "floors_climbed"
	ActivityColumnExprActivityDurationActiveSecond     ActivityColumnExprActivity = "duration_active_second"
	ActivityColumnExprActivityIntensitySedentarySecond ActivityColumnExprActivity = "intensity_sedentary_second"
	ActivityColumnExprActivityIntensityLowSecond       ActivityColumnExprActivity = "intensity_low_second"
	ActivityColumnExprActivityIntensityMediumSecond    ActivityColumnExprActivity = "intensity_medium_second"
	ActivityColumnExprActivityIntensityHighSecond      ActivityColumnExprActivity = "intensity_high_second"
	ActivityColumnExprActivityHeartRateMean            ActivityColumnExprActivity = "heart_rate_mean"
	ActivityColumnExprActivityHeartRateMinimum         ActivityColumnExprActivity = "heart_rate_minimum"
	ActivityColumnExprActivityHeartRateMaximum         ActivityColumnExprActivity = "heart_rate_maximum"
	ActivityColumnExprActivityHeartRateResting         ActivityColumnExprActivity = "heart_rate_resting"
	ActivityColumnExprActivityHeartRateMeanWalking     ActivityColumnExprActivity = "heart_rate_mean_walking"
	ActivityColumnExprActivityWheelchairUse            ActivityColumnExprActivity = "wheelchair_use"
	ActivityColumnExprActivityWheelchairPush           ActivityColumnExprActivity = "wheelchair_push"
	ActivityColumnExprActivitySourceType               ActivityColumnExprActivity = "source_type"
	ActivityColumnExprActivitySourceProvider           ActivityColumnExprActivity = "source_provider"
	ActivityColumnExprActivitySourceAppId              ActivityColumnExprActivity = "source_app_id"
	ActivityColumnExprActivitySourceDeviceId           ActivityColumnExprActivity = "source_device_id"
	ActivityColumnExprActivityTimeZone                 ActivityColumnExprActivity = "time_zone"
	ActivityColumnExprActivityTimeZoneOffset           ActivityColumnExprActivity = "time_zone_offset"
)

func NewActivityColumnExprActivityFromString(s string) (ActivityColumnExprActivity, error) {
	switch s {
	case "date":
		return ActivityColumnExprActivityDate, nil
	case "calories_total":
		return ActivityColumnExprActivityCaloriesTotal, nil
	case "calories_active":
		return ActivityColumnExprActivityCaloriesActive, nil
	case "steps":
		return ActivityColumnExprActivitySteps, nil
	case "distance_meter":
		return ActivityColumnExprActivityDistanceMeter, nil
	case "floors_climbed":
		return ActivityColumnExprActivityFloorsClimbed, nil
	case "duration_active_second":
		return ActivityColumnExprActivityDurationActiveSecond, nil
	case "intensity_sedentary_second":
		return ActivityColumnExprActivityIntensitySedentarySecond, nil
	case "intensity_low_second":
		return ActivityColumnExprActivityIntensityLowSecond, nil
	case "intensity_medium_second":
		return ActivityColumnExprActivityIntensityMediumSecond, nil
	case "intensity_high_second":
		return ActivityColumnExprActivityIntensityHighSecond, nil
	case "heart_rate_mean":
		return ActivityColumnExprActivityHeartRateMean, nil
	case "heart_rate_minimum":
		return ActivityColumnExprActivityHeartRateMinimum, nil
	case "heart_rate_maximum":
		return ActivityColumnExprActivityHeartRateMaximum, nil
	case "heart_rate_resting":
		return ActivityColumnExprActivityHeartRateResting, nil
	case "heart_rate_mean_walking":
		return ActivityColumnExprActivityHeartRateMeanWalking, nil
	case "wheelchair_use":
		return ActivityColumnExprActivityWheelchairUse, nil
	case "wheelchair_push":
		return ActivityColumnExprActivityWheelchairPush, nil
	case "source_type":
		return ActivityColumnExprActivitySourceType, nil
	case "source_provider":
		return ActivityColumnExprActivitySourceProvider, nil
	case "source_app_id":
		return ActivityColumnExprActivitySourceAppId, nil
	case "source_device_id":
		return ActivityColumnExprActivitySourceDeviceId, nil
	case "time_zone":
		return ActivityColumnExprActivityTimeZone, nil
	case "time_zone_offset":
		return ActivityColumnExprActivityTimeZoneOffset, nil
	}
	var t ActivityColumnExprActivity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActivityColumnExprActivity) Ptr() *ActivityColumnExprActivity {
	return &a
}

var (
	aggregateExprFieldArg  = big.NewInt(1 << 0)
	aggregateExprFieldFunc = big.NewInt(1 << 1)
)

type AggregateExpr struct {
	Arg *AggregateExprArg `json:"arg" url:"arg"`
	// ℹ️ This enum is non-exhaustive.
	Func AggregateExprFunc `json:"func" url:"func"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AggregateExpr) GetArg() *AggregateExprArg {
	if a == nil {
		return nil
	}
	return a.Arg
}

func (a *AggregateExpr) GetFunc() AggregateExprFunc {
	if a == nil {
		return ""
	}
	return a.Func
}

func (a *AggregateExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregateExpr) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetArg sets the Arg field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AggregateExpr) SetArg(arg *AggregateExprArg) {
	a.Arg = arg
	a.require(aggregateExprFieldArg)
}

// SetFunc sets the Func field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AggregateExpr) SetFunc(func_ AggregateExprFunc) {
	a.Func = func_
	a.require(aggregateExprFieldFunc)
}

func (a *AggregateExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregateExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregateExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregateExpr) MarshalJSON() ([]byte, error) {
	type embed AggregateExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AggregateExpr) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AggregateExprArg struct {
	SleepColumnExpr               *SleepColumnExpr
	ActivityColumnExpr            *ActivityColumnExpr
	WorkoutColumnExpr             *WorkoutColumnExpr
	BodyColumnExpr                *BodyColumnExpr
	MealColumnExpr                *MealColumnExpr
	SleepScoreValueMacroExpr      *SleepScoreValueMacroExpr
	ChronotypeValueMacroExpr      *ChronotypeValueMacroExpr
	AsleepAtValueMacroExpr        *AsleepAtValueMacroExpr
	AwakeAtValueMacroExpr         *AwakeAtValueMacroExpr
	UnrecognizedValueMacroExpr    *UnrecognizedValueMacroExpr
	DiscreteTimeseriesExpr        *DiscreteTimeseriesExpr
	IntervalTimeseriesExpr        *IntervalTimeseriesExpr
	BloodPressureTimeseriesExpr   *BloodPressureTimeseriesExpr
	TemperatureTimeseriesExpr     *TemperatureTimeseriesExpr
	WorkoutDurationTimeseriesExpr *WorkoutDurationTimeseriesExpr
	NoteTimeseriesExpr            *NoteTimeseriesExpr
	IndexColumnExpr               *IndexColumnExpr

	typ string
}

func (a *AggregateExprArg) GetSleepColumnExpr() *SleepColumnExpr {
	if a == nil {
		return nil
	}
	return a.SleepColumnExpr
}

func (a *AggregateExprArg) GetActivityColumnExpr() *ActivityColumnExpr {
	if a == nil {
		return nil
	}
	return a.ActivityColumnExpr
}

func (a *AggregateExprArg) GetWorkoutColumnExpr() *WorkoutColumnExpr {
	if a == nil {
		return nil
	}
	return a.WorkoutColumnExpr
}

func (a *AggregateExprArg) GetBodyColumnExpr() *BodyColumnExpr {
	if a == nil {
		return nil
	}
	return a.BodyColumnExpr
}

func (a *AggregateExprArg) GetMealColumnExpr() *MealColumnExpr {
	if a == nil {
		return nil
	}
	return a.MealColumnExpr
}

func (a *AggregateExprArg) GetSleepScoreValueMacroExpr() *SleepScoreValueMacroExpr {
	if a == nil {
		return nil
	}
	return a.SleepScoreValueMacroExpr
}

func (a *AggregateExprArg) GetChronotypeValueMacroExpr() *ChronotypeValueMacroExpr {
	if a == nil {
		return nil
	}
	return a.ChronotypeValueMacroExpr
}

func (a *AggregateExprArg) GetAsleepAtValueMacroExpr() *AsleepAtValueMacroExpr {
	if a == nil {
		return nil
	}
	return a.AsleepAtValueMacroExpr
}

func (a *AggregateExprArg) GetAwakeAtValueMacroExpr() *AwakeAtValueMacroExpr {
	if a == nil {
		return nil
	}
	return a.AwakeAtValueMacroExpr
}

func (a *AggregateExprArg) GetUnrecognizedValueMacroExpr() *UnrecognizedValueMacroExpr {
	if a == nil {
		return nil
	}
	return a.UnrecognizedValueMacroExpr
}

func (a *AggregateExprArg) GetDiscreteTimeseriesExpr() *DiscreteTimeseriesExpr {
	if a == nil {
		return nil
	}
	return a.DiscreteTimeseriesExpr
}

func (a *AggregateExprArg) GetIntervalTimeseriesExpr() *IntervalTimeseriesExpr {
	if a == nil {
		return nil
	}
	return a.IntervalTimeseriesExpr
}

func (a *AggregateExprArg) GetBloodPressureTimeseriesExpr() *BloodPressureTimeseriesExpr {
	if a == nil {
		return nil
	}
	return a.BloodPressureTimeseriesExpr
}

func (a *AggregateExprArg) GetTemperatureTimeseriesExpr() *TemperatureTimeseriesExpr {
	if a == nil {
		return nil
	}
	return a.TemperatureTimeseriesExpr
}

func (a *AggregateExprArg) GetWorkoutDurationTimeseriesExpr() *WorkoutDurationTimeseriesExpr {
	if a == nil {
		return nil
	}
	return a.WorkoutDurationTimeseriesExpr
}

func (a *AggregateExprArg) GetNoteTimeseriesExpr() *NoteTimeseriesExpr {
	if a == nil {
		return nil
	}
	return a.NoteTimeseriesExpr
}

func (a *AggregateExprArg) GetIndexColumnExpr() *IndexColumnExpr {
	if a == nil {
		return nil
	}
	return a.IndexColumnExpr
}

func (a *AggregateExprArg) UnmarshalJSON(data []byte) error {
	valueSleepColumnExpr := new(SleepColumnExpr)
	if err := json.Unmarshal(data, &valueSleepColumnExpr); err == nil {
		a.typ = "SleepColumnExpr"
		a.SleepColumnExpr = valueSleepColumnExpr
		return nil
	}
	valueActivityColumnExpr := new(ActivityColumnExpr)
	if err := json.Unmarshal(data, &valueActivityColumnExpr); err == nil {
		a.typ = "ActivityColumnExpr"
		a.ActivityColumnExpr = valueActivityColumnExpr
		return nil
	}
	valueWorkoutColumnExpr := new(WorkoutColumnExpr)
	if err := json.Unmarshal(data, &valueWorkoutColumnExpr); err == nil {
		a.typ = "WorkoutColumnExpr"
		a.WorkoutColumnExpr = valueWorkoutColumnExpr
		return nil
	}
	valueBodyColumnExpr := new(BodyColumnExpr)
	if err := json.Unmarshal(data, &valueBodyColumnExpr); err == nil {
		a.typ = "BodyColumnExpr"
		a.BodyColumnExpr = valueBodyColumnExpr
		return nil
	}
	valueMealColumnExpr := new(MealColumnExpr)
	if err := json.Unmarshal(data, &valueMealColumnExpr); err == nil {
		a.typ = "MealColumnExpr"
		a.MealColumnExpr = valueMealColumnExpr
		return nil
	}
	valueSleepScoreValueMacroExpr := new(SleepScoreValueMacroExpr)
	if err := json.Unmarshal(data, &valueSleepScoreValueMacroExpr); err == nil {
		a.typ = "SleepScoreValueMacroExpr"
		a.SleepScoreValueMacroExpr = valueSleepScoreValueMacroExpr
		return nil
	}
	valueChronotypeValueMacroExpr := new(ChronotypeValueMacroExpr)
	if err := json.Unmarshal(data, &valueChronotypeValueMacroExpr); err == nil {
		a.typ = "ChronotypeValueMacroExpr"
		a.ChronotypeValueMacroExpr = valueChronotypeValueMacroExpr
		return nil
	}
	valueAsleepAtValueMacroExpr := new(AsleepAtValueMacroExpr)
	if err := json.Unmarshal(data, &valueAsleepAtValueMacroExpr); err == nil {
		a.typ = "AsleepAtValueMacroExpr"
		a.AsleepAtValueMacroExpr = valueAsleepAtValueMacroExpr
		return nil
	}
	valueAwakeAtValueMacroExpr := new(AwakeAtValueMacroExpr)
	if err := json.Unmarshal(data, &valueAwakeAtValueMacroExpr); err == nil {
		a.typ = "AwakeAtValueMacroExpr"
		a.AwakeAtValueMacroExpr = valueAwakeAtValueMacroExpr
		return nil
	}
	valueUnrecognizedValueMacroExpr := new(UnrecognizedValueMacroExpr)
	if err := json.Unmarshal(data, &valueUnrecognizedValueMacroExpr); err == nil {
		a.typ = "UnrecognizedValueMacroExpr"
		a.UnrecognizedValueMacroExpr = valueUnrecognizedValueMacroExpr
		return nil
	}
	valueDiscreteTimeseriesExpr := new(DiscreteTimeseriesExpr)
	if err := json.Unmarshal(data, &valueDiscreteTimeseriesExpr); err == nil {
		a.typ = "DiscreteTimeseriesExpr"
		a.DiscreteTimeseriesExpr = valueDiscreteTimeseriesExpr
		return nil
	}
	valueIntervalTimeseriesExpr := new(IntervalTimeseriesExpr)
	if err := json.Unmarshal(data, &valueIntervalTimeseriesExpr); err == nil {
		a.typ = "IntervalTimeseriesExpr"
		a.IntervalTimeseriesExpr = valueIntervalTimeseriesExpr
		return nil
	}
	valueBloodPressureTimeseriesExpr := new(BloodPressureTimeseriesExpr)
	if err := json.Unmarshal(data, &valueBloodPressureTimeseriesExpr); err == nil {
		a.typ = "BloodPressureTimeseriesExpr"
		a.BloodPressureTimeseriesExpr = valueBloodPressureTimeseriesExpr
		return nil
	}
	valueTemperatureTimeseriesExpr := new(TemperatureTimeseriesExpr)
	if err := json.Unmarshal(data, &valueTemperatureTimeseriesExpr); err == nil {
		a.typ = "TemperatureTimeseriesExpr"
		a.TemperatureTimeseriesExpr = valueTemperatureTimeseriesExpr
		return nil
	}
	valueWorkoutDurationTimeseriesExpr := new(WorkoutDurationTimeseriesExpr)
	if err := json.Unmarshal(data, &valueWorkoutDurationTimeseriesExpr); err == nil {
		a.typ = "WorkoutDurationTimeseriesExpr"
		a.WorkoutDurationTimeseriesExpr = valueWorkoutDurationTimeseriesExpr
		return nil
	}
	valueNoteTimeseriesExpr := new(NoteTimeseriesExpr)
	if err := json.Unmarshal(data, &valueNoteTimeseriesExpr); err == nil {
		a.typ = "NoteTimeseriesExpr"
		a.NoteTimeseriesExpr = valueNoteTimeseriesExpr
		return nil
	}
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		a.typ = "IndexColumnExpr"
		a.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AggregateExprArg) MarshalJSON() ([]byte, error) {
	if a.typ == "SleepColumnExpr" || a.SleepColumnExpr != nil {
		return json.Marshal(a.SleepColumnExpr)
	}
	if a.typ == "ActivityColumnExpr" || a.ActivityColumnExpr != nil {
		return json.Marshal(a.ActivityColumnExpr)
	}
	if a.typ == "WorkoutColumnExpr" || a.WorkoutColumnExpr != nil {
		return json.Marshal(a.WorkoutColumnExpr)
	}
	if a.typ == "BodyColumnExpr" || a.BodyColumnExpr != nil {
		return json.Marshal(a.BodyColumnExpr)
	}
	if a.typ == "MealColumnExpr" || a.MealColumnExpr != nil {
		return json.Marshal(a.MealColumnExpr)
	}
	if a.typ == "SleepScoreValueMacroExpr" || a.SleepScoreValueMacroExpr != nil {
		return json.Marshal(a.SleepScoreValueMacroExpr)
	}
	if a.typ == "ChronotypeValueMacroExpr" || a.ChronotypeValueMacroExpr != nil {
		return json.Marshal(a.ChronotypeValueMacroExpr)
	}
	if a.typ == "AsleepAtValueMacroExpr" || a.AsleepAtValueMacroExpr != nil {
		return json.Marshal(a.AsleepAtValueMacroExpr)
	}
	if a.typ == "AwakeAtValueMacroExpr" || a.AwakeAtValueMacroExpr != nil {
		return json.Marshal(a.AwakeAtValueMacroExpr)
	}
	if a.typ == "UnrecognizedValueMacroExpr" || a.UnrecognizedValueMacroExpr != nil {
		return json.Marshal(a.UnrecognizedValueMacroExpr)
	}
	if a.typ == "DiscreteTimeseriesExpr" || a.DiscreteTimeseriesExpr != nil {
		return json.Marshal(a.DiscreteTimeseriesExpr)
	}
	if a.typ == "IntervalTimeseriesExpr" || a.IntervalTimeseriesExpr != nil {
		return json.Marshal(a.IntervalTimeseriesExpr)
	}
	if a.typ == "BloodPressureTimeseriesExpr" || a.BloodPressureTimeseriesExpr != nil {
		return json.Marshal(a.BloodPressureTimeseriesExpr)
	}
	if a.typ == "TemperatureTimeseriesExpr" || a.TemperatureTimeseriesExpr != nil {
		return json.Marshal(a.TemperatureTimeseriesExpr)
	}
	if a.typ == "WorkoutDurationTimeseriesExpr" || a.WorkoutDurationTimeseriesExpr != nil {
		return json.Marshal(a.WorkoutDurationTimeseriesExpr)
	}
	if a.typ == "NoteTimeseriesExpr" || a.NoteTimeseriesExpr != nil {
		return json.Marshal(a.NoteTimeseriesExpr)
	}
	if a.typ == "IndexColumnExpr" || a.IndexColumnExpr != nil {
		return json.Marshal(a.IndexColumnExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregateExprArgVisitor interface {
	VisitSleepColumnExpr(*SleepColumnExpr) error
	VisitActivityColumnExpr(*ActivityColumnExpr) error
	VisitWorkoutColumnExpr(*WorkoutColumnExpr) error
	VisitBodyColumnExpr(*BodyColumnExpr) error
	VisitMealColumnExpr(*MealColumnExpr) error
	VisitSleepScoreValueMacroExpr(*SleepScoreValueMacroExpr) error
	VisitChronotypeValueMacroExpr(*ChronotypeValueMacroExpr) error
	VisitAsleepAtValueMacroExpr(*AsleepAtValueMacroExpr) error
	VisitAwakeAtValueMacroExpr(*AwakeAtValueMacroExpr) error
	VisitUnrecognizedValueMacroExpr(*UnrecognizedValueMacroExpr) error
	VisitDiscreteTimeseriesExpr(*DiscreteTimeseriesExpr) error
	VisitIntervalTimeseriesExpr(*IntervalTimeseriesExpr) error
	VisitBloodPressureTimeseriesExpr(*BloodPressureTimeseriesExpr) error
	VisitTemperatureTimeseriesExpr(*TemperatureTimeseriesExpr) error
	VisitWorkoutDurationTimeseriesExpr(*WorkoutDurationTimeseriesExpr) error
	VisitNoteTimeseriesExpr(*NoteTimeseriesExpr) error
	VisitIndexColumnExpr(*IndexColumnExpr) error
}

func (a *AggregateExprArg) Accept(visitor AggregateExprArgVisitor) error {
	if a.typ == "SleepColumnExpr" || a.SleepColumnExpr != nil {
		return visitor.VisitSleepColumnExpr(a.SleepColumnExpr)
	}
	if a.typ == "ActivityColumnExpr" || a.ActivityColumnExpr != nil {
		return visitor.VisitActivityColumnExpr(a.ActivityColumnExpr)
	}
	if a.typ == "WorkoutColumnExpr" || a.WorkoutColumnExpr != nil {
		return visitor.VisitWorkoutColumnExpr(a.WorkoutColumnExpr)
	}
	if a.typ == "BodyColumnExpr" || a.BodyColumnExpr != nil {
		return visitor.VisitBodyColumnExpr(a.BodyColumnExpr)
	}
	if a.typ == "MealColumnExpr" || a.MealColumnExpr != nil {
		return visitor.VisitMealColumnExpr(a.MealColumnExpr)
	}
	if a.typ == "SleepScoreValueMacroExpr" || a.SleepScoreValueMacroExpr != nil {
		return visitor.VisitSleepScoreValueMacroExpr(a.SleepScoreValueMacroExpr)
	}
	if a.typ == "ChronotypeValueMacroExpr" || a.ChronotypeValueMacroExpr != nil {
		return visitor.VisitChronotypeValueMacroExpr(a.ChronotypeValueMacroExpr)
	}
	if a.typ == "AsleepAtValueMacroExpr" || a.AsleepAtValueMacroExpr != nil {
		return visitor.VisitAsleepAtValueMacroExpr(a.AsleepAtValueMacroExpr)
	}
	if a.typ == "AwakeAtValueMacroExpr" || a.AwakeAtValueMacroExpr != nil {
		return visitor.VisitAwakeAtValueMacroExpr(a.AwakeAtValueMacroExpr)
	}
	if a.typ == "UnrecognizedValueMacroExpr" || a.UnrecognizedValueMacroExpr != nil {
		return visitor.VisitUnrecognizedValueMacroExpr(a.UnrecognizedValueMacroExpr)
	}
	if a.typ == "DiscreteTimeseriesExpr" || a.DiscreteTimeseriesExpr != nil {
		return visitor.VisitDiscreteTimeseriesExpr(a.DiscreteTimeseriesExpr)
	}
	if a.typ == "IntervalTimeseriesExpr" || a.IntervalTimeseriesExpr != nil {
		return visitor.VisitIntervalTimeseriesExpr(a.IntervalTimeseriesExpr)
	}
	if a.typ == "BloodPressureTimeseriesExpr" || a.BloodPressureTimeseriesExpr != nil {
		return visitor.VisitBloodPressureTimeseriesExpr(a.BloodPressureTimeseriesExpr)
	}
	if a.typ == "TemperatureTimeseriesExpr" || a.TemperatureTimeseriesExpr != nil {
		return visitor.VisitTemperatureTimeseriesExpr(a.TemperatureTimeseriesExpr)
	}
	if a.typ == "WorkoutDurationTimeseriesExpr" || a.WorkoutDurationTimeseriesExpr != nil {
		return visitor.VisitWorkoutDurationTimeseriesExpr(a.WorkoutDurationTimeseriesExpr)
	}
	if a.typ == "NoteTimeseriesExpr" || a.NoteTimeseriesExpr != nil {
		return visitor.VisitNoteTimeseriesExpr(a.NoteTimeseriesExpr)
	}
	if a.typ == "IndexColumnExpr" || a.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(a.IndexColumnExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// ℹ️ This enum is non-exhaustive.
type AggregateExprFunc string

const (
	AggregateExprFuncMean   AggregateExprFunc = "mean"
	AggregateExprFuncMin    AggregateExprFunc = "min"
	AggregateExprFuncMax    AggregateExprFunc = "max"
	AggregateExprFuncSum    AggregateExprFunc = "sum"
	AggregateExprFuncCount  AggregateExprFunc = "count"
	AggregateExprFuncMedian AggregateExprFunc = "median"
	AggregateExprFuncStddev AggregateExprFunc = "stddev"
	AggregateExprFuncOldest AggregateExprFunc = "oldest"
	AggregateExprFuncNewest AggregateExprFunc = "newest"
)

func NewAggregateExprFuncFromString(s string) (AggregateExprFunc, error) {
	switch s {
	case "mean":
		return AggregateExprFuncMean, nil
	case "min":
		return AggregateExprFuncMin, nil
	case "max":
		return AggregateExprFuncMax, nil
	case "sum":
		return AggregateExprFuncSum, nil
	case "count":
		return AggregateExprFuncCount, nil
	case "median":
		return AggregateExprFuncMedian, nil
	case "stddev":
		return AggregateExprFuncStddev, nil
	case "oldest":
		return AggregateExprFuncOldest, nil
	case "newest":
		return AggregateExprFuncNewest, nil
	}
	var t AggregateExprFunc
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregateExprFunc) Ptr() *AggregateExprFunc {
	return &a
}

var (
	aggregationResponseFieldResults = big.NewInt(1 << 0)
)

type AggregationResponse struct {
	Results []*AggregationResult `json:"results" url:"results"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AggregationResponse) GetResults() []*AggregationResult {
	if a == nil {
		return nil
	}
	return a.Results
}

func (a *AggregationResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregationResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetResults sets the Results field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AggregationResponse) SetResults(results []*AggregationResult) {
	a.Results = results
	a.require(aggregationResponseFieldResults)
}

func (a *AggregationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregationResponse) MarshalJSON() ([]byte, error) {
	type embed AggregationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AggregationResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	aggregationResultFieldTable = big.NewInt(1 << 0)
)

type AggregationResult struct {
	// The result table of the query, organized in a column oriented format.
	Table map[string][]interface{} `json:"table" url:"table"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AggregationResult) GetTable() map[string][]interface{} {
	if a == nil {
		return nil
	}
	return a.Table
}

func (a *AggregationResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregationResult) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetTable sets the Table field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AggregationResult) SetTable(table map[string][]interface{}) {
	a.Table = table
	a.require(aggregationResultFieldTable)
}

func (a *AggregationResult) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregationResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregationResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregationResult) MarshalJSON() ([]byte, error) {
	type embed AggregationResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AggregationResult) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	asleepAtValueMacroExprFieldVersion = big.NewInt(1 << 0)
)

type AsleepAtValueMacroExpr struct {
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	valueMacro     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AsleepAtValueMacroExpr) ValueMacro() string {
	return a.valueMacro
}

func (a *AsleepAtValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AsleepAtValueMacroExpr) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AsleepAtValueMacroExpr) SetVersion(version *string) {
	a.Version = version
	a.require(asleepAtValueMacroExprFieldVersion)
}

func (a *AsleepAtValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed AsleepAtValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AsleepAtValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "asleep_at" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "asleep_at", unmarshaler.ValueMacro)
	}
	a.valueMacro = unmarshaler.ValueMacro
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "value_macro")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AsleepAtValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed AsleepAtValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*a),
		ValueMacro: "asleep_at",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AsleepAtValueMacroExpr) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	awakeAtValueMacroExprFieldVersion = big.NewInt(1 << 0)
)

type AwakeAtValueMacroExpr struct {
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	valueMacro     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AwakeAtValueMacroExpr) ValueMacro() string {
	return a.valueMacro
}

func (a *AwakeAtValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AwakeAtValueMacroExpr) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AwakeAtValueMacroExpr) SetVersion(version *string) {
	a.Version = version
	a.require(awakeAtValueMacroExprFieldVersion)
}

func (a *AwakeAtValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed AwakeAtValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AwakeAtValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "awake_at" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "awake_at", unmarshaler.ValueMacro)
	}
	a.valueMacro = unmarshaler.ValueMacro
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "value_macro")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AwakeAtValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed AwakeAtValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*a),
		ValueMacro: "awake_at",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AwakeAtValueMacroExpr) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	bloodPressureTimeseriesExprFieldField = big.NewInt(1 << 0)
)

type BloodPressureTimeseriesExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Field BloodPressureTimeseriesExprField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	timeseries     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BloodPressureTimeseriesExpr) GetField() BloodPressureTimeseriesExprField {
	if b == nil {
		return ""
	}
	return b.Field
}

func (b *BloodPressureTimeseriesExpr) Timeseries() string {
	return b.timeseries
}

func (b *BloodPressureTimeseriesExpr) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BloodPressureTimeseriesExpr) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureTimeseriesExpr) SetField(field BloodPressureTimeseriesExprField) {
	b.Field = field
	b.require(bloodPressureTimeseriesExprFieldField)
}

func (b *BloodPressureTimeseriesExpr) UnmarshalJSON(data []byte) error {
	type embed BloodPressureTimeseriesExpr
	var unmarshaler = struct {
		embed
		Timeseries string `json:"timeseries"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BloodPressureTimeseriesExpr(unmarshaler.embed)
	if unmarshaler.Timeseries != "blood_pressure" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", b, "blood_pressure", unmarshaler.Timeseries)
	}
	b.timeseries = unmarshaler.Timeseries
	extraProperties, err := internal.ExtractExtraProperties(data, *b, "timeseries")
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BloodPressureTimeseriesExpr) MarshalJSON() ([]byte, error) {
	type embed BloodPressureTimeseriesExpr
	var marshaler = struct {
		embed
		Timeseries string `json:"timeseries"`
	}{
		embed:      embed(*b),
		Timeseries: "blood_pressure",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BloodPressureTimeseriesExpr) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// ℹ️ This enum is non-exhaustive.
type BloodPressureTimeseriesExprField string

const (
	BloodPressureTimeseriesExprFieldSourceProvider  BloodPressureTimeseriesExprField = "source_provider"
	BloodPressureTimeseriesExprFieldSourceType      BloodPressureTimeseriesExprField = "source_type"
	BloodPressureTimeseriesExprFieldSourceAppId     BloodPressureTimeseriesExprField = "source_app_id"
	BloodPressureTimeseriesExprFieldSourceWorkoutId BloodPressureTimeseriesExprField = "source_workout_id"
	BloodPressureTimeseriesExprFieldSourceSport     BloodPressureTimeseriesExprField = "source_sport"
	BloodPressureTimeseriesExprFieldTimezoneOffset  BloodPressureTimeseriesExprField = "timezone_offset"
	BloodPressureTimeseriesExprFieldType            BloodPressureTimeseriesExprField = "type"
	BloodPressureTimeseriesExprFieldSystolic        BloodPressureTimeseriesExprField = "systolic"
	BloodPressureTimeseriesExprFieldDiastolic       BloodPressureTimeseriesExprField = "diastolic"
)

func NewBloodPressureTimeseriesExprFieldFromString(s string) (BloodPressureTimeseriesExprField, error) {
	switch s {
	case "source_provider":
		return BloodPressureTimeseriesExprFieldSourceProvider, nil
	case "source_type":
		return BloodPressureTimeseriesExprFieldSourceType, nil
	case "source_app_id":
		return BloodPressureTimeseriesExprFieldSourceAppId, nil
	case "source_workout_id":
		return BloodPressureTimeseriesExprFieldSourceWorkoutId, nil
	case "source_sport":
		return BloodPressureTimeseriesExprFieldSourceSport, nil
	case "timezone_offset":
		return BloodPressureTimeseriesExprFieldTimezoneOffset, nil
	case "type":
		return BloodPressureTimeseriesExprFieldType, nil
	case "systolic":
		return BloodPressureTimeseriesExprFieldSystolic, nil
	case "diastolic":
		return BloodPressureTimeseriesExprFieldDiastolic, nil
	}
	var t BloodPressureTimeseriesExprField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BloodPressureTimeseriesExprField) Ptr() *BloodPressureTimeseriesExprField {
	return &b
}

var (
	bodyColumnExprFieldBody = big.NewInt(1 << 0)
)

type BodyColumnExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Body BodyColumnExprBody `json:"body" url:"body"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BodyColumnExpr) GetBody() BodyColumnExprBody {
	if b == nil {
		return ""
	}
	return b.Body
}

func (b *BodyColumnExpr) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyColumnExpr) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetBody sets the Body field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyColumnExpr) SetBody(body BodyColumnExprBody) {
	b.Body = body
	b.require(bodyColumnExprFieldBody)
}

func (b *BodyColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BodyColumnExpr) MarshalJSON() ([]byte, error) {
	type embed BodyColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BodyColumnExpr) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// ℹ️ This enum is non-exhaustive.
type BodyColumnExprBody string

const (
	BodyColumnExprBodyMeasuredAt                   BodyColumnExprBody = "measured_at"
	BodyColumnExprBodyWeightKilogram               BodyColumnExprBody = "weight_kilogram"
	BodyColumnExprBodyFatMassPercentage            BodyColumnExprBody = "fat_mass_percentage"
	BodyColumnExprBodyWaterPercentage              BodyColumnExprBody = "water_percentage"
	BodyColumnExprBodyMuscleMassPercentage         BodyColumnExprBody = "muscle_mass_percentage"
	BodyColumnExprBodyVisceralFatIndex             BodyColumnExprBody = "visceral_fat_index"
	BodyColumnExprBodyBoneMassPercentage           BodyColumnExprBody = "bone_mass_percentage"
	BodyColumnExprBodyBodyMassIndex                BodyColumnExprBody = "body_mass_index"
	BodyColumnExprBodyLeanBodyMassKilogram         BodyColumnExprBody = "lean_body_mass_kilogram"
	BodyColumnExprBodyWaistCircumferenceCentimeter BodyColumnExprBody = "waist_circumference_centimeter"
	BodyColumnExprBodySourceType                   BodyColumnExprBody = "source_type"
	BodyColumnExprBodySourceProvider               BodyColumnExprBody = "source_provider"
	BodyColumnExprBodySourceAppId                  BodyColumnExprBody = "source_app_id"
	BodyColumnExprBodySourceDeviceId               BodyColumnExprBody = "source_device_id"
	BodyColumnExprBodyTimeZone                     BodyColumnExprBody = "time_zone"
)

func NewBodyColumnExprBodyFromString(s string) (BodyColumnExprBody, error) {
	switch s {
	case "measured_at":
		return BodyColumnExprBodyMeasuredAt, nil
	case "weight_kilogram":
		return BodyColumnExprBodyWeightKilogram, nil
	case "fat_mass_percentage":
		return BodyColumnExprBodyFatMassPercentage, nil
	case "water_percentage":
		return BodyColumnExprBodyWaterPercentage, nil
	case "muscle_mass_percentage":
		return BodyColumnExprBodyMuscleMassPercentage, nil
	case "visceral_fat_index":
		return BodyColumnExprBodyVisceralFatIndex, nil
	case "bone_mass_percentage":
		return BodyColumnExprBodyBoneMassPercentage, nil
	case "body_mass_index":
		return BodyColumnExprBodyBodyMassIndex, nil
	case "lean_body_mass_kilogram":
		return BodyColumnExprBodyLeanBodyMassKilogram, nil
	case "waist_circumference_centimeter":
		return BodyColumnExprBodyWaistCircumferenceCentimeter, nil
	case "source_type":
		return BodyColumnExprBodySourceType, nil
	case "source_provider":
		return BodyColumnExprBodySourceProvider, nil
	case "source_app_id":
		return BodyColumnExprBodySourceAppId, nil
	case "source_device_id":
		return BodyColumnExprBodySourceDeviceId, nil
	case "time_zone":
		return BodyColumnExprBodyTimeZone, nil
	}
	var t BodyColumnExprBody
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BodyColumnExprBody) Ptr() *BodyColumnExprBody {
	return &b
}

var (
	chronotypeValueMacroExprFieldVersion = big.NewInt(1 << 0)
)

type ChronotypeValueMacroExpr struct {
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	valueMacro     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChronotypeValueMacroExpr) ValueMacro() string {
	return c.valueMacro
}

func (c *ChronotypeValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChronotypeValueMacroExpr) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChronotypeValueMacroExpr) SetVersion(version *string) {
	c.Version = version
	c.require(chronotypeValueMacroExprFieldVersion)
}

func (c *ChronotypeValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed ChronotypeValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ChronotypeValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "chronotype" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "chronotype", unmarshaler.ValueMacro)
	}
	c.valueMacro = unmarshaler.ValueMacro
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "value_macro")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChronotypeValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed ChronotypeValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*c),
		ValueMacro: "chronotype",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChronotypeValueMacroExpr) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	continuousQueryTaskHistoryEntryFieldQueryId      = big.NewInt(1 << 0)
	continuousQueryTaskHistoryEntryFieldUserId       = big.NewInt(1 << 1)
	continuousQueryTaskHistoryEntryFieldStatus       = big.NewInt(1 << 2)
	continuousQueryTaskHistoryEntryFieldScheduledAt  = big.NewInt(1 << 3)
	continuousQueryTaskHistoryEntryFieldStartedAt    = big.NewInt(1 << 4)
	continuousQueryTaskHistoryEntryFieldEndedAt      = big.NewInt(1 << 5)
	continuousQueryTaskHistoryEntryFieldErrorDetails = big.NewInt(1 << 6)
)

type ContinuousQueryTaskHistoryEntry struct {
	QueryId      string                    `json:"query_id" url:"query_id"`
	UserId       string                    `json:"user_id" url:"user_id"`
	Status       ContinuousQueryTaskStatus `json:"status" url:"status"`
	ScheduledAt  time.Time                 `json:"scheduled_at" url:"scheduled_at"`
	StartedAt    *time.Time                `json:"started_at,omitempty" url:"started_at,omitempty"`
	EndedAt      *time.Time                `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	ErrorDetails *string                   `json:"error_details,omitempty" url:"error_details,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContinuousQueryTaskHistoryEntry) GetQueryId() string {
	if c == nil {
		return ""
	}
	return c.QueryId
}

func (c *ContinuousQueryTaskHistoryEntry) GetUserId() string {
	if c == nil {
		return ""
	}
	return c.UserId
}

func (c *ContinuousQueryTaskHistoryEntry) GetStatus() ContinuousQueryTaskStatus {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *ContinuousQueryTaskHistoryEntry) GetScheduledAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.ScheduledAt
}

func (c *ContinuousQueryTaskHistoryEntry) GetStartedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.StartedAt
}

func (c *ContinuousQueryTaskHistoryEntry) GetEndedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.EndedAt
}

func (c *ContinuousQueryTaskHistoryEntry) GetErrorDetails() *string {
	if c == nil {
		return nil
	}
	return c.ErrorDetails
}

func (c *ContinuousQueryTaskHistoryEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContinuousQueryTaskHistoryEntry) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetQueryId sets the QueryId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryEntry) SetQueryId(queryId string) {
	c.QueryId = queryId
	c.require(continuousQueryTaskHistoryEntryFieldQueryId)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryEntry) SetUserId(userId string) {
	c.UserId = userId
	c.require(continuousQueryTaskHistoryEntryFieldUserId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryEntry) SetStatus(status ContinuousQueryTaskStatus) {
	c.Status = status
	c.require(continuousQueryTaskHistoryEntryFieldStatus)
}

// SetScheduledAt sets the ScheduledAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryEntry) SetScheduledAt(scheduledAt time.Time) {
	c.ScheduledAt = scheduledAt
	c.require(continuousQueryTaskHistoryEntryFieldScheduledAt)
}

// SetStartedAt sets the StartedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryEntry) SetStartedAt(startedAt *time.Time) {
	c.StartedAt = startedAt
	c.require(continuousQueryTaskHistoryEntryFieldStartedAt)
}

// SetEndedAt sets the EndedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryEntry) SetEndedAt(endedAt *time.Time) {
	c.EndedAt = endedAt
	c.require(continuousQueryTaskHistoryEntryFieldEndedAt)
}

// SetErrorDetails sets the ErrorDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryEntry) SetErrorDetails(errorDetails *string) {
	c.ErrorDetails = errorDetails
	c.require(continuousQueryTaskHistoryEntryFieldErrorDetails)
}

func (c *ContinuousQueryTaskHistoryEntry) UnmarshalJSON(data []byte) error {
	type embed ContinuousQueryTaskHistoryEntry
	var unmarshaler = struct {
		embed
		ScheduledAt *internal.DateTime `json:"scheduled_at"`
		StartedAt   *internal.DateTime `json:"started_at,omitempty"`
		EndedAt     *internal.DateTime `json:"ended_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContinuousQueryTaskHistoryEntry(unmarshaler.embed)
	c.ScheduledAt = unmarshaler.ScheduledAt.Time()
	c.StartedAt = unmarshaler.StartedAt.TimePtr()
	c.EndedAt = unmarshaler.EndedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContinuousQueryTaskHistoryEntry) MarshalJSON() ([]byte, error) {
	type embed ContinuousQueryTaskHistoryEntry
	var marshaler = struct {
		embed
		ScheduledAt *internal.DateTime `json:"scheduled_at"`
		StartedAt   *internal.DateTime `json:"started_at,omitempty"`
		EndedAt     *internal.DateTime `json:"ended_at,omitempty"`
	}{
		embed:       embed(*c),
		ScheduledAt: internal.NewDateTime(c.ScheduledAt),
		StartedAt:   internal.NewOptionalDateTime(c.StartedAt),
		EndedAt:     internal.NewOptionalDateTime(c.EndedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContinuousQueryTaskHistoryEntry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	continuousQueryTaskHistoryResponseFieldData       = big.NewInt(1 << 0)
	continuousQueryTaskHistoryResponseFieldNextCursor = big.NewInt(1 << 1)
)

type ContinuousQueryTaskHistoryResponse struct {
	Data       []*ContinuousQueryTaskHistoryEntry `json:"data" url:"data"`
	NextCursor *string                            `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContinuousQueryTaskHistoryResponse) GetData() []*ContinuousQueryTaskHistoryEntry {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *ContinuousQueryTaskHistoryResponse) GetNextCursor() *string {
	if c == nil {
		return nil
	}
	return c.NextCursor
}

func (c *ContinuousQueryTaskHistoryResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContinuousQueryTaskHistoryResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryResponse) SetData(data []*ContinuousQueryTaskHistoryEntry) {
	c.Data = data
	c.require(continuousQueryTaskHistoryResponseFieldData)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContinuousQueryTaskHistoryResponse) SetNextCursor(nextCursor *string) {
	c.NextCursor = nextCursor
	c.require(continuousQueryTaskHistoryResponseFieldNextCursor)
}

func (c *ContinuousQueryTaskHistoryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ContinuousQueryTaskHistoryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContinuousQueryTaskHistoryResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContinuousQueryTaskHistoryResponse) MarshalJSON() ([]byte, error) {
	type embed ContinuousQueryTaskHistoryResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContinuousQueryTaskHistoryResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// ℹ️ This enum is non-exhaustive.
type ContinuousQueryTaskStatus string

const (
	ContinuousQueryTaskStatusScheduled ContinuousQueryTaskStatus = "scheduled"
	ContinuousQueryTaskStatusStarted   ContinuousQueryTaskStatus = "started"
	ContinuousQueryTaskStatusCompleted ContinuousQueryTaskStatus = "completed"
	ContinuousQueryTaskStatusError     ContinuousQueryTaskStatus = "error"
)

func NewContinuousQueryTaskStatusFromString(s string) (ContinuousQueryTaskStatus, error) {
	switch s {
	case "scheduled":
		return ContinuousQueryTaskStatusScheduled, nil
	case "started":
		return ContinuousQueryTaskStatusStarted, nil
	case "completed":
		return ContinuousQueryTaskStatusCompleted, nil
	case "error":
		return ContinuousQueryTaskStatusError, nil
	}
	var t ContinuousQueryTaskStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContinuousQueryTaskStatus) Ptr() *ContinuousQueryTaskStatus {
	return &c
}

var (
	datePartExprFieldArg      = big.NewInt(1 << 0)
	datePartExprFieldDatePart = big.NewInt(1 << 1)
)

type DatePartExpr struct {
	Arg *DatePartExprArg `json:"arg" url:"arg"`
	// ℹ️ This enum is non-exhaustive.
	DatePart DatePartExprDatePart `json:"date_part" url:"date_part"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DatePartExpr) GetArg() *DatePartExprArg {
	if d == nil {
		return nil
	}
	return d.Arg
}

func (d *DatePartExpr) GetDatePart() DatePartExprDatePart {
	if d == nil {
		return ""
	}
	return d.DatePart
}

func (d *DatePartExpr) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DatePartExpr) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetArg sets the Arg field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DatePartExpr) SetArg(arg *DatePartExprArg) {
	d.Arg = arg
	d.require(datePartExprFieldArg)
}

// SetDatePart sets the DatePart field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DatePartExpr) SetDatePart(datePart DatePartExprDatePart) {
	d.DatePart = datePart
	d.require(datePartExprFieldDatePart)
}

func (d *DatePartExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler DatePartExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatePartExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatePartExpr) MarshalJSON() ([]byte, error) {
	type embed DatePartExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DatePartExpr) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DatePartExprArg struct {
	IndexColumnExpr *IndexColumnExpr
	Placeholder     *Placeholder

	typ string
}

func (d *DatePartExprArg) GetIndexColumnExpr() *IndexColumnExpr {
	if d == nil {
		return nil
	}
	return d.IndexColumnExpr
}

func (d *DatePartExprArg) GetPlaceholder() *Placeholder {
	if d == nil {
		return nil
	}
	return d.Placeholder
}

func (d *DatePartExprArg) UnmarshalJSON(data []byte) error {
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		d.typ = "IndexColumnExpr"
		d.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		d.typ = "Placeholder"
		d.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DatePartExprArg) MarshalJSON() ([]byte, error) {
	if d.typ == "IndexColumnExpr" || d.IndexColumnExpr != nil {
		return json.Marshal(d.IndexColumnExpr)
	}
	if d.typ == "Placeholder" || d.Placeholder != nil {
		return json.Marshal(d.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DatePartExprArgVisitor interface {
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitPlaceholder(*Placeholder) error
}

func (d *DatePartExprArg) Accept(visitor DatePartExprArgVisitor) error {
	if d.typ == "IndexColumnExpr" || d.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(d.IndexColumnExpr)
	}
	if d.typ == "Placeholder" || d.Placeholder != nil {
		return visitor.VisitPlaceholder(d.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

// ℹ️ This enum is non-exhaustive.
type DatePartExprDatePart string

const (
	DatePartExprDatePartMinute     DatePartExprDatePart = "minute"
	DatePartExprDatePartHour       DatePartExprDatePart = "hour"
	DatePartExprDatePartDay        DatePartExprDatePart = "day"
	DatePartExprDatePartWeek       DatePartExprDatePart = "week"
	DatePartExprDatePartMonth      DatePartExprDatePart = "month"
	DatePartExprDatePartYear       DatePartExprDatePart = "year"
	DatePartExprDatePartWeekday    DatePartExprDatePart = "weekday"
	DatePartExprDatePartWeekOfYear DatePartExprDatePart = "week_of_year"
	DatePartExprDatePartDayOfYear  DatePartExprDatePart = "day_of_year"
)

func NewDatePartExprDatePartFromString(s string) (DatePartExprDatePart, error) {
	switch s {
	case "minute":
		return DatePartExprDatePartMinute, nil
	case "hour":
		return DatePartExprDatePartHour, nil
	case "day":
		return DatePartExprDatePartDay, nil
	case "week":
		return DatePartExprDatePartWeek, nil
	case "month":
		return DatePartExprDatePartMonth, nil
	case "year":
		return DatePartExprDatePartYear, nil
	case "weekday":
		return DatePartExprDatePartWeekday, nil
	case "week_of_year":
		return DatePartExprDatePartWeekOfYear, nil
	case "day_of_year":
		return DatePartExprDatePartDayOfYear, nil
	}
	var t DatePartExprDatePart
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatePartExprDatePart) Ptr() *DatePartExprDatePart {
	return &d
}

var (
	dateTruncExprFieldDateTrunc = big.NewInt(1 << 0)
	dateTruncExprFieldArg       = big.NewInt(1 << 1)
)

type DateTruncExpr struct {
	DateTrunc *Period           `json:"date_trunc" url:"date_trunc"`
	Arg       *DateTruncExprArg `json:"arg" url:"arg"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DateTruncExpr) GetDateTrunc() *Period {
	if d == nil {
		return nil
	}
	return d.DateTrunc
}

func (d *DateTruncExpr) GetArg() *DateTruncExprArg {
	if d == nil {
		return nil
	}
	return d.Arg
}

func (d *DateTruncExpr) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateTruncExpr) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDateTrunc sets the DateTrunc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DateTruncExpr) SetDateTrunc(dateTrunc *Period) {
	d.DateTrunc = dateTrunc
	d.require(dateTruncExprFieldDateTrunc)
}

// SetArg sets the Arg field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DateTruncExpr) SetArg(arg *DateTruncExprArg) {
	d.Arg = arg
	d.require(dateTruncExprFieldArg)
}

func (d *DateTruncExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler DateTruncExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateTruncExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateTruncExpr) MarshalJSON() ([]byte, error) {
	type embed DateTruncExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DateTruncExpr) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DateTruncExprArg struct {
	IndexColumnExpr *IndexColumnExpr
	Placeholder     *Placeholder

	typ string
}

func (d *DateTruncExprArg) GetIndexColumnExpr() *IndexColumnExpr {
	if d == nil {
		return nil
	}
	return d.IndexColumnExpr
}

func (d *DateTruncExprArg) GetPlaceholder() *Placeholder {
	if d == nil {
		return nil
	}
	return d.Placeholder
}

func (d *DateTruncExprArg) UnmarshalJSON(data []byte) error {
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		d.typ = "IndexColumnExpr"
		d.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		d.typ = "Placeholder"
		d.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DateTruncExprArg) MarshalJSON() ([]byte, error) {
	if d.typ == "IndexColumnExpr" || d.IndexColumnExpr != nil {
		return json.Marshal(d.IndexColumnExpr)
	}
	if d.typ == "Placeholder" || d.Placeholder != nil {
		return json.Marshal(d.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DateTruncExprArgVisitor interface {
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitPlaceholder(*Placeholder) error
}

func (d *DateTruncExprArg) Accept(visitor DateTruncExprArgVisitor) error {
	if d.typ == "IndexColumnExpr" || d.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(d.IndexColumnExpr)
	}
	if d.typ == "Placeholder" || d.Placeholder != nil {
		return visitor.VisitPlaceholder(d.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

var (
	discreteTimeseriesExprFieldTimeseries = big.NewInt(1 << 0)
	discreteTimeseriesExprFieldField      = big.NewInt(1 << 1)
)

type DiscreteTimeseriesExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Timeseries DiscreteTimeseriesExprTimeseries `json:"timeseries" url:"timeseries"`
	// ℹ️ This enum is non-exhaustive.
	Field DiscreteTimeseriesExprField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DiscreteTimeseriesExpr) GetTimeseries() DiscreteTimeseriesExprTimeseries {
	if d == nil {
		return ""
	}
	return d.Timeseries
}

func (d *DiscreteTimeseriesExpr) GetField() DiscreteTimeseriesExprField {
	if d == nil {
		return ""
	}
	return d.Field
}

func (d *DiscreteTimeseriesExpr) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiscreteTimeseriesExpr) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetTimeseries sets the Timeseries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DiscreteTimeseriesExpr) SetTimeseries(timeseries DiscreteTimeseriesExprTimeseries) {
	d.Timeseries = timeseries
	d.require(discreteTimeseriesExprFieldTimeseries)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DiscreteTimeseriesExpr) SetField(field DiscreteTimeseriesExprField) {
	d.Field = field
	d.require(discreteTimeseriesExprFieldField)
}

func (d *DiscreteTimeseriesExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler DiscreteTimeseriesExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiscreteTimeseriesExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiscreteTimeseriesExpr) MarshalJSON() ([]byte, error) {
	type embed DiscreteTimeseriesExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DiscreteTimeseriesExpr) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// ℹ️ This enum is non-exhaustive.
type DiscreteTimeseriesExprField string

const (
	DiscreteTimeseriesExprFieldSourceProvider  DiscreteTimeseriesExprField = "source_provider"
	DiscreteTimeseriesExprFieldSourceType      DiscreteTimeseriesExprField = "source_type"
	DiscreteTimeseriesExprFieldSourceAppId     DiscreteTimeseriesExprField = "source_app_id"
	DiscreteTimeseriesExprFieldSourceWorkoutId DiscreteTimeseriesExprField = "source_workout_id"
	DiscreteTimeseriesExprFieldSourceSport     DiscreteTimeseriesExprField = "source_sport"
	DiscreteTimeseriesExprFieldTimezoneOffset  DiscreteTimeseriesExprField = "timezone_offset"
	DiscreteTimeseriesExprFieldType            DiscreteTimeseriesExprField = "type"
	DiscreteTimeseriesExprFieldValue           DiscreteTimeseriesExprField = "value"
)

func NewDiscreteTimeseriesExprFieldFromString(s string) (DiscreteTimeseriesExprField, error) {
	switch s {
	case "source_provider":
		return DiscreteTimeseriesExprFieldSourceProvider, nil
	case "source_type":
		return DiscreteTimeseriesExprFieldSourceType, nil
	case "source_app_id":
		return DiscreteTimeseriesExprFieldSourceAppId, nil
	case "source_workout_id":
		return DiscreteTimeseriesExprFieldSourceWorkoutId, nil
	case "source_sport":
		return DiscreteTimeseriesExprFieldSourceSport, nil
	case "timezone_offset":
		return DiscreteTimeseriesExprFieldTimezoneOffset, nil
	case "type":
		return DiscreteTimeseriesExprFieldType, nil
	case "value":
		return DiscreteTimeseriesExprFieldValue, nil
	}
	var t DiscreteTimeseriesExprField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DiscreteTimeseriesExprField) Ptr() *DiscreteTimeseriesExprField {
	return &d
}

// ℹ️ This enum is non-exhaustive.
type DiscreteTimeseriesExprTimeseries string

const (
	DiscreteTimeseriesExprTimeseriesGlucose                  DiscreteTimeseriesExprTimeseries = "glucose"
	DiscreteTimeseriesExprTimeseriesHeartrate                DiscreteTimeseriesExprTimeseries = "heartrate"
	DiscreteTimeseriesExprTimeseriesHrv                      DiscreteTimeseriesExprTimeseries = "hrv"
	DiscreteTimeseriesExprTimeseriesIge                      DiscreteTimeseriesExprTimeseries = "ige"
	DiscreteTimeseriesExprTimeseriesIgg                      DiscreteTimeseriesExprTimeseries = "igg"
	DiscreteTimeseriesExprTimeseriesCholesterol              DiscreteTimeseriesExprTimeseries = "cholesterol"
	DiscreteTimeseriesExprTimeseriesWeight                   DiscreteTimeseriesExprTimeseries = "weight"
	DiscreteTimeseriesExprTimeseriesFat                      DiscreteTimeseriesExprTimeseries = "fat"
	DiscreteTimeseriesExprTimeseriesBloodOxygen              DiscreteTimeseriesExprTimeseries = "blood_oxygen"
	DiscreteTimeseriesExprTimeseriesElectrocardiogramVoltage DiscreteTimeseriesExprTimeseries = "electrocardiogram_voltage"
	DiscreteTimeseriesExprTimeseriesRespiratoryRate          DiscreteTimeseriesExprTimeseries = "respiratory_rate"
	DiscreteTimeseriesExprTimeseriesStressLevel              DiscreteTimeseriesExprTimeseries = "stress_level"
)

func NewDiscreteTimeseriesExprTimeseriesFromString(s string) (DiscreteTimeseriesExprTimeseries, error) {
	switch s {
	case "glucose":
		return DiscreteTimeseriesExprTimeseriesGlucose, nil
	case "heartrate":
		return DiscreteTimeseriesExprTimeseriesHeartrate, nil
	case "hrv":
		return DiscreteTimeseriesExprTimeseriesHrv, nil
	case "ige":
		return DiscreteTimeseriesExprTimeseriesIge, nil
	case "igg":
		return DiscreteTimeseriesExprTimeseriesIgg, nil
	case "cholesterol":
		return DiscreteTimeseriesExprTimeseriesCholesterol, nil
	case "weight":
		return DiscreteTimeseriesExprTimeseriesWeight, nil
	case "fat":
		return DiscreteTimeseriesExprTimeseriesFat, nil
	case "blood_oxygen":
		return DiscreteTimeseriesExprTimeseriesBloodOxygen, nil
	case "electrocardiogram_voltage":
		return DiscreteTimeseriesExprTimeseriesElectrocardiogramVoltage, nil
	case "respiratory_rate":
		return DiscreteTimeseriesExprTimeseriesRespiratoryRate, nil
	case "stress_level":
		return DiscreteTimeseriesExprTimeseriesStressLevel, nil
	}
	var t DiscreteTimeseriesExprTimeseries
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DiscreteTimeseriesExprTimeseries) Ptr() *DiscreteTimeseriesExprTimeseries {
	return &d
}

var (
	groupKeyColumnExprFieldGroupKey = big.NewInt(1 << 0)
)

type GroupKeyColumnExpr struct {
	GroupKey *GroupKeyColumnExprGroupKey `json:"group_key" url:"group_key"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupKeyColumnExpr) GetGroupKey() *GroupKeyColumnExprGroupKey {
	if g == nil {
		return nil
	}
	return g.GroupKey
}

func (g *GroupKeyColumnExpr) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupKeyColumnExpr) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroupKey sets the GroupKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupKeyColumnExpr) SetGroupKey(groupKey *GroupKeyColumnExprGroupKey) {
	g.GroupKey = groupKey
	g.require(groupKeyColumnExprFieldGroupKey)
}

func (g *GroupKeyColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupKeyColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupKeyColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupKeyColumnExpr) MarshalJSON() ([]byte, error) {
	type embed GroupKeyColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupKeyColumnExpr) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupKeyColumnExprGroupKey struct {
	Integer int
	Select  Select

	typ string
}

func (g *GroupKeyColumnExprGroupKey) GetInteger() int {
	if g == nil {
		return 0
	}
	return g.Integer
}

func (g *GroupKeyColumnExprGroupKey) GetSelect() Select {
	if g == nil {
		return ""
	}
	return g.Select
}

func (g *GroupKeyColumnExprGroupKey) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typ = "Integer"
		g.Integer = valueInteger
		return nil
	}
	var valueSelect Select
	if err := json.Unmarshal(data, &valueSelect); err == nil {
		g.typ = "Select"
		g.Select = valueSelect
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GroupKeyColumnExprGroupKey) MarshalJSON() ([]byte, error) {
	if g.typ == "Integer" || g.Integer != 0 {
		return json.Marshal(g.Integer)
	}
	if g.typ == "Select" || g.Select != "" {
		return json.Marshal(g.Select)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", g)
}

type GroupKeyColumnExprGroupKeyVisitor interface {
	VisitInteger(int) error
	VisitSelect(Select) error
}

func (g *GroupKeyColumnExprGroupKey) Accept(visitor GroupKeyColumnExprGroupKeyVisitor) error {
	if g.typ == "Integer" || g.Integer != 0 {
		return visitor.VisitInteger(g.Integer)
	}
	if g.typ == "Select" || g.Select != "" {
		return visitor.VisitSelect(g.Select)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", g)
}

var (
	indexColumnExprFieldIndex = big.NewInt(1 << 0)
)

type IndexColumnExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Index IndexColumnExprIndex `json:"index" url:"index"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndexColumnExpr) GetIndex() IndexColumnExprIndex {
	if i == nil {
		return ""
	}
	return i.Index
}

func (i *IndexColumnExpr) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndexColumnExpr) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetIndex sets the Index field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IndexColumnExpr) SetIndex(index IndexColumnExprIndex) {
	i.Index = index
	i.require(indexColumnExprFieldIndex)
}

func (i *IndexColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler IndexColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndexColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndexColumnExpr) MarshalJSON() ([]byte, error) {
	type embed IndexColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IndexColumnExpr) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// ℹ️ This enum is non-exhaustive.
type IndexColumnExprIndex string

const (
	IndexColumnExprIndexSleep      IndexColumnExprIndex = "sleep"
	IndexColumnExprIndexActivity   IndexColumnExprIndex = "activity"
	IndexColumnExprIndexWorkout    IndexColumnExprIndex = "workout"
	IndexColumnExprIndexBody       IndexColumnExprIndex = "body"
	IndexColumnExprIndexMeal       IndexColumnExprIndex = "meal"
	IndexColumnExprIndexTimeseries IndexColumnExprIndex = "timeseries"
)

func NewIndexColumnExprIndexFromString(s string) (IndexColumnExprIndex, error) {
	switch s {
	case "sleep":
		return IndexColumnExprIndexSleep, nil
	case "activity":
		return IndexColumnExprIndexActivity, nil
	case "workout":
		return IndexColumnExprIndexWorkout, nil
	case "body":
		return IndexColumnExprIndexBody, nil
	case "meal":
		return IndexColumnExprIndexMeal, nil
	case "timeseries":
		return IndexColumnExprIndexTimeseries, nil
	}
	var t IndexColumnExprIndex
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IndexColumnExprIndex) Ptr() *IndexColumnExprIndex {
	return &i
}

var (
	intervalTimeseriesExprFieldTimeseries = big.NewInt(1 << 0)
	intervalTimeseriesExprFieldField      = big.NewInt(1 << 1)
)

type IntervalTimeseriesExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Timeseries IntervalTimeseriesExprTimeseries `json:"timeseries" url:"timeseries"`
	// ℹ️ This enum is non-exhaustive.
	Field IntervalTimeseriesExprField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntervalTimeseriesExpr) GetTimeseries() IntervalTimeseriesExprTimeseries {
	if i == nil {
		return ""
	}
	return i.Timeseries
}

func (i *IntervalTimeseriesExpr) GetField() IntervalTimeseriesExprField {
	if i == nil {
		return ""
	}
	return i.Field
}

func (i *IntervalTimeseriesExpr) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntervalTimeseriesExpr) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetTimeseries sets the Timeseries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntervalTimeseriesExpr) SetTimeseries(timeseries IntervalTimeseriesExprTimeseries) {
	i.Timeseries = timeseries
	i.require(intervalTimeseriesExprFieldTimeseries)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntervalTimeseriesExpr) SetField(field IntervalTimeseriesExprField) {
	i.Field = field
	i.require(intervalTimeseriesExprFieldField)
}

func (i *IntervalTimeseriesExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler IntervalTimeseriesExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntervalTimeseriesExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntervalTimeseriesExpr) MarshalJSON() ([]byte, error) {
	type embed IntervalTimeseriesExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntervalTimeseriesExpr) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// ℹ️ This enum is non-exhaustive.
type IntervalTimeseriesExprField string

const (
	IntervalTimeseriesExprFieldSourceProvider  IntervalTimeseriesExprField = "source_provider"
	IntervalTimeseriesExprFieldSourceType      IntervalTimeseriesExprField = "source_type"
	IntervalTimeseriesExprFieldSourceAppId     IntervalTimeseriesExprField = "source_app_id"
	IntervalTimeseriesExprFieldSourceWorkoutId IntervalTimeseriesExprField = "source_workout_id"
	IntervalTimeseriesExprFieldSourceSport     IntervalTimeseriesExprField = "source_sport"
	IntervalTimeseriesExprFieldTimezoneOffset  IntervalTimeseriesExprField = "timezone_offset"
	IntervalTimeseriesExprFieldType            IntervalTimeseriesExprField = "type"
	IntervalTimeseriesExprFieldDuration        IntervalTimeseriesExprField = "duration"
	IntervalTimeseriesExprFieldValue           IntervalTimeseriesExprField = "value"
)

func NewIntervalTimeseriesExprFieldFromString(s string) (IntervalTimeseriesExprField, error) {
	switch s {
	case "source_provider":
		return IntervalTimeseriesExprFieldSourceProvider, nil
	case "source_type":
		return IntervalTimeseriesExprFieldSourceType, nil
	case "source_app_id":
		return IntervalTimeseriesExprFieldSourceAppId, nil
	case "source_workout_id":
		return IntervalTimeseriesExprFieldSourceWorkoutId, nil
	case "source_sport":
		return IntervalTimeseriesExprFieldSourceSport, nil
	case "timezone_offset":
		return IntervalTimeseriesExprFieldTimezoneOffset, nil
	case "type":
		return IntervalTimeseriesExprFieldType, nil
	case "duration":
		return IntervalTimeseriesExprFieldDuration, nil
	case "value":
		return IntervalTimeseriesExprFieldValue, nil
	}
	var t IntervalTimeseriesExprField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntervalTimeseriesExprField) Ptr() *IntervalTimeseriesExprField {
	return &i
}

// ℹ️ This enum is non-exhaustive.
type IntervalTimeseriesExprTimeseries string

const (
	IntervalTimeseriesExprTimeseriesSteps                      IntervalTimeseriesExprTimeseries = "steps"
	IntervalTimeseriesExprTimeseriesDistance                   IntervalTimeseriesExprTimeseries = "distance"
	IntervalTimeseriesExprTimeseriesVo2Max                     IntervalTimeseriesExprTimeseries = "vo2_max"
	IntervalTimeseriesExprTimeseriesHeartRateAlert             IntervalTimeseriesExprTimeseries = "heart_rate_alert"
	IntervalTimeseriesExprTimeseriesStandHour                  IntervalTimeseriesExprTimeseries = "stand_hour"
	IntervalTimeseriesExprTimeseriesSleepBreathingDisturbance  IntervalTimeseriesExprTimeseries = "sleep_breathing_disturbance"
	IntervalTimeseriesExprTimeseriesInsulinInjection           IntervalTimeseriesExprTimeseries = "insulin_injection"
	IntervalTimeseriesExprTimeseriesWater                      IntervalTimeseriesExprTimeseries = "water"
	IntervalTimeseriesExprTimeseriesCaffeine                   IntervalTimeseriesExprTimeseries = "caffeine"
	IntervalTimeseriesExprTimeseriesMindfulnessMinutes         IntervalTimeseriesExprTimeseries = "mindfulness_minutes"
	IntervalTimeseriesExprTimeseriesCaloriesActive             IntervalTimeseriesExprTimeseries = "calories_active"
	IntervalTimeseriesExprTimeseriesFloorsClimbed              IntervalTimeseriesExprTimeseries = "floors_climbed"
	IntervalTimeseriesExprTimeseriesCaloriesBasal              IntervalTimeseriesExprTimeseries = "calories_basal"
	IntervalTimeseriesExprTimeseriesAfibBurden                 IntervalTimeseriesExprTimeseries = "afib_burden"
	IntervalTimeseriesExprTimeseriesStandDuration              IntervalTimeseriesExprTimeseries = "stand_duration"
	IntervalTimeseriesExprTimeseriesSleepApneaAlert            IntervalTimeseriesExprTimeseries = "sleep_apnea_alert"
	IntervalTimeseriesExprTimeseriesWheelchairPush             IntervalTimeseriesExprTimeseries = "wheelchair_push"
	IntervalTimeseriesExprTimeseriesForcedExpiratoryVolume1    IntervalTimeseriesExprTimeseries = "forced_expiratory_volume_1"
	IntervalTimeseriesExprTimeseriesForcedVitalCapacity        IntervalTimeseriesExprTimeseries = "forced_vital_capacity"
	IntervalTimeseriesExprTimeseriesPeakExpiratoryFlowRate     IntervalTimeseriesExprTimeseries = "peak_expiratory_flow_rate"
	IntervalTimeseriesExprTimeseriesInhalerUsage               IntervalTimeseriesExprTimeseries = "inhaler_usage"
	IntervalTimeseriesExprTimeseriesFall                       IntervalTimeseriesExprTimeseries = "fall"
	IntervalTimeseriesExprTimeseriesUvExposure                 IntervalTimeseriesExprTimeseries = "uv_exposure"
	IntervalTimeseriesExprTimeseriesDaylightExposure           IntervalTimeseriesExprTimeseries = "daylight_exposure"
	IntervalTimeseriesExprTimeseriesHandwashing                IntervalTimeseriesExprTimeseries = "handwashing"
	IntervalTimeseriesExprTimeseriesBasalBodyTemperature       IntervalTimeseriesExprTimeseries = "basal_body_temperature"
	IntervalTimeseriesExprTimeseriesBodyMassIndex              IntervalTimeseriesExprTimeseries = "body_mass_index"
	IntervalTimeseriesExprTimeseriesLeanBodyMass               IntervalTimeseriesExprTimeseries = "lean_body_mass"
	IntervalTimeseriesExprTimeseriesWaistCircumference         IntervalTimeseriesExprTimeseries = "waist_circumference"
	IntervalTimeseriesExprTimeseriesHeartRateRecoveryOneMinute IntervalTimeseriesExprTimeseries = "heart_rate_recovery_one_minute"
	IntervalTimeseriesExprTimeseriesWorkoutSwimmingStroke      IntervalTimeseriesExprTimeseries = "workout_swimming_stroke"
	IntervalTimeseriesExprTimeseriesWorkoutDistance            IntervalTimeseriesExprTimeseries = "workout_distance"
	IntervalTimeseriesExprTimeseriesCarbohydrates              IntervalTimeseriesExprTimeseries = "carbohydrates"
)

func NewIntervalTimeseriesExprTimeseriesFromString(s string) (IntervalTimeseriesExprTimeseries, error) {
	switch s {
	case "steps":
		return IntervalTimeseriesExprTimeseriesSteps, nil
	case "distance":
		return IntervalTimeseriesExprTimeseriesDistance, nil
	case "vo2_max":
		return IntervalTimeseriesExprTimeseriesVo2Max, nil
	case "heart_rate_alert":
		return IntervalTimeseriesExprTimeseriesHeartRateAlert, nil
	case "stand_hour":
		return IntervalTimeseriesExprTimeseriesStandHour, nil
	case "sleep_breathing_disturbance":
		return IntervalTimeseriesExprTimeseriesSleepBreathingDisturbance, nil
	case "insulin_injection":
		return IntervalTimeseriesExprTimeseriesInsulinInjection, nil
	case "water":
		return IntervalTimeseriesExprTimeseriesWater, nil
	case "caffeine":
		return IntervalTimeseriesExprTimeseriesCaffeine, nil
	case "mindfulness_minutes":
		return IntervalTimeseriesExprTimeseriesMindfulnessMinutes, nil
	case "calories_active":
		return IntervalTimeseriesExprTimeseriesCaloriesActive, nil
	case "floors_climbed":
		return IntervalTimeseriesExprTimeseriesFloorsClimbed, nil
	case "calories_basal":
		return IntervalTimeseriesExprTimeseriesCaloriesBasal, nil
	case "afib_burden":
		return IntervalTimeseriesExprTimeseriesAfibBurden, nil
	case "stand_duration":
		return IntervalTimeseriesExprTimeseriesStandDuration, nil
	case "sleep_apnea_alert":
		return IntervalTimeseriesExprTimeseriesSleepApneaAlert, nil
	case "wheelchair_push":
		return IntervalTimeseriesExprTimeseriesWheelchairPush, nil
	case "forced_expiratory_volume_1":
		return IntervalTimeseriesExprTimeseriesForcedExpiratoryVolume1, nil
	case "forced_vital_capacity":
		return IntervalTimeseriesExprTimeseriesForcedVitalCapacity, nil
	case "peak_expiratory_flow_rate":
		return IntervalTimeseriesExprTimeseriesPeakExpiratoryFlowRate, nil
	case "inhaler_usage":
		return IntervalTimeseriesExprTimeseriesInhalerUsage, nil
	case "fall":
		return IntervalTimeseriesExprTimeseriesFall, nil
	case "uv_exposure":
		return IntervalTimeseriesExprTimeseriesUvExposure, nil
	case "daylight_exposure":
		return IntervalTimeseriesExprTimeseriesDaylightExposure, nil
	case "handwashing":
		return IntervalTimeseriesExprTimeseriesHandwashing, nil
	case "basal_body_temperature":
		return IntervalTimeseriesExprTimeseriesBasalBodyTemperature, nil
	case "body_mass_index":
		return IntervalTimeseriesExprTimeseriesBodyMassIndex, nil
	case "lean_body_mass":
		return IntervalTimeseriesExprTimeseriesLeanBodyMass, nil
	case "waist_circumference":
		return IntervalTimeseriesExprTimeseriesWaistCircumference, nil
	case "heart_rate_recovery_one_minute":
		return IntervalTimeseriesExprTimeseriesHeartRateRecoveryOneMinute, nil
	case "workout_swimming_stroke":
		return IntervalTimeseriesExprTimeseriesWorkoutSwimmingStroke, nil
	case "workout_distance":
		return IntervalTimeseriesExprTimeseriesWorkoutDistance, nil
	case "carbohydrates":
		return IntervalTimeseriesExprTimeseriesCarbohydrates, nil
	}
	var t IntervalTimeseriesExprTimeseries
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntervalTimeseriesExprTimeseries) Ptr() *IntervalTimeseriesExprTimeseries {
	return &i
}

var (
	mealColumnExprFieldMeal = big.NewInt(1 << 0)
)

type MealColumnExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Meal MealColumnExprMeal `json:"meal" url:"meal"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MealColumnExpr) GetMeal() MealColumnExprMeal {
	if m == nil {
		return ""
	}
	return m.Meal
}

func (m *MealColumnExpr) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MealColumnExpr) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetMeal sets the Meal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MealColumnExpr) SetMeal(meal MealColumnExprMeal) {
	m.Meal = meal
	m.require(mealColumnExprFieldMeal)
}

func (m *MealColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler MealColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MealColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MealColumnExpr) MarshalJSON() ([]byte, error) {
	type embed MealColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MealColumnExpr) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// ℹ️ This enum is non-exhaustive.
type MealColumnExprMeal string

const (
	MealColumnExprMealCalories                 MealColumnExprMeal = "calories"
	MealColumnExprMealCarbohydrateGram         MealColumnExprMeal = "carbohydrate_gram"
	MealColumnExprMealProteinGram              MealColumnExprMeal = "protein_gram"
	MealColumnExprMealAlcoholGram              MealColumnExprMeal = "alcohol_gram"
	MealColumnExprMealWaterGram                MealColumnExprMeal = "water_gram"
	MealColumnExprMealFibreGram                MealColumnExprMeal = "fibre_gram"
	MealColumnExprMealSugarGram                MealColumnExprMeal = "sugar_gram"
	MealColumnExprMealCholesterolGram          MealColumnExprMeal = "cholesterol_gram"
	MealColumnExprMealSaturatedFatGram         MealColumnExprMeal = "saturated_fat_gram"
	MealColumnExprMealMonounsaturatedFatGram   MealColumnExprMeal = "monounsaturated_fat_gram"
	MealColumnExprMealPolyunsaturatedFatGram   MealColumnExprMeal = "polyunsaturated_fat_gram"
	MealColumnExprMealOmega3FatGram            MealColumnExprMeal = "omega3_fat_gram"
	MealColumnExprMealOmega6FatGram            MealColumnExprMeal = "omega6_fat_gram"
	MealColumnExprMealTotalFatGram             MealColumnExprMeal = "total_fat_gram"
	MealColumnExprMealSodiumMilligram          MealColumnExprMeal = "sodium_milligram"
	MealColumnExprMealPotassiumMilligram       MealColumnExprMeal = "potassium_milligram"
	MealColumnExprMealCalciumMilligram         MealColumnExprMeal = "calcium_milligram"
	MealColumnExprMealPhosphorusMilligram      MealColumnExprMeal = "phosphorus_milligram"
	MealColumnExprMealMagnesiumMilligram       MealColumnExprMeal = "magnesium_milligram"
	MealColumnExprMealIronMilligram            MealColumnExprMeal = "iron_milligram"
	MealColumnExprMealZincMilligram            MealColumnExprMeal = "zinc_milligram"
	MealColumnExprMealFluorideMilligram        MealColumnExprMeal = "fluoride_milligram"
	MealColumnExprMealChlorideMilligram        MealColumnExprMeal = "chloride_milligram"
	MealColumnExprMealVitaminAMilligram        MealColumnExprMeal = "vitamin_a_milligram"
	MealColumnExprMealVitaminB1Milligram       MealColumnExprMeal = "vitamin_b1_milligram"
	MealColumnExprMealRiboflavinMilligram      MealColumnExprMeal = "riboflavin_milligram"
	MealColumnExprMealNiacinMilligram          MealColumnExprMeal = "niacin_milligram"
	MealColumnExprMealPantothenicAcidMilligram MealColumnExprMeal = "pantothenic_acid_milligram"
	MealColumnExprMealVitaminB6Milligram       MealColumnExprMeal = "vitamin_b6_milligram"
	MealColumnExprMealBiotinMicrogram          MealColumnExprMeal = "biotin_microgram"
	MealColumnExprMealVitaminB12Microgram      MealColumnExprMeal = "vitamin_b12_microgram"
	MealColumnExprMealVitaminCMilligram        MealColumnExprMeal = "vitamin_c_milligram"
	MealColumnExprMealVitaminDMicrogram        MealColumnExprMeal = "vitamin_d_microgram"
	MealColumnExprMealVitaminEMilligram        MealColumnExprMeal = "vitamin_e_milligram"
	MealColumnExprMealVitaminKMicrogram        MealColumnExprMeal = "vitamin_k_microgram"
	MealColumnExprMealFolicAcidMicrogram       MealColumnExprMeal = "folic_acid_microgram"
	MealColumnExprMealChromiumMicrogram        MealColumnExprMeal = "chromium_microgram"
	MealColumnExprMealCopperMilligram          MealColumnExprMeal = "copper_milligram"
	MealColumnExprMealIodineMicrogram          MealColumnExprMeal = "iodine_microgram"
	MealColumnExprMealManganeseMilligram       MealColumnExprMeal = "manganese_milligram"
	MealColumnExprMealMolybdenumMicrogram      MealColumnExprMeal = "molybdenum_microgram"
	MealColumnExprMealSeleniumMicrogram        MealColumnExprMeal = "selenium_microgram"
	MealColumnExprMealDate                     MealColumnExprMeal = "date"
	MealColumnExprMealName                     MealColumnExprMeal = "name"
	MealColumnExprMealSourceType               MealColumnExprMeal = "source_type"
	MealColumnExprMealSourceProvider           MealColumnExprMeal = "source_provider"
	MealColumnExprMealSourceAppId              MealColumnExprMeal = "source_app_id"
	MealColumnExprMealSourceDeviceId           MealColumnExprMeal = "source_device_id"
)

func NewMealColumnExprMealFromString(s string) (MealColumnExprMeal, error) {
	switch s {
	case "calories":
		return MealColumnExprMealCalories, nil
	case "carbohydrate_gram":
		return MealColumnExprMealCarbohydrateGram, nil
	case "protein_gram":
		return MealColumnExprMealProteinGram, nil
	case "alcohol_gram":
		return MealColumnExprMealAlcoholGram, nil
	case "water_gram":
		return MealColumnExprMealWaterGram, nil
	case "fibre_gram":
		return MealColumnExprMealFibreGram, nil
	case "sugar_gram":
		return MealColumnExprMealSugarGram, nil
	case "cholesterol_gram":
		return MealColumnExprMealCholesterolGram, nil
	case "saturated_fat_gram":
		return MealColumnExprMealSaturatedFatGram, nil
	case "monounsaturated_fat_gram":
		return MealColumnExprMealMonounsaturatedFatGram, nil
	case "polyunsaturated_fat_gram":
		return MealColumnExprMealPolyunsaturatedFatGram, nil
	case "omega3_fat_gram":
		return MealColumnExprMealOmega3FatGram, nil
	case "omega6_fat_gram":
		return MealColumnExprMealOmega6FatGram, nil
	case "total_fat_gram":
		return MealColumnExprMealTotalFatGram, nil
	case "sodium_milligram":
		return MealColumnExprMealSodiumMilligram, nil
	case "potassium_milligram":
		return MealColumnExprMealPotassiumMilligram, nil
	case "calcium_milligram":
		return MealColumnExprMealCalciumMilligram, nil
	case "phosphorus_milligram":
		return MealColumnExprMealPhosphorusMilligram, nil
	case "magnesium_milligram":
		return MealColumnExprMealMagnesiumMilligram, nil
	case "iron_milligram":
		return MealColumnExprMealIronMilligram, nil
	case "zinc_milligram":
		return MealColumnExprMealZincMilligram, nil
	case "fluoride_milligram":
		return MealColumnExprMealFluorideMilligram, nil
	case "chloride_milligram":
		return MealColumnExprMealChlorideMilligram, nil
	case "vitamin_a_milligram":
		return MealColumnExprMealVitaminAMilligram, nil
	case "vitamin_b1_milligram":
		return MealColumnExprMealVitaminB1Milligram, nil
	case "riboflavin_milligram":
		return MealColumnExprMealRiboflavinMilligram, nil
	case "niacin_milligram":
		return MealColumnExprMealNiacinMilligram, nil
	case "pantothenic_acid_milligram":
		return MealColumnExprMealPantothenicAcidMilligram, nil
	case "vitamin_b6_milligram":
		return MealColumnExprMealVitaminB6Milligram, nil
	case "biotin_microgram":
		return MealColumnExprMealBiotinMicrogram, nil
	case "vitamin_b12_microgram":
		return MealColumnExprMealVitaminB12Microgram, nil
	case "vitamin_c_milligram":
		return MealColumnExprMealVitaminCMilligram, nil
	case "vitamin_d_microgram":
		return MealColumnExprMealVitaminDMicrogram, nil
	case "vitamin_e_milligram":
		return MealColumnExprMealVitaminEMilligram, nil
	case "vitamin_k_microgram":
		return MealColumnExprMealVitaminKMicrogram, nil
	case "folic_acid_microgram":
		return MealColumnExprMealFolicAcidMicrogram, nil
	case "chromium_microgram":
		return MealColumnExprMealChromiumMicrogram, nil
	case "copper_milligram":
		return MealColumnExprMealCopperMilligram, nil
	case "iodine_microgram":
		return MealColumnExprMealIodineMicrogram, nil
	case "manganese_milligram":
		return MealColumnExprMealManganeseMilligram, nil
	case "molybdenum_microgram":
		return MealColumnExprMealMolybdenumMicrogram, nil
	case "selenium_microgram":
		return MealColumnExprMealSeleniumMicrogram, nil
	case "date":
		return MealColumnExprMealDate, nil
	case "name":
		return MealColumnExprMealName, nil
	case "source_type":
		return MealColumnExprMealSourceType, nil
	case "source_provider":
		return MealColumnExprMealSourceProvider, nil
	case "source_app_id":
		return MealColumnExprMealSourceAppId, nil
	case "source_device_id":
		return MealColumnExprMealSourceDeviceId, nil
	}
	var t MealColumnExprMeal
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MealColumnExprMeal) Ptr() *MealColumnExprMeal {
	return &m
}

var (
	noteTimeseriesExprFieldField = big.NewInt(1 << 0)
)

type NoteTimeseriesExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Field NoteTimeseriesExprField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	timeseries     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NoteTimeseriesExpr) GetField() NoteTimeseriesExprField {
	if n == nil {
		return ""
	}
	return n.Field
}

func (n *NoteTimeseriesExpr) Timeseries() string {
	return n.timeseries
}

func (n *NoteTimeseriesExpr) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NoteTimeseriesExpr) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NoteTimeseriesExpr) SetField(field NoteTimeseriesExprField) {
	n.Field = field
	n.require(noteTimeseriesExprFieldField)
}

func (n *NoteTimeseriesExpr) UnmarshalJSON(data []byte) error {
	type embed NoteTimeseriesExpr
	var unmarshaler = struct {
		embed
		Timeseries string `json:"timeseries"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NoteTimeseriesExpr(unmarshaler.embed)
	if unmarshaler.Timeseries != "note" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", n, "note", unmarshaler.Timeseries)
	}
	n.timeseries = unmarshaler.Timeseries
	extraProperties, err := internal.ExtractExtraProperties(data, *n, "timeseries")
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NoteTimeseriesExpr) MarshalJSON() ([]byte, error) {
	type embed NoteTimeseriesExpr
	var marshaler = struct {
		embed
		Timeseries string `json:"timeseries"`
	}{
		embed:      embed(*n),
		Timeseries: "note",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NoteTimeseriesExpr) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// ℹ️ This enum is non-exhaustive.
type NoteTimeseriesExprField string

const (
	NoteTimeseriesExprFieldSourceProvider  NoteTimeseriesExprField = "source_provider"
	NoteTimeseriesExprFieldSourceType      NoteTimeseriesExprField = "source_type"
	NoteTimeseriesExprFieldSourceAppId     NoteTimeseriesExprField = "source_app_id"
	NoteTimeseriesExprFieldSourceWorkoutId NoteTimeseriesExprField = "source_workout_id"
	NoteTimeseriesExprFieldSourceSport     NoteTimeseriesExprField = "source_sport"
	NoteTimeseriesExprFieldTimezoneOffset  NoteTimeseriesExprField = "timezone_offset"
	NoteTimeseriesExprFieldType            NoteTimeseriesExprField = "type"
	NoteTimeseriesExprFieldTags            NoteTimeseriesExprField = "tags"
	NoteTimeseriesExprFieldContent         NoteTimeseriesExprField = "content"
)

func NewNoteTimeseriesExprFieldFromString(s string) (NoteTimeseriesExprField, error) {
	switch s {
	case "source_provider":
		return NoteTimeseriesExprFieldSourceProvider, nil
	case "source_type":
		return NoteTimeseriesExprFieldSourceType, nil
	case "source_app_id":
		return NoteTimeseriesExprFieldSourceAppId, nil
	case "source_workout_id":
		return NoteTimeseriesExprFieldSourceWorkoutId, nil
	case "source_sport":
		return NoteTimeseriesExprFieldSourceSport, nil
	case "timezone_offset":
		return NoteTimeseriesExprFieldTimezoneOffset, nil
	case "type":
		return NoteTimeseriesExprFieldType, nil
	case "tags":
		return NoteTimeseriesExprFieldTags, nil
	case "content":
		return NoteTimeseriesExprFieldContent, nil
	}
	var t NoteTimeseriesExprField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NoteTimeseriesExprField) Ptr() *NoteTimeseriesExprField {
	return &n
}

var (
	periodFieldValue = big.NewInt(1 << 0)
	periodFieldUnit  = big.NewInt(1 << 1)
)

type Period struct {
	Value *int `json:"value,omitempty" url:"value,omitempty"`
	// ℹ️ This enum is non-exhaustive.
	Unit PeriodUnit `json:"unit" url:"unit"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Period) GetValue() *int {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *Period) GetUnit() PeriodUnit {
	if p == nil {
		return ""
	}
	return p.Unit
}

func (p *Period) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Period) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Period) SetValue(value *int) {
	p.Value = value
	p.require(periodFieldValue)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Period) SetUnit(unit PeriodUnit) {
	p.Unit = unit
	p.require(periodFieldUnit)
}

func (p *Period) UnmarshalJSON(data []byte) error {
	type unmarshaler Period
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Period(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Period) MarshalJSON() ([]byte, error) {
	type embed Period
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Period) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// ℹ️ This enum is non-exhaustive.
type PeriodUnit string

const (
	PeriodUnitMinute PeriodUnit = "minute"
	PeriodUnitHour   PeriodUnit = "hour"
	PeriodUnitDay    PeriodUnit = "day"
	PeriodUnitWeek   PeriodUnit = "week"
	PeriodUnitMonth  PeriodUnit = "month"
	PeriodUnitYear   PeriodUnit = "year"
)

func NewPeriodUnitFromString(s string) (PeriodUnit, error) {
	switch s {
	case "minute":
		return PeriodUnitMinute, nil
	case "hour":
		return PeriodUnitHour, nil
	case "day":
		return PeriodUnitDay, nil
	case "week":
		return PeriodUnitWeek, nil
	case "month":
		return PeriodUnitMonth, nil
	case "year":
		return PeriodUnitYear, nil
	}
	var t PeriodUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PeriodUnit) Ptr() *PeriodUnit {
	return &p
}

var (
	placeholderFieldPlaceholder = big.NewInt(1 << 0)
)

type Placeholder struct {
	Placeholder bool `json:"placeholder" url:"placeholder"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Placeholder) GetPlaceholder() bool {
	if p == nil {
		return false
	}
	return p.Placeholder
}

func (p *Placeholder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Placeholder) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPlaceholder sets the Placeholder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Placeholder) SetPlaceholder(placeholder bool) {
	p.Placeholder = placeholder
	p.require(placeholderFieldPlaceholder)
}

func (p *Placeholder) UnmarshalJSON(data []byte) error {
	type unmarshaler Placeholder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Placeholder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Placeholder) MarshalJSON() ([]byte, error) {
	type embed Placeholder
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Placeholder) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	queryFieldSelect  = big.NewInt(1 << 0)
	queryFieldGroupBy = big.NewInt(1 << 1)
	queryFieldWhere   = big.NewInt(1 << 2)
)

type Query struct {
	Select  []*QuerySelectItem  `json:"select" url:"select"`
	GroupBy []*QueryGroupByItem `json:"group_by,omitempty" url:"group_by,omitempty"`
	// A WHERE clause filtering the input data. If a GROUP BY clause is present, filtering happens prior to GROUP BY evaluation.
	//
	// WHERE clause uses SQL Expression syntax to describe the filtering criteria:
	// * Available operators: `>`, `>=`, `<`, `<=`, `=`, `!=`, `NOT`, `AND` and `OR`.
	// * Parentheses is supported.
	Where *string `json:"where,omitempty" url:"where,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *Query) GetSelect() []*QuerySelectItem {
	if q == nil {
		return nil
	}
	return q.Select
}

func (q *Query) GetGroupBy() []*QueryGroupByItem {
	if q == nil {
		return nil
	}
	return q.GroupBy
}

func (q *Query) GetWhere() *string {
	if q == nil {
		return nil
	}
	return q.Where
}

func (q *Query) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *Query) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetSelect sets the Select field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *Query) SetSelect(select_ []*QuerySelectItem) {
	q.Select = select_
	q.require(queryFieldSelect)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *Query) SetGroupBy(groupBy []*QueryGroupByItem) {
	q.GroupBy = groupBy
	q.require(queryFieldGroupBy)
}

// SetWhere sets the Where field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *Query) SetWhere(where *string) {
	q.Where = where
	q.require(queryFieldWhere)
}

func (q *Query) UnmarshalJSON(data []byte) error {
	type unmarshaler Query
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = Query(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *Query) MarshalJSON() ([]byte, error) {
	type embed Query
	var marshaler = struct {
		embed
	}{
		embed: embed(*q),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, q.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (q *Query) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

var (
	queryConfigFieldProviderPriorityOverrides = big.NewInt(1 << 0)
)

type QueryConfig struct {
	ProviderPriorityOverrides []*QueryConfigProviderPriorityOverridesItem `json:"provider_priority_overrides,omitempty" url:"provider_priority_overrides,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryConfig) GetProviderPriorityOverrides() []*QueryConfigProviderPriorityOverridesItem {
	if q == nil {
		return nil
	}
	return q.ProviderPriorityOverrides
}

func (q *QueryConfig) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryConfig) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetProviderPriorityOverrides sets the ProviderPriorityOverrides field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryConfig) SetProviderPriorityOverrides(providerPriorityOverrides []*QueryConfigProviderPriorityOverridesItem) {
	q.ProviderPriorityOverrides = providerPriorityOverrides
	q.require(queryConfigFieldProviderPriorityOverrides)
}

func (q *QueryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryConfig) MarshalJSON() ([]byte, error) {
	type embed QueryConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*q),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, q.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (q *QueryConfig) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryConfigProviderPriorityOverridesItem struct {
	Providers Providers
	Labs      Labs

	typ string
}

func (q *QueryConfigProviderPriorityOverridesItem) GetProviders() Providers {
	if q == nil {
		return ""
	}
	return q.Providers
}

func (q *QueryConfigProviderPriorityOverridesItem) GetLabs() Labs {
	if q == nil {
		return ""
	}
	return q.Labs
}

func (q *QueryConfigProviderPriorityOverridesItem) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		q.typ = "Providers"
		q.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		q.typ = "Labs"
		q.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryConfigProviderPriorityOverridesItem) MarshalJSON() ([]byte, error) {
	if q.typ == "Providers" || q.Providers != "" {
		return json.Marshal(q.Providers)
	}
	if q.typ == "Labs" || q.Labs != "" {
		return json.Marshal(q.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryConfigProviderPriorityOverridesItemVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (q *QueryConfigProviderPriorityOverridesItem) Accept(visitor QueryConfigProviderPriorityOverridesItemVisitor) error {
	if q.typ == "Providers" || q.Providers != "" {
		return visitor.VisitProviders(q.Providers)
	}
	if q.typ == "Labs" || q.Labs != "" {
		return visitor.VisitLabs(q.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryGroupByItem struct {
	DateTruncExpr                 *DateTruncExpr
	DatePartExpr                  *DatePartExpr
	SleepColumnExpr               *SleepColumnExpr
	ActivityColumnExpr            *ActivityColumnExpr
	WorkoutColumnExpr             *WorkoutColumnExpr
	BodyColumnExpr                *BodyColumnExpr
	MealColumnExpr                *MealColumnExpr
	SleepScoreValueMacroExpr      *SleepScoreValueMacroExpr
	ChronotypeValueMacroExpr      *ChronotypeValueMacroExpr
	AsleepAtValueMacroExpr        *AsleepAtValueMacroExpr
	AwakeAtValueMacroExpr         *AwakeAtValueMacroExpr
	UnrecognizedValueMacroExpr    *UnrecognizedValueMacroExpr
	DiscreteTimeseriesExpr        *DiscreteTimeseriesExpr
	IntervalTimeseriesExpr        *IntervalTimeseriesExpr
	BloodPressureTimeseriesExpr   *BloodPressureTimeseriesExpr
	TemperatureTimeseriesExpr     *TemperatureTimeseriesExpr
	WorkoutDurationTimeseriesExpr *WorkoutDurationTimeseriesExpr
	NoteTimeseriesExpr            *NoteTimeseriesExpr
	SourceColumnExpr              *SourceColumnExpr

	typ string
}

func (q *QueryGroupByItem) GetDateTruncExpr() *DateTruncExpr {
	if q == nil {
		return nil
	}
	return q.DateTruncExpr
}

func (q *QueryGroupByItem) GetDatePartExpr() *DatePartExpr {
	if q == nil {
		return nil
	}
	return q.DatePartExpr
}

func (q *QueryGroupByItem) GetSleepColumnExpr() *SleepColumnExpr {
	if q == nil {
		return nil
	}
	return q.SleepColumnExpr
}

func (q *QueryGroupByItem) GetActivityColumnExpr() *ActivityColumnExpr {
	if q == nil {
		return nil
	}
	return q.ActivityColumnExpr
}

func (q *QueryGroupByItem) GetWorkoutColumnExpr() *WorkoutColumnExpr {
	if q == nil {
		return nil
	}
	return q.WorkoutColumnExpr
}

func (q *QueryGroupByItem) GetBodyColumnExpr() *BodyColumnExpr {
	if q == nil {
		return nil
	}
	return q.BodyColumnExpr
}

func (q *QueryGroupByItem) GetMealColumnExpr() *MealColumnExpr {
	if q == nil {
		return nil
	}
	return q.MealColumnExpr
}

func (q *QueryGroupByItem) GetSleepScoreValueMacroExpr() *SleepScoreValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.SleepScoreValueMacroExpr
}

func (q *QueryGroupByItem) GetChronotypeValueMacroExpr() *ChronotypeValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.ChronotypeValueMacroExpr
}

func (q *QueryGroupByItem) GetAsleepAtValueMacroExpr() *AsleepAtValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.AsleepAtValueMacroExpr
}

func (q *QueryGroupByItem) GetAwakeAtValueMacroExpr() *AwakeAtValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.AwakeAtValueMacroExpr
}

func (q *QueryGroupByItem) GetUnrecognizedValueMacroExpr() *UnrecognizedValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.UnrecognizedValueMacroExpr
}

func (q *QueryGroupByItem) GetDiscreteTimeseriesExpr() *DiscreteTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.DiscreteTimeseriesExpr
}

func (q *QueryGroupByItem) GetIntervalTimeseriesExpr() *IntervalTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.IntervalTimeseriesExpr
}

func (q *QueryGroupByItem) GetBloodPressureTimeseriesExpr() *BloodPressureTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.BloodPressureTimeseriesExpr
}

func (q *QueryGroupByItem) GetTemperatureTimeseriesExpr() *TemperatureTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.TemperatureTimeseriesExpr
}

func (q *QueryGroupByItem) GetWorkoutDurationTimeseriesExpr() *WorkoutDurationTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.WorkoutDurationTimeseriesExpr
}

func (q *QueryGroupByItem) GetNoteTimeseriesExpr() *NoteTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.NoteTimeseriesExpr
}

func (q *QueryGroupByItem) GetSourceColumnExpr() *SourceColumnExpr {
	if q == nil {
		return nil
	}
	return q.SourceColumnExpr
}

func (q *QueryGroupByItem) UnmarshalJSON(data []byte) error {
	valueDateTruncExpr := new(DateTruncExpr)
	if err := json.Unmarshal(data, &valueDateTruncExpr); err == nil {
		q.typ = "DateTruncExpr"
		q.DateTruncExpr = valueDateTruncExpr
		return nil
	}
	valueDatePartExpr := new(DatePartExpr)
	if err := json.Unmarshal(data, &valueDatePartExpr); err == nil {
		q.typ = "DatePartExpr"
		q.DatePartExpr = valueDatePartExpr
		return nil
	}
	valueSleepColumnExpr := new(SleepColumnExpr)
	if err := json.Unmarshal(data, &valueSleepColumnExpr); err == nil {
		q.typ = "SleepColumnExpr"
		q.SleepColumnExpr = valueSleepColumnExpr
		return nil
	}
	valueActivityColumnExpr := new(ActivityColumnExpr)
	if err := json.Unmarshal(data, &valueActivityColumnExpr); err == nil {
		q.typ = "ActivityColumnExpr"
		q.ActivityColumnExpr = valueActivityColumnExpr
		return nil
	}
	valueWorkoutColumnExpr := new(WorkoutColumnExpr)
	if err := json.Unmarshal(data, &valueWorkoutColumnExpr); err == nil {
		q.typ = "WorkoutColumnExpr"
		q.WorkoutColumnExpr = valueWorkoutColumnExpr
		return nil
	}
	valueBodyColumnExpr := new(BodyColumnExpr)
	if err := json.Unmarshal(data, &valueBodyColumnExpr); err == nil {
		q.typ = "BodyColumnExpr"
		q.BodyColumnExpr = valueBodyColumnExpr
		return nil
	}
	valueMealColumnExpr := new(MealColumnExpr)
	if err := json.Unmarshal(data, &valueMealColumnExpr); err == nil {
		q.typ = "MealColumnExpr"
		q.MealColumnExpr = valueMealColumnExpr
		return nil
	}
	valueSleepScoreValueMacroExpr := new(SleepScoreValueMacroExpr)
	if err := json.Unmarshal(data, &valueSleepScoreValueMacroExpr); err == nil {
		q.typ = "SleepScoreValueMacroExpr"
		q.SleepScoreValueMacroExpr = valueSleepScoreValueMacroExpr
		return nil
	}
	valueChronotypeValueMacroExpr := new(ChronotypeValueMacroExpr)
	if err := json.Unmarshal(data, &valueChronotypeValueMacroExpr); err == nil {
		q.typ = "ChronotypeValueMacroExpr"
		q.ChronotypeValueMacroExpr = valueChronotypeValueMacroExpr
		return nil
	}
	valueAsleepAtValueMacroExpr := new(AsleepAtValueMacroExpr)
	if err := json.Unmarshal(data, &valueAsleepAtValueMacroExpr); err == nil {
		q.typ = "AsleepAtValueMacroExpr"
		q.AsleepAtValueMacroExpr = valueAsleepAtValueMacroExpr
		return nil
	}
	valueAwakeAtValueMacroExpr := new(AwakeAtValueMacroExpr)
	if err := json.Unmarshal(data, &valueAwakeAtValueMacroExpr); err == nil {
		q.typ = "AwakeAtValueMacroExpr"
		q.AwakeAtValueMacroExpr = valueAwakeAtValueMacroExpr
		return nil
	}
	valueUnrecognizedValueMacroExpr := new(UnrecognizedValueMacroExpr)
	if err := json.Unmarshal(data, &valueUnrecognizedValueMacroExpr); err == nil {
		q.typ = "UnrecognizedValueMacroExpr"
		q.UnrecognizedValueMacroExpr = valueUnrecognizedValueMacroExpr
		return nil
	}
	valueDiscreteTimeseriesExpr := new(DiscreteTimeseriesExpr)
	if err := json.Unmarshal(data, &valueDiscreteTimeseriesExpr); err == nil {
		q.typ = "DiscreteTimeseriesExpr"
		q.DiscreteTimeseriesExpr = valueDiscreteTimeseriesExpr
		return nil
	}
	valueIntervalTimeseriesExpr := new(IntervalTimeseriesExpr)
	if err := json.Unmarshal(data, &valueIntervalTimeseriesExpr); err == nil {
		q.typ = "IntervalTimeseriesExpr"
		q.IntervalTimeseriesExpr = valueIntervalTimeseriesExpr
		return nil
	}
	valueBloodPressureTimeseriesExpr := new(BloodPressureTimeseriesExpr)
	if err := json.Unmarshal(data, &valueBloodPressureTimeseriesExpr); err == nil {
		q.typ = "BloodPressureTimeseriesExpr"
		q.BloodPressureTimeseriesExpr = valueBloodPressureTimeseriesExpr
		return nil
	}
	valueTemperatureTimeseriesExpr := new(TemperatureTimeseriesExpr)
	if err := json.Unmarshal(data, &valueTemperatureTimeseriesExpr); err == nil {
		q.typ = "TemperatureTimeseriesExpr"
		q.TemperatureTimeseriesExpr = valueTemperatureTimeseriesExpr
		return nil
	}
	valueWorkoutDurationTimeseriesExpr := new(WorkoutDurationTimeseriesExpr)
	if err := json.Unmarshal(data, &valueWorkoutDurationTimeseriesExpr); err == nil {
		q.typ = "WorkoutDurationTimeseriesExpr"
		q.WorkoutDurationTimeseriesExpr = valueWorkoutDurationTimeseriesExpr
		return nil
	}
	valueNoteTimeseriesExpr := new(NoteTimeseriesExpr)
	if err := json.Unmarshal(data, &valueNoteTimeseriesExpr); err == nil {
		q.typ = "NoteTimeseriesExpr"
		q.NoteTimeseriesExpr = valueNoteTimeseriesExpr
		return nil
	}
	valueSourceColumnExpr := new(SourceColumnExpr)
	if err := json.Unmarshal(data, &valueSourceColumnExpr); err == nil {
		q.typ = "SourceColumnExpr"
		q.SourceColumnExpr = valueSourceColumnExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryGroupByItem) MarshalJSON() ([]byte, error) {
	if q.typ == "DateTruncExpr" || q.DateTruncExpr != nil {
		return json.Marshal(q.DateTruncExpr)
	}
	if q.typ == "DatePartExpr" || q.DatePartExpr != nil {
		return json.Marshal(q.DatePartExpr)
	}
	if q.typ == "SleepColumnExpr" || q.SleepColumnExpr != nil {
		return json.Marshal(q.SleepColumnExpr)
	}
	if q.typ == "ActivityColumnExpr" || q.ActivityColumnExpr != nil {
		return json.Marshal(q.ActivityColumnExpr)
	}
	if q.typ == "WorkoutColumnExpr" || q.WorkoutColumnExpr != nil {
		return json.Marshal(q.WorkoutColumnExpr)
	}
	if q.typ == "BodyColumnExpr" || q.BodyColumnExpr != nil {
		return json.Marshal(q.BodyColumnExpr)
	}
	if q.typ == "MealColumnExpr" || q.MealColumnExpr != nil {
		return json.Marshal(q.MealColumnExpr)
	}
	if q.typ == "SleepScoreValueMacroExpr" || q.SleepScoreValueMacroExpr != nil {
		return json.Marshal(q.SleepScoreValueMacroExpr)
	}
	if q.typ == "ChronotypeValueMacroExpr" || q.ChronotypeValueMacroExpr != nil {
		return json.Marshal(q.ChronotypeValueMacroExpr)
	}
	if q.typ == "AsleepAtValueMacroExpr" || q.AsleepAtValueMacroExpr != nil {
		return json.Marshal(q.AsleepAtValueMacroExpr)
	}
	if q.typ == "AwakeAtValueMacroExpr" || q.AwakeAtValueMacroExpr != nil {
		return json.Marshal(q.AwakeAtValueMacroExpr)
	}
	if q.typ == "UnrecognizedValueMacroExpr" || q.UnrecognizedValueMacroExpr != nil {
		return json.Marshal(q.UnrecognizedValueMacroExpr)
	}
	if q.typ == "DiscreteTimeseriesExpr" || q.DiscreteTimeseriesExpr != nil {
		return json.Marshal(q.DiscreteTimeseriesExpr)
	}
	if q.typ == "IntervalTimeseriesExpr" || q.IntervalTimeseriesExpr != nil {
		return json.Marshal(q.IntervalTimeseriesExpr)
	}
	if q.typ == "BloodPressureTimeseriesExpr" || q.BloodPressureTimeseriesExpr != nil {
		return json.Marshal(q.BloodPressureTimeseriesExpr)
	}
	if q.typ == "TemperatureTimeseriesExpr" || q.TemperatureTimeseriesExpr != nil {
		return json.Marshal(q.TemperatureTimeseriesExpr)
	}
	if q.typ == "WorkoutDurationTimeseriesExpr" || q.WorkoutDurationTimeseriesExpr != nil {
		return json.Marshal(q.WorkoutDurationTimeseriesExpr)
	}
	if q.typ == "NoteTimeseriesExpr" || q.NoteTimeseriesExpr != nil {
		return json.Marshal(q.NoteTimeseriesExpr)
	}
	if q.typ == "SourceColumnExpr" || q.SourceColumnExpr != nil {
		return json.Marshal(q.SourceColumnExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryGroupByItemVisitor interface {
	VisitDateTruncExpr(*DateTruncExpr) error
	VisitDatePartExpr(*DatePartExpr) error
	VisitSleepColumnExpr(*SleepColumnExpr) error
	VisitActivityColumnExpr(*ActivityColumnExpr) error
	VisitWorkoutColumnExpr(*WorkoutColumnExpr) error
	VisitBodyColumnExpr(*BodyColumnExpr) error
	VisitMealColumnExpr(*MealColumnExpr) error
	VisitSleepScoreValueMacroExpr(*SleepScoreValueMacroExpr) error
	VisitChronotypeValueMacroExpr(*ChronotypeValueMacroExpr) error
	VisitAsleepAtValueMacroExpr(*AsleepAtValueMacroExpr) error
	VisitAwakeAtValueMacroExpr(*AwakeAtValueMacroExpr) error
	VisitUnrecognizedValueMacroExpr(*UnrecognizedValueMacroExpr) error
	VisitDiscreteTimeseriesExpr(*DiscreteTimeseriesExpr) error
	VisitIntervalTimeseriesExpr(*IntervalTimeseriesExpr) error
	VisitBloodPressureTimeseriesExpr(*BloodPressureTimeseriesExpr) error
	VisitTemperatureTimeseriesExpr(*TemperatureTimeseriesExpr) error
	VisitWorkoutDurationTimeseriesExpr(*WorkoutDurationTimeseriesExpr) error
	VisitNoteTimeseriesExpr(*NoteTimeseriesExpr) error
	VisitSourceColumnExpr(*SourceColumnExpr) error
}

func (q *QueryGroupByItem) Accept(visitor QueryGroupByItemVisitor) error {
	if q.typ == "DateTruncExpr" || q.DateTruncExpr != nil {
		return visitor.VisitDateTruncExpr(q.DateTruncExpr)
	}
	if q.typ == "DatePartExpr" || q.DatePartExpr != nil {
		return visitor.VisitDatePartExpr(q.DatePartExpr)
	}
	if q.typ == "SleepColumnExpr" || q.SleepColumnExpr != nil {
		return visitor.VisitSleepColumnExpr(q.SleepColumnExpr)
	}
	if q.typ == "ActivityColumnExpr" || q.ActivityColumnExpr != nil {
		return visitor.VisitActivityColumnExpr(q.ActivityColumnExpr)
	}
	if q.typ == "WorkoutColumnExpr" || q.WorkoutColumnExpr != nil {
		return visitor.VisitWorkoutColumnExpr(q.WorkoutColumnExpr)
	}
	if q.typ == "BodyColumnExpr" || q.BodyColumnExpr != nil {
		return visitor.VisitBodyColumnExpr(q.BodyColumnExpr)
	}
	if q.typ == "MealColumnExpr" || q.MealColumnExpr != nil {
		return visitor.VisitMealColumnExpr(q.MealColumnExpr)
	}
	if q.typ == "SleepScoreValueMacroExpr" || q.SleepScoreValueMacroExpr != nil {
		return visitor.VisitSleepScoreValueMacroExpr(q.SleepScoreValueMacroExpr)
	}
	if q.typ == "ChronotypeValueMacroExpr" || q.ChronotypeValueMacroExpr != nil {
		return visitor.VisitChronotypeValueMacroExpr(q.ChronotypeValueMacroExpr)
	}
	if q.typ == "AsleepAtValueMacroExpr" || q.AsleepAtValueMacroExpr != nil {
		return visitor.VisitAsleepAtValueMacroExpr(q.AsleepAtValueMacroExpr)
	}
	if q.typ == "AwakeAtValueMacroExpr" || q.AwakeAtValueMacroExpr != nil {
		return visitor.VisitAwakeAtValueMacroExpr(q.AwakeAtValueMacroExpr)
	}
	if q.typ == "UnrecognizedValueMacroExpr" || q.UnrecognizedValueMacroExpr != nil {
		return visitor.VisitUnrecognizedValueMacroExpr(q.UnrecognizedValueMacroExpr)
	}
	if q.typ == "DiscreteTimeseriesExpr" || q.DiscreteTimeseriesExpr != nil {
		return visitor.VisitDiscreteTimeseriesExpr(q.DiscreteTimeseriesExpr)
	}
	if q.typ == "IntervalTimeseriesExpr" || q.IntervalTimeseriesExpr != nil {
		return visitor.VisitIntervalTimeseriesExpr(q.IntervalTimeseriesExpr)
	}
	if q.typ == "BloodPressureTimeseriesExpr" || q.BloodPressureTimeseriesExpr != nil {
		return visitor.VisitBloodPressureTimeseriesExpr(q.BloodPressureTimeseriesExpr)
	}
	if q.typ == "TemperatureTimeseriesExpr" || q.TemperatureTimeseriesExpr != nil {
		return visitor.VisitTemperatureTimeseriesExpr(q.TemperatureTimeseriesExpr)
	}
	if q.typ == "WorkoutDurationTimeseriesExpr" || q.WorkoutDurationTimeseriesExpr != nil {
		return visitor.VisitWorkoutDurationTimeseriesExpr(q.WorkoutDurationTimeseriesExpr)
	}
	if q.typ == "NoteTimeseriesExpr" || q.NoteTimeseriesExpr != nil {
		return visitor.VisitNoteTimeseriesExpr(q.NoteTimeseriesExpr)
	}
	if q.typ == "SourceColumnExpr" || q.SourceColumnExpr != nil {
		return visitor.VisitSourceColumnExpr(q.SourceColumnExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QuerySelectItem struct {
	AggregateExpr                 *AggregateExpr
	GroupKeyColumnExpr            *GroupKeyColumnExpr
	SleepColumnExpr               *SleepColumnExpr
	ActivityColumnExpr            *ActivityColumnExpr
	WorkoutColumnExpr             *WorkoutColumnExpr
	BodyColumnExpr                *BodyColumnExpr
	MealColumnExpr                *MealColumnExpr
	SleepScoreValueMacroExpr      *SleepScoreValueMacroExpr
	ChronotypeValueMacroExpr      *ChronotypeValueMacroExpr
	AsleepAtValueMacroExpr        *AsleepAtValueMacroExpr
	AwakeAtValueMacroExpr         *AwakeAtValueMacroExpr
	UnrecognizedValueMacroExpr    *UnrecognizedValueMacroExpr
	DiscreteTimeseriesExpr        *DiscreteTimeseriesExpr
	IntervalTimeseriesExpr        *IntervalTimeseriesExpr
	BloodPressureTimeseriesExpr   *BloodPressureTimeseriesExpr
	TemperatureTimeseriesExpr     *TemperatureTimeseriesExpr
	WorkoutDurationTimeseriesExpr *WorkoutDurationTimeseriesExpr
	NoteTimeseriesExpr            *NoteTimeseriesExpr
	IndexColumnExpr               *IndexColumnExpr
	SourceColumnExpr              *SourceColumnExpr

	typ string
}

func (q *QuerySelectItem) GetAggregateExpr() *AggregateExpr {
	if q == nil {
		return nil
	}
	return q.AggregateExpr
}

func (q *QuerySelectItem) GetGroupKeyColumnExpr() *GroupKeyColumnExpr {
	if q == nil {
		return nil
	}
	return q.GroupKeyColumnExpr
}

func (q *QuerySelectItem) GetSleepColumnExpr() *SleepColumnExpr {
	if q == nil {
		return nil
	}
	return q.SleepColumnExpr
}

func (q *QuerySelectItem) GetActivityColumnExpr() *ActivityColumnExpr {
	if q == nil {
		return nil
	}
	return q.ActivityColumnExpr
}

func (q *QuerySelectItem) GetWorkoutColumnExpr() *WorkoutColumnExpr {
	if q == nil {
		return nil
	}
	return q.WorkoutColumnExpr
}

func (q *QuerySelectItem) GetBodyColumnExpr() *BodyColumnExpr {
	if q == nil {
		return nil
	}
	return q.BodyColumnExpr
}

func (q *QuerySelectItem) GetMealColumnExpr() *MealColumnExpr {
	if q == nil {
		return nil
	}
	return q.MealColumnExpr
}

func (q *QuerySelectItem) GetSleepScoreValueMacroExpr() *SleepScoreValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.SleepScoreValueMacroExpr
}

func (q *QuerySelectItem) GetChronotypeValueMacroExpr() *ChronotypeValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.ChronotypeValueMacroExpr
}

func (q *QuerySelectItem) GetAsleepAtValueMacroExpr() *AsleepAtValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.AsleepAtValueMacroExpr
}

func (q *QuerySelectItem) GetAwakeAtValueMacroExpr() *AwakeAtValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.AwakeAtValueMacroExpr
}

func (q *QuerySelectItem) GetUnrecognizedValueMacroExpr() *UnrecognizedValueMacroExpr {
	if q == nil {
		return nil
	}
	return q.UnrecognizedValueMacroExpr
}

func (q *QuerySelectItem) GetDiscreteTimeseriesExpr() *DiscreteTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.DiscreteTimeseriesExpr
}

func (q *QuerySelectItem) GetIntervalTimeseriesExpr() *IntervalTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.IntervalTimeseriesExpr
}

func (q *QuerySelectItem) GetBloodPressureTimeseriesExpr() *BloodPressureTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.BloodPressureTimeseriesExpr
}

func (q *QuerySelectItem) GetTemperatureTimeseriesExpr() *TemperatureTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.TemperatureTimeseriesExpr
}

func (q *QuerySelectItem) GetWorkoutDurationTimeseriesExpr() *WorkoutDurationTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.WorkoutDurationTimeseriesExpr
}

func (q *QuerySelectItem) GetNoteTimeseriesExpr() *NoteTimeseriesExpr {
	if q == nil {
		return nil
	}
	return q.NoteTimeseriesExpr
}

func (q *QuerySelectItem) GetIndexColumnExpr() *IndexColumnExpr {
	if q == nil {
		return nil
	}
	return q.IndexColumnExpr
}

func (q *QuerySelectItem) GetSourceColumnExpr() *SourceColumnExpr {
	if q == nil {
		return nil
	}
	return q.SourceColumnExpr
}

func (q *QuerySelectItem) UnmarshalJSON(data []byte) error {
	valueAggregateExpr := new(AggregateExpr)
	if err := json.Unmarshal(data, &valueAggregateExpr); err == nil {
		q.typ = "AggregateExpr"
		q.AggregateExpr = valueAggregateExpr
		return nil
	}
	valueGroupKeyColumnExpr := new(GroupKeyColumnExpr)
	if err := json.Unmarshal(data, &valueGroupKeyColumnExpr); err == nil {
		q.typ = "GroupKeyColumnExpr"
		q.GroupKeyColumnExpr = valueGroupKeyColumnExpr
		return nil
	}
	valueSleepColumnExpr := new(SleepColumnExpr)
	if err := json.Unmarshal(data, &valueSleepColumnExpr); err == nil {
		q.typ = "SleepColumnExpr"
		q.SleepColumnExpr = valueSleepColumnExpr
		return nil
	}
	valueActivityColumnExpr := new(ActivityColumnExpr)
	if err := json.Unmarshal(data, &valueActivityColumnExpr); err == nil {
		q.typ = "ActivityColumnExpr"
		q.ActivityColumnExpr = valueActivityColumnExpr
		return nil
	}
	valueWorkoutColumnExpr := new(WorkoutColumnExpr)
	if err := json.Unmarshal(data, &valueWorkoutColumnExpr); err == nil {
		q.typ = "WorkoutColumnExpr"
		q.WorkoutColumnExpr = valueWorkoutColumnExpr
		return nil
	}
	valueBodyColumnExpr := new(BodyColumnExpr)
	if err := json.Unmarshal(data, &valueBodyColumnExpr); err == nil {
		q.typ = "BodyColumnExpr"
		q.BodyColumnExpr = valueBodyColumnExpr
		return nil
	}
	valueMealColumnExpr := new(MealColumnExpr)
	if err := json.Unmarshal(data, &valueMealColumnExpr); err == nil {
		q.typ = "MealColumnExpr"
		q.MealColumnExpr = valueMealColumnExpr
		return nil
	}
	valueSleepScoreValueMacroExpr := new(SleepScoreValueMacroExpr)
	if err := json.Unmarshal(data, &valueSleepScoreValueMacroExpr); err == nil {
		q.typ = "SleepScoreValueMacroExpr"
		q.SleepScoreValueMacroExpr = valueSleepScoreValueMacroExpr
		return nil
	}
	valueChronotypeValueMacroExpr := new(ChronotypeValueMacroExpr)
	if err := json.Unmarshal(data, &valueChronotypeValueMacroExpr); err == nil {
		q.typ = "ChronotypeValueMacroExpr"
		q.ChronotypeValueMacroExpr = valueChronotypeValueMacroExpr
		return nil
	}
	valueAsleepAtValueMacroExpr := new(AsleepAtValueMacroExpr)
	if err := json.Unmarshal(data, &valueAsleepAtValueMacroExpr); err == nil {
		q.typ = "AsleepAtValueMacroExpr"
		q.AsleepAtValueMacroExpr = valueAsleepAtValueMacroExpr
		return nil
	}
	valueAwakeAtValueMacroExpr := new(AwakeAtValueMacroExpr)
	if err := json.Unmarshal(data, &valueAwakeAtValueMacroExpr); err == nil {
		q.typ = "AwakeAtValueMacroExpr"
		q.AwakeAtValueMacroExpr = valueAwakeAtValueMacroExpr
		return nil
	}
	valueUnrecognizedValueMacroExpr := new(UnrecognizedValueMacroExpr)
	if err := json.Unmarshal(data, &valueUnrecognizedValueMacroExpr); err == nil {
		q.typ = "UnrecognizedValueMacroExpr"
		q.UnrecognizedValueMacroExpr = valueUnrecognizedValueMacroExpr
		return nil
	}
	valueDiscreteTimeseriesExpr := new(DiscreteTimeseriesExpr)
	if err := json.Unmarshal(data, &valueDiscreteTimeseriesExpr); err == nil {
		q.typ = "DiscreteTimeseriesExpr"
		q.DiscreteTimeseriesExpr = valueDiscreteTimeseriesExpr
		return nil
	}
	valueIntervalTimeseriesExpr := new(IntervalTimeseriesExpr)
	if err := json.Unmarshal(data, &valueIntervalTimeseriesExpr); err == nil {
		q.typ = "IntervalTimeseriesExpr"
		q.IntervalTimeseriesExpr = valueIntervalTimeseriesExpr
		return nil
	}
	valueBloodPressureTimeseriesExpr := new(BloodPressureTimeseriesExpr)
	if err := json.Unmarshal(data, &valueBloodPressureTimeseriesExpr); err == nil {
		q.typ = "BloodPressureTimeseriesExpr"
		q.BloodPressureTimeseriesExpr = valueBloodPressureTimeseriesExpr
		return nil
	}
	valueTemperatureTimeseriesExpr := new(TemperatureTimeseriesExpr)
	if err := json.Unmarshal(data, &valueTemperatureTimeseriesExpr); err == nil {
		q.typ = "TemperatureTimeseriesExpr"
		q.TemperatureTimeseriesExpr = valueTemperatureTimeseriesExpr
		return nil
	}
	valueWorkoutDurationTimeseriesExpr := new(WorkoutDurationTimeseriesExpr)
	if err := json.Unmarshal(data, &valueWorkoutDurationTimeseriesExpr); err == nil {
		q.typ = "WorkoutDurationTimeseriesExpr"
		q.WorkoutDurationTimeseriesExpr = valueWorkoutDurationTimeseriesExpr
		return nil
	}
	valueNoteTimeseriesExpr := new(NoteTimeseriesExpr)
	if err := json.Unmarshal(data, &valueNoteTimeseriesExpr); err == nil {
		q.typ = "NoteTimeseriesExpr"
		q.NoteTimeseriesExpr = valueNoteTimeseriesExpr
		return nil
	}
	valueIndexColumnExpr := new(IndexColumnExpr)
	if err := json.Unmarshal(data, &valueIndexColumnExpr); err == nil {
		q.typ = "IndexColumnExpr"
		q.IndexColumnExpr = valueIndexColumnExpr
		return nil
	}
	valueSourceColumnExpr := new(SourceColumnExpr)
	if err := json.Unmarshal(data, &valueSourceColumnExpr); err == nil {
		q.typ = "SourceColumnExpr"
		q.SourceColumnExpr = valueSourceColumnExpr
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QuerySelectItem) MarshalJSON() ([]byte, error) {
	if q.typ == "AggregateExpr" || q.AggregateExpr != nil {
		return json.Marshal(q.AggregateExpr)
	}
	if q.typ == "GroupKeyColumnExpr" || q.GroupKeyColumnExpr != nil {
		return json.Marshal(q.GroupKeyColumnExpr)
	}
	if q.typ == "SleepColumnExpr" || q.SleepColumnExpr != nil {
		return json.Marshal(q.SleepColumnExpr)
	}
	if q.typ == "ActivityColumnExpr" || q.ActivityColumnExpr != nil {
		return json.Marshal(q.ActivityColumnExpr)
	}
	if q.typ == "WorkoutColumnExpr" || q.WorkoutColumnExpr != nil {
		return json.Marshal(q.WorkoutColumnExpr)
	}
	if q.typ == "BodyColumnExpr" || q.BodyColumnExpr != nil {
		return json.Marshal(q.BodyColumnExpr)
	}
	if q.typ == "MealColumnExpr" || q.MealColumnExpr != nil {
		return json.Marshal(q.MealColumnExpr)
	}
	if q.typ == "SleepScoreValueMacroExpr" || q.SleepScoreValueMacroExpr != nil {
		return json.Marshal(q.SleepScoreValueMacroExpr)
	}
	if q.typ == "ChronotypeValueMacroExpr" || q.ChronotypeValueMacroExpr != nil {
		return json.Marshal(q.ChronotypeValueMacroExpr)
	}
	if q.typ == "AsleepAtValueMacroExpr" || q.AsleepAtValueMacroExpr != nil {
		return json.Marshal(q.AsleepAtValueMacroExpr)
	}
	if q.typ == "AwakeAtValueMacroExpr" || q.AwakeAtValueMacroExpr != nil {
		return json.Marshal(q.AwakeAtValueMacroExpr)
	}
	if q.typ == "UnrecognizedValueMacroExpr" || q.UnrecognizedValueMacroExpr != nil {
		return json.Marshal(q.UnrecognizedValueMacroExpr)
	}
	if q.typ == "DiscreteTimeseriesExpr" || q.DiscreteTimeseriesExpr != nil {
		return json.Marshal(q.DiscreteTimeseriesExpr)
	}
	if q.typ == "IntervalTimeseriesExpr" || q.IntervalTimeseriesExpr != nil {
		return json.Marshal(q.IntervalTimeseriesExpr)
	}
	if q.typ == "BloodPressureTimeseriesExpr" || q.BloodPressureTimeseriesExpr != nil {
		return json.Marshal(q.BloodPressureTimeseriesExpr)
	}
	if q.typ == "TemperatureTimeseriesExpr" || q.TemperatureTimeseriesExpr != nil {
		return json.Marshal(q.TemperatureTimeseriesExpr)
	}
	if q.typ == "WorkoutDurationTimeseriesExpr" || q.WorkoutDurationTimeseriesExpr != nil {
		return json.Marshal(q.WorkoutDurationTimeseriesExpr)
	}
	if q.typ == "NoteTimeseriesExpr" || q.NoteTimeseriesExpr != nil {
		return json.Marshal(q.NoteTimeseriesExpr)
	}
	if q.typ == "IndexColumnExpr" || q.IndexColumnExpr != nil {
		return json.Marshal(q.IndexColumnExpr)
	}
	if q.typ == "SourceColumnExpr" || q.SourceColumnExpr != nil {
		return json.Marshal(q.SourceColumnExpr)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QuerySelectItemVisitor interface {
	VisitAggregateExpr(*AggregateExpr) error
	VisitGroupKeyColumnExpr(*GroupKeyColumnExpr) error
	VisitSleepColumnExpr(*SleepColumnExpr) error
	VisitActivityColumnExpr(*ActivityColumnExpr) error
	VisitWorkoutColumnExpr(*WorkoutColumnExpr) error
	VisitBodyColumnExpr(*BodyColumnExpr) error
	VisitMealColumnExpr(*MealColumnExpr) error
	VisitSleepScoreValueMacroExpr(*SleepScoreValueMacroExpr) error
	VisitChronotypeValueMacroExpr(*ChronotypeValueMacroExpr) error
	VisitAsleepAtValueMacroExpr(*AsleepAtValueMacroExpr) error
	VisitAwakeAtValueMacroExpr(*AwakeAtValueMacroExpr) error
	VisitUnrecognizedValueMacroExpr(*UnrecognizedValueMacroExpr) error
	VisitDiscreteTimeseriesExpr(*DiscreteTimeseriesExpr) error
	VisitIntervalTimeseriesExpr(*IntervalTimeseriesExpr) error
	VisitBloodPressureTimeseriesExpr(*BloodPressureTimeseriesExpr) error
	VisitTemperatureTimeseriesExpr(*TemperatureTimeseriesExpr) error
	VisitWorkoutDurationTimeseriesExpr(*WorkoutDurationTimeseriesExpr) error
	VisitNoteTimeseriesExpr(*NoteTimeseriesExpr) error
	VisitIndexColumnExpr(*IndexColumnExpr) error
	VisitSourceColumnExpr(*SourceColumnExpr) error
}

func (q *QuerySelectItem) Accept(visitor QuerySelectItemVisitor) error {
	if q.typ == "AggregateExpr" || q.AggregateExpr != nil {
		return visitor.VisitAggregateExpr(q.AggregateExpr)
	}
	if q.typ == "GroupKeyColumnExpr" || q.GroupKeyColumnExpr != nil {
		return visitor.VisitGroupKeyColumnExpr(q.GroupKeyColumnExpr)
	}
	if q.typ == "SleepColumnExpr" || q.SleepColumnExpr != nil {
		return visitor.VisitSleepColumnExpr(q.SleepColumnExpr)
	}
	if q.typ == "ActivityColumnExpr" || q.ActivityColumnExpr != nil {
		return visitor.VisitActivityColumnExpr(q.ActivityColumnExpr)
	}
	if q.typ == "WorkoutColumnExpr" || q.WorkoutColumnExpr != nil {
		return visitor.VisitWorkoutColumnExpr(q.WorkoutColumnExpr)
	}
	if q.typ == "BodyColumnExpr" || q.BodyColumnExpr != nil {
		return visitor.VisitBodyColumnExpr(q.BodyColumnExpr)
	}
	if q.typ == "MealColumnExpr" || q.MealColumnExpr != nil {
		return visitor.VisitMealColumnExpr(q.MealColumnExpr)
	}
	if q.typ == "SleepScoreValueMacroExpr" || q.SleepScoreValueMacroExpr != nil {
		return visitor.VisitSleepScoreValueMacroExpr(q.SleepScoreValueMacroExpr)
	}
	if q.typ == "ChronotypeValueMacroExpr" || q.ChronotypeValueMacroExpr != nil {
		return visitor.VisitChronotypeValueMacroExpr(q.ChronotypeValueMacroExpr)
	}
	if q.typ == "AsleepAtValueMacroExpr" || q.AsleepAtValueMacroExpr != nil {
		return visitor.VisitAsleepAtValueMacroExpr(q.AsleepAtValueMacroExpr)
	}
	if q.typ == "AwakeAtValueMacroExpr" || q.AwakeAtValueMacroExpr != nil {
		return visitor.VisitAwakeAtValueMacroExpr(q.AwakeAtValueMacroExpr)
	}
	if q.typ == "UnrecognizedValueMacroExpr" || q.UnrecognizedValueMacroExpr != nil {
		return visitor.VisitUnrecognizedValueMacroExpr(q.UnrecognizedValueMacroExpr)
	}
	if q.typ == "DiscreteTimeseriesExpr" || q.DiscreteTimeseriesExpr != nil {
		return visitor.VisitDiscreteTimeseriesExpr(q.DiscreteTimeseriesExpr)
	}
	if q.typ == "IntervalTimeseriesExpr" || q.IntervalTimeseriesExpr != nil {
		return visitor.VisitIntervalTimeseriesExpr(q.IntervalTimeseriesExpr)
	}
	if q.typ == "BloodPressureTimeseriesExpr" || q.BloodPressureTimeseriesExpr != nil {
		return visitor.VisitBloodPressureTimeseriesExpr(q.BloodPressureTimeseriesExpr)
	}
	if q.typ == "TemperatureTimeseriesExpr" || q.TemperatureTimeseriesExpr != nil {
		return visitor.VisitTemperatureTimeseriesExpr(q.TemperatureTimeseriesExpr)
	}
	if q.typ == "WorkoutDurationTimeseriesExpr" || q.WorkoutDurationTimeseriesExpr != nil {
		return visitor.VisitWorkoutDurationTimeseriesExpr(q.WorkoutDurationTimeseriesExpr)
	}
	if q.typ == "NoteTimeseriesExpr" || q.NoteTimeseriesExpr != nil {
		return visitor.VisitNoteTimeseriesExpr(q.NoteTimeseriesExpr)
	}
	if q.typ == "IndexColumnExpr" || q.IndexColumnExpr != nil {
		return visitor.VisitIndexColumnExpr(q.IndexColumnExpr)
	}
	if q.typ == "SourceColumnExpr" || q.SourceColumnExpr != nil {
		return visitor.VisitSourceColumnExpr(q.SourceColumnExpr)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

var (
	relativeTimeframeFieldAnchor = big.NewInt(1 << 0)
	relativeTimeframeFieldPast   = big.NewInt(1 << 1)
)

type RelativeTimeframe struct {
	Anchor time.Time `json:"anchor" url:"anchor" format:"date"`
	Past   *Period   `json:"past" url:"past"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RelativeTimeframe) GetAnchor() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.Anchor
}

func (r *RelativeTimeframe) GetPast() *Period {
	if r == nil {
		return nil
	}
	return r.Past
}

func (r *RelativeTimeframe) Type() string {
	return r.type_
}

func (r *RelativeTimeframe) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RelativeTimeframe) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetAnchor sets the Anchor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RelativeTimeframe) SetAnchor(anchor time.Time) {
	r.Anchor = anchor
	r.require(relativeTimeframeFieldAnchor)
}

// SetPast sets the Past field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RelativeTimeframe) SetPast(past *Period) {
	r.Past = past
	r.require(relativeTimeframeFieldPast)
}

func (r *RelativeTimeframe) UnmarshalJSON(data []byte) error {
	type embed RelativeTimeframe
	var unmarshaler = struct {
		embed
		Anchor *internal.Date `json:"anchor"`
		Type   string         `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RelativeTimeframe(unmarshaler.embed)
	r.Anchor = unmarshaler.Anchor.Time()
	if unmarshaler.Type != "relative" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "relative", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelativeTimeframe) MarshalJSON() ([]byte, error) {
	type embed RelativeTimeframe
	var marshaler = struct {
		embed
		Anchor *internal.Date `json:"anchor"`
		Type   string         `json:"type"`
	}{
		embed:  embed(*r),
		Anchor: internal.NewDate(r.Anchor),
		Type:   "relative",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RelativeTimeframe) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Select string

const (
	SelectSelectAll Select = "*"
)

func NewSelectFromString(s string) (Select, error) {
	switch s {
	case "*":
		return SelectSelectAll, nil
	}
	var t Select
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Select) Ptr() *Select {
	return &s
}

var (
	sleepColumnExprFieldSleep = big.NewInt(1 << 0)
)

type SleepColumnExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Sleep SleepColumnExprSleep `json:"sleep" url:"sleep"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SleepColumnExpr) GetSleep() SleepColumnExprSleep {
	if s == nil {
		return ""
	}
	return s.Sleep
}

func (s *SleepColumnExpr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepColumnExpr) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSleep sets the Sleep field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepColumnExpr) SetSleep(sleep SleepColumnExprSleep) {
	s.Sleep = sleep
	s.require(sleepColumnExprFieldSleep)
}

func (s *SleepColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler SleepColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SleepColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepColumnExpr) MarshalJSON() ([]byte, error) {
	type embed SleepColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SleepColumnExpr) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// ℹ️ This enum is non-exhaustive.
type SleepColumnExprSleep string

const (
	SleepColumnExprSleepId                   SleepColumnExprSleep = "id"
	SleepColumnExprSleepSessionStart         SleepColumnExprSleep = "session_start"
	SleepColumnExprSleepSessionEnd           SleepColumnExprSleep = "session_end"
	SleepColumnExprSleepState                SleepColumnExprSleep = "state"
	SleepColumnExprSleepType                 SleepColumnExprSleep = "type"
	SleepColumnExprSleepDurationSecond       SleepColumnExprSleep = "duration_second"
	SleepColumnExprSleepStageAsleepSecond    SleepColumnExprSleep = "stage_asleep_second"
	SleepColumnExprSleepStageAwakeSecond     SleepColumnExprSleep = "stage_awake_second"
	SleepColumnExprSleepStageLightSecond     SleepColumnExprSleep = "stage_light_second"
	SleepColumnExprSleepStageRemSecond       SleepColumnExprSleep = "stage_rem_second"
	SleepColumnExprSleepStageDeepSecond      SleepColumnExprSleep = "stage_deep_second"
	SleepColumnExprSleepStageUnknownSecond   SleepColumnExprSleep = "stage_unknown_second"
	SleepColumnExprSleepLatencySecond        SleepColumnExprSleep = "latency_second"
	SleepColumnExprSleepHeartRateMinimum     SleepColumnExprSleep = "heart_rate_minimum"
	SleepColumnExprSleepHeartRateMean        SleepColumnExprSleep = "heart_rate_mean"
	SleepColumnExprSleepHeartRateMaximum     SleepColumnExprSleep = "heart_rate_maximum"
	SleepColumnExprSleepHeartRateDip         SleepColumnExprSleep = "heart_rate_dip"
	SleepColumnExprSleepHeartRateResting     SleepColumnExprSleep = "heart_rate_resting"
	SleepColumnExprSleepEfficiency           SleepColumnExprSleep = "efficiency"
	SleepColumnExprSleepHrvMeanRmssd         SleepColumnExprSleep = "hrv_mean_rmssd"
	SleepColumnExprSleepHrvMeanSdnn          SleepColumnExprSleep = "hrv_mean_sdnn"
	SleepColumnExprSleepSkinTemperature      SleepColumnExprSleep = "skin_temperature"
	SleepColumnExprSleepSkinTemperatureDelta SleepColumnExprSleep = "skin_temperature_delta"
	SleepColumnExprSleepRespiratoryRate      SleepColumnExprSleep = "respiratory_rate"
	SleepColumnExprSleepScore                SleepColumnExprSleep = "score"
	SleepColumnExprSleepSourceType           SleepColumnExprSleep = "source_type"
	SleepColumnExprSleepSourceProvider       SleepColumnExprSleep = "source_provider"
	SleepColumnExprSleepSourceAppId          SleepColumnExprSleep = "source_app_id"
	SleepColumnExprSleepSourceDeviceId       SleepColumnExprSleep = "source_device_id"
	SleepColumnExprSleepTimeZone             SleepColumnExprSleep = "time_zone"
)

func NewSleepColumnExprSleepFromString(s string) (SleepColumnExprSleep, error) {
	switch s {
	case "id":
		return SleepColumnExprSleepId, nil
	case "session_start":
		return SleepColumnExprSleepSessionStart, nil
	case "session_end":
		return SleepColumnExprSleepSessionEnd, nil
	case "state":
		return SleepColumnExprSleepState, nil
	case "type":
		return SleepColumnExprSleepType, nil
	case "duration_second":
		return SleepColumnExprSleepDurationSecond, nil
	case "stage_asleep_second":
		return SleepColumnExprSleepStageAsleepSecond, nil
	case "stage_awake_second":
		return SleepColumnExprSleepStageAwakeSecond, nil
	case "stage_light_second":
		return SleepColumnExprSleepStageLightSecond, nil
	case "stage_rem_second":
		return SleepColumnExprSleepStageRemSecond, nil
	case "stage_deep_second":
		return SleepColumnExprSleepStageDeepSecond, nil
	case "stage_unknown_second":
		return SleepColumnExprSleepStageUnknownSecond, nil
	case "latency_second":
		return SleepColumnExprSleepLatencySecond, nil
	case "heart_rate_minimum":
		return SleepColumnExprSleepHeartRateMinimum, nil
	case "heart_rate_mean":
		return SleepColumnExprSleepHeartRateMean, nil
	case "heart_rate_maximum":
		return SleepColumnExprSleepHeartRateMaximum, nil
	case "heart_rate_dip":
		return SleepColumnExprSleepHeartRateDip, nil
	case "heart_rate_resting":
		return SleepColumnExprSleepHeartRateResting, nil
	case "efficiency":
		return SleepColumnExprSleepEfficiency, nil
	case "hrv_mean_rmssd":
		return SleepColumnExprSleepHrvMeanRmssd, nil
	case "hrv_mean_sdnn":
		return SleepColumnExprSleepHrvMeanSdnn, nil
	case "skin_temperature":
		return SleepColumnExprSleepSkinTemperature, nil
	case "skin_temperature_delta":
		return SleepColumnExprSleepSkinTemperatureDelta, nil
	case "respiratory_rate":
		return SleepColumnExprSleepRespiratoryRate, nil
	case "score":
		return SleepColumnExprSleepScore, nil
	case "source_type":
		return SleepColumnExprSleepSourceType, nil
	case "source_provider":
		return SleepColumnExprSleepSourceProvider, nil
	case "source_app_id":
		return SleepColumnExprSleepSourceAppId, nil
	case "source_device_id":
		return SleepColumnExprSleepSourceDeviceId, nil
	case "time_zone":
		return SleepColumnExprSleepTimeZone, nil
	}
	var t SleepColumnExprSleep
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SleepColumnExprSleep) Ptr() *SleepColumnExprSleep {
	return &s
}

var (
	sleepScoreValueMacroExprFieldVersion = big.NewInt(1 << 0)
)

type SleepScoreValueMacroExpr struct {
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	valueMacro     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SleepScoreValueMacroExpr) ValueMacro() string {
	return s.valueMacro
}

func (s *SleepScoreValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SleepScoreValueMacroExpr) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepScoreValueMacroExpr) SetVersion(version *string) {
	s.Version = version
	s.require(sleepScoreValueMacroExprFieldVersion)
}

func (s *SleepScoreValueMacroExpr) UnmarshalJSON(data []byte) error {
	type embed SleepScoreValueMacroExpr
	var unmarshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SleepScoreValueMacroExpr(unmarshaler.embed)
	if unmarshaler.ValueMacro != "sleep_score" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", s, "sleep_score", unmarshaler.ValueMacro)
	}
	s.valueMacro = unmarshaler.ValueMacro
	extraProperties, err := internal.ExtractExtraProperties(data, *s, "value_macro")
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SleepScoreValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed SleepScoreValueMacroExpr
	var marshaler = struct {
		embed
		ValueMacro string `json:"value_macro"`
	}{
		embed:      embed(*s),
		ValueMacro: "sleep_score",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SleepScoreValueMacroExpr) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sourceColumnExprFieldSource = big.NewInt(1 << 0)
)

type SourceColumnExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Source SourceColumnExprSource `json:"source" url:"source"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceColumnExpr) GetSource() SourceColumnExprSource {
	if s == nil {
		return ""
	}
	return s.Source
}

func (s *SourceColumnExpr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceColumnExpr) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceColumnExpr) SetSource(source SourceColumnExprSource) {
	s.Source = source
	s.require(sourceColumnExprFieldSource)
}

func (s *SourceColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceColumnExpr) MarshalJSON() ([]byte, error) {
	type embed SourceColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SourceColumnExpr) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// ℹ️ This enum is non-exhaustive.
type SourceColumnExprSource string

const (
	SourceColumnExprSourceSourceProvider  SourceColumnExprSource = "source_provider"
	SourceColumnExprSourceSourceType      SourceColumnExprSource = "source_type"
	SourceColumnExprSourceSourceAppId     SourceColumnExprSource = "source_app_id"
	SourceColumnExprSourceSourceWorkoutId SourceColumnExprSource = "source_workout_id"
	SourceColumnExprSourceSourceSport     SourceColumnExprSource = "source_sport"
)

func NewSourceColumnExprSourceFromString(s string) (SourceColumnExprSource, error) {
	switch s {
	case "source_provider":
		return SourceColumnExprSourceSourceProvider, nil
	case "source_type":
		return SourceColumnExprSourceSourceType, nil
	case "source_app_id":
		return SourceColumnExprSourceSourceAppId, nil
	case "source_workout_id":
		return SourceColumnExprSourceSourceWorkoutId, nil
	case "source_sport":
		return SourceColumnExprSourceSourceSport, nil
	}
	var t SourceColumnExprSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceColumnExprSource) Ptr() *SourceColumnExprSource {
	return &s
}

var (
	temperatureTimeseriesExprFieldTimeseries = big.NewInt(1 << 0)
	temperatureTimeseriesExprFieldField      = big.NewInt(1 << 1)
)

type TemperatureTimeseriesExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Timeseries TemperatureTimeseriesExprTimeseries `json:"timeseries" url:"timeseries"`
	// ℹ️ This enum is non-exhaustive.
	Field TemperatureTimeseriesExprField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TemperatureTimeseriesExpr) GetTimeseries() TemperatureTimeseriesExprTimeseries {
	if t == nil {
		return ""
	}
	return t.Timeseries
}

func (t *TemperatureTimeseriesExpr) GetField() TemperatureTimeseriesExprField {
	if t == nil {
		return ""
	}
	return t.Field
}

func (t *TemperatureTimeseriesExpr) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TemperatureTimeseriesExpr) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTimeseries sets the Timeseries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TemperatureTimeseriesExpr) SetTimeseries(timeseries TemperatureTimeseriesExprTimeseries) {
	t.Timeseries = timeseries
	t.require(temperatureTimeseriesExprFieldTimeseries)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TemperatureTimeseriesExpr) SetField(field TemperatureTimeseriesExprField) {
	t.Field = field
	t.require(temperatureTimeseriesExprFieldField)
}

func (t *TemperatureTimeseriesExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler TemperatureTimeseriesExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TemperatureTimeseriesExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TemperatureTimeseriesExpr) MarshalJSON() ([]byte, error) {
	type embed TemperatureTimeseriesExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TemperatureTimeseriesExpr) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// ℹ️ This enum is non-exhaustive.
type TemperatureTimeseriesExprField string

const (
	TemperatureTimeseriesExprFieldSourceProvider  TemperatureTimeseriesExprField = "source_provider"
	TemperatureTimeseriesExprFieldSourceType      TemperatureTimeseriesExprField = "source_type"
	TemperatureTimeseriesExprFieldSourceAppId     TemperatureTimeseriesExprField = "source_app_id"
	TemperatureTimeseriesExprFieldSourceWorkoutId TemperatureTimeseriesExprField = "source_workout_id"
	TemperatureTimeseriesExprFieldSourceSport     TemperatureTimeseriesExprField = "source_sport"
	TemperatureTimeseriesExprFieldTimezoneOffset  TemperatureTimeseriesExprField = "timezone_offset"
	TemperatureTimeseriesExprFieldType            TemperatureTimeseriesExprField = "type"
	TemperatureTimeseriesExprFieldDuration        TemperatureTimeseriesExprField = "duration"
	TemperatureTimeseriesExprFieldValue           TemperatureTimeseriesExprField = "value"
	TemperatureTimeseriesExprFieldSensorLocation  TemperatureTimeseriesExprField = "sensor_location"
)

func NewTemperatureTimeseriesExprFieldFromString(s string) (TemperatureTimeseriesExprField, error) {
	switch s {
	case "source_provider":
		return TemperatureTimeseriesExprFieldSourceProvider, nil
	case "source_type":
		return TemperatureTimeseriesExprFieldSourceType, nil
	case "source_app_id":
		return TemperatureTimeseriesExprFieldSourceAppId, nil
	case "source_workout_id":
		return TemperatureTimeseriesExprFieldSourceWorkoutId, nil
	case "source_sport":
		return TemperatureTimeseriesExprFieldSourceSport, nil
	case "timezone_offset":
		return TemperatureTimeseriesExprFieldTimezoneOffset, nil
	case "type":
		return TemperatureTimeseriesExprFieldType, nil
	case "duration":
		return TemperatureTimeseriesExprFieldDuration, nil
	case "value":
		return TemperatureTimeseriesExprFieldValue, nil
	case "sensor_location":
		return TemperatureTimeseriesExprFieldSensorLocation, nil
	}
	var t TemperatureTimeseriesExprField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemperatureTimeseriesExprField) Ptr() *TemperatureTimeseriesExprField {
	return &t
}

// ℹ️ This enum is non-exhaustive.
type TemperatureTimeseriesExprTimeseries string

const (
	TemperatureTimeseriesExprTimeseriesBodyTemperature      TemperatureTimeseriesExprTimeseries = "body_temperature"
	TemperatureTimeseriesExprTimeseriesBodyTemperatureDelta TemperatureTimeseriesExprTimeseries = "body_temperature_delta"
)

func NewTemperatureTimeseriesExprTimeseriesFromString(s string) (TemperatureTimeseriesExprTimeseries, error) {
	switch s {
	case "body_temperature":
		return TemperatureTimeseriesExprTimeseriesBodyTemperature, nil
	case "body_temperature_delta":
		return TemperatureTimeseriesExprTimeseriesBodyTemperatureDelta, nil
	}
	var t TemperatureTimeseriesExprTimeseries
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TemperatureTimeseriesExprTimeseries) Ptr() *TemperatureTimeseriesExprTimeseries {
	return &t
}

var (
	unrecognizedValueMacroExprFieldValueMacro = big.NewInt(1 << 0)
)

type UnrecognizedValueMacroExpr struct {
	ValueMacro string `json:"value_macro" url:"value_macro"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UnrecognizedValueMacroExpr) GetValueMacro() string {
	if u == nil {
		return ""
	}
	return u.ValueMacro
}

func (u *UnrecognizedValueMacroExpr) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnrecognizedValueMacroExpr) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetValueMacro sets the ValueMacro field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnrecognizedValueMacroExpr) SetValueMacro(valueMacro string) {
	u.ValueMacro = valueMacro
	u.require(unrecognizedValueMacroExprFieldValueMacro)
}

func (u *UnrecognizedValueMacroExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler UnrecognizedValueMacroExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnrecognizedValueMacroExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnrecognizedValueMacroExpr) MarshalJSON() ([]byte, error) {
	type embed UnrecognizedValueMacroExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UnrecognizedValueMacroExpr) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	workoutColumnExprFieldWorkout = big.NewInt(1 << 0)
)

type WorkoutColumnExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Workout WorkoutColumnExprWorkout `json:"workout" url:"workout"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WorkoutColumnExpr) GetWorkout() WorkoutColumnExprWorkout {
	if w == nil {
		return ""
	}
	return w.Workout
}

func (w *WorkoutColumnExpr) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkoutColumnExpr) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetWorkout sets the Workout field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutColumnExpr) SetWorkout(workout WorkoutColumnExprWorkout) {
	w.Workout = workout
	w.require(workoutColumnExprFieldWorkout)
}

func (w *WorkoutColumnExpr) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkoutColumnExpr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkoutColumnExpr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutColumnExpr) MarshalJSON() ([]byte, error) {
	type embed WorkoutColumnExpr
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WorkoutColumnExpr) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// ℹ️ This enum is non-exhaustive.
type WorkoutColumnExprWorkout string

const (
	WorkoutColumnExprWorkoutSessionStart          WorkoutColumnExprWorkout = "session_start"
	WorkoutColumnExprWorkoutSessionEnd            WorkoutColumnExprWorkout = "session_end"
	WorkoutColumnExprWorkoutTitle                 WorkoutColumnExprWorkout = "title"
	WorkoutColumnExprWorkoutSportName             WorkoutColumnExprWorkout = "sport_name"
	WorkoutColumnExprWorkoutSportSlug             WorkoutColumnExprWorkout = "sport_slug"
	WorkoutColumnExprWorkoutDurationActiveSecond  WorkoutColumnExprWorkout = "duration_active_second"
	WorkoutColumnExprWorkoutHeartRateMean         WorkoutColumnExprWorkout = "heart_rate_mean"
	WorkoutColumnExprWorkoutHeartRateMinimum      WorkoutColumnExprWorkout = "heart_rate_minimum"
	WorkoutColumnExprWorkoutHeartRateMaximum      WorkoutColumnExprWorkout = "heart_rate_maximum"
	WorkoutColumnExprWorkoutHeartRateZone1        WorkoutColumnExprWorkout = "heart_rate_zone_1"
	WorkoutColumnExprWorkoutHeartRateZone2        WorkoutColumnExprWorkout = "heart_rate_zone_2"
	WorkoutColumnExprWorkoutHeartRateZone3        WorkoutColumnExprWorkout = "heart_rate_zone_3"
	WorkoutColumnExprWorkoutHeartRateZone4        WorkoutColumnExprWorkout = "heart_rate_zone_4"
	WorkoutColumnExprWorkoutHeartRateZone5        WorkoutColumnExprWorkout = "heart_rate_zone_5"
	WorkoutColumnExprWorkoutHeartRateZone6        WorkoutColumnExprWorkout = "heart_rate_zone_6"
	WorkoutColumnExprWorkoutDistanceMeter         WorkoutColumnExprWorkout = "distance_meter"
	WorkoutColumnExprWorkoutCalories              WorkoutColumnExprWorkout = "calories"
	WorkoutColumnExprWorkoutElevationGainMeter    WorkoutColumnExprWorkout = "elevation_gain_meter"
	WorkoutColumnExprWorkoutElevationMaximumMeter WorkoutColumnExprWorkout = "elevation_maximum_meter"
	WorkoutColumnExprWorkoutElevationMinimumMeter WorkoutColumnExprWorkout = "elevation_minimum_meter"
	WorkoutColumnExprWorkoutSpeedMean             WorkoutColumnExprWorkout = "speed_mean"
	WorkoutColumnExprWorkoutSpeedMaximum          WorkoutColumnExprWorkout = "speed_maximum"
	WorkoutColumnExprWorkoutPowerSource           WorkoutColumnExprWorkout = "power_source"
	WorkoutColumnExprWorkoutPowerMean             WorkoutColumnExprWorkout = "power_mean"
	WorkoutColumnExprWorkoutPowerMaximum          WorkoutColumnExprWorkout = "power_maximum"
	WorkoutColumnExprWorkoutPowerWeightedMean     WorkoutColumnExprWorkout = "power_weighted_mean"
	WorkoutColumnExprWorkoutSteps                 WorkoutColumnExprWorkout = "steps"
	WorkoutColumnExprWorkoutMapPolyline           WorkoutColumnExprWorkout = "map_polyline"
	WorkoutColumnExprWorkoutMapSummaryPolyline    WorkoutColumnExprWorkout = "map_summary_polyline"
	WorkoutColumnExprWorkoutSourceType            WorkoutColumnExprWorkout = "source_type"
	WorkoutColumnExprWorkoutSourceProvider        WorkoutColumnExprWorkout = "source_provider"
	WorkoutColumnExprWorkoutSourceAppId           WorkoutColumnExprWorkout = "source_app_id"
	WorkoutColumnExprWorkoutSourceDeviceId        WorkoutColumnExprWorkout = "source_device_id"
	WorkoutColumnExprWorkoutExternalId            WorkoutColumnExprWorkout = "external_id"
	WorkoutColumnExprWorkoutTimeZone              WorkoutColumnExprWorkout = "time_zone"
)

func NewWorkoutColumnExprWorkoutFromString(s string) (WorkoutColumnExprWorkout, error) {
	switch s {
	case "session_start":
		return WorkoutColumnExprWorkoutSessionStart, nil
	case "session_end":
		return WorkoutColumnExprWorkoutSessionEnd, nil
	case "title":
		return WorkoutColumnExprWorkoutTitle, nil
	case "sport_name":
		return WorkoutColumnExprWorkoutSportName, nil
	case "sport_slug":
		return WorkoutColumnExprWorkoutSportSlug, nil
	case "duration_active_second":
		return WorkoutColumnExprWorkoutDurationActiveSecond, nil
	case "heart_rate_mean":
		return WorkoutColumnExprWorkoutHeartRateMean, nil
	case "heart_rate_minimum":
		return WorkoutColumnExprWorkoutHeartRateMinimum, nil
	case "heart_rate_maximum":
		return WorkoutColumnExprWorkoutHeartRateMaximum, nil
	case "heart_rate_zone_1":
		return WorkoutColumnExprWorkoutHeartRateZone1, nil
	case "heart_rate_zone_2":
		return WorkoutColumnExprWorkoutHeartRateZone2, nil
	case "heart_rate_zone_3":
		return WorkoutColumnExprWorkoutHeartRateZone3, nil
	case "heart_rate_zone_4":
		return WorkoutColumnExprWorkoutHeartRateZone4, nil
	case "heart_rate_zone_5":
		return WorkoutColumnExprWorkoutHeartRateZone5, nil
	case "heart_rate_zone_6":
		return WorkoutColumnExprWorkoutHeartRateZone6, nil
	case "distance_meter":
		return WorkoutColumnExprWorkoutDistanceMeter, nil
	case "calories":
		return WorkoutColumnExprWorkoutCalories, nil
	case "elevation_gain_meter":
		return WorkoutColumnExprWorkoutElevationGainMeter, nil
	case "elevation_maximum_meter":
		return WorkoutColumnExprWorkoutElevationMaximumMeter, nil
	case "elevation_minimum_meter":
		return WorkoutColumnExprWorkoutElevationMinimumMeter, nil
	case "speed_mean":
		return WorkoutColumnExprWorkoutSpeedMean, nil
	case "speed_maximum":
		return WorkoutColumnExprWorkoutSpeedMaximum, nil
	case "power_source":
		return WorkoutColumnExprWorkoutPowerSource, nil
	case "power_mean":
		return WorkoutColumnExprWorkoutPowerMean, nil
	case "power_maximum":
		return WorkoutColumnExprWorkoutPowerMaximum, nil
	case "power_weighted_mean":
		return WorkoutColumnExprWorkoutPowerWeightedMean, nil
	case "steps":
		return WorkoutColumnExprWorkoutSteps, nil
	case "map_polyline":
		return WorkoutColumnExprWorkoutMapPolyline, nil
	case "map_summary_polyline":
		return WorkoutColumnExprWorkoutMapSummaryPolyline, nil
	case "source_type":
		return WorkoutColumnExprWorkoutSourceType, nil
	case "source_provider":
		return WorkoutColumnExprWorkoutSourceProvider, nil
	case "source_app_id":
		return WorkoutColumnExprWorkoutSourceAppId, nil
	case "source_device_id":
		return WorkoutColumnExprWorkoutSourceDeviceId, nil
	case "external_id":
		return WorkoutColumnExprWorkoutExternalId, nil
	case "time_zone":
		return WorkoutColumnExprWorkoutTimeZone, nil
	}
	var t WorkoutColumnExprWorkout
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkoutColumnExprWorkout) Ptr() *WorkoutColumnExprWorkout {
	return &w
}

var (
	workoutDurationTimeseriesExprFieldField = big.NewInt(1 << 0)
)

type WorkoutDurationTimeseriesExpr struct {
	// ℹ️ This enum is non-exhaustive.
	Field WorkoutDurationTimeseriesExprField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	timeseries     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WorkoutDurationTimeseriesExpr) GetField() WorkoutDurationTimeseriesExprField {
	if w == nil {
		return ""
	}
	return w.Field
}

func (w *WorkoutDurationTimeseriesExpr) Timeseries() string {
	return w.timeseries
}

func (w *WorkoutDurationTimeseriesExpr) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkoutDurationTimeseriesExpr) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDurationTimeseriesExpr) SetField(field WorkoutDurationTimeseriesExprField) {
	w.Field = field
	w.require(workoutDurationTimeseriesExprFieldField)
}

func (w *WorkoutDurationTimeseriesExpr) UnmarshalJSON(data []byte) error {
	type embed WorkoutDurationTimeseriesExpr
	var unmarshaler = struct {
		embed
		Timeseries string `json:"timeseries"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WorkoutDurationTimeseriesExpr(unmarshaler.embed)
	if unmarshaler.Timeseries != "workout_duration" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", w, "workout_duration", unmarshaler.Timeseries)
	}
	w.timeseries = unmarshaler.Timeseries
	extraProperties, err := internal.ExtractExtraProperties(data, *w, "timeseries")
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkoutDurationTimeseriesExpr) MarshalJSON() ([]byte, error) {
	type embed WorkoutDurationTimeseriesExpr
	var marshaler = struct {
		embed
		Timeseries string `json:"timeseries"`
	}{
		embed:      embed(*w),
		Timeseries: "workout_duration",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WorkoutDurationTimeseriesExpr) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// ℹ️ This enum is non-exhaustive.
type WorkoutDurationTimeseriesExprField string

const (
	WorkoutDurationTimeseriesExprFieldSourceProvider  WorkoutDurationTimeseriesExprField = "source_provider"
	WorkoutDurationTimeseriesExprFieldSourceType      WorkoutDurationTimeseriesExprField = "source_type"
	WorkoutDurationTimeseriesExprFieldSourceAppId     WorkoutDurationTimeseriesExprField = "source_app_id"
	WorkoutDurationTimeseriesExprFieldSourceWorkoutId WorkoutDurationTimeseriesExprField = "source_workout_id"
	WorkoutDurationTimeseriesExprFieldSourceSport     WorkoutDurationTimeseriesExprField = "source_sport"
	WorkoutDurationTimeseriesExprFieldTimezoneOffset  WorkoutDurationTimeseriesExprField = "timezone_offset"
	WorkoutDurationTimeseriesExprFieldType            WorkoutDurationTimeseriesExprField = "type"
	WorkoutDurationTimeseriesExprFieldDuration        WorkoutDurationTimeseriesExprField = "duration"
	WorkoutDurationTimeseriesExprFieldValue           WorkoutDurationTimeseriesExprField = "value"
	WorkoutDurationTimeseriesExprFieldIntensity       WorkoutDurationTimeseriesExprField = "intensity"
)

func NewWorkoutDurationTimeseriesExprFieldFromString(s string) (WorkoutDurationTimeseriesExprField, error) {
	switch s {
	case "source_provider":
		return WorkoutDurationTimeseriesExprFieldSourceProvider, nil
	case "source_type":
		return WorkoutDurationTimeseriesExprFieldSourceType, nil
	case "source_app_id":
		return WorkoutDurationTimeseriesExprFieldSourceAppId, nil
	case "source_workout_id":
		return WorkoutDurationTimeseriesExprFieldSourceWorkoutId, nil
	case "source_sport":
		return WorkoutDurationTimeseriesExprFieldSourceSport, nil
	case "timezone_offset":
		return WorkoutDurationTimeseriesExprFieldTimezoneOffset, nil
	case "type":
		return WorkoutDurationTimeseriesExprFieldType, nil
	case "duration":
		return WorkoutDurationTimeseriesExprFieldDuration, nil
	case "value":
		return WorkoutDurationTimeseriesExprFieldValue, nil
	case "intensity":
		return WorkoutDurationTimeseriesExprFieldIntensity, nil
	}
	var t WorkoutDurationTimeseriesExprField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkoutDurationTimeseriesExprField) Ptr() *WorkoutDurationTimeseriesExprField {
	return &w
}

type QueryBatchTimeframe struct {
	RelativeTimeframe *RelativeTimeframe
	Placeholder       *Placeholder

	typ string
}

func (q *QueryBatchTimeframe) GetRelativeTimeframe() *RelativeTimeframe {
	if q == nil {
		return nil
	}
	return q.RelativeTimeframe
}

func (q *QueryBatchTimeframe) GetPlaceholder() *Placeholder {
	if q == nil {
		return nil
	}
	return q.Placeholder
}

func (q *QueryBatchTimeframe) UnmarshalJSON(data []byte) error {
	valueRelativeTimeframe := new(RelativeTimeframe)
	if err := json.Unmarshal(data, &valueRelativeTimeframe); err == nil {
		q.typ = "RelativeTimeframe"
		q.RelativeTimeframe = valueRelativeTimeframe
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		q.typ = "Placeholder"
		q.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryBatchTimeframe) MarshalJSON() ([]byte, error) {
	if q.typ == "RelativeTimeframe" || q.RelativeTimeframe != nil {
		return json.Marshal(q.RelativeTimeframe)
	}
	if q.typ == "Placeholder" || q.Placeholder != nil {
		return json.Marshal(q.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryBatchTimeframeVisitor interface {
	VisitRelativeTimeframe(*RelativeTimeframe) error
	VisitPlaceholder(*Placeholder) error
}

func (q *QueryBatchTimeframe) Accept(visitor QueryBatchTimeframeVisitor) error {
	if q.typ == "RelativeTimeframe" || q.RelativeTimeframe != nil {
		return visitor.VisitRelativeTimeframe(q.RelativeTimeframe)
	}
	if q.typ == "Placeholder" || q.Placeholder != nil {
		return visitor.VisitPlaceholder(q.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}
