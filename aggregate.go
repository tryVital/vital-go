// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type QueryBatch struct {
	Timeframe *QueryBatchTimeframe `json:"timeframe,omitempty" url:"-"`
	Queries   []*Query             `json:"queries,omitempty" url:"-"`
	Config    *QueryConfig         `json:"config,omitempty" url:"-"`
	accept    string
}

func (q *QueryBatch) Accept() string {
	return q.accept
}

func (q *QueryBatch) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryBatch
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*q = QueryBatch(body)
	q.accept = "*/*"
	return nil
}

func (q *QueryBatch) MarshalJSON() ([]byte, error) {
	type embed QueryBatch
	var marshaler = struct {
		embed
		Accept string `json:"accept"`
	}{
		embed:  embed(*q),
		Accept: "*/*",
	}
	return json.Marshal(marshaler)
}

type QueryBatchTimeframe struct {
	RelativeTimeframe *RelativeTimeframe
	Placeholder       *Placeholder
}

func NewQueryBatchTimeframeFromRelativeTimeframe(value *RelativeTimeframe) *QueryBatchTimeframe {
	return &QueryBatchTimeframe{RelativeTimeframe: value}
}

func NewQueryBatchTimeframeFromPlaceholder(value *Placeholder) *QueryBatchTimeframe {
	return &QueryBatchTimeframe{Placeholder: value}
}

func (q *QueryBatchTimeframe) UnmarshalJSON(data []byte) error {
	valueRelativeTimeframe := new(RelativeTimeframe)
	if err := json.Unmarshal(data, &valueRelativeTimeframe); err == nil {
		q.RelativeTimeframe = valueRelativeTimeframe
		return nil
	}
	valuePlaceholder := new(Placeholder)
	if err := json.Unmarshal(data, &valuePlaceholder); err == nil {
		q.Placeholder = valuePlaceholder
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryBatchTimeframe) MarshalJSON() ([]byte, error) {
	if q.RelativeTimeframe != nil {
		return json.Marshal(q.RelativeTimeframe)
	}
	if q.Placeholder != nil {
		return json.Marshal(q.Placeholder)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryBatchTimeframeVisitor interface {
	VisitRelativeTimeframe(*RelativeTimeframe) error
	VisitPlaceholder(*Placeholder) error
}

func (q *QueryBatchTimeframe) Accept(visitor QueryBatchTimeframeVisitor) error {
	if q.RelativeTimeframe != nil {
		return visitor.VisitRelativeTimeframe(q.RelativeTimeframe)
	}
	if q.Placeholder != nil {
		return visitor.VisitPlaceholder(q.Placeholder)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}
