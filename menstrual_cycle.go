// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tryVital/vital-go/internal"
	big "math/big"
	time "time"
)

var (
	menstrualCycleGetRequestFieldProvider  = big.NewInt(1 << 0)
	menstrualCycleGetRequestFieldStartDate = big.NewInt(1 << 1)
	menstrualCycleGetRequestFieldEndDate   = big.NewInt(1 << 2)
)

type MenstrualCycleGetRequest struct {
	// Provider oura/strava etc
	Provider  *string `json:"-" url:"provider,omitempty"`
	StartDate string  `json:"-" url:"start_date"`
	EndDate   *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *MenstrualCycleGetRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MenstrualCycleGetRequest) SetProvider(provider *string) {
	m.Provider = provider
	m.require(menstrualCycleGetRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MenstrualCycleGetRequest) SetStartDate(startDate string) {
	m.StartDate = startDate
	m.require(menstrualCycleGetRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MenstrualCycleGetRequest) SetEndDate(endDate *string) {
	m.EndDate = endDate
	m.require(menstrualCycleGetRequestFieldEndDate)
}

var (
	basalBodyTemperatureEntryFieldDate  = big.NewInt(1 << 0)
	basalBodyTemperatureEntryFieldValue = big.NewInt(1 << 1)
)

type BasalBodyTemperatureEntry struct {
	Date  string  `json:"date" url:"date"`
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BasalBodyTemperatureEntry) GetDate() string {
	if b == nil {
		return ""
	}
	return b.Date
}

func (b *BasalBodyTemperatureEntry) GetValue() float64 {
	if b == nil {
		return 0
	}
	return b.Value
}

func (b *BasalBodyTemperatureEntry) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasalBodyTemperatureEntry) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureEntry) SetDate(date string) {
	b.Date = date
	b.require(basalBodyTemperatureEntryFieldDate)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureEntry) SetValue(value float64) {
	b.Value = value
	b.require(basalBodyTemperatureEntryFieldValue)
}

func (b *BasalBodyTemperatureEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler BasalBodyTemperatureEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasalBodyTemperatureEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasalBodyTemperatureEntry) MarshalJSON() ([]byte, error) {
	type embed BasalBodyTemperatureEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BasalBodyTemperatureEntry) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	cervicalMucusEntryFieldDate    = big.NewInt(1 << 0)
	cervicalMucusEntryFieldQuality = big.NewInt(1 << 1)
)

type CervicalMucusEntry struct {
	Date string `json:"date" url:"date"`
	// ℹ️ This enum is non-exhaustive.
	Quality CervicalMucusEntryQuality `json:"quality" url:"quality"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CervicalMucusEntry) GetDate() string {
	if c == nil {
		return ""
	}
	return c.Date
}

func (c *CervicalMucusEntry) GetQuality() CervicalMucusEntryQuality {
	if c == nil {
		return ""
	}
	return c.Quality
}

func (c *CervicalMucusEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CervicalMucusEntry) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CervicalMucusEntry) SetDate(date string) {
	c.Date = date
	c.require(cervicalMucusEntryFieldDate)
}

// SetQuality sets the Quality field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CervicalMucusEntry) SetQuality(quality CervicalMucusEntryQuality) {
	c.Quality = quality
	c.require(cervicalMucusEntryFieldQuality)
}

func (c *CervicalMucusEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler CervicalMucusEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CervicalMucusEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CervicalMucusEntry) MarshalJSON() ([]byte, error) {
	type embed CervicalMucusEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CervicalMucusEntry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// ℹ️ This enum is non-exhaustive.
type CervicalMucusEntryQuality string

const (
	CervicalMucusEntryQualityDry      CervicalMucusEntryQuality = "dry"
	CervicalMucusEntryQualitySticky   CervicalMucusEntryQuality = "sticky"
	CervicalMucusEntryQualityCreamy   CervicalMucusEntryQuality = "creamy"
	CervicalMucusEntryQualityWatery   CervicalMucusEntryQuality = "watery"
	CervicalMucusEntryQualityEggWhite CervicalMucusEntryQuality = "egg_white"
)

func NewCervicalMucusEntryQualityFromString(s string) (CervicalMucusEntryQuality, error) {
	switch s {
	case "dry":
		return CervicalMucusEntryQualityDry, nil
	case "sticky":
		return CervicalMucusEntryQualitySticky, nil
	case "creamy":
		return CervicalMucusEntryQualityCreamy, nil
	case "watery":
		return CervicalMucusEntryQualityWatery, nil
	case "egg_white":
		return CervicalMucusEntryQualityEggWhite, nil
	}
	var t CervicalMucusEntryQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CervicalMucusEntryQuality) Ptr() *CervicalMucusEntryQuality {
	return &c
}

var (
	clientFacingMenstrualCycleFieldId                     = big.NewInt(1 << 0)
	clientFacingMenstrualCycleFieldPeriodStart            = big.NewInt(1 << 1)
	clientFacingMenstrualCycleFieldPeriodEnd              = big.NewInt(1 << 2)
	clientFacingMenstrualCycleFieldCycleEnd               = big.NewInt(1 << 3)
	clientFacingMenstrualCycleFieldIsPredicted            = big.NewInt(1 << 4)
	clientFacingMenstrualCycleFieldMenstrualFlow          = big.NewInt(1 << 5)
	clientFacingMenstrualCycleFieldCervicalMucus          = big.NewInt(1 << 6)
	clientFacingMenstrualCycleFieldIntermenstrualBleeding = big.NewInt(1 << 7)
	clientFacingMenstrualCycleFieldContraceptive          = big.NewInt(1 << 8)
	clientFacingMenstrualCycleFieldDetectedDeviations     = big.NewInt(1 << 9)
	clientFacingMenstrualCycleFieldOvulationTest          = big.NewInt(1 << 10)
	clientFacingMenstrualCycleFieldHomePregnancyTest      = big.NewInt(1 << 11)
	clientFacingMenstrualCycleFieldHomeProgesteroneTest   = big.NewInt(1 << 12)
	clientFacingMenstrualCycleFieldSexualActivity         = big.NewInt(1 << 13)
	clientFacingMenstrualCycleFieldBasalBodyTemperature   = big.NewInt(1 << 14)
	clientFacingMenstrualCycleFieldSourceProvider         = big.NewInt(1 << 15)
	clientFacingMenstrualCycleFieldSourceType             = big.NewInt(1 << 16)
	clientFacingMenstrualCycleFieldSourceAppId            = big.NewInt(1 << 17)
	clientFacingMenstrualCycleFieldSourceDeviceId         = big.NewInt(1 << 18)
	clientFacingMenstrualCycleFieldCreatedAt              = big.NewInt(1 << 19)
	clientFacingMenstrualCycleFieldUpdatedAt              = big.NewInt(1 << 20)
	clientFacingMenstrualCycleFieldUserId                 = big.NewInt(1 << 21)
	clientFacingMenstrualCycleFieldSource                 = big.NewInt(1 << 22)
)

type ClientFacingMenstrualCycle struct {
	Id                     string                                    `json:"id" url:"id"`
	PeriodStart            string                                    `json:"period_start" url:"period_start"`
	PeriodEnd              *string                                   `json:"period_end,omitempty" url:"period_end,omitempty"`
	CycleEnd               *string                                   `json:"cycle_end,omitempty" url:"cycle_end,omitempty"`
	IsPredicted            *bool                                     `json:"is_predicted,omitempty" url:"is_predicted,omitempty"`
	MenstrualFlow          []*MenstrualFlowEntry                     `json:"menstrual_flow,omitempty" url:"menstrual_flow,omitempty"`
	CervicalMucus          []*CervicalMucusEntry                     `json:"cervical_mucus,omitempty" url:"cervical_mucus,omitempty"`
	IntermenstrualBleeding []*IntermenstrualBleedingEntry            `json:"intermenstrual_bleeding,omitempty" url:"intermenstrual_bleeding,omitempty"`
	Contraceptive          []*ContraceptiveEntry                     `json:"contraceptive,omitempty" url:"contraceptive,omitempty"`
	DetectedDeviations     []*DetectedDeviationEntry                 `json:"detected_deviations,omitempty" url:"detected_deviations,omitempty"`
	OvulationTest          []*OvulationTestEntry                     `json:"ovulation_test,omitempty" url:"ovulation_test,omitempty"`
	HomePregnancyTest      []*HomePregnancyTestEntry                 `json:"home_pregnancy_test,omitempty" url:"home_pregnancy_test,omitempty"`
	HomeProgesteroneTest   []*HomeProgesteroneTestEntry              `json:"home_progesterone_test,omitempty" url:"home_progesterone_test,omitempty"`
	SexualActivity         []*SexualActivityEntry                    `json:"sexual_activity,omitempty" url:"sexual_activity,omitempty"`
	BasalBodyTemperature   []*BasalBodyTemperatureEntry              `json:"basal_body_temperature,omitempty" url:"basal_body_temperature,omitempty"`
	SourceProvider         *ClientFacingMenstrualCycleSourceProvider `json:"source_provider" url:"source_provider"`
	// ℹ️ This enum is non-exhaustive.
	SourceType     ClientFacingMenstrualCycleSourceType `json:"source_type" url:"source_type"`
	SourceAppId    *string                              `json:"source_app_id,omitempty" url:"source_app_id,omitempty"`
	SourceDeviceId *string                              `json:"source_device_id,omitempty" url:"source_device_id,omitempty"`
	CreatedAt      time.Time                            `json:"created_at" url:"created_at"`
	UpdatedAt      time.Time                            `json:"updated_at" url:"updated_at"`
	UserId         string                               `json:"user_id" url:"user_id"`
	Source         *ClientFacingSource                  `json:"source" url:"source"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingMenstrualCycle) GetId() string {
	if c == nil {
		return ""
	}
	return c.Id
}

func (c *ClientFacingMenstrualCycle) GetPeriodStart() string {
	if c == nil {
		return ""
	}
	return c.PeriodStart
}

func (c *ClientFacingMenstrualCycle) GetPeriodEnd() *string {
	if c == nil {
		return nil
	}
	return c.PeriodEnd
}

func (c *ClientFacingMenstrualCycle) GetCycleEnd() *string {
	if c == nil {
		return nil
	}
	return c.CycleEnd
}

func (c *ClientFacingMenstrualCycle) GetIsPredicted() *bool {
	if c == nil {
		return nil
	}
	return c.IsPredicted
}

func (c *ClientFacingMenstrualCycle) GetMenstrualFlow() []*MenstrualFlowEntry {
	if c == nil {
		return nil
	}
	return c.MenstrualFlow
}

func (c *ClientFacingMenstrualCycle) GetCervicalMucus() []*CervicalMucusEntry {
	if c == nil {
		return nil
	}
	return c.CervicalMucus
}

func (c *ClientFacingMenstrualCycle) GetIntermenstrualBleeding() []*IntermenstrualBleedingEntry {
	if c == nil {
		return nil
	}
	return c.IntermenstrualBleeding
}

func (c *ClientFacingMenstrualCycle) GetContraceptive() []*ContraceptiveEntry {
	if c == nil {
		return nil
	}
	return c.Contraceptive
}

func (c *ClientFacingMenstrualCycle) GetDetectedDeviations() []*DetectedDeviationEntry {
	if c == nil {
		return nil
	}
	return c.DetectedDeviations
}

func (c *ClientFacingMenstrualCycle) GetOvulationTest() []*OvulationTestEntry {
	if c == nil {
		return nil
	}
	return c.OvulationTest
}

func (c *ClientFacingMenstrualCycle) GetHomePregnancyTest() []*HomePregnancyTestEntry {
	if c == nil {
		return nil
	}
	return c.HomePregnancyTest
}

func (c *ClientFacingMenstrualCycle) GetHomeProgesteroneTest() []*HomeProgesteroneTestEntry {
	if c == nil {
		return nil
	}
	return c.HomeProgesteroneTest
}

func (c *ClientFacingMenstrualCycle) GetSexualActivity() []*SexualActivityEntry {
	if c == nil {
		return nil
	}
	return c.SexualActivity
}

func (c *ClientFacingMenstrualCycle) GetBasalBodyTemperature() []*BasalBodyTemperatureEntry {
	if c == nil {
		return nil
	}
	return c.BasalBodyTemperature
}

func (c *ClientFacingMenstrualCycle) GetSourceProvider() *ClientFacingMenstrualCycleSourceProvider {
	if c == nil {
		return nil
	}
	return c.SourceProvider
}

func (c *ClientFacingMenstrualCycle) GetSourceType() ClientFacingMenstrualCycleSourceType {
	if c == nil {
		return ""
	}
	return c.SourceType
}

func (c *ClientFacingMenstrualCycle) GetSourceAppId() *string {
	if c == nil {
		return nil
	}
	return c.SourceAppId
}

func (c *ClientFacingMenstrualCycle) GetSourceDeviceId() *string {
	if c == nil {
		return nil
	}
	return c.SourceDeviceId
}

func (c *ClientFacingMenstrualCycle) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *ClientFacingMenstrualCycle) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *ClientFacingMenstrualCycle) GetUserId() string {
	if c == nil {
		return ""
	}
	return c.UserId
}

func (c *ClientFacingMenstrualCycle) GetSource() *ClientFacingSource {
	if c == nil {
		return nil
	}
	return c.Source
}

func (c *ClientFacingMenstrualCycle) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMenstrualCycle) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetId(id string) {
	c.Id = id
	c.require(clientFacingMenstrualCycleFieldId)
}

// SetPeriodStart sets the PeriodStart field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetPeriodStart(periodStart string) {
	c.PeriodStart = periodStart
	c.require(clientFacingMenstrualCycleFieldPeriodStart)
}

// SetPeriodEnd sets the PeriodEnd field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetPeriodEnd(periodEnd *string) {
	c.PeriodEnd = periodEnd
	c.require(clientFacingMenstrualCycleFieldPeriodEnd)
}

// SetCycleEnd sets the CycleEnd field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetCycleEnd(cycleEnd *string) {
	c.CycleEnd = cycleEnd
	c.require(clientFacingMenstrualCycleFieldCycleEnd)
}

// SetIsPredicted sets the IsPredicted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetIsPredicted(isPredicted *bool) {
	c.IsPredicted = isPredicted
	c.require(clientFacingMenstrualCycleFieldIsPredicted)
}

// SetMenstrualFlow sets the MenstrualFlow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetMenstrualFlow(menstrualFlow []*MenstrualFlowEntry) {
	c.MenstrualFlow = menstrualFlow
	c.require(clientFacingMenstrualCycleFieldMenstrualFlow)
}

// SetCervicalMucus sets the CervicalMucus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetCervicalMucus(cervicalMucus []*CervicalMucusEntry) {
	c.CervicalMucus = cervicalMucus
	c.require(clientFacingMenstrualCycleFieldCervicalMucus)
}

// SetIntermenstrualBleeding sets the IntermenstrualBleeding field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetIntermenstrualBleeding(intermenstrualBleeding []*IntermenstrualBleedingEntry) {
	c.IntermenstrualBleeding = intermenstrualBleeding
	c.require(clientFacingMenstrualCycleFieldIntermenstrualBleeding)
}

// SetContraceptive sets the Contraceptive field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetContraceptive(contraceptive []*ContraceptiveEntry) {
	c.Contraceptive = contraceptive
	c.require(clientFacingMenstrualCycleFieldContraceptive)
}

// SetDetectedDeviations sets the DetectedDeviations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetDetectedDeviations(detectedDeviations []*DetectedDeviationEntry) {
	c.DetectedDeviations = detectedDeviations
	c.require(clientFacingMenstrualCycleFieldDetectedDeviations)
}

// SetOvulationTest sets the OvulationTest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetOvulationTest(ovulationTest []*OvulationTestEntry) {
	c.OvulationTest = ovulationTest
	c.require(clientFacingMenstrualCycleFieldOvulationTest)
}

// SetHomePregnancyTest sets the HomePregnancyTest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetHomePregnancyTest(homePregnancyTest []*HomePregnancyTestEntry) {
	c.HomePregnancyTest = homePregnancyTest
	c.require(clientFacingMenstrualCycleFieldHomePregnancyTest)
}

// SetHomeProgesteroneTest sets the HomeProgesteroneTest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetHomeProgesteroneTest(homeProgesteroneTest []*HomeProgesteroneTestEntry) {
	c.HomeProgesteroneTest = homeProgesteroneTest
	c.require(clientFacingMenstrualCycleFieldHomeProgesteroneTest)
}

// SetSexualActivity sets the SexualActivity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetSexualActivity(sexualActivity []*SexualActivityEntry) {
	c.SexualActivity = sexualActivity
	c.require(clientFacingMenstrualCycleFieldSexualActivity)
}

// SetBasalBodyTemperature sets the BasalBodyTemperature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetBasalBodyTemperature(basalBodyTemperature []*BasalBodyTemperatureEntry) {
	c.BasalBodyTemperature = basalBodyTemperature
	c.require(clientFacingMenstrualCycleFieldBasalBodyTemperature)
}

// SetSourceProvider sets the SourceProvider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetSourceProvider(sourceProvider *ClientFacingMenstrualCycleSourceProvider) {
	c.SourceProvider = sourceProvider
	c.require(clientFacingMenstrualCycleFieldSourceProvider)
}

// SetSourceType sets the SourceType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetSourceType(sourceType ClientFacingMenstrualCycleSourceType) {
	c.SourceType = sourceType
	c.require(clientFacingMenstrualCycleFieldSourceType)
}

// SetSourceAppId sets the SourceAppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetSourceAppId(sourceAppId *string) {
	c.SourceAppId = sourceAppId
	c.require(clientFacingMenstrualCycleFieldSourceAppId)
}

// SetSourceDeviceId sets the SourceDeviceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetSourceDeviceId(sourceDeviceId *string) {
	c.SourceDeviceId = sourceDeviceId
	c.require(clientFacingMenstrualCycleFieldSourceDeviceId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetCreatedAt(createdAt time.Time) {
	c.CreatedAt = createdAt
	c.require(clientFacingMenstrualCycleFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetUpdatedAt(updatedAt time.Time) {
	c.UpdatedAt = updatedAt
	c.require(clientFacingMenstrualCycleFieldUpdatedAt)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetUserId(userId string) {
	c.UserId = userId
	c.require(clientFacingMenstrualCycleFieldUserId)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMenstrualCycle) SetSource(source *ClientFacingSource) {
	c.Source = source
	c.require(clientFacingMenstrualCycleFieldSource)
}

func (c *ClientFacingMenstrualCycle) UnmarshalJSON(data []byte) error {
	type embed ClientFacingMenstrualCycle
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingMenstrualCycle(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMenstrualCycle) MarshalJSON() ([]byte, error) {
	type embed ClientFacingMenstrualCycle
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at"`
		UpdatedAt *internal.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingMenstrualCycle) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingMenstrualCycleSourceProvider struct {
	Providers Providers
	Labs      Labs

	typ string
}

func (c *ClientFacingMenstrualCycleSourceProvider) GetProviders() Providers {
	if c == nil {
		return ""
	}
	return c.Providers
}

func (c *ClientFacingMenstrualCycleSourceProvider) GetLabs() Labs {
	if c == nil {
		return ""
	}
	return c.Labs
}

func (c *ClientFacingMenstrualCycleSourceProvider) UnmarshalJSON(data []byte) error {
	var valueProviders Providers
	if err := json.Unmarshal(data, &valueProviders); err == nil {
		c.typ = "Providers"
		c.Providers = valueProviders
		return nil
	}
	var valueLabs Labs
	if err := json.Unmarshal(data, &valueLabs); err == nil {
		c.typ = "Labs"
		c.Labs = valueLabs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ClientFacingMenstrualCycleSourceProvider) MarshalJSON() ([]byte, error) {
	if c.typ == "Providers" || c.Providers != "" {
		return json.Marshal(c.Providers)
	}
	if c.typ == "Labs" || c.Labs != "" {
		return json.Marshal(c.Labs)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ClientFacingMenstrualCycleSourceProviderVisitor interface {
	VisitProviders(Providers) error
	VisitLabs(Labs) error
}

func (c *ClientFacingMenstrualCycleSourceProvider) Accept(visitor ClientFacingMenstrualCycleSourceProviderVisitor) error {
	if c.typ == "Providers" || c.Providers != "" {
		return visitor.VisitProviders(c.Providers)
	}
	if c.typ == "Labs" || c.Labs != "" {
		return visitor.VisitLabs(c.Labs)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

// ℹ️ This enum is non-exhaustive.
type ClientFacingMenstrualCycleSourceType string

const (
	ClientFacingMenstrualCycleSourceTypeUnknown         ClientFacingMenstrualCycleSourceType = "unknown"
	ClientFacingMenstrualCycleSourceTypePhone           ClientFacingMenstrualCycleSourceType = "phone"
	ClientFacingMenstrualCycleSourceTypeWatch           ClientFacingMenstrualCycleSourceType = "watch"
	ClientFacingMenstrualCycleSourceTypeApp             ClientFacingMenstrualCycleSourceType = "app"
	ClientFacingMenstrualCycleSourceTypeMultipleSources ClientFacingMenstrualCycleSourceType = "multiple_sources"
	ClientFacingMenstrualCycleSourceTypeFingerprick     ClientFacingMenstrualCycleSourceType = "fingerprick"
	ClientFacingMenstrualCycleSourceTypeCuff            ClientFacingMenstrualCycleSourceType = "cuff"
	ClientFacingMenstrualCycleSourceTypeManualScan      ClientFacingMenstrualCycleSourceType = "manual_scan"
	ClientFacingMenstrualCycleSourceTypeAutomatic       ClientFacingMenstrualCycleSourceType = "automatic"
	ClientFacingMenstrualCycleSourceTypeScale           ClientFacingMenstrualCycleSourceType = "scale"
	ClientFacingMenstrualCycleSourceTypeChestStrap      ClientFacingMenstrualCycleSourceType = "chest_strap"
	ClientFacingMenstrualCycleSourceTypeRing            ClientFacingMenstrualCycleSourceType = "ring"
	ClientFacingMenstrualCycleSourceTypeLab             ClientFacingMenstrualCycleSourceType = "lab"
	ClientFacingMenstrualCycleSourceTypeExerciseMachine ClientFacingMenstrualCycleSourceType = "exercise_machine"
	ClientFacingMenstrualCycleSourceTypeEarphone        ClientFacingMenstrualCycleSourceType = "earphone"
)

func NewClientFacingMenstrualCycleSourceTypeFromString(s string) (ClientFacingMenstrualCycleSourceType, error) {
	switch s {
	case "unknown":
		return ClientFacingMenstrualCycleSourceTypeUnknown, nil
	case "phone":
		return ClientFacingMenstrualCycleSourceTypePhone, nil
	case "watch":
		return ClientFacingMenstrualCycleSourceTypeWatch, nil
	case "app":
		return ClientFacingMenstrualCycleSourceTypeApp, nil
	case "multiple_sources":
		return ClientFacingMenstrualCycleSourceTypeMultipleSources, nil
	case "fingerprick":
		return ClientFacingMenstrualCycleSourceTypeFingerprick, nil
	case "cuff":
		return ClientFacingMenstrualCycleSourceTypeCuff, nil
	case "manual_scan":
		return ClientFacingMenstrualCycleSourceTypeManualScan, nil
	case "automatic":
		return ClientFacingMenstrualCycleSourceTypeAutomatic, nil
	case "scale":
		return ClientFacingMenstrualCycleSourceTypeScale, nil
	case "chest_strap":
		return ClientFacingMenstrualCycleSourceTypeChestStrap, nil
	case "ring":
		return ClientFacingMenstrualCycleSourceTypeRing, nil
	case "lab":
		return ClientFacingMenstrualCycleSourceTypeLab, nil
	case "exercise_machine":
		return ClientFacingMenstrualCycleSourceTypeExerciseMachine, nil
	case "earphone":
		return ClientFacingMenstrualCycleSourceTypeEarphone, nil
	}
	var t ClientFacingMenstrualCycleSourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingMenstrualCycleSourceType) Ptr() *ClientFacingMenstrualCycleSourceType {
	return &c
}

var (
	contraceptiveEntryFieldDate = big.NewInt(1 << 0)
	contraceptiveEntryFieldType = big.NewInt(1 << 1)
)

type ContraceptiveEntry struct {
	Date string `json:"date" url:"date"`
	// ℹ️ This enum is non-exhaustive.
	Type ContraceptiveEntryType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContraceptiveEntry) GetDate() string {
	if c == nil {
		return ""
	}
	return c.Date
}

func (c *ContraceptiveEntry) GetType() ContraceptiveEntryType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ContraceptiveEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContraceptiveEntry) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContraceptiveEntry) SetDate(date string) {
	c.Date = date
	c.require(contraceptiveEntryFieldDate)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContraceptiveEntry) SetType(type_ ContraceptiveEntryType) {
	c.Type = type_
	c.require(contraceptiveEntryFieldType)
}

func (c *ContraceptiveEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ContraceptiveEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContraceptiveEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContraceptiveEntry) MarshalJSON() ([]byte, error) {
	type embed ContraceptiveEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContraceptiveEntry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// ℹ️ This enum is non-exhaustive.
type ContraceptiveEntryType string

const (
	ContraceptiveEntryTypeUnspecified      ContraceptiveEntryType = "unspecified"
	ContraceptiveEntryTypeImplant          ContraceptiveEntryType = "implant"
	ContraceptiveEntryTypeInjection        ContraceptiveEntryType = "injection"
	ContraceptiveEntryTypeIud              ContraceptiveEntryType = "iud"
	ContraceptiveEntryTypeIntravaginalRing ContraceptiveEntryType = "intravaginal_ring"
	ContraceptiveEntryTypeOral             ContraceptiveEntryType = "oral"
	ContraceptiveEntryTypePatch            ContraceptiveEntryType = "patch"
)

func NewContraceptiveEntryTypeFromString(s string) (ContraceptiveEntryType, error) {
	switch s {
	case "unspecified":
		return ContraceptiveEntryTypeUnspecified, nil
	case "implant":
		return ContraceptiveEntryTypeImplant, nil
	case "injection":
		return ContraceptiveEntryTypeInjection, nil
	case "iud":
		return ContraceptiveEntryTypeIud, nil
	case "intravaginal_ring":
		return ContraceptiveEntryTypeIntravaginalRing, nil
	case "oral":
		return ContraceptiveEntryTypeOral, nil
	case "patch":
		return ContraceptiveEntryTypePatch, nil
	}
	var t ContraceptiveEntryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContraceptiveEntryType) Ptr() *ContraceptiveEntryType {
	return &c
}

var (
	detectedDeviationEntryFieldDate      = big.NewInt(1 << 0)
	detectedDeviationEntryFieldDeviation = big.NewInt(1 << 1)
)

type DetectedDeviationEntry struct {
	Date string `json:"date" url:"date"`
	// ℹ️ This enum is non-exhaustive.
	Deviation DetectedDeviationEntryDeviation `json:"deviation" url:"deviation"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DetectedDeviationEntry) GetDate() string {
	if d == nil {
		return ""
	}
	return d.Date
}

func (d *DetectedDeviationEntry) GetDeviation() DetectedDeviationEntryDeviation {
	if d == nil {
		return ""
	}
	return d.Deviation
}

func (d *DetectedDeviationEntry) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetectedDeviationEntry) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DetectedDeviationEntry) SetDate(date string) {
	d.Date = date
	d.require(detectedDeviationEntryFieldDate)
}

// SetDeviation sets the Deviation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DetectedDeviationEntry) SetDeviation(deviation DetectedDeviationEntryDeviation) {
	d.Deviation = deviation
	d.require(detectedDeviationEntryFieldDeviation)
}

func (d *DetectedDeviationEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler DetectedDeviationEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetectedDeviationEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetectedDeviationEntry) MarshalJSON() ([]byte, error) {
	type embed DetectedDeviationEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DetectedDeviationEntry) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// ℹ️ This enum is non-exhaustive.
type DetectedDeviationEntryDeviation string

const (
	DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding DetectedDeviationEntryDeviation = "persistent_intermenstrual_bleeding"
	DetectedDeviationEntryDeviationProlongedMenstrualPeriods        DetectedDeviationEntryDeviation = "prolonged_menstrual_periods"
	DetectedDeviationEntryDeviationIrregularMenstrualCycles         DetectedDeviationEntryDeviation = "irregular_menstrual_cycles"
	DetectedDeviationEntryDeviationInfrequentMenstrualCycles        DetectedDeviationEntryDeviation = "infrequent_menstrual_cycles"
)

func NewDetectedDeviationEntryDeviationFromString(s string) (DetectedDeviationEntryDeviation, error) {
	switch s {
	case "persistent_intermenstrual_bleeding":
		return DetectedDeviationEntryDeviationPersistentIntermenstrualBleeding, nil
	case "prolonged_menstrual_periods":
		return DetectedDeviationEntryDeviationProlongedMenstrualPeriods, nil
	case "irregular_menstrual_cycles":
		return DetectedDeviationEntryDeviationIrregularMenstrualCycles, nil
	case "infrequent_menstrual_cycles":
		return DetectedDeviationEntryDeviationInfrequentMenstrualCycles, nil
	}
	var t DetectedDeviationEntryDeviation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DetectedDeviationEntryDeviation) Ptr() *DetectedDeviationEntryDeviation {
	return &d
}

var (
	homePregnancyTestEntryFieldDate       = big.NewInt(1 << 0)
	homePregnancyTestEntryFieldTestResult = big.NewInt(1 << 1)
)

type HomePregnancyTestEntry struct {
	Date string `json:"date" url:"date"`
	// ℹ️ This enum is non-exhaustive.
	TestResult HomePregnancyTestEntryTestResult `json:"test_result" url:"test_result"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HomePregnancyTestEntry) GetDate() string {
	if h == nil {
		return ""
	}
	return h.Date
}

func (h *HomePregnancyTestEntry) GetTestResult() HomePregnancyTestEntryTestResult {
	if h == nil {
		return ""
	}
	return h.TestResult
}

func (h *HomePregnancyTestEntry) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HomePregnancyTestEntry) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HomePregnancyTestEntry) SetDate(date string) {
	h.Date = date
	h.require(homePregnancyTestEntryFieldDate)
}

// SetTestResult sets the TestResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HomePregnancyTestEntry) SetTestResult(testResult HomePregnancyTestEntryTestResult) {
	h.TestResult = testResult
	h.require(homePregnancyTestEntryFieldTestResult)
}

func (h *HomePregnancyTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomePregnancyTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomePregnancyTestEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomePregnancyTestEntry) MarshalJSON() ([]byte, error) {
	type embed HomePregnancyTestEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HomePregnancyTestEntry) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// ℹ️ This enum is non-exhaustive.
type HomePregnancyTestEntryTestResult string

const (
	HomePregnancyTestEntryTestResultNegative      HomePregnancyTestEntryTestResult = "negative"
	HomePregnancyTestEntryTestResultPositive      HomePregnancyTestEntryTestResult = "positive"
	HomePregnancyTestEntryTestResultIndeterminate HomePregnancyTestEntryTestResult = "indeterminate"
)

func NewHomePregnancyTestEntryTestResultFromString(s string) (HomePregnancyTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomePregnancyTestEntryTestResultNegative, nil
	case "positive":
		return HomePregnancyTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomePregnancyTestEntryTestResultIndeterminate, nil
	}
	var t HomePregnancyTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomePregnancyTestEntryTestResult) Ptr() *HomePregnancyTestEntryTestResult {
	return &h
}

var (
	homeProgesteroneTestEntryFieldDate       = big.NewInt(1 << 0)
	homeProgesteroneTestEntryFieldTestResult = big.NewInt(1 << 1)
)

type HomeProgesteroneTestEntry struct {
	Date string `json:"date" url:"date"`
	// ℹ️ This enum is non-exhaustive.
	TestResult HomeProgesteroneTestEntryTestResult `json:"test_result" url:"test_result"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HomeProgesteroneTestEntry) GetDate() string {
	if h == nil {
		return ""
	}
	return h.Date
}

func (h *HomeProgesteroneTestEntry) GetTestResult() HomeProgesteroneTestEntryTestResult {
	if h == nil {
		return ""
	}
	return h.TestResult
}

func (h *HomeProgesteroneTestEntry) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HomeProgesteroneTestEntry) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HomeProgesteroneTestEntry) SetDate(date string) {
	h.Date = date
	h.require(homeProgesteroneTestEntryFieldDate)
}

// SetTestResult sets the TestResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HomeProgesteroneTestEntry) SetTestResult(testResult HomeProgesteroneTestEntryTestResult) {
	h.TestResult = testResult
	h.require(homeProgesteroneTestEntryFieldTestResult)
}

func (h *HomeProgesteroneTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler HomeProgesteroneTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HomeProgesteroneTestEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HomeProgesteroneTestEntry) MarshalJSON() ([]byte, error) {
	type embed HomeProgesteroneTestEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HomeProgesteroneTestEntry) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// ℹ️ This enum is non-exhaustive.
type HomeProgesteroneTestEntryTestResult string

const (
	HomeProgesteroneTestEntryTestResultNegative      HomeProgesteroneTestEntryTestResult = "negative"
	HomeProgesteroneTestEntryTestResultPositive      HomeProgesteroneTestEntryTestResult = "positive"
	HomeProgesteroneTestEntryTestResultIndeterminate HomeProgesteroneTestEntryTestResult = "indeterminate"
)

func NewHomeProgesteroneTestEntryTestResultFromString(s string) (HomeProgesteroneTestEntryTestResult, error) {
	switch s {
	case "negative":
		return HomeProgesteroneTestEntryTestResultNegative, nil
	case "positive":
		return HomeProgesteroneTestEntryTestResultPositive, nil
	case "indeterminate":
		return HomeProgesteroneTestEntryTestResultIndeterminate, nil
	}
	var t HomeProgesteroneTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HomeProgesteroneTestEntryTestResult) Ptr() *HomeProgesteroneTestEntryTestResult {
	return &h
}

var (
	intermenstrualBleedingEntryFieldDate = big.NewInt(1 << 0)
)

type IntermenstrualBleedingEntry struct {
	Date string `json:"date" url:"date"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntermenstrualBleedingEntry) GetDate() string {
	if i == nil {
		return ""
	}
	return i.Date
}

func (i *IntermenstrualBleedingEntry) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntermenstrualBleedingEntry) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntermenstrualBleedingEntry) SetDate(date string) {
	i.Date = date
	i.require(intermenstrualBleedingEntryFieldDate)
}

func (i *IntermenstrualBleedingEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler IntermenstrualBleedingEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntermenstrualBleedingEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntermenstrualBleedingEntry) MarshalJSON() ([]byte, error) {
	type embed IntermenstrualBleedingEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntermenstrualBleedingEntry) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	menstrualCycleResponseFieldMenstrualCycle = big.NewInt(1 << 0)
)

type MenstrualCycleResponse struct {
	MenstrualCycle []*ClientFacingMenstrualCycle `json:"menstrual_cycle" url:"menstrual_cycle"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MenstrualCycleResponse) GetMenstrualCycle() []*ClientFacingMenstrualCycle {
	if m == nil {
		return nil
	}
	return m.MenstrualCycle
}

func (m *MenstrualCycleResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MenstrualCycleResponse) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetMenstrualCycle sets the MenstrualCycle field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MenstrualCycleResponse) SetMenstrualCycle(menstrualCycle []*ClientFacingMenstrualCycle) {
	m.MenstrualCycle = menstrualCycle
	m.require(menstrualCycleResponseFieldMenstrualCycle)
}

func (m *MenstrualCycleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualCycleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualCycleResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualCycleResponse) MarshalJSON() ([]byte, error) {
	type embed MenstrualCycleResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MenstrualCycleResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	menstrualFlowEntryFieldDate = big.NewInt(1 << 0)
	menstrualFlowEntryFieldFlow = big.NewInt(1 << 1)
)

type MenstrualFlowEntry struct {
	Date string `json:"date" url:"date"`
	// ℹ️ This enum is non-exhaustive.
	Flow MenstrualFlowEntryFlow `json:"flow" url:"flow"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MenstrualFlowEntry) GetDate() string {
	if m == nil {
		return ""
	}
	return m.Date
}

func (m *MenstrualFlowEntry) GetFlow() MenstrualFlowEntryFlow {
	if m == nil {
		return ""
	}
	return m.Flow
}

func (m *MenstrualFlowEntry) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MenstrualFlowEntry) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MenstrualFlowEntry) SetDate(date string) {
	m.Date = date
	m.require(menstrualFlowEntryFieldDate)
}

// SetFlow sets the Flow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MenstrualFlowEntry) SetFlow(flow MenstrualFlowEntryFlow) {
	m.Flow = flow
	m.require(menstrualFlowEntryFieldFlow)
}

func (m *MenstrualFlowEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler MenstrualFlowEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MenstrualFlowEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MenstrualFlowEntry) MarshalJSON() ([]byte, error) {
	type embed MenstrualFlowEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MenstrualFlowEntry) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// ℹ️ This enum is non-exhaustive.
type MenstrualFlowEntryFlow string

const (
	MenstrualFlowEntryFlowUnspecified MenstrualFlowEntryFlow = "unspecified"
	MenstrualFlowEntryFlowNone        MenstrualFlowEntryFlow = "none"
	MenstrualFlowEntryFlowLight       MenstrualFlowEntryFlow = "light"
	MenstrualFlowEntryFlowMedium      MenstrualFlowEntryFlow = "medium"
	MenstrualFlowEntryFlowHeavy       MenstrualFlowEntryFlow = "heavy"
)

func NewMenstrualFlowEntryFlowFromString(s string) (MenstrualFlowEntryFlow, error) {
	switch s {
	case "unspecified":
		return MenstrualFlowEntryFlowUnspecified, nil
	case "none":
		return MenstrualFlowEntryFlowNone, nil
	case "light":
		return MenstrualFlowEntryFlowLight, nil
	case "medium":
		return MenstrualFlowEntryFlowMedium, nil
	case "heavy":
		return MenstrualFlowEntryFlowHeavy, nil
	}
	var t MenstrualFlowEntryFlow
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MenstrualFlowEntryFlow) Ptr() *MenstrualFlowEntryFlow {
	return &m
}

var (
	ovulationTestEntryFieldDate       = big.NewInt(1 << 0)
	ovulationTestEntryFieldTestResult = big.NewInt(1 << 1)
)

type OvulationTestEntry struct {
	Date string `json:"date" url:"date"`
	// ℹ️ This enum is non-exhaustive.
	TestResult OvulationTestEntryTestResult `json:"test_result" url:"test_result"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OvulationTestEntry) GetDate() string {
	if o == nil {
		return ""
	}
	return o.Date
}

func (o *OvulationTestEntry) GetTestResult() OvulationTestEntryTestResult {
	if o == nil {
		return ""
	}
	return o.TestResult
}

func (o *OvulationTestEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OvulationTestEntry) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OvulationTestEntry) SetDate(date string) {
	o.Date = date
	o.require(ovulationTestEntryFieldDate)
}

// SetTestResult sets the TestResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OvulationTestEntry) SetTestResult(testResult OvulationTestEntryTestResult) {
	o.TestResult = testResult
	o.require(ovulationTestEntryFieldTestResult)
}

func (o *OvulationTestEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OvulationTestEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OvulationTestEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OvulationTestEntry) MarshalJSON() ([]byte, error) {
	type embed OvulationTestEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OvulationTestEntry) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// ℹ️ This enum is non-exhaustive.
type OvulationTestEntryTestResult string

const (
	OvulationTestEntryTestResultNegative                OvulationTestEntryTestResult = "negative"
	OvulationTestEntryTestResultPositive                OvulationTestEntryTestResult = "positive"
	OvulationTestEntryTestResultLuteinizingHormoneSurge OvulationTestEntryTestResult = "luteinizing_hormone_surge"
	OvulationTestEntryTestResultEstrogenSurge           OvulationTestEntryTestResult = "estrogen_surge"
	OvulationTestEntryTestResultIndeterminate           OvulationTestEntryTestResult = "indeterminate"
)

func NewOvulationTestEntryTestResultFromString(s string) (OvulationTestEntryTestResult, error) {
	switch s {
	case "negative":
		return OvulationTestEntryTestResultNegative, nil
	case "positive":
		return OvulationTestEntryTestResultPositive, nil
	case "luteinizing_hormone_surge":
		return OvulationTestEntryTestResultLuteinizingHormoneSurge, nil
	case "estrogen_surge":
		return OvulationTestEntryTestResultEstrogenSurge, nil
	case "indeterminate":
		return OvulationTestEntryTestResultIndeterminate, nil
	}
	var t OvulationTestEntryTestResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OvulationTestEntryTestResult) Ptr() *OvulationTestEntryTestResult {
	return &o
}

var (
	sexualActivityEntryFieldDate           = big.NewInt(1 << 0)
	sexualActivityEntryFieldProtectionUsed = big.NewInt(1 << 1)
)

type SexualActivityEntry struct {
	Date           string `json:"date" url:"date"`
	ProtectionUsed *bool  `json:"protection_used,omitempty" url:"protection_used,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SexualActivityEntry) GetDate() string {
	if s == nil {
		return ""
	}
	return s.Date
}

func (s *SexualActivityEntry) GetProtectionUsed() *bool {
	if s == nil {
		return nil
	}
	return s.ProtectionUsed
}

func (s *SexualActivityEntry) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SexualActivityEntry) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SexualActivityEntry) SetDate(date string) {
	s.Date = date
	s.require(sexualActivityEntryFieldDate)
}

// SetProtectionUsed sets the ProtectionUsed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SexualActivityEntry) SetProtectionUsed(protectionUsed *bool) {
	s.ProtectionUsed = protectionUsed
	s.require(sexualActivityEntryFieldProtectionUsed)
}

func (s *SexualActivityEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler SexualActivityEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SexualActivityEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SexualActivityEntry) MarshalJSON() ([]byte, error) {
	type embed SexualActivityEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SexualActivityEntry) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
