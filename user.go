// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tryVital/vital-go/internal"
	time "time"
)

type UserCreateBody struct {
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id" url:"-"`
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	FallbackTimeZone *string `json:"fallback_time_zone,omitempty" url:"-"`
	// Fallback date of birth of the user, in YYYY-mm-dd format. Used for calculating max heartrate for providers that don not provide users' age.
	FallbackBirthDate *string `json:"fallback_birth_date,omitempty" url:"-"`
	// Starting bound for user [data ingestion bounds](https://docs.tryvital.io/wearables/providers/data-ingestion-bounds).
	IngestionStart *string `json:"ingestion_start,omitempty" url:"-"`
	// Ending bound for user [data ingestion bounds](https://docs.tryvital.io/wearables/providers/data-ingestion-bounds).
	IngestionEnd *string `json:"ingestion_end,omitempty" url:"-"`
}

type CreateInsuranceRequest struct {
	PayorCode    string                                                  `json:"payor_code" url:"-"`
	MemberId     string                                                  `json:"member_id" url:"-"`
	GroupId      *string                                                 `json:"group_id,omitempty" url:"-"`
	Relationship ResponsibleRelationship                                 `json:"relationship" url:"-"`
	Insured      *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails `json:"insured,omitempty" url:"-"`
	Guarantor    *GuarantorDetails                                       `json:"guarantor,omitempty" url:"-"`
}

type UserGetAllRequest struct {
	Offset *int `json:"-" url:"offset,omitempty"`
	Limit  *int `json:"-" url:"limit,omitempty"`
}

type UserPatchBody struct {
	// Fallback time zone of the user, in the form of a valid IANA tzdatabase identifier (e.g., `Europe/London` or `America/Los_Angeles`).
	// Used when pulling data from sources that are completely time zone agnostic (e.g., all time is relative to UTC clock, without any time zone attributions on data points).
	FallbackTimeZone *string `json:"fallback_time_zone,omitempty" url:"-"`
	// Fallback date of birth of the user, in YYYY-mm-dd format. Used for calculating max heartrate for providers that don not provide users' age.
	FallbackBirthDate *string `json:"fallback_birth_date,omitempty" url:"-"`
	// Starting bound for user [data ingestion bounds](https://docs.tryvital.io/wearables/providers/data-ingestion-bounds).
	IngestionStart *string `json:"ingestion_start,omitempty" url:"-"`
	// Ending bound for user [data ingestion bounds](https://docs.tryvital.io/wearables/providers/data-ingestion-bounds).
	IngestionEnd *string `json:"ingestion_end,omitempty" url:"-"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId *string `json:"client_user_id,omitempty" url:"-"`
}

type UserRefreshRequest struct {
	Timeout *float64 `json:"-" url:"timeout,omitempty"`
}

// ℹ️ This enum is non-exhaustive.
type Availability string

const (
	AvailabilityAvailable   Availability = "available"
	AvailabilityUnavailable Availability = "unavailable"
)

func NewAvailabilityFromString(s string) (Availability, error) {
	switch s {
	case "available":
		return AvailabilityAvailable, nil
	case "unavailable":
		return AvailabilityUnavailable, nil
	}
	var t Availability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a Availability) Ptr() *Availability {
	return &a
}

type ClientFacingConnectionErrorDetails struct {
	// ℹ️ This enum is non-exhaustive.
	ErrorType    ClientFacingConnectionErrorDetailsErrorType `json:"error_type" url:"error_type"`
	ErrorMessage string                                      `json:"error_message" url:"error_message"`
	ErroredAt    time.Time                                   `json:"errored_at" url:"errored_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingConnectionErrorDetails) GetErrorType() ClientFacingConnectionErrorDetailsErrorType {
	if c == nil {
		return ""
	}
	return c.ErrorType
}

func (c *ClientFacingConnectionErrorDetails) GetErrorMessage() string {
	if c == nil {
		return ""
	}
	return c.ErrorMessage
}

func (c *ClientFacingConnectionErrorDetails) GetErroredAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.ErroredAt
}

func (c *ClientFacingConnectionErrorDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingConnectionErrorDetails) UnmarshalJSON(data []byte) error {
	type embed ClientFacingConnectionErrorDetails
	var unmarshaler = struct {
		embed
		ErroredAt *internal.DateTime `json:"errored_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingConnectionErrorDetails(unmarshaler.embed)
	c.ErroredAt = unmarshaler.ErroredAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingConnectionErrorDetails) MarshalJSON() ([]byte, error) {
	type embed ClientFacingConnectionErrorDetails
	var marshaler = struct {
		embed
		ErroredAt *internal.DateTime `json:"errored_at"`
	}{
		embed:     embed(*c),
		ErroredAt: internal.NewDateTime(c.ErroredAt),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingConnectionErrorDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// ℹ️ This enum is non-exhaustive.
type ClientFacingConnectionErrorDetailsErrorType string

const (
	ClientFacingConnectionErrorDetailsErrorTypeTokenRefreshFailed        ClientFacingConnectionErrorDetailsErrorType = "token_refresh_failed"
	ClientFacingConnectionErrorDetailsErrorTypeWebhookRegistrationFailed ClientFacingConnectionErrorDetailsErrorType = "webhook_registration_failed"
	ClientFacingConnectionErrorDetailsErrorTypeUserNotFound              ClientFacingConnectionErrorDetailsErrorType = "user_not_found"
	ClientFacingConnectionErrorDetailsErrorTypeDeregisteredPerProvider   ClientFacingConnectionErrorDetailsErrorType = "deregistered_per_provider"
	ClientFacingConnectionErrorDetailsErrorTypeRequiredScopesNotGranted  ClientFacingConnectionErrorDetailsErrorType = "required_scopes_not_granted"
	ClientFacingConnectionErrorDetailsErrorTypeProviderCredentialError   ClientFacingConnectionErrorDetailsErrorType = "provider_credential_error"
	ClientFacingConnectionErrorDetailsErrorTypeProviderPasswordExpired   ClientFacingConnectionErrorDetailsErrorType = "provider_password_expired"
	ClientFacingConnectionErrorDetailsErrorTypeUnknown                   ClientFacingConnectionErrorDetailsErrorType = "unknown"
)

func NewClientFacingConnectionErrorDetailsErrorTypeFromString(s string) (ClientFacingConnectionErrorDetailsErrorType, error) {
	switch s {
	case "token_refresh_failed":
		return ClientFacingConnectionErrorDetailsErrorTypeTokenRefreshFailed, nil
	case "webhook_registration_failed":
		return ClientFacingConnectionErrorDetailsErrorTypeWebhookRegistrationFailed, nil
	case "user_not_found":
		return ClientFacingConnectionErrorDetailsErrorTypeUserNotFound, nil
	case "deregistered_per_provider":
		return ClientFacingConnectionErrorDetailsErrorTypeDeregisteredPerProvider, nil
	case "required_scopes_not_granted":
		return ClientFacingConnectionErrorDetailsErrorTypeRequiredScopesNotGranted, nil
	case "provider_credential_error":
		return ClientFacingConnectionErrorDetailsErrorTypeProviderCredentialError, nil
	case "provider_password_expired":
		return ClientFacingConnectionErrorDetailsErrorTypeProviderPasswordExpired, nil
	case "unknown":
		return ClientFacingConnectionErrorDetailsErrorTypeUnknown, nil
	}
	var t ClientFacingConnectionErrorDetailsErrorType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingConnectionErrorDetailsErrorType) Ptr() *ClientFacingConnectionErrorDetailsErrorType {
	return &c
}

type ClientFacingInsurance struct {
	MemberId     string                                                  `json:"member_id" url:"member_id"`
	PayorCode    string                                                  `json:"payor_code" url:"payor_code"`
	Relationship ResponsibleRelationship                                 `json:"relationship" url:"relationship"`
	Insured      *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails `json:"insured" url:"insured"`
	Company      *CompanyDetails                                         `json:"company" url:"company"`
	GroupId      *string                                                 `json:"group_id,omitempty" url:"group_id,omitempty"`
	Guarantor    *GuarantorDetails                                       `json:"guarantor,omitempty" url:"guarantor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingInsurance) GetMemberId() string {
	if c == nil {
		return ""
	}
	return c.MemberId
}

func (c *ClientFacingInsurance) GetPayorCode() string {
	if c == nil {
		return ""
	}
	return c.PayorCode
}

func (c *ClientFacingInsurance) GetRelationship() ResponsibleRelationship {
	if c == nil {
		return ""
	}
	return c.Relationship
}

func (c *ClientFacingInsurance) GetInsured() *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails {
	if c == nil {
		return nil
	}
	return c.Insured
}

func (c *ClientFacingInsurance) GetCompany() *CompanyDetails {
	if c == nil {
		return nil
	}
	return c.Company
}

func (c *ClientFacingInsurance) GetGroupId() *string {
	if c == nil {
		return nil
	}
	return c.GroupId
}

func (c *ClientFacingInsurance) GetGuarantor() *GuarantorDetails {
	if c == nil {
		return nil
	}
	return c.Guarantor
}

func (c *ClientFacingInsurance) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsurance) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingInsurance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingInsurance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsurance) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingProviderWithStatus struct {
	// Name of source of information
	Name string `json:"name" url:"name"`
	// Slug for designated source
	Slug string `json:"slug" url:"slug"`
	// URL for source logo
	Logo      string    `json:"logo" url:"logo"`
	CreatedOn time.Time `json:"created_on" url:"created_on"`
	// Status of source, either error or connected
	Status string `json:"status" url:"status"`
	// The unique identifier of the associated external data provider user.
	//
	// * OAuth Providers: User unique identifier; provider-specific formats
	// * Password Providers: Username
	// * Email Providers: Email
	// * Junction Mobile SDK Providers: `null` (not available)
	ExternalUserId *string `json:"external_user_id,omitempty" url:"external_user_id,omitempty"`
	// Details of the terminal connection error — populated only when the status is `error`.
	ErrorDetails         *ClientFacingConnectionErrorDetails `json:"error_details,omitempty" url:"error_details,omitempty"`
	ResourceAvailability map[string]*ResourceAvailability    `json:"resource_availability" url:"resource_availability"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingProviderWithStatus) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ClientFacingProviderWithStatus) GetSlug() string {
	if c == nil {
		return ""
	}
	return c.Slug
}

func (c *ClientFacingProviderWithStatus) GetLogo() string {
	if c == nil {
		return ""
	}
	return c.Logo
}

func (c *ClientFacingProviderWithStatus) GetCreatedOn() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedOn
}

func (c *ClientFacingProviderWithStatus) GetStatus() string {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *ClientFacingProviderWithStatus) GetExternalUserId() *string {
	if c == nil {
		return nil
	}
	return c.ExternalUserId
}

func (c *ClientFacingProviderWithStatus) GetErrorDetails() *ClientFacingConnectionErrorDetails {
	if c == nil {
		return nil
	}
	return c.ErrorDetails
}

func (c *ClientFacingProviderWithStatus) GetResourceAvailability() map[string]*ResourceAvailability {
	if c == nil {
		return nil
	}
	return c.ResourceAvailability
}

func (c *ClientFacingProviderWithStatus) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingProviderWithStatus) UnmarshalJSON(data []byte) error {
	type embed ClientFacingProviderWithStatus
	var unmarshaler = struct {
		embed
		CreatedOn *internal.DateTime `json:"created_on"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingProviderWithStatus(unmarshaler.embed)
	c.CreatedOn = unmarshaler.CreatedOn.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingProviderWithStatus) MarshalJSON() ([]byte, error) {
	type embed ClientFacingProviderWithStatus
	var marshaler = struct {
		embed
		CreatedOn *internal.DateTime `json:"created_on"`
	}{
		embed:     embed(*c),
		CreatedOn: internal.NewDateTime(c.CreatedOn),
	}
	return json.Marshal(marshaler)
}

func (c *ClientFacingProviderWithStatus) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingUserKey struct {
	// User id returned by vital create user request. This id should be stored in your database against the user and used for all interactions with the vital api.
	UserId string `json:"user_id" url:"user_id"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	ClientUserId string `json:"client_user_id" url:"client_user_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingUserKey) GetUserId() string {
	if c == nil {
		return ""
	}
	return c.UserId
}

func (c *ClientFacingUserKey) GetClientUserId() string {
	if c == nil {
		return ""
	}
	return c.ClientUserId
}

func (c *ClientFacingUserKey) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUserKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientFacingUserKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientFacingUserKey(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUserKey) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CompanyDetails struct {
	Name    string   `json:"name" url:"name"`
	Address *Address `json:"address" url:"address"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CompanyDetails) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CompanyDetails) GetAddress() *Address {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CompanyDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompanyDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CompanyDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompanyDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompanyDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type MetricsResult struct {
	TeamId                          string                   `json:"team_id" url:"team_id"`
	NumberOfConnectedSources        *int                     `json:"number_of_connected_sources,omitempty" url:"number_of_connected_sources,omitempty"`
	NumberOfUsers                   *int                     `json:"number_of_users,omitempty" url:"number_of_users,omitempty"`
	NumberOfErroredConnectedSources *int                     `json:"number_of_errored_connected_sources,omitempty" url:"number_of_errored_connected_sources,omitempty"`
	NumberOfConnectedSourcesByWeek  []*TimeseriesMetricPoint `json:"number_of_connected_sources_by_week,omitempty" url:"number_of_connected_sources_by_week,omitempty"`
	NumberOfOrderedTests            *int                     `json:"number_of_ordered_tests,omitempty" url:"number_of_ordered_tests,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetricsResult) GetTeamId() string {
	if m == nil {
		return ""
	}
	return m.TeamId
}

func (m *MetricsResult) GetNumberOfConnectedSources() *int {
	if m == nil {
		return nil
	}
	return m.NumberOfConnectedSources
}

func (m *MetricsResult) GetNumberOfUsers() *int {
	if m == nil {
		return nil
	}
	return m.NumberOfUsers
}

func (m *MetricsResult) GetNumberOfErroredConnectedSources() *int {
	if m == nil {
		return nil
	}
	return m.NumberOfErroredConnectedSources
}

func (m *MetricsResult) GetNumberOfConnectedSourcesByWeek() []*TimeseriesMetricPoint {
	if m == nil {
		return nil
	}
	return m.NumberOfConnectedSourcesByWeek
}

func (m *MetricsResult) GetNumberOfOrderedTests() *int {
	if m == nil {
		return nil
	}
	return m.NumberOfOrderedTests
}

func (m *MetricsResult) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetricsResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsResult) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PaginatedUsersResponse struct {
	Users  []*ClientFacingUser `json:"users" url:"users"`
	Total  int                 `json:"total" url:"total"`
	Offset int                 `json:"offset" url:"offset"`
	Limit  int                 `json:"limit" url:"limit"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedUsersResponse) GetUsers() []*ClientFacingUser {
	if p == nil {
		return nil
	}
	return p.Users
}

func (p *PaginatedUsersResponse) GetTotal() int {
	if p == nil {
		return 0
	}
	return p.Total
}

func (p *PaginatedUsersResponse) GetOffset() int {
	if p == nil {
		return 0
	}
	return p.Offset
}

func (p *PaginatedUsersResponse) GetLimit() int {
	if p == nil {
		return 0
	}
	return p.Limit
}

func (p *PaginatedUsersResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedUsersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedUsersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedUsersResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedUsersResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResourceAvailability struct {
	Status            Availability             `json:"status" url:"status"`
	ScopeRequirements *ScopeRequirementsGrants `json:"scope_requirements,omitempty" url:"scope_requirements,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResourceAvailability) GetStatus() Availability {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *ResourceAvailability) GetScopeRequirements() *ScopeRequirementsGrants {
	if r == nil {
		return nil
	}
	return r.ScopeRequirements
}

func (r *ResourceAvailability) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResourceAvailability) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceAvailability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceAvailability(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResourceAvailability) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ScopeRequirementsGrants struct {
	UserGranted *ScopeRequirementsStr `json:"user_granted" url:"user_granted"`
	UserDenied  *ScopeRequirementsStr `json:"user_denied" url:"user_denied"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScopeRequirementsGrants) GetUserGranted() *ScopeRequirementsStr {
	if s == nil {
		return nil
	}
	return s.UserGranted
}

func (s *ScopeRequirementsGrants) GetUserDenied() *ScopeRequirementsStr {
	if s == nil {
		return nil
	}
	return s.UserDenied
}

func (s *ScopeRequirementsGrants) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopeRequirementsGrants) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsGrants
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsGrants(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsGrants) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScopeRequirementsStr struct {
	Required []string `json:"required" url:"required"`
	Optional []string `json:"optional" url:"optional"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScopeRequirementsStr) GetRequired() []string {
	if s == nil {
		return nil
	}
	return s.Required
}

func (s *ScopeRequirementsStr) GetOptional() []string {
	if s == nil {
		return nil
	}
	return s.Optional
}

func (s *ScopeRequirementsStr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopeRequirementsStr) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopeRequirementsStr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopeRequirementsStr(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopeRequirementsStr) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TimeseriesMetricPoint struct {
	Date  time.Time `json:"date" url:"date"`
	Value float64   `json:"value" url:"value"`
	All   float64   `json:"all" url:"all"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimeseriesMetricPoint) GetDate() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.Date
}

func (t *TimeseriesMetricPoint) GetValue() float64 {
	if t == nil {
		return 0
	}
	return t.Value
}

func (t *TimeseriesMetricPoint) GetAll() float64 {
	if t == nil {
		return 0
	}
	return t.All
}

func (t *TimeseriesMetricPoint) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeseriesMetricPoint) UnmarshalJSON(data []byte) error {
	type embed TimeseriesMetricPoint
	var unmarshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeseriesMetricPoint(unmarshaler.embed)
	t.Date = unmarshaler.Date.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeseriesMetricPoint) MarshalJSON() ([]byte, error) {
	type embed TimeseriesMetricPoint
	var marshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*t),
		Date:  internal.NewDateTime(t.Date),
	}
	return json.Marshal(marshaler)
}

func (t *TimeseriesMetricPoint) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UserInfo struct {
	FirstName         string             `json:"first_name" url:"first_name"`
	LastName          string             `json:"last_name" url:"last_name"`
	Email             string             `json:"email" url:"email"`
	PhoneNumber       string             `json:"phone_number" url:"phone_number"`
	Gender            string             `json:"gender" url:"gender"`
	Dob               string             `json:"dob" url:"dob"`
	Address           *Address           `json:"address" url:"address"`
	MedicalProxy      *GuarantorDetails  `json:"medical_proxy,omitempty" url:"medical_proxy,omitempty"`
	Race              *Race              `json:"race,omitempty" url:"race,omitempty"`
	Ethnicity         *Ethnicity         `json:"ethnicity,omitempty" url:"ethnicity,omitempty"`
	SexualOrientation *SexualOrientation `json:"sexual_orientation,omitempty" url:"sexual_orientation,omitempty"`
	GenderIdentity    *GenderIdentity    `json:"gender_identity,omitempty" url:"gender_identity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserInfo) GetFirstName() string {
	if u == nil {
		return ""
	}
	return u.FirstName
}

func (u *UserInfo) GetLastName() string {
	if u == nil {
		return ""
	}
	return u.LastName
}

func (u *UserInfo) GetEmail() string {
	if u == nil {
		return ""
	}
	return u.Email
}

func (u *UserInfo) GetPhoneNumber() string {
	if u == nil {
		return ""
	}
	return u.PhoneNumber
}

func (u *UserInfo) GetGender() string {
	if u == nil {
		return ""
	}
	return u.Gender
}

func (u *UserInfo) GetDob() string {
	if u == nil {
		return ""
	}
	return u.Dob
}

func (u *UserInfo) GetAddress() *Address {
	if u == nil {
		return nil
	}
	return u.Address
}

func (u *UserInfo) GetMedicalProxy() *GuarantorDetails {
	if u == nil {
		return nil
	}
	return u.MedicalProxy
}

func (u *UserInfo) GetRace() *Race {
	if u == nil {
		return nil
	}
	return u.Race
}

func (u *UserInfo) GetEthnicity() *Ethnicity {
	if u == nil {
		return nil
	}
	return u.Ethnicity
}

func (u *UserInfo) GetSexualOrientation() *SexualOrientation {
	if u == nil {
		return nil
	}
	return u.SexualOrientation
}

func (u *UserInfo) GetGenderIdentity() *GenderIdentity {
	if u == nil {
		return nil
	}
	return u.GenderIdentity
}

func (u *UserInfo) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler UserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserInfo) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserRefreshSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`
	// A unique ID representing the end user. Typically this will be a user ID from your application. Personally identifiable information, such as an email address or phone number, should not be used in the client_user_id.
	UserId            string   `json:"user_id" url:"user_id"`
	RefreshedSources  []string `json:"refreshed_sources" url:"refreshed_sources"`
	InProgressSources []string `json:"in_progress_sources" url:"in_progress_sources"`
	FailedSources     []string `json:"failed_sources" url:"failed_sources"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserRefreshSuccessResponse) GetSuccess() bool {
	if u == nil {
		return false
	}
	return u.Success
}

func (u *UserRefreshSuccessResponse) GetUserId() string {
	if u == nil {
		return ""
	}
	return u.UserId
}

func (u *UserRefreshSuccessResponse) GetRefreshedSources() []string {
	if u == nil {
		return nil
	}
	return u.RefreshedSources
}

func (u *UserRefreshSuccessResponse) GetInProgressSources() []string {
	if u == nil {
		return nil
	}
	return u.InProgressSources
}

func (u *UserRefreshSuccessResponse) GetFailedSources() []string {
	if u == nil {
		return nil
	}
	return u.FailedSources
}

func (u *UserRefreshSuccessResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserRefreshSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserRefreshSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserRefreshSuccessResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserRefreshSuccessResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSignInTokenResponse struct {
	UserId      string `json:"user_id" url:"user_id"`
	SignInToken string `json:"sign_in_token" url:"sign_in_token"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserSignInTokenResponse) GetUserId() string {
	if u == nil {
		return ""
	}
	return u.UserId
}

func (u *UserSignInTokenResponse) GetSignInToken() string {
	if u == nil {
		return ""
	}
	return u.SignInToken
}

func (u *UserSignInTokenResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserSignInTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSignInTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSignInTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSignInTokenResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserSuccessResponse struct {
	// Whether operation was successful or not
	Success bool `json:"success" url:"success"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserSuccessResponse) GetSuccess() bool {
	if u == nil {
		return false
	}
	return u.Success
}

func (u *UserSuccessResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserSuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserSuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserSuccessResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserSuccessResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails struct {
	FirstName   string   `json:"first_name" url:"first_name"`
	LastName    string   `json:"last_name" url:"last_name"`
	Gender      Gender   `json:"gender" url:"gender"`
	Address     *Address `json:"address" url:"address"`
	Dob         string   `json:"dob" url:"dob"`
	Email       string   `json:"email" url:"email"`
	PhoneNumber string   `json:"phone_number" url:"phone_number"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetFirstName() string {
	if v == nil {
		return ""
	}
	return v.FirstName
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetLastName() string {
	if v == nil {
		return ""
	}
	return v.LastName
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetGender() Gender {
	if v == nil {
		return ""
	}
	return v.Gender
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetAddress() *Address {
	if v == nil {
		return nil
	}
	return v.Address
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetDob() string {
	if v == nil {
		return ""
	}
	return v.Dob
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetEmail() string {
	if v == nil {
		return ""
	}
	return v.Email
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetPhoneNumber() string {
	if v == nil {
		return ""
	}
	return v.PhoneNumber
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VitalCoreSchemasDbSchemasLabTestInsurancePersonDetails) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type UserUndoDeleteRequest struct {
	// User ID to undo deletion. Mutually exclusive with `client_user_id`.
	UserId *string `json:"-" url:"user_id,omitempty"`
	// Client User ID to undo deletion. Mutually exclusive with `user_id`.
	ClientUserId *string `json:"-" url:"client_user_id,omitempty"`
}

type UserInfoCreateRequest struct {
	FirstName         string             `json:"first_name" url:"-"`
	LastName          string             `json:"last_name" url:"-"`
	Email             string             `json:"email" url:"-"`
	PhoneNumber       string             `json:"phone_number" url:"-"`
	Gender            string             `json:"gender" url:"-"`
	Dob               string             `json:"dob" url:"-"`
	Address           *Address           `json:"address,omitempty" url:"-"`
	MedicalProxy      *GuarantorDetails  `json:"medical_proxy,omitempty" url:"-"`
	Race              *Race              `json:"race,omitempty" url:"-"`
	Ethnicity         *Ethnicity         `json:"ethnicity,omitempty" url:"-"`
	SexualOrientation *SexualOrientation `json:"sexual_orientation,omitempty" url:"-"`
	GenderIdentity    *GenderIdentity    `json:"gender_identity,omitempty" url:"-"`
}
