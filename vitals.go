// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tryVital/vital-go/internal"
	big "math/big"
	time "time"
)

var (
	afibBurdenGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	afibBurdenGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	afibBurdenGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	afibBurdenGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	afibBurdenGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	afibBurdenGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type AfibBurdenGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (a *AfibBurdenGroupedVitalsRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AfibBurdenGroupedVitalsRequest) SetUserId(userId string) {
	a.UserId = userId
	a.require(afibBurdenGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AfibBurdenGroupedVitalsRequest) SetCursor(cursor *string) {
	a.Cursor = cursor
	a.require(afibBurdenGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AfibBurdenGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	a.NextCursor = nextCursor
	a.require(afibBurdenGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AfibBurdenGroupedVitalsRequest) SetProvider(provider *string) {
	a.Provider = provider
	a.require(afibBurdenGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AfibBurdenGroupedVitalsRequest) SetStartDate(startDate string) {
	a.StartDate = startDate
	a.require(afibBurdenGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AfibBurdenGroupedVitalsRequest) SetEndDate(endDate *string) {
	a.EndDate = endDate
	a.require(afibBurdenGroupedVitalsRequestFieldEndDate)
}

var (
	basalBodyTemperatureGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	basalBodyTemperatureGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	basalBodyTemperatureGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	basalBodyTemperatureGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	basalBodyTemperatureGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	basalBodyTemperatureGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BasalBodyTemperatureGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BasalBodyTemperatureGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(basalBodyTemperatureGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(basalBodyTemperatureGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(basalBodyTemperatureGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(basalBodyTemperatureGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(basalBodyTemperatureGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasalBodyTemperatureGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(basalBodyTemperatureGroupedVitalsRequestFieldEndDate)
}

var (
	bloodOxygenVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	bloodOxygenVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	bloodOxygenVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	bloodOxygenVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type BloodOxygenVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BloodOxygenVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bloodOxygenVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bloodOxygenVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bloodOxygenVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bloodOxygenVitalsRequestFieldEndDate)
}

var (
	bloodOxygenGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	bloodOxygenGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	bloodOxygenGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	bloodOxygenGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	bloodOxygenGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	bloodOxygenGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BloodOxygenGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BloodOxygenGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bloodOxygenGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(bloodOxygenGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(bloodOxygenGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bloodOxygenGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bloodOxygenGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodOxygenGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bloodOxygenGroupedVitalsRequestFieldEndDate)
}

var (
	bloodPressureVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	bloodPressureVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	bloodPressureVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	bloodPressureVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type BloodPressureVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BloodPressureVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bloodPressureVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bloodPressureVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bloodPressureVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bloodPressureVitalsRequestFieldEndDate)
}

var (
	bloodPressureGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	bloodPressureGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	bloodPressureGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	bloodPressureGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	bloodPressureGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	bloodPressureGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BloodPressureGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BloodPressureGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bloodPressureGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(bloodPressureGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(bloodPressureGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bloodPressureGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bloodPressureGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BloodPressureGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bloodPressureGroupedVitalsRequestFieldEndDate)
}

var (
	bodyFatVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	bodyFatVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	bodyFatVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	bodyFatVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type BodyFatVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyFatVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bodyFatVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bodyFatVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bodyFatVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bodyFatVitalsRequestFieldEndDate)
}

var (
	bodyFatGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	bodyFatGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	bodyFatGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	bodyFatGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	bodyFatGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	bodyFatGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BodyFatGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyFatGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bodyFatGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(bodyFatGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(bodyFatGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bodyFatGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bodyFatGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyFatGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bodyFatGroupedVitalsRequestFieldEndDate)
}

var (
	bodyMassIndexGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	bodyMassIndexGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	bodyMassIndexGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	bodyMassIndexGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	bodyMassIndexGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	bodyMassIndexGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BodyMassIndexGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyMassIndexGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyMassIndexGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bodyMassIndexGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyMassIndexGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(bodyMassIndexGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyMassIndexGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(bodyMassIndexGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyMassIndexGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bodyMassIndexGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyMassIndexGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bodyMassIndexGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyMassIndexGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bodyMassIndexGroupedVitalsRequestFieldEndDate)
}

var (
	bodyTemperatureDeltaGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	bodyTemperatureDeltaGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	bodyTemperatureDeltaGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	bodyTemperatureDeltaGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	bodyTemperatureDeltaGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	bodyTemperatureDeltaGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BodyTemperatureDeltaGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyTemperatureDeltaGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureDeltaGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bodyTemperatureDeltaGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureDeltaGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(bodyTemperatureDeltaGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureDeltaGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(bodyTemperatureDeltaGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureDeltaGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bodyTemperatureDeltaGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureDeltaGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bodyTemperatureDeltaGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureDeltaGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bodyTemperatureDeltaGroupedVitalsRequestFieldEndDate)
}

var (
	bodyTemperatureGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	bodyTemperatureGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	bodyTemperatureGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	bodyTemperatureGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	bodyTemperatureGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	bodyTemperatureGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BodyTemperatureGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyTemperatureGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bodyTemperatureGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(bodyTemperatureGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(bodyTemperatureGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bodyTemperatureGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bodyTemperatureGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyTemperatureGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bodyTemperatureGroupedVitalsRequestFieldEndDate)
}

var (
	bodyWeightVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	bodyWeightVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	bodyWeightVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	bodyWeightVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type BodyWeightVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyWeightVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bodyWeightVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bodyWeightVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bodyWeightVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bodyWeightVitalsRequestFieldEndDate)
}

var (
	bodyWeightGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	bodyWeightGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	bodyWeightGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	bodyWeightGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	bodyWeightGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	bodyWeightGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type BodyWeightGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BodyWeightGroupedVitalsRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightGroupedVitalsRequest) SetUserId(userId string) {
	b.UserId = userId
	b.require(bodyWeightGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightGroupedVitalsRequest) SetCursor(cursor *string) {
	b.Cursor = cursor
	b.require(bodyWeightGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	b.NextCursor = nextCursor
	b.require(bodyWeightGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightGroupedVitalsRequest) SetProvider(provider *string) {
	b.Provider = provider
	b.require(bodyWeightGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightGroupedVitalsRequest) SetStartDate(startDate string) {
	b.StartDate = startDate
	b.require(bodyWeightGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BodyWeightGroupedVitalsRequest) SetEndDate(endDate *string) {
	b.EndDate = endDate
	b.require(bodyWeightGroupedVitalsRequestFieldEndDate)
}

var (
	caffeineVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	caffeineVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	caffeineVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	caffeineVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CaffeineVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CaffeineVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(caffeineVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(caffeineVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(caffeineVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(caffeineVitalsRequestFieldEndDate)
}

var (
	caffeineGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	caffeineGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	caffeineGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	caffeineGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	caffeineGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	caffeineGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type CaffeineGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CaffeineGroupedVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineGroupedVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(caffeineGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineGroupedVitalsRequest) SetCursor(cursor *string) {
	c.Cursor = cursor
	c.require(caffeineGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	c.NextCursor = nextCursor
	c.require(caffeineGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineGroupedVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(caffeineGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineGroupedVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(caffeineGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaffeineGroupedVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(caffeineGroupedVitalsRequestFieldEndDate)
}

var (
	caloriesActiveVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	caloriesActiveVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	caloriesActiveVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	caloriesActiveVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CaloriesActiveVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CaloriesActiveVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(caloriesActiveVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(caloriesActiveVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(caloriesActiveVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(caloriesActiveVitalsRequestFieldEndDate)
}

var (
	caloriesActiveGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	caloriesActiveGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	caloriesActiveGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	caloriesActiveGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	caloriesActiveGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	caloriesActiveGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type CaloriesActiveGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CaloriesActiveGroupedVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveGroupedVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(caloriesActiveGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveGroupedVitalsRequest) SetCursor(cursor *string) {
	c.Cursor = cursor
	c.require(caloriesActiveGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	c.NextCursor = nextCursor
	c.require(caloriesActiveGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveGroupedVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(caloriesActiveGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveGroupedVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(caloriesActiveGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesActiveGroupedVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(caloriesActiveGroupedVitalsRequestFieldEndDate)
}

var (
	caloriesBasalVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	caloriesBasalVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	caloriesBasalVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	caloriesBasalVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CaloriesBasalVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CaloriesBasalVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(caloriesBasalVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(caloriesBasalVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(caloriesBasalVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(caloriesBasalVitalsRequestFieldEndDate)
}

var (
	caloriesBasalGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	caloriesBasalGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	caloriesBasalGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	caloriesBasalGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	caloriesBasalGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	caloriesBasalGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type CaloriesBasalGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CaloriesBasalGroupedVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalGroupedVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(caloriesBasalGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalGroupedVitalsRequest) SetCursor(cursor *string) {
	c.Cursor = cursor
	c.require(caloriesBasalGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	c.NextCursor = nextCursor
	c.require(caloriesBasalGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalGroupedVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(caloriesBasalGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalGroupedVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(caloriesBasalGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CaloriesBasalGroupedVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(caloriesBasalGroupedVitalsRequestFieldEndDate)
}

var (
	carbohydratesGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	carbohydratesGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	carbohydratesGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	carbohydratesGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	carbohydratesGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	carbohydratesGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type CarbohydratesGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CarbohydratesGroupedVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CarbohydratesGroupedVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(carbohydratesGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CarbohydratesGroupedVitalsRequest) SetCursor(cursor *string) {
	c.Cursor = cursor
	c.require(carbohydratesGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CarbohydratesGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	c.NextCursor = nextCursor
	c.require(carbohydratesGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CarbohydratesGroupedVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(carbohydratesGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CarbohydratesGroupedVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(carbohydratesGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CarbohydratesGroupedVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(carbohydratesGroupedVitalsRequestFieldEndDate)
}

var (
	cholesterolVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	cholesterolVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	cholesterolVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	cholesterolVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CholesterolVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CholesterolVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(cholesterolVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(cholesterolVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(cholesterolVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(cholesterolVitalsRequestFieldEndDate)
}

var (
	cholesterolHdlVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	cholesterolHdlVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	cholesterolHdlVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	cholesterolHdlVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CholesterolHdlVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CholesterolHdlVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolHdlVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(cholesterolHdlVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolHdlVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(cholesterolHdlVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolHdlVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(cholesterolHdlVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolHdlVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(cholesterolHdlVitalsRequestFieldEndDate)
}

var (
	cholesterolLdlVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	cholesterolLdlVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	cholesterolLdlVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	cholesterolLdlVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CholesterolLdlVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CholesterolLdlVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolLdlVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(cholesterolLdlVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolLdlVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(cholesterolLdlVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolLdlVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(cholesterolLdlVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolLdlVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(cholesterolLdlVitalsRequestFieldEndDate)
}

var (
	cholesterolTotalVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	cholesterolTotalVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	cholesterolTotalVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	cholesterolTotalVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CholesterolTotalVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CholesterolTotalVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTotalVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(cholesterolTotalVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTotalVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(cholesterolTotalVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTotalVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(cholesterolTotalVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTotalVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(cholesterolTotalVitalsRequestFieldEndDate)
}

var (
	cholesterolTriglyceridesVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	cholesterolTriglyceridesVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	cholesterolTriglyceridesVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	cholesterolTriglyceridesVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type CholesterolTriglyceridesVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CholesterolTriglyceridesVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTriglyceridesVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(cholesterolTriglyceridesVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTriglyceridesVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(cholesterolTriglyceridesVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTriglyceridesVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(cholesterolTriglyceridesVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolTriglyceridesVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(cholesterolTriglyceridesVitalsRequestFieldEndDate)
}

var (
	cholesterolGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	cholesterolGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	cholesterolGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	cholesterolGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	cholesterolGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	cholesterolGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type CholesterolGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CholesterolGroupedVitalsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolGroupedVitalsRequest) SetUserId(userId string) {
	c.UserId = userId
	c.require(cholesterolGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolGroupedVitalsRequest) SetCursor(cursor *string) {
	c.Cursor = cursor
	c.require(cholesterolGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	c.NextCursor = nextCursor
	c.require(cholesterolGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolGroupedVitalsRequest) SetProvider(provider *string) {
	c.Provider = provider
	c.require(cholesterolGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolGroupedVitalsRequest) SetStartDate(startDate string) {
	c.StartDate = startDate
	c.require(cholesterolGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CholesterolGroupedVitalsRequest) SetEndDate(endDate *string) {
	c.EndDate = endDate
	c.require(cholesterolGroupedVitalsRequestFieldEndDate)
}

var (
	daylightExposureGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	daylightExposureGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	daylightExposureGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	daylightExposureGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	daylightExposureGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	daylightExposureGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type DaylightExposureGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DaylightExposureGroupedVitalsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DaylightExposureGroupedVitalsRequest) SetUserId(userId string) {
	d.UserId = userId
	d.require(daylightExposureGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DaylightExposureGroupedVitalsRequest) SetCursor(cursor *string) {
	d.Cursor = cursor
	d.require(daylightExposureGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DaylightExposureGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	d.NextCursor = nextCursor
	d.require(daylightExposureGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DaylightExposureGroupedVitalsRequest) SetProvider(provider *string) {
	d.Provider = provider
	d.require(daylightExposureGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DaylightExposureGroupedVitalsRequest) SetStartDate(startDate string) {
	d.StartDate = startDate
	d.require(daylightExposureGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DaylightExposureGroupedVitalsRequest) SetEndDate(endDate *string) {
	d.EndDate = endDate
	d.require(daylightExposureGroupedVitalsRequestFieldEndDate)
}

var (
	distanceVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	distanceVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	distanceVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	distanceVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type DistanceVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DistanceVitalsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceVitalsRequest) SetUserId(userId string) {
	d.UserId = userId
	d.require(distanceVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceVitalsRequest) SetProvider(provider *string) {
	d.Provider = provider
	d.require(distanceVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceVitalsRequest) SetStartDate(startDate string) {
	d.StartDate = startDate
	d.require(distanceVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceVitalsRequest) SetEndDate(endDate *string) {
	d.EndDate = endDate
	d.require(distanceVitalsRequestFieldEndDate)
}

var (
	distanceGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	distanceGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	distanceGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	distanceGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	distanceGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	distanceGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type DistanceGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DistanceGroupedVitalsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceGroupedVitalsRequest) SetUserId(userId string) {
	d.UserId = userId
	d.require(distanceGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceGroupedVitalsRequest) SetCursor(cursor *string) {
	d.Cursor = cursor
	d.require(distanceGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	d.NextCursor = nextCursor
	d.require(distanceGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceGroupedVitalsRequest) SetProvider(provider *string) {
	d.Provider = provider
	d.require(distanceGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceGroupedVitalsRequest) SetStartDate(startDate string) {
	d.StartDate = startDate
	d.require(distanceGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DistanceGroupedVitalsRequest) SetEndDate(endDate *string) {
	d.EndDate = endDate
	d.require(distanceGroupedVitalsRequestFieldEndDate)
}

var (
	electrocardiogramVoltageVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	electrocardiogramVoltageVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	electrocardiogramVoltageVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	electrocardiogramVoltageVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type ElectrocardiogramVoltageVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *ElectrocardiogramVoltageVitalsRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageVitalsRequest) SetUserId(userId string) {
	e.UserId = userId
	e.require(electrocardiogramVoltageVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageVitalsRequest) SetProvider(provider *string) {
	e.Provider = provider
	e.require(electrocardiogramVoltageVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageVitalsRequest) SetStartDate(startDate string) {
	e.StartDate = startDate
	e.require(electrocardiogramVoltageVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageVitalsRequest) SetEndDate(endDate *string) {
	e.EndDate = endDate
	e.require(electrocardiogramVoltageVitalsRequestFieldEndDate)
}

var (
	electrocardiogramVoltageGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	electrocardiogramVoltageGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	electrocardiogramVoltageGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	electrocardiogramVoltageGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	electrocardiogramVoltageGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	electrocardiogramVoltageGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type ElectrocardiogramVoltageGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (e *ElectrocardiogramVoltageGroupedVitalsRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageGroupedVitalsRequest) SetUserId(userId string) {
	e.UserId = userId
	e.require(electrocardiogramVoltageGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageGroupedVitalsRequest) SetCursor(cursor *string) {
	e.Cursor = cursor
	e.require(electrocardiogramVoltageGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	e.NextCursor = nextCursor
	e.require(electrocardiogramVoltageGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageGroupedVitalsRequest) SetProvider(provider *string) {
	e.Provider = provider
	e.require(electrocardiogramVoltageGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageGroupedVitalsRequest) SetStartDate(startDate string) {
	e.StartDate = startDate
	e.require(electrocardiogramVoltageGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectrocardiogramVoltageGroupedVitalsRequest) SetEndDate(endDate *string) {
	e.EndDate = endDate
	e.require(electrocardiogramVoltageGroupedVitalsRequestFieldEndDate)
}

var (
	fallGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	fallGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	fallGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	fallGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	fallGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	fallGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type FallGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FallGroupedVitalsRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FallGroupedVitalsRequest) SetUserId(userId string) {
	f.UserId = userId
	f.require(fallGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FallGroupedVitalsRequest) SetCursor(cursor *string) {
	f.Cursor = cursor
	f.require(fallGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FallGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	f.NextCursor = nextCursor
	f.require(fallGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FallGroupedVitalsRequest) SetProvider(provider *string) {
	f.Provider = provider
	f.require(fallGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FallGroupedVitalsRequest) SetStartDate(startDate string) {
	f.StartDate = startDate
	f.require(fallGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FallGroupedVitalsRequest) SetEndDate(endDate *string) {
	f.EndDate = endDate
	f.require(fallGroupedVitalsRequestFieldEndDate)
}

var (
	floorsClimbedVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	floorsClimbedVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	floorsClimbedVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	floorsClimbedVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type FloorsClimbedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FloorsClimbedVitalsRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedVitalsRequest) SetUserId(userId string) {
	f.UserId = userId
	f.require(floorsClimbedVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedVitalsRequest) SetProvider(provider *string) {
	f.Provider = provider
	f.require(floorsClimbedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedVitalsRequest) SetStartDate(startDate string) {
	f.StartDate = startDate
	f.require(floorsClimbedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedVitalsRequest) SetEndDate(endDate *string) {
	f.EndDate = endDate
	f.require(floorsClimbedVitalsRequestFieldEndDate)
}

var (
	floorsClimbedGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	floorsClimbedGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	floorsClimbedGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	floorsClimbedGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	floorsClimbedGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	floorsClimbedGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type FloorsClimbedGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *FloorsClimbedGroupedVitalsRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedGroupedVitalsRequest) SetUserId(userId string) {
	f.UserId = userId
	f.require(floorsClimbedGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedGroupedVitalsRequest) SetCursor(cursor *string) {
	f.Cursor = cursor
	f.require(floorsClimbedGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	f.NextCursor = nextCursor
	f.require(floorsClimbedGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedGroupedVitalsRequest) SetProvider(provider *string) {
	f.Provider = provider
	f.require(floorsClimbedGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedGroupedVitalsRequest) SetStartDate(startDate string) {
	f.StartDate = startDate
	f.require(floorsClimbedGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FloorsClimbedGroupedVitalsRequest) SetEndDate(endDate *string) {
	f.EndDate = endDate
	f.require(floorsClimbedGroupedVitalsRequestFieldEndDate)
}

var (
	forcedExpiratoryVolume1GroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	forcedExpiratoryVolume1GroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	forcedExpiratoryVolume1GroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	forcedExpiratoryVolume1GroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	forcedExpiratoryVolume1GroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	forcedExpiratoryVolume1GroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type ForcedExpiratoryVolume1GroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *ForcedExpiratoryVolume1GroupedVitalsRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedExpiratoryVolume1GroupedVitalsRequest) SetUserId(userId string) {
	f.UserId = userId
	f.require(forcedExpiratoryVolume1GroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedExpiratoryVolume1GroupedVitalsRequest) SetCursor(cursor *string) {
	f.Cursor = cursor
	f.require(forcedExpiratoryVolume1GroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedExpiratoryVolume1GroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	f.NextCursor = nextCursor
	f.require(forcedExpiratoryVolume1GroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedExpiratoryVolume1GroupedVitalsRequest) SetProvider(provider *string) {
	f.Provider = provider
	f.require(forcedExpiratoryVolume1GroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedExpiratoryVolume1GroupedVitalsRequest) SetStartDate(startDate string) {
	f.StartDate = startDate
	f.require(forcedExpiratoryVolume1GroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedExpiratoryVolume1GroupedVitalsRequest) SetEndDate(endDate *string) {
	f.EndDate = endDate
	f.require(forcedExpiratoryVolume1GroupedVitalsRequestFieldEndDate)
}

var (
	forcedVitalCapacityGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	forcedVitalCapacityGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	forcedVitalCapacityGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	forcedVitalCapacityGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	forcedVitalCapacityGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	forcedVitalCapacityGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type ForcedVitalCapacityGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (f *ForcedVitalCapacityGroupedVitalsRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedVitalCapacityGroupedVitalsRequest) SetUserId(userId string) {
	f.UserId = userId
	f.require(forcedVitalCapacityGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedVitalCapacityGroupedVitalsRequest) SetCursor(cursor *string) {
	f.Cursor = cursor
	f.require(forcedVitalCapacityGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedVitalCapacityGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	f.NextCursor = nextCursor
	f.require(forcedVitalCapacityGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedVitalCapacityGroupedVitalsRequest) SetProvider(provider *string) {
	f.Provider = provider
	f.require(forcedVitalCapacityGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedVitalCapacityGroupedVitalsRequest) SetStartDate(startDate string) {
	f.StartDate = startDate
	f.require(forcedVitalCapacityGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *ForcedVitalCapacityGroupedVitalsRequest) SetEndDate(endDate *string) {
	f.EndDate = endDate
	f.require(forcedVitalCapacityGroupedVitalsRequestFieldEndDate)
}

var (
	glucoseVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	glucoseVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	glucoseVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	glucoseVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type GlucoseVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GlucoseVitalsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseVitalsRequest) SetUserId(userId string) {
	g.UserId = userId
	g.require(glucoseVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseVitalsRequest) SetProvider(provider *string) {
	g.Provider = provider
	g.require(glucoseVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseVitalsRequest) SetStartDate(startDate string) {
	g.StartDate = startDate
	g.require(glucoseVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseVitalsRequest) SetEndDate(endDate *string) {
	g.EndDate = endDate
	g.require(glucoseVitalsRequestFieldEndDate)
}

var (
	glucoseGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	glucoseGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	glucoseGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	glucoseGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	glucoseGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	glucoseGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type GlucoseGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GlucoseGroupedVitalsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseGroupedVitalsRequest) SetUserId(userId string) {
	g.UserId = userId
	g.require(glucoseGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseGroupedVitalsRequest) SetCursor(cursor *string) {
	g.Cursor = cursor
	g.require(glucoseGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(glucoseGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseGroupedVitalsRequest) SetProvider(provider *string) {
	g.Provider = provider
	g.require(glucoseGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseGroupedVitalsRequest) SetStartDate(startDate string) {
	g.StartDate = startDate
	g.require(glucoseGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GlucoseGroupedVitalsRequest) SetEndDate(endDate *string) {
	g.EndDate = endDate
	g.require(glucoseGroupedVitalsRequestFieldEndDate)
}

var (
	handwashingGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	handwashingGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	handwashingGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	handwashingGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	handwashingGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	handwashingGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type HandwashingGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HandwashingGroupedVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandwashingGroupedVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(handwashingGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandwashingGroupedVitalsRequest) SetCursor(cursor *string) {
	h.Cursor = cursor
	h.require(handwashingGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandwashingGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	h.NextCursor = nextCursor
	h.require(handwashingGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandwashingGroupedVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(handwashingGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandwashingGroupedVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(handwashingGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HandwashingGroupedVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(handwashingGroupedVitalsRequestFieldEndDate)
}

var (
	heartRateAlertGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	heartRateAlertGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	heartRateAlertGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	heartRateAlertGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	heartRateAlertGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	heartRateAlertGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type HeartRateAlertGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HeartRateAlertGroupedVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateAlertGroupedVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(heartRateAlertGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateAlertGroupedVitalsRequest) SetCursor(cursor *string) {
	h.Cursor = cursor
	h.require(heartRateAlertGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateAlertGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	h.NextCursor = nextCursor
	h.require(heartRateAlertGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateAlertGroupedVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(heartRateAlertGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateAlertGroupedVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(heartRateAlertGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateAlertGroupedVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(heartRateAlertGroupedVitalsRequestFieldEndDate)
}

var (
	heartRateRecoveryOneMinuteGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	heartRateRecoveryOneMinuteGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	heartRateRecoveryOneMinuteGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	heartRateRecoveryOneMinuteGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	heartRateRecoveryOneMinuteGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	heartRateRecoveryOneMinuteGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type HeartRateRecoveryOneMinuteGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HeartRateRecoveryOneMinuteGroupedVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateRecoveryOneMinuteGroupedVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(heartRateRecoveryOneMinuteGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateRecoveryOneMinuteGroupedVitalsRequest) SetCursor(cursor *string) {
	h.Cursor = cursor
	h.require(heartRateRecoveryOneMinuteGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateRecoveryOneMinuteGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	h.NextCursor = nextCursor
	h.require(heartRateRecoveryOneMinuteGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateRecoveryOneMinuteGroupedVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(heartRateRecoveryOneMinuteGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateRecoveryOneMinuteGroupedVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(heartRateRecoveryOneMinuteGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartRateRecoveryOneMinuteGroupedVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(heartRateRecoveryOneMinuteGroupedVitalsRequestFieldEndDate)
}

var (
	heartrateVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	heartrateVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	heartrateVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	heartrateVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type HeartrateVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HeartrateVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(heartrateVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(heartrateVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(heartrateVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(heartrateVitalsRequestFieldEndDate)
}

var (
	heartrateGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	heartrateGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	heartrateGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	heartrateGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	heartrateGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	heartrateGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type HeartrateGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HeartrateGroupedVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateGroupedVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(heartrateGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateGroupedVitalsRequest) SetCursor(cursor *string) {
	h.Cursor = cursor
	h.require(heartrateGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	h.NextCursor = nextCursor
	h.require(heartrateGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateGroupedVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(heartrateGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateGroupedVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(heartrateGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HeartrateGroupedVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(heartrateGroupedVitalsRequestFieldEndDate)
}

var (
	hrvVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	hrvVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	hrvVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	hrvVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type HrvVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HrvVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(hrvVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(hrvVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(hrvVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(hrvVitalsRequestFieldEndDate)
}

var (
	hrvGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	hrvGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	hrvGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	hrvGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	hrvGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	hrvGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type HrvGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HrvGroupedVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvGroupedVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(hrvGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvGroupedVitalsRequest) SetCursor(cursor *string) {
	h.Cursor = cursor
	h.require(hrvGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	h.NextCursor = nextCursor
	h.require(hrvGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvGroupedVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(hrvGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvGroupedVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(hrvGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HrvGroupedVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(hrvGroupedVitalsRequestFieldEndDate)
}

var (
	hypnogramVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	hypnogramVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	hypnogramVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	hypnogramVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type HypnogramVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HypnogramVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(hypnogramVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(hypnogramVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(hypnogramVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(hypnogramVitalsRequestFieldEndDate)
}

var (
	hypnogramGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	hypnogramGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	hypnogramGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	hypnogramGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	hypnogramGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	hypnogramGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type HypnogramGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HypnogramGroupedVitalsRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramGroupedVitalsRequest) SetUserId(userId string) {
	h.UserId = userId
	h.require(hypnogramGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramGroupedVitalsRequest) SetCursor(cursor *string) {
	h.Cursor = cursor
	h.require(hypnogramGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	h.NextCursor = nextCursor
	h.require(hypnogramGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramGroupedVitalsRequest) SetProvider(provider *string) {
	h.Provider = provider
	h.require(hypnogramGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramGroupedVitalsRequest) SetStartDate(startDate string) {
	h.StartDate = startDate
	h.require(hypnogramGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HypnogramGroupedVitalsRequest) SetEndDate(endDate *string) {
	h.EndDate = endDate
	h.require(hypnogramGroupedVitalsRequestFieldEndDate)
}

var (
	igeVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	igeVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	igeVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	igeVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type IgeVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *IgeVitalsRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeVitalsRequest) SetUserId(userId string) {
	i.UserId = userId
	i.require(igeVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeVitalsRequest) SetProvider(provider *string) {
	i.Provider = provider
	i.require(igeVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeVitalsRequest) SetStartDate(startDate string) {
	i.StartDate = startDate
	i.require(igeVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeVitalsRequest) SetEndDate(endDate *string) {
	i.EndDate = endDate
	i.require(igeVitalsRequestFieldEndDate)
}

var (
	igeGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	igeGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	igeGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	igeGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	igeGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	igeGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type IgeGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *IgeGroupedVitalsRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeGroupedVitalsRequest) SetUserId(userId string) {
	i.UserId = userId
	i.require(igeGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeGroupedVitalsRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(igeGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	i.NextCursor = nextCursor
	i.require(igeGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeGroupedVitalsRequest) SetProvider(provider *string) {
	i.Provider = provider
	i.require(igeGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeGroupedVitalsRequest) SetStartDate(startDate string) {
	i.StartDate = startDate
	i.require(igeGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IgeGroupedVitalsRequest) SetEndDate(endDate *string) {
	i.EndDate = endDate
	i.require(igeGroupedVitalsRequestFieldEndDate)
}

var (
	iggVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	iggVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	iggVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	iggVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type IggVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *IggVitalsRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggVitalsRequest) SetUserId(userId string) {
	i.UserId = userId
	i.require(iggVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggVitalsRequest) SetProvider(provider *string) {
	i.Provider = provider
	i.require(iggVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggVitalsRequest) SetStartDate(startDate string) {
	i.StartDate = startDate
	i.require(iggVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggVitalsRequest) SetEndDate(endDate *string) {
	i.EndDate = endDate
	i.require(iggVitalsRequestFieldEndDate)
}

var (
	iggGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	iggGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	iggGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	iggGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	iggGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	iggGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type IggGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *IggGroupedVitalsRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggGroupedVitalsRequest) SetUserId(userId string) {
	i.UserId = userId
	i.require(iggGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggGroupedVitalsRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(iggGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	i.NextCursor = nextCursor
	i.require(iggGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggGroupedVitalsRequest) SetProvider(provider *string) {
	i.Provider = provider
	i.require(iggGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggGroupedVitalsRequest) SetStartDate(startDate string) {
	i.StartDate = startDate
	i.require(iggGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IggGroupedVitalsRequest) SetEndDate(endDate *string) {
	i.EndDate = endDate
	i.require(iggGroupedVitalsRequestFieldEndDate)
}

var (
	inhalerUsageGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	inhalerUsageGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	inhalerUsageGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	inhalerUsageGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	inhalerUsageGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	inhalerUsageGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type InhalerUsageGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InhalerUsageGroupedVitalsRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InhalerUsageGroupedVitalsRequest) SetUserId(userId string) {
	i.UserId = userId
	i.require(inhalerUsageGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InhalerUsageGroupedVitalsRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(inhalerUsageGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InhalerUsageGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	i.NextCursor = nextCursor
	i.require(inhalerUsageGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InhalerUsageGroupedVitalsRequest) SetProvider(provider *string) {
	i.Provider = provider
	i.require(inhalerUsageGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InhalerUsageGroupedVitalsRequest) SetStartDate(startDate string) {
	i.StartDate = startDate
	i.require(inhalerUsageGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InhalerUsageGroupedVitalsRequest) SetEndDate(endDate *string) {
	i.EndDate = endDate
	i.require(inhalerUsageGroupedVitalsRequestFieldEndDate)
}

var (
	insulinInjectionGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	insulinInjectionGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	insulinInjectionGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	insulinInjectionGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	insulinInjectionGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	insulinInjectionGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type InsulinInjectionGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (i *InsulinInjectionGroupedVitalsRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsulinInjectionGroupedVitalsRequest) SetUserId(userId string) {
	i.UserId = userId
	i.require(insulinInjectionGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsulinInjectionGroupedVitalsRequest) SetCursor(cursor *string) {
	i.Cursor = cursor
	i.require(insulinInjectionGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsulinInjectionGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	i.NextCursor = nextCursor
	i.require(insulinInjectionGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsulinInjectionGroupedVitalsRequest) SetProvider(provider *string) {
	i.Provider = provider
	i.require(insulinInjectionGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsulinInjectionGroupedVitalsRequest) SetStartDate(startDate string) {
	i.StartDate = startDate
	i.require(insulinInjectionGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InsulinInjectionGroupedVitalsRequest) SetEndDate(endDate *string) {
	i.EndDate = endDate
	i.require(insulinInjectionGroupedVitalsRequestFieldEndDate)
}

var (
	leanBodyMassGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	leanBodyMassGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	leanBodyMassGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	leanBodyMassGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	leanBodyMassGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	leanBodyMassGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type LeanBodyMassGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *LeanBodyMassGroupedVitalsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LeanBodyMassGroupedVitalsRequest) SetUserId(userId string) {
	l.UserId = userId
	l.require(leanBodyMassGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LeanBodyMassGroupedVitalsRequest) SetCursor(cursor *string) {
	l.Cursor = cursor
	l.require(leanBodyMassGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LeanBodyMassGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	l.NextCursor = nextCursor
	l.require(leanBodyMassGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LeanBodyMassGroupedVitalsRequest) SetProvider(provider *string) {
	l.Provider = provider
	l.require(leanBodyMassGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LeanBodyMassGroupedVitalsRequest) SetStartDate(startDate string) {
	l.StartDate = startDate
	l.require(leanBodyMassGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LeanBodyMassGroupedVitalsRequest) SetEndDate(endDate *string) {
	l.EndDate = endDate
	l.require(leanBodyMassGroupedVitalsRequestFieldEndDate)
}

var (
	mindfulnessMinutesVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	mindfulnessMinutesVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	mindfulnessMinutesVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	mindfulnessMinutesVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type MindfulnessMinutesVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *MindfulnessMinutesVitalsRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesVitalsRequest) SetUserId(userId string) {
	m.UserId = userId
	m.require(mindfulnessMinutesVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesVitalsRequest) SetProvider(provider *string) {
	m.Provider = provider
	m.require(mindfulnessMinutesVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesVitalsRequest) SetStartDate(startDate string) {
	m.StartDate = startDate
	m.require(mindfulnessMinutesVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesVitalsRequest) SetEndDate(endDate *string) {
	m.EndDate = endDate
	m.require(mindfulnessMinutesVitalsRequestFieldEndDate)
}

var (
	mindfulnessMinutesGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	mindfulnessMinutesGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	mindfulnessMinutesGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	mindfulnessMinutesGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	mindfulnessMinutesGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	mindfulnessMinutesGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type MindfulnessMinutesGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *MindfulnessMinutesGroupedVitalsRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesGroupedVitalsRequest) SetUserId(userId string) {
	m.UserId = userId
	m.require(mindfulnessMinutesGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesGroupedVitalsRequest) SetCursor(cursor *string) {
	m.Cursor = cursor
	m.require(mindfulnessMinutesGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	m.NextCursor = nextCursor
	m.require(mindfulnessMinutesGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesGroupedVitalsRequest) SetProvider(provider *string) {
	m.Provider = provider
	m.require(mindfulnessMinutesGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesGroupedVitalsRequest) SetStartDate(startDate string) {
	m.StartDate = startDate
	m.require(mindfulnessMinutesGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MindfulnessMinutesGroupedVitalsRequest) SetEndDate(endDate *string) {
	m.EndDate = endDate
	m.require(mindfulnessMinutesGroupedVitalsRequestFieldEndDate)
}

var (
	noteGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	noteGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	noteGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	noteGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	noteGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	noteGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type NoteGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (n *NoteGroupedVitalsRequest) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NoteGroupedVitalsRequest) SetUserId(userId string) {
	n.UserId = userId
	n.require(noteGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NoteGroupedVitalsRequest) SetCursor(cursor *string) {
	n.Cursor = cursor
	n.require(noteGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NoteGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	n.NextCursor = nextCursor
	n.require(noteGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NoteGroupedVitalsRequest) SetProvider(provider *string) {
	n.Provider = provider
	n.require(noteGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NoteGroupedVitalsRequest) SetStartDate(startDate string) {
	n.StartDate = startDate
	n.require(noteGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NoteGroupedVitalsRequest) SetEndDate(endDate *string) {
	n.EndDate = endDate
	n.require(noteGroupedVitalsRequestFieldEndDate)
}

var (
	peakExpiratoryFlowRateGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	peakExpiratoryFlowRateGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	peakExpiratoryFlowRateGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	peakExpiratoryFlowRateGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	peakExpiratoryFlowRateGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	peakExpiratoryFlowRateGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type PeakExpiratoryFlowRateGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PeakExpiratoryFlowRateGroupedVitalsRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PeakExpiratoryFlowRateGroupedVitalsRequest) SetUserId(userId string) {
	p.UserId = userId
	p.require(peakExpiratoryFlowRateGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PeakExpiratoryFlowRateGroupedVitalsRequest) SetCursor(cursor *string) {
	p.Cursor = cursor
	p.require(peakExpiratoryFlowRateGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PeakExpiratoryFlowRateGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	p.NextCursor = nextCursor
	p.require(peakExpiratoryFlowRateGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PeakExpiratoryFlowRateGroupedVitalsRequest) SetProvider(provider *string) {
	p.Provider = provider
	p.require(peakExpiratoryFlowRateGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PeakExpiratoryFlowRateGroupedVitalsRequest) SetStartDate(startDate string) {
	p.StartDate = startDate
	p.require(peakExpiratoryFlowRateGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PeakExpiratoryFlowRateGroupedVitalsRequest) SetEndDate(endDate *string) {
	p.EndDate = endDate
	p.require(peakExpiratoryFlowRateGroupedVitalsRequestFieldEndDate)
}

var (
	respiratoryRateVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	respiratoryRateVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	respiratoryRateVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	respiratoryRateVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type RespiratoryRateVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RespiratoryRateVitalsRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateVitalsRequest) SetUserId(userId string) {
	r.UserId = userId
	r.require(respiratoryRateVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateVitalsRequest) SetProvider(provider *string) {
	r.Provider = provider
	r.require(respiratoryRateVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateVitalsRequest) SetStartDate(startDate string) {
	r.StartDate = startDate
	r.require(respiratoryRateVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateVitalsRequest) SetEndDate(endDate *string) {
	r.EndDate = endDate
	r.require(respiratoryRateVitalsRequestFieldEndDate)
}

var (
	respiratoryRateGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	respiratoryRateGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	respiratoryRateGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	respiratoryRateGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	respiratoryRateGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	respiratoryRateGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type RespiratoryRateGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RespiratoryRateGroupedVitalsRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateGroupedVitalsRequest) SetUserId(userId string) {
	r.UserId = userId
	r.require(respiratoryRateGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateGroupedVitalsRequest) SetCursor(cursor *string) {
	r.Cursor = cursor
	r.require(respiratoryRateGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	r.NextCursor = nextCursor
	r.require(respiratoryRateGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateGroupedVitalsRequest) SetProvider(provider *string) {
	r.Provider = provider
	r.require(respiratoryRateGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateGroupedVitalsRequest) SetStartDate(startDate string) {
	r.StartDate = startDate
	r.require(respiratoryRateGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RespiratoryRateGroupedVitalsRequest) SetEndDate(endDate *string) {
	r.EndDate = endDate
	r.require(respiratoryRateGroupedVitalsRequestFieldEndDate)
}

var (
	sleepApneaAlertGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	sleepApneaAlertGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	sleepApneaAlertGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	sleepApneaAlertGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	sleepApneaAlertGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	sleepApneaAlertGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type SleepApneaAlertGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SleepApneaAlertGroupedVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepApneaAlertGroupedVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(sleepApneaAlertGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepApneaAlertGroupedVitalsRequest) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(sleepApneaAlertGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepApneaAlertGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	s.NextCursor = nextCursor
	s.require(sleepApneaAlertGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepApneaAlertGroupedVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(sleepApneaAlertGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepApneaAlertGroupedVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(sleepApneaAlertGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepApneaAlertGroupedVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(sleepApneaAlertGroupedVitalsRequestFieldEndDate)
}

var (
	sleepBreathingDisturbanceGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	sleepBreathingDisturbanceGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	sleepBreathingDisturbanceGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	sleepBreathingDisturbanceGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	sleepBreathingDisturbanceGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	sleepBreathingDisturbanceGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type SleepBreathingDisturbanceGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SleepBreathingDisturbanceGroupedVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepBreathingDisturbanceGroupedVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(sleepBreathingDisturbanceGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepBreathingDisturbanceGroupedVitalsRequest) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(sleepBreathingDisturbanceGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepBreathingDisturbanceGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	s.NextCursor = nextCursor
	s.require(sleepBreathingDisturbanceGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepBreathingDisturbanceGroupedVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(sleepBreathingDisturbanceGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepBreathingDisturbanceGroupedVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(sleepBreathingDisturbanceGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SleepBreathingDisturbanceGroupedVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(sleepBreathingDisturbanceGroupedVitalsRequestFieldEndDate)
}

var (
	standDurationGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	standDurationGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	standDurationGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	standDurationGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	standDurationGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	standDurationGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type StandDurationGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StandDurationGroupedVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandDurationGroupedVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(standDurationGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandDurationGroupedVitalsRequest) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(standDurationGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandDurationGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	s.NextCursor = nextCursor
	s.require(standDurationGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandDurationGroupedVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(standDurationGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandDurationGroupedVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(standDurationGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandDurationGroupedVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(standDurationGroupedVitalsRequestFieldEndDate)
}

var (
	standHourGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	standHourGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	standHourGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	standHourGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	standHourGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	standHourGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type StandHourGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StandHourGroupedVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandHourGroupedVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(standHourGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandHourGroupedVitalsRequest) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(standHourGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandHourGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	s.NextCursor = nextCursor
	s.require(standHourGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandHourGroupedVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(standHourGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandHourGroupedVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(standHourGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandHourGroupedVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(standHourGroupedVitalsRequestFieldEndDate)
}

var (
	stepsVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	stepsVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	stepsVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	stepsVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type StepsVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StepsVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(stepsVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(stepsVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(stepsVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(stepsVitalsRequestFieldEndDate)
}

var (
	stepsGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	stepsGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	stepsGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	stepsGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	stepsGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	stepsGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type StepsGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StepsGroupedVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsGroupedVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(stepsGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsGroupedVitalsRequest) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(stepsGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	s.NextCursor = nextCursor
	s.require(stepsGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsGroupedVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(stepsGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsGroupedVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(stepsGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StepsGroupedVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(stepsGroupedVitalsRequestFieldEndDate)
}

var (
	stressLevelVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	stressLevelVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	stressLevelVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	stressLevelVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type StressLevelVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StressLevelVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(stressLevelVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(stressLevelVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(stressLevelVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(stressLevelVitalsRequestFieldEndDate)
}

var (
	stressLevelGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	stressLevelGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	stressLevelGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	stressLevelGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	stressLevelGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	stressLevelGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type StressLevelGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *StressLevelGroupedVitalsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelGroupedVitalsRequest) SetUserId(userId string) {
	s.UserId = userId
	s.require(stressLevelGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelGroupedVitalsRequest) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(stressLevelGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	s.NextCursor = nextCursor
	s.require(stressLevelGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelGroupedVitalsRequest) SetProvider(provider *string) {
	s.Provider = provider
	s.require(stressLevelGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelGroupedVitalsRequest) SetStartDate(startDate string) {
	s.StartDate = startDate
	s.require(stressLevelGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StressLevelGroupedVitalsRequest) SetEndDate(endDate *string) {
	s.EndDate = endDate
	s.require(stressLevelGroupedVitalsRequestFieldEndDate)
}

var (
	clientFacingAFibBurdenSampleFieldId             = big.NewInt(1 << 0)
	clientFacingAFibBurdenSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingAFibBurdenSampleFieldType           = big.NewInt(1 << 2)
	clientFacingAFibBurdenSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingAFibBurdenSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingAFibBurdenSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingAFibBurdenSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingAFibBurdenSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingAFibBurdenSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingAFibBurdenSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingAFibBurdenSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingAFibBurdenSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingAFibBurdenSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingAFibBurdenSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingAFibBurdenSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingAFibBurdenSample) Unit() string {
	return c.unit
}

func (c *ClientFacingAFibBurdenSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAFibBurdenSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingAFibBurdenSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingAFibBurdenSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingAFibBurdenSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingAFibBurdenSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingAFibBurdenSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingAFibBurdenSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingAFibBurdenSampleFieldValue)
}

func (c *ClientFacingAFibBurdenSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAFibBurdenSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAFibBurdenSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "%" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "%", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAFibBurdenSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAFibBurdenSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "%",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingAFibBurdenSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBasalBodyTemperatureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBasalBodyTemperatureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBasalBodyTemperatureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBasalBodyTemperatureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBasalBodyTemperatureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBasalBodyTemperatureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBasalBodyTemperatureSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingBasalBodyTemperatureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBasalBodyTemperatureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBasalBodyTemperatureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBasalBodyTemperatureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBasalBodyTemperatureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBasalBodyTemperatureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBasalBodyTemperatureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBasalBodyTemperatureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBasalBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBasalBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBasalBodyTemperatureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBasalBodyTemperatureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBasalBodyTemperatureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBasalBodyTemperatureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBasalBodyTemperatureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBasalBodyTemperatureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBasalBodyTemperatureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBasalBodyTemperatureSampleFieldValue)
}

func (c *ClientFacingBasalBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBasalBodyTemperatureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBasalBodyTemperatureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBasalBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBasalBodyTemperatureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "C",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBasalBodyTemperatureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBloodOxygenTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBloodOxygenTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBloodOxygenTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBloodOxygenTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBloodOxygenTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingBloodOxygenTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingBloodOxygenTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (spo2).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBloodOxygenTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBloodOxygenTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBloodOxygenTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBloodOxygenTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBloodOxygenTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBloodOxygenTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBloodOxygenTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodOxygenTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBloodOxygenTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBloodOxygenTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBloodOxygenTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBloodOxygenTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBloodOxygenTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBloodOxygenTimeseriesFieldValue)
}

func (c *ClientFacingBloodOxygenTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodOxygenTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodOxygenTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBloodOxygenTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBloodPressureTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBloodPressureTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBloodPressureTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBloodPressureTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBloodPressureTimeseriesFieldGrouping       = big.NewInt(1 << 4)
	clientFacingBloodPressureTimeseriesFieldTimestamp      = big.NewInt(1 << 5)
	clientFacingBloodPressureTimeseriesFieldSystolic       = big.NewInt(1 << 6)
	clientFacingBloodPressureTimeseriesFieldDiastolic      = big.NewInt(1 << 7)
)

type ClientFacingBloodPressureTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unit of the value. We use SI units where possible, e.g. mmol/L for glucose/cholesterol, bpm for heart rate, etc.
	Unit      string                          `json:"unit" url:"unit"`
	Grouping  *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	Timestamp time.Time                       `json:"timestamp" url:"timestamp"`
	Systolic  float64                         `json:"systolic" url:"systolic"`
	Diastolic float64                         `json:"diastolic" url:"diastolic"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBloodPressureTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBloodPressureTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBloodPressureTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBloodPressureTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBloodPressureTimeseries) GetGrouping() *ClientFacingSampleGroupingKeys {
	if c == nil {
		return nil
	}
	return c.Grouping
}

func (c *ClientFacingBloodPressureTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBloodPressureTimeseries) GetSystolic() float64 {
	if c == nil {
		return 0
	}
	return c.Systolic
}

func (c *ClientFacingBloodPressureTimeseries) GetDiastolic() float64 {
	if c == nil {
		return 0
	}
	return c.Diastolic
}

func (c *ClientFacingBloodPressureTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodPressureTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBloodPressureTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBloodPressureTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBloodPressureTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBloodPressureTimeseriesFieldUnit)
}

// SetGrouping sets the Grouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetGrouping(grouping *ClientFacingSampleGroupingKeys) {
	c.Grouping = grouping
	c.require(clientFacingBloodPressureTimeseriesFieldGrouping)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBloodPressureTimeseriesFieldTimestamp)
}

// SetSystolic sets the Systolic field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetSystolic(systolic float64) {
	c.Systolic = systolic
	c.require(clientFacingBloodPressureTimeseriesFieldSystolic)
}

// SetDiastolic sets the Diastolic field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetDiastolic(diastolic float64) {
	c.Diastolic = diastolic
	c.require(clientFacingBloodPressureTimeseriesFieldDiastolic)
}

func (c *ClientFacingBloodPressureTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodPressureTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodPressureTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBloodPressureTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBodyFatTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBodyFatTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyFatTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBodyFatTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBodyFatTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingBodyFatTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingBodyFatTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyFatTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyFatTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyFatTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyFatTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBodyFatTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyFatTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyFatTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyFatTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyFatTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyFatTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyFatTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBodyFatTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyFatTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyFatTimeseriesFieldValue)
}

func (c *ClientFacingBodyFatTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyFatTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyFatTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyFatTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyFatTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyFatTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBodyMassIndexSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBodyMassIndexSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyMassIndexSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBodyMassIndexSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBodyMassIndexSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBodyMassIndexSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBodyMassIndexSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingBodyMassIndexSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyMassIndexSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyMassIndexSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyMassIndexSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyMassIndexSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyMassIndexSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBodyMassIndexSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBodyMassIndexSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyMassIndexSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyMassIndexSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyMassIndexSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyMassIndexSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyMassIndexSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyMassIndexSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyMassIndexSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBodyMassIndexSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBodyMassIndexSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyMassIndexSampleFieldValue)
}

func (c *ClientFacingBodyMassIndexSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyMassIndexSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyMassIndexSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "index" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "index", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyMassIndexSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyMassIndexSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "index",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyMassIndexSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBodyTemperatureDeltaSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBodyTemperatureDeltaSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyTemperatureDeltaSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBodyTemperatureDeltaSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBodyTemperatureDeltaSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBodyTemperatureDeltaSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBodyTemperatureDeltaSampleFieldValue          = big.NewInt(1 << 6)
	clientFacingBodyTemperatureDeltaSampleFieldSensorLocation = big.NewInt(1 << 7)
)

type ClientFacingBodyTemperatureDeltaSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.  This enum is non-exhaustive.
	SensorLocation *ClientFacingBodyTemperatureDeltaSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetSensorLocation() *ClientFacingBodyTemperatureDeltaSampleSensorLocation {
	if c == nil {
		return nil
	}
	return c.SensorLocation
}

func (c *ClientFacingBodyTemperatureDeltaSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureDeltaSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyTemperatureDeltaSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyTemperatureDeltaSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyTemperatureDeltaSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyTemperatureDeltaSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBodyTemperatureDeltaSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBodyTemperatureDeltaSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyTemperatureDeltaSampleFieldValue)
}

// SetSensorLocation sets the SensorLocation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetSensorLocation(sensorLocation *ClientFacingBodyTemperatureDeltaSampleSensorLocation) {
	c.SensorLocation = sensorLocation
	c.require(clientFacingBodyTemperatureDeltaSampleFieldSensorLocation)
}

func (c *ClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureDeltaSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureDeltaSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureDeltaSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureDeltaSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "C",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSampleSensorLocation string

const (
	ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationBody             ClientFacingBodyTemperatureDeltaSampleSensorLocation = "body"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEar              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureDeltaSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationToe              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum          ClientFacingBodyTemperatureDeltaSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureDeltaSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead         ClientFacingBodyTemperatureDeltaSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureDeltaSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureDeltaSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureDeltaSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureDeltaSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureDeltaSampleSensorLocation {
	return &c
}

var (
	clientFacingBodyTemperatureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBodyTemperatureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyTemperatureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBodyTemperatureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBodyTemperatureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBodyTemperatureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBodyTemperatureSampleFieldValue          = big.NewInt(1 << 6)
	clientFacingBodyTemperatureSampleFieldSensorLocation = big.NewInt(1 << 7)
)

type ClientFacingBodyTemperatureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.  This enum is non-exhaustive.
	SensorLocation *ClientFacingBodyTemperatureSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyTemperatureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyTemperatureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyTemperatureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyTemperatureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyTemperatureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBodyTemperatureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBodyTemperatureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyTemperatureSample) GetSensorLocation() *ClientFacingBodyTemperatureSampleSensorLocation {
	if c == nil {
		return nil
	}
	return c.SensorLocation
}

func (c *ClientFacingBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyTemperatureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyTemperatureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyTemperatureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyTemperatureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBodyTemperatureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBodyTemperatureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyTemperatureSampleFieldValue)
}

// SetSensorLocation sets the SensorLocation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetSensorLocation(sensorLocation *ClientFacingBodyTemperatureSampleSensorLocation) {
	c.SensorLocation = sensorLocation
	c.require(clientFacingBodyTemperatureSampleFieldSensorLocation)
}

func (c *ClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "C",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyTemperatureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureSampleSensorLocation string

const (
	ClientFacingBodyTemperatureSampleSensorLocationArmpit           ClientFacingBodyTemperatureSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureSampleSensorLocationBody             ClientFacingBodyTemperatureSampleSensorLocation = "body"
	ClientFacingBodyTemperatureSampleSensorLocationEar              ClientFacingBodyTemperatureSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureSampleSensorLocationFinger           ClientFacingBodyTemperatureSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureSampleSensorLocationMouth            ClientFacingBodyTemperatureSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureSampleSensorLocationRectum           ClientFacingBodyTemperatureSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureSampleSensorLocationToe              ClientFacingBodyTemperatureSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureSampleSensorLocationEardrum          ClientFacingBodyTemperatureSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureSampleSensorLocationForehead         ClientFacingBodyTemperatureSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureSampleSensorLocationWrist            ClientFacingBodyTemperatureSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureSampleSensorLocation {
	return &c
}

var (
	clientFacingBodyWeightTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBodyWeightTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyWeightTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBodyWeightTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBodyWeightTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingBodyWeightTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingBodyWeightTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilograms (kg).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyWeightTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyWeightTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyWeightTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyWeightTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBodyWeightTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyWeightTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyWeightTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyWeightTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyWeightTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyWeightTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyWeightTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBodyWeightTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyWeightTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyWeightTimeseriesFieldValue)
}

func (c *ClientFacingBodyWeightTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyWeightTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyWeightTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyWeightTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyWeightTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyWeightTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCaffeineTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCaffeineTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCaffeineTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCaffeineTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingCaffeineTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingCaffeineTimeseriesFieldStart          = big.NewInt(1 << 5)
	clientFacingCaffeineTimeseriesFieldEnd            = big.NewInt(1 << 6)
	clientFacingCaffeineTimeseriesFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingCaffeineTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Quantity of caffeine consumed during the time period.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCaffeineTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCaffeineTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCaffeineTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCaffeineTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingCaffeineTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCaffeineTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingCaffeineTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingCaffeineTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCaffeineTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaffeineTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCaffeineTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCaffeineTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCaffeineTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingCaffeineTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCaffeineTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingCaffeineTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingCaffeineTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCaffeineTimeseriesFieldValue)
}

func (c *ClientFacingCaffeineTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaffeineTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaffeineTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaffeineTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCaffeineTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCaloriesActiveTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCaloriesActiveTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCaloriesActiveTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCaloriesActiveTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingCaloriesActiveTimeseriesFieldStart          = big.NewInt(1 << 4)
	clientFacingCaloriesActiveTimeseriesFieldEnd            = big.NewInt(1 << 5)
	clientFacingCaloriesActiveTimeseriesFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingCaloriesActiveTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Energy consumption caused by the physical activity at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCaloriesActiveTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCaloriesActiveTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCaloriesActiveTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCaloriesActiveTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCaloriesActiveTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingCaloriesActiveTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingCaloriesActiveTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCaloriesActiveTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesActiveTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesActiveTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCaloriesActiveTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCaloriesActiveTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCaloriesActiveTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCaloriesActiveTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingCaloriesActiveTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingCaloriesActiveTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCaloriesActiveTimeseriesFieldValue)
}

func (c *ClientFacingCaloriesActiveTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesActiveTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "kcal",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCaloriesActiveTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCaloriesBasalTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCaloriesBasalTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCaloriesBasalTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCaloriesBasalTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingCaloriesBasalTimeseriesFieldValue          = big.NewInt(1 << 4)
)

type ClientFacingCaloriesBasalTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Basal Metabolic Rate at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCaloriesBasalTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCaloriesBasalTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCaloriesBasalTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCaloriesBasalTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCaloriesBasalTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCaloriesBasalTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesBasalTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesBasalTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCaloriesBasalTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCaloriesBasalTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCaloriesBasalTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCaloriesBasalTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCaloriesBasalTimeseriesFieldValue)
}

func (c *ClientFacingCaloriesBasalTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesBasalTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Unit:      "kcal",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCaloriesBasalTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCarbohydratesSampleFieldId             = big.NewInt(1 << 0)
	clientFacingCarbohydratesSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCarbohydratesSampleFieldType           = big.NewInt(1 << 2)
	clientFacingCarbohydratesSampleFieldUnit           = big.NewInt(1 << 3)
	clientFacingCarbohydratesSampleFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingCarbohydratesSampleFieldStart          = big.NewInt(1 << 5)
	clientFacingCarbohydratesSampleFieldEnd            = big.NewInt(1 << 6)
	clientFacingCarbohydratesSampleFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingCarbohydratesSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCarbohydratesSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCarbohydratesSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCarbohydratesSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCarbohydratesSample) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingCarbohydratesSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCarbohydratesSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingCarbohydratesSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingCarbohydratesSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCarbohydratesSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCarbohydratesSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCarbohydratesSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCarbohydratesSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCarbohydratesSampleFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingCarbohydratesSampleFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCarbohydratesSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingCarbohydratesSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingCarbohydratesSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCarbohydratesSampleFieldValue)
}

func (c *ClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCarbohydratesSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCarbohydratesSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCarbohydratesSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCarbohydratesSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCarbohydratesSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCholesterolTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCholesterolTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCholesterolTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCholesterolTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingCholesterolTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingCholesterolTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingCholesterolTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in mmol/L.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCholesterolTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCholesterolTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCholesterolTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingCholesterolTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingCholesterolTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCholesterolTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCholesterolTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCholesterolTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCholesterolTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCholesterolTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingCholesterolTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingCholesterolTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCholesterolTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCholesterolTimeseriesFieldValue)
}

func (c *ClientFacingCholesterolTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCholesterolTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCholesterolTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCholesterolTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCholesterolTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingDaylightExposureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingDaylightExposureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingDaylightExposureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingDaylightExposureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingDaylightExposureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingDaylightExposureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingDaylightExposureSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingDaylightExposureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingDaylightExposureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingDaylightExposureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingDaylightExposureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingDaylightExposureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingDaylightExposureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingDaylightExposureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingDaylightExposureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingDaylightExposureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingDaylightExposureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDaylightExposureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingDaylightExposureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingDaylightExposureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingDaylightExposureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingDaylightExposureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingDaylightExposureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingDaylightExposureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingDaylightExposureSampleFieldValue)
}

func (c *ClientFacingDaylightExposureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDaylightExposureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDaylightExposureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDaylightExposureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDaylightExposureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingDaylightExposureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingDistanceTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingDistanceTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingDistanceTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingDistanceTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingDistanceTimeseriesFieldStart          = big.NewInt(1 << 4)
	clientFacingDistanceTimeseriesFieldEnd            = big.NewInt(1 << 5)
	clientFacingDistanceTimeseriesFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingDistanceTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in meters (m)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Distance traveled during activities at the time or interval::steps
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingDistanceTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingDistanceTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingDistanceTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingDistanceTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingDistanceTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingDistanceTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingDistanceTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingDistanceTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingDistanceTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDistanceTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingDistanceTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingDistanceTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingDistanceTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingDistanceTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingDistanceTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingDistanceTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingDistanceTimeseriesFieldValue)
}

func (c *ClientFacingDistanceTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDistanceTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDistanceTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "m" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "m", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "m",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingDistanceTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingElectrocardiogramVoltageTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingElectrocardiogramVoltageTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingElectrocardiogramVoltageTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingElectrocardiogramVoltageTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingElectrocardiogramVoltageTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingElectrocardiogramVoltageTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingElectrocardiogramVoltageTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The lead of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in mV.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldValue)
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingElectrocardiogramVoltageTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingElectrocardiogramVoltageTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingFallSampleFieldId             = big.NewInt(1 << 0)
	clientFacingFallSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingFallSampleFieldType           = big.NewInt(1 << 2)
	clientFacingFallSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingFallSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingFallSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingFallSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingFallSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingFallSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingFallSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingFallSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingFallSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingFallSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingFallSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingFallSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingFallSample) Unit() string {
	return c.unit
}

func (c *ClientFacingFallSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFallSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingFallSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingFallSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingFallSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingFallSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingFallSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingFallSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingFallSampleFieldValue)
}

func (c *ClientFacingFallSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFallSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFallSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFallSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFallSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingFallSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingFloorsClimbedTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingFloorsClimbedTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingFloorsClimbedTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingFloorsClimbedTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingFloorsClimbedTimeseriesFieldValue          = big.NewInt(1 << 4)
)

type ClientFacingFloorsClimbedTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Number of floors climbed at the time or interval::count
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingFloorsClimbedTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingFloorsClimbedTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingFloorsClimbedTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingFloorsClimbedTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingFloorsClimbedTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingFloorsClimbedTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingFloorsClimbedTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFloorsClimbedTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingFloorsClimbedTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingFloorsClimbedTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingFloorsClimbedTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingFloorsClimbedTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingFloorsClimbedTimeseriesFieldValue)
}

func (c *ClientFacingFloorsClimbedTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFloorsClimbedTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingFloorsClimbedTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingForcedExpiratoryVolume1SampleFieldId             = big.NewInt(1 << 0)
	clientFacingForcedExpiratoryVolume1SampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingForcedExpiratoryVolume1SampleFieldType           = big.NewInt(1 << 2)
	clientFacingForcedExpiratoryVolume1SampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingForcedExpiratoryVolume1SampleFieldStart          = big.NewInt(1 << 4)
	clientFacingForcedExpiratoryVolume1SampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingForcedExpiratoryVolume1SampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingForcedExpiratoryVolume1Sample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) Unit() string {
	return c.unit
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldValue)
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedExpiratoryVolume1Sample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedExpiratoryVolume1Sample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedExpiratoryVolume1Sample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "L",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingForcedVitalCapacitySampleFieldId             = big.NewInt(1 << 0)
	clientFacingForcedVitalCapacitySampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingForcedVitalCapacitySampleFieldType           = big.NewInt(1 << 2)
	clientFacingForcedVitalCapacitySampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingForcedVitalCapacitySampleFieldStart          = big.NewInt(1 << 4)
	clientFacingForcedVitalCapacitySampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingForcedVitalCapacitySampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingForcedVitalCapacitySample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingForcedVitalCapacitySample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingForcedVitalCapacitySample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingForcedVitalCapacitySample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingForcedVitalCapacitySample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingForcedVitalCapacitySample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingForcedVitalCapacitySample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingForcedVitalCapacitySample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingForcedVitalCapacitySample) Unit() string {
	return c.unit
}

func (c *ClientFacingForcedVitalCapacitySample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedVitalCapacitySample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingForcedVitalCapacitySampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingForcedVitalCapacitySampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingForcedVitalCapacitySampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingForcedVitalCapacitySampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingForcedVitalCapacitySampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingForcedVitalCapacitySampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingForcedVitalCapacitySampleFieldValue)
}

func (c *ClientFacingForcedVitalCapacitySample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedVitalCapacitySample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedVitalCapacitySample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedVitalCapacitySample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedVitalCapacitySample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "L",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingForcedVitalCapacitySample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingGlucoseTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingGlucoseTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingGlucoseTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingGlucoseTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingGlucoseTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingGlucoseTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingGlucoseTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingGlucoseTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingGlucoseTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingGlucoseTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingGlucoseTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingGlucoseTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingGlucoseTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingGlucoseTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGlucoseTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingGlucoseTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingGlucoseTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingGlucoseTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingGlucoseTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingGlucoseTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingGlucoseTimeseriesFieldValue)
}

func (c *ClientFacingGlucoseTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingGlucoseTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingGlucoseTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingGlucoseTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingGlucoseTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingHandwashingSampleFieldId             = big.NewInt(1 << 0)
	clientFacingHandwashingSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingHandwashingSampleFieldType           = big.NewInt(1 << 2)
	clientFacingHandwashingSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingHandwashingSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingHandwashingSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingHandwashingSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingHandwashingSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingHandwashingSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingHandwashingSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingHandwashingSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingHandwashingSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingHandwashingSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingHandwashingSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingHandwashingSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingHandwashingSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHandwashingSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHandwashingSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingHandwashingSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingHandwashingSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingHandwashingSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingHandwashingSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingHandwashingSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingHandwashingSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingHandwashingSampleFieldValue)
}

func (c *ClientFacingHandwashingSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHandwashingSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHandwashingSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHandwashingSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHandwashingSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingHandwashingSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingHeartRateAlertSampleFieldId             = big.NewInt(1 << 0)
	clientFacingHeartRateAlertSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingHeartRateAlertSampleFieldType           = big.NewInt(1 << 2)
	clientFacingHeartRateAlertSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingHeartRateAlertSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingHeartRateAlertSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingHeartRateAlertSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingHeartRateAlertSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of heart rate alert.  This enum is non-exhaustive.
	Type ClientFacingHeartRateAlertSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End   time.Time `json:"end" url:"end"`
	Value int       `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingHeartRateAlertSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingHeartRateAlertSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingHeartRateAlertSample) GetType() ClientFacingHeartRateAlertSampleType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingHeartRateAlertSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingHeartRateAlertSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingHeartRateAlertSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingHeartRateAlertSample) GetValue() int {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingHeartRateAlertSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHeartRateAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateAlertSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingHeartRateAlertSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingHeartRateAlertSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetType(type_ ClientFacingHeartRateAlertSampleType) {
	c.Type = type_
	c.require(clientFacingHeartRateAlertSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingHeartRateAlertSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingHeartRateAlertSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingHeartRateAlertSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetValue(value int) {
	c.Value = value
	c.require(clientFacingHeartRateAlertSampleFieldValue)
}

func (c *ClientFacingHeartRateAlertSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateAlertSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateAlertSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateAlertSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateAlertSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingHeartRateAlertSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of heart rate alert.  This enum is non-exhaustive.
type ClientFacingHeartRateAlertSampleType string

const (
	ClientFacingHeartRateAlertSampleTypeLowHeartRate    ClientFacingHeartRateAlertSampleType = "low_heart_rate"
	ClientFacingHeartRateAlertSampleTypeHighHeartRate   ClientFacingHeartRateAlertSampleType = "high_heart_rate"
	ClientFacingHeartRateAlertSampleTypeIrregularRhythm ClientFacingHeartRateAlertSampleType = "irregular_rhythm"
)

func NewClientFacingHeartRateAlertSampleTypeFromString(s string) (ClientFacingHeartRateAlertSampleType, error) {
	switch s {
	case "low_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeLowHeartRate, nil
	case "high_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeHighHeartRate, nil
	case "irregular_rhythm":
		return ClientFacingHeartRateAlertSampleTypeIrregularRhythm, nil
	}
	var t ClientFacingHeartRateAlertSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHeartRateAlertSampleType) Ptr() *ClientFacingHeartRateAlertSampleType {
	return &c
}

var (
	clientFacingHeartRateRecoveryOneMinuteSampleFieldId             = big.NewInt(1 << 0)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldType           = big.NewInt(1 << 2)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingHeartRateRecoveryOneMinuteSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldValue)
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateRecoveryOneMinuteSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateRecoveryOneMinuteSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateRecoveryOneMinuteSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingIgeTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingIgeTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingIgeTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingIgeTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingIgeTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingIgeTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingIgeTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in FSU.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingIgeTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingIgeTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingIgeTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingIgeTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingIgeTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingIgeTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingIgeTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIgeTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingIgeTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingIgeTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingIgeTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingIgeTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingIgeTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingIgeTimeseriesFieldValue)
}

func (c *ClientFacingIgeTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIgeTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIgeTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIgeTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingIgeTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingIggTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingIggTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingIggTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingIggTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingIggTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingIggTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingIggTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in FSU.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingIggTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingIggTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingIggTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingIggTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingIggTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingIggTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingIggTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIggTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingIggTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingIggTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingIggTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingIggTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingIggTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingIggTimeseriesFieldValue)
}

func (c *ClientFacingIggTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIggTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIggTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIggTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingIggTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingInhalerUsageSampleFieldId             = big.NewInt(1 << 0)
	clientFacingInhalerUsageSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingInhalerUsageSampleFieldType           = big.NewInt(1 << 2)
	clientFacingInhalerUsageSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingInhalerUsageSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingInhalerUsageSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingInhalerUsageSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingInhalerUsageSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingInhalerUsageSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingInhalerUsageSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingInhalerUsageSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingInhalerUsageSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingInhalerUsageSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingInhalerUsageSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingInhalerUsageSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingInhalerUsageSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInhalerUsageSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInhalerUsageSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingInhalerUsageSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingInhalerUsageSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingInhalerUsageSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingInhalerUsageSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingInhalerUsageSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingInhalerUsageSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingInhalerUsageSampleFieldValue)
}

func (c *ClientFacingInhalerUsageSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInhalerUsageSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInhalerUsageSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInhalerUsageSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInhalerUsageSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingInhalerUsageSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingInsulinInjectionSampleFieldId             = big.NewInt(1 << 0)
	clientFacingInsulinInjectionSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingInsulinInjectionSampleFieldType           = big.NewInt(1 << 2)
	clientFacingInsulinInjectionSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingInsulinInjectionSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingInsulinInjectionSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingInsulinInjectionSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingInsulinInjectionSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of insulin injection.  This enum is non-exhaustive.
	Type ClientFacingInsulinInjectionSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingInsulinInjectionSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingInsulinInjectionSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingInsulinInjectionSample) GetType() ClientFacingInsulinInjectionSampleType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingInsulinInjectionSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingInsulinInjectionSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingInsulinInjectionSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingInsulinInjectionSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingInsulinInjectionSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInsulinInjectionSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsulinInjectionSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingInsulinInjectionSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingInsulinInjectionSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetType(type_ ClientFacingInsulinInjectionSampleType) {
	c.Type = type_
	c.require(clientFacingInsulinInjectionSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingInsulinInjectionSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingInsulinInjectionSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingInsulinInjectionSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingInsulinInjectionSampleFieldValue)
}

func (c *ClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInsulinInjectionSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInsulinInjectionSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "unit" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "unit", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsulinInjectionSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInsulinInjectionSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "unit",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingInsulinInjectionSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of insulin injection.  This enum is non-exhaustive.
type ClientFacingInsulinInjectionSampleType string

const (
	ClientFacingInsulinInjectionSampleTypeRapidActing ClientFacingInsulinInjectionSampleType = "rapid_acting"
	ClientFacingInsulinInjectionSampleTypeLongActing  ClientFacingInsulinInjectionSampleType = "long_acting"
)

func NewClientFacingInsulinInjectionSampleTypeFromString(s string) (ClientFacingInsulinInjectionSampleType, error) {
	switch s {
	case "rapid_acting":
		return ClientFacingInsulinInjectionSampleTypeRapidActing, nil
	case "long_acting":
		return ClientFacingInsulinInjectionSampleTypeLongActing, nil
	}
	var t ClientFacingInsulinInjectionSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingInsulinInjectionSampleType) Ptr() *ClientFacingInsulinInjectionSampleType {
	return &c
}

var (
	clientFacingLeanBodyMassSampleFieldId             = big.NewInt(1 << 0)
	clientFacingLeanBodyMassSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingLeanBodyMassSampleFieldType           = big.NewInt(1 << 2)
	clientFacingLeanBodyMassSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingLeanBodyMassSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingLeanBodyMassSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingLeanBodyMassSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingLeanBodyMassSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingLeanBodyMassSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingLeanBodyMassSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingLeanBodyMassSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingLeanBodyMassSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingLeanBodyMassSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingLeanBodyMassSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingLeanBodyMassSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingLeanBodyMassSample) Unit() string {
	return c.unit
}

func (c *ClientFacingLeanBodyMassSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLeanBodyMassSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingLeanBodyMassSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingLeanBodyMassSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingLeanBodyMassSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingLeanBodyMassSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingLeanBodyMassSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingLeanBodyMassSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingLeanBodyMassSampleFieldValue)
}

func (c *ClientFacingLeanBodyMassSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingLeanBodyMassSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingLeanBodyMassSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "kg" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kg", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLeanBodyMassSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingLeanBodyMassSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "kg",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingLeanBodyMassSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingMindfulnessMinutesTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingMindfulnessMinutesTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingMindfulnessMinutesTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingMindfulnessMinutesTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingMindfulnessMinutesTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingMindfulnessMinutesTimeseriesFieldStart          = big.NewInt(1 << 5)
	clientFacingMindfulnessMinutesTimeseriesFieldEnd            = big.NewInt(1 << 6)
	clientFacingMindfulnessMinutesTimeseriesFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingMindfulnessMinutesTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in minutes.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Number of minutes spent in a mindful state.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMindfulnessMinutesTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldValue)
}

func (c *ClientFacingMindfulnessMinutesTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingMindfulnessMinutesTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingMindfulnessMinutesTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingMindfulnessMinutesTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingNoteSampleFieldId             = big.NewInt(1 << 0)
	clientFacingNoteSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingNoteSampleFieldType           = big.NewInt(1 << 2)
	clientFacingNoteSampleFieldUnit           = big.NewInt(1 << 3)
	clientFacingNoteSampleFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingNoteSampleFieldStart          = big.NewInt(1 << 5)
	clientFacingNoteSampleFieldEnd            = big.NewInt(1 << 6)
	clientFacingNoteSampleFieldValue          = big.NewInt(1 << 7)
	clientFacingNoteSampleFieldTags           = big.NewInt(1 << 8)
)

type ClientFacingNoteSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// User notes as text.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value string `json:"value" url:"value"`
	// What the note refers to.
	Tags []ClientFacingNoteSampleTagsItem `json:"tags,omitempty" url:"tags,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingNoteSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingNoteSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingNoteSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingNoteSample) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingNoteSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingNoteSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingNoteSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingNoteSample) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *ClientFacingNoteSample) GetTags() []ClientFacingNoteSampleTagsItem {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ClientFacingNoteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingNoteSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingNoteSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingNoteSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingNoteSampleFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingNoteSampleFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingNoteSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingNoteSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingNoteSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetValue(value string) {
	c.Value = value
	c.require(clientFacingNoteSampleFieldValue)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetTags(tags []ClientFacingNoteSampleTagsItem) {
	c.Tags = tags
	c.require(clientFacingNoteSampleFieldTags)
}

func (c *ClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingNoteSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingNoteSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingNoteSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingNoteSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingNoteSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSampleTagsItem string

const (
	ClientFacingNoteSampleTagsItemFood             ClientFacingNoteSampleTagsItem = "food"
	ClientFacingNoteSampleTagsItemExercise         ClientFacingNoteSampleTagsItem = "exercise"
	ClientFacingNoteSampleTagsItemInsulinInjection ClientFacingNoteSampleTagsItem = "insulin_injection"
	ClientFacingNoteSampleTagsItemUnspecified      ClientFacingNoteSampleTagsItem = "unspecified"
)

func NewClientFacingNoteSampleTagsItemFromString(s string) (ClientFacingNoteSampleTagsItem, error) {
	switch s {
	case "food":
		return ClientFacingNoteSampleTagsItemFood, nil
	case "exercise":
		return ClientFacingNoteSampleTagsItemExercise, nil
	case "insulin_injection":
		return ClientFacingNoteSampleTagsItemInsulinInjection, nil
	case "unspecified":
		return ClientFacingNoteSampleTagsItemUnspecified, nil
	}
	var t ClientFacingNoteSampleTagsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingNoteSampleTagsItem) Ptr() *ClientFacingNoteSampleTagsItem {
	return &c
}

var (
	clientFacingPeakExpiratoryFlowRateSampleFieldId             = big.NewInt(1 << 0)
	clientFacingPeakExpiratoryFlowRateSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingPeakExpiratoryFlowRateSampleFieldType           = big.NewInt(1 << 2)
	clientFacingPeakExpiratoryFlowRateSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingPeakExpiratoryFlowRateSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingPeakExpiratoryFlowRateSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingPeakExpiratoryFlowRateSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingPeakExpiratoryFlowRateSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) Unit() string {
	return c.unit
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldValue)
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingPeakExpiratoryFlowRateSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingPeakExpiratoryFlowRateSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L/min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L/min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingPeakExpiratoryFlowRateSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "L/min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSampleGroupingKeys = []interface{}

var (
	clientFacingSleepApneaAlertSampleFieldId             = big.NewInt(1 << 0)
	clientFacingSleepApneaAlertSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingSleepApneaAlertSampleFieldType           = big.NewInt(1 << 2)
	clientFacingSleepApneaAlertSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingSleepApneaAlertSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingSleepApneaAlertSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingSleepApneaAlertSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingSleepApneaAlertSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingSleepApneaAlertSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingSleepApneaAlertSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingSleepApneaAlertSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingSleepApneaAlertSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingSleepApneaAlertSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingSleepApneaAlertSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingSleepApneaAlertSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingSleepApneaAlertSample) Unit() string {
	return c.unit
}

func (c *ClientFacingSleepApneaAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepApneaAlertSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingSleepApneaAlertSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingSleepApneaAlertSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingSleepApneaAlertSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingSleepApneaAlertSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingSleepApneaAlertSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingSleepApneaAlertSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingSleepApneaAlertSampleFieldValue)
}

func (c *ClientFacingSleepApneaAlertSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepApneaAlertSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepApneaAlertSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepApneaAlertSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepApneaAlertSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingSleepApneaAlertSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingSleepBreathingDisturbanceSampleFieldId             = big.NewInt(1 << 0)
	clientFacingSleepBreathingDisturbanceSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingSleepBreathingDisturbanceSampleFieldType           = big.NewInt(1 << 2)
	clientFacingSleepBreathingDisturbanceSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingSleepBreathingDisturbanceSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingSleepBreathingDisturbanceSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingSleepBreathingDisturbanceSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingSleepBreathingDisturbanceSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of sleep breathing disturbance.  This enum is non-exhaustive.
	Type *ClientFacingSleepBreathingDisturbanceSampleType `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetType() *ClientFacingSleepBreathingDisturbanceSampleType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingSleepBreathingDisturbanceSample) Unit() string {
	return c.unit
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepBreathingDisturbanceSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetType(type_ *ClientFacingSleepBreathingDisturbanceSampleType) {
	c.Type = type_
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldValue)
}

func (c *ClientFacingSleepBreathingDisturbanceSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepBreathingDisturbanceSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepBreathingDisturbanceSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepBreathingDisturbanceSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepBreathingDisturbanceSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingSleepBreathingDisturbanceSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepBreathingDisturbanceSampleType string

const (
	ClientFacingSleepBreathingDisturbanceSampleTypeElevated    ClientFacingSleepBreathingDisturbanceSampleType = "elevated"
	ClientFacingSleepBreathingDisturbanceSampleTypeNotElevated ClientFacingSleepBreathingDisturbanceSampleType = "not_elevated"
)

func NewClientFacingSleepBreathingDisturbanceSampleTypeFromString(s string) (ClientFacingSleepBreathingDisturbanceSampleType, error) {
	switch s {
	case "elevated":
		return ClientFacingSleepBreathingDisturbanceSampleTypeElevated, nil
	case "not_elevated":
		return ClientFacingSleepBreathingDisturbanceSampleTypeNotElevated, nil
	}
	var t ClientFacingSleepBreathingDisturbanceSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepBreathingDisturbanceSampleType) Ptr() *ClientFacingSleepBreathingDisturbanceSampleType {
	return &c
}

var (
	clientFacingStandDurationSampleFieldId             = big.NewInt(1 << 0)
	clientFacingStandDurationSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStandDurationSampleFieldType           = big.NewInt(1 << 2)
	clientFacingStandDurationSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingStandDurationSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingStandDurationSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingStandDurationSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingStandDurationSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStandDurationSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStandDurationSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStandDurationSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingStandDurationSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStandDurationSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingStandDurationSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingStandDurationSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStandDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingStandDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandDurationSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStandDurationSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStandDurationSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingStandDurationSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStandDurationSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingStandDurationSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingStandDurationSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStandDurationSampleFieldValue)
}

func (c *ClientFacingStandDurationSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandDurationSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandDurationSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandDurationSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStandDurationSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingStandHourSampleFieldId             = big.NewInt(1 << 0)
	clientFacingStandHourSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStandHourSampleFieldType           = big.NewInt(1 << 2)
	clientFacingStandHourSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingStandHourSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingStandHourSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingStandHourSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingStandHourSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of stand hour.  This enum is non-exhaustive.
	Type ClientFacingStandHourSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStandHourSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStandHourSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStandHourSample) GetType() ClientFacingStandHourSampleType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingStandHourSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStandHourSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingStandHourSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingStandHourSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStandHourSample) Unit() string {
	return c.unit
}

func (c *ClientFacingStandHourSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandHourSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStandHourSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStandHourSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetType(type_ ClientFacingStandHourSampleType) {
	c.Type = type_
	c.require(clientFacingStandHourSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStandHourSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingStandHourSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingStandHourSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStandHourSampleFieldValue)
}

func (c *ClientFacingStandHourSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandHourSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandHourSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandHourSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandHourSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStandHourSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of stand hour.  This enum is non-exhaustive.
type ClientFacingStandHourSampleType string

const (
	ClientFacingStandHourSampleTypeStood ClientFacingStandHourSampleType = "stood"
	ClientFacingStandHourSampleTypeIdle  ClientFacingStandHourSampleType = "idle"
)

func NewClientFacingStandHourSampleTypeFromString(s string) (ClientFacingStandHourSampleType, error) {
	switch s {
	case "stood":
		return ClientFacingStandHourSampleTypeStood, nil
	case "idle":
		return ClientFacingStandHourSampleTypeIdle, nil
	}
	var t ClientFacingStandHourSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingStandHourSampleType) Ptr() *ClientFacingStandHourSampleType {
	return &c
}

var (
	clientFacingStepsTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingStepsTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStepsTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingStepsTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingStepsTimeseriesFieldStart          = big.NewInt(1 << 4)
	clientFacingStepsTimeseriesFieldEnd            = big.NewInt(1 << 5)
	clientFacingStepsTimeseriesFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingStepsTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The number of steps sampled at the time or interval::count
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStepsTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStepsTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStepsTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingStepsTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStepsTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingStepsTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingStepsTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStepsTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingStepsTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStepsTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStepsTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStepsTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingStepsTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStepsTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingStepsTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingStepsTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStepsTimeseriesFieldValue)
}

func (c *ClientFacingStepsTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStepsTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStepsTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStepsTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStepsTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingStressLevelTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingStressLevelTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStressLevelTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingStressLevelTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingStressLevelTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingStressLevelTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingStressLevelTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	Value     float64   `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStressLevelTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStressLevelTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStressLevelTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingStressLevelTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingStressLevelTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStressLevelTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStressLevelTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStressLevelTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStressLevelTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStressLevelTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingStressLevelTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingStressLevelTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStressLevelTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStressLevelTimeseriesFieldValue)
}

func (c *ClientFacingStressLevelTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStressLevelTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStressLevelTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStressLevelTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStressLevelTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStressLevelTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingUvExposureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingUvExposureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingUvExposureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingUvExposureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingUvExposureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingUvExposureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingUvExposureSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingUvExposureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingUvExposureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingUvExposureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingUvExposureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingUvExposureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingUvExposureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingUvExposureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingUvExposureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingUvExposureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingUvExposureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUvExposureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingUvExposureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingUvExposureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingUvExposureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingUvExposureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingUvExposureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingUvExposureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingUvExposureSampleFieldValue)
}

func (c *ClientFacingUvExposureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingUvExposureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingUvExposureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "index" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "index", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUvExposureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingUvExposureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "index",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingUvExposureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingVo2MaxTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingVo2MaxTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingVo2MaxTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingVo2MaxTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingVo2MaxTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingVo2MaxTimeseriesFieldStart          = big.NewInt(1 << 5)
	clientFacingVo2MaxTimeseriesFieldEnd            = big.NewInt(1 << 6)
	clientFacingVo2MaxTimeseriesFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingVo2MaxTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mL/kg/min.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingVo2MaxTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingVo2MaxTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingVo2MaxTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingVo2MaxTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingVo2MaxTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingVo2MaxTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingVo2MaxTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingVo2MaxTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingVo2MaxTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingVo2MaxTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingVo2MaxTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingVo2MaxTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingVo2MaxTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingVo2MaxTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingVo2MaxTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingVo2MaxTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingVo2MaxTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingVo2MaxTimeseriesFieldValue)
}

func (c *ClientFacingVo2MaxTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingVo2MaxTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingVo2MaxTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingVo2MaxTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingVo2MaxTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingVo2MaxTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWaistCircumferenceSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWaistCircumferenceSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWaistCircumferenceSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWaistCircumferenceSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWaistCircumferenceSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWaistCircumferenceSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWaistCircumferenceSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWaistCircumferenceSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWaistCircumferenceSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWaistCircumferenceSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWaistCircumferenceSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWaistCircumferenceSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWaistCircumferenceSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWaistCircumferenceSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWaistCircumferenceSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWaistCircumferenceSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWaistCircumferenceSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaistCircumferenceSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWaistCircumferenceSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWaistCircumferenceSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWaistCircumferenceSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWaistCircumferenceSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWaistCircumferenceSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWaistCircumferenceSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWaistCircumferenceSampleFieldValue)
}

func (c *ClientFacingWaistCircumferenceSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWaistCircumferenceSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWaistCircumferenceSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "cm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cm", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaistCircumferenceSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWaistCircumferenceSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "cm",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWaistCircumferenceSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWaterTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingWaterTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWaterTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingWaterTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingWaterTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingWaterTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingWaterTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in milliters.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Quantity of water drank during the time period.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWaterTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWaterTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWaterTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWaterTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingWaterTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWaterTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWaterTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaterTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWaterTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWaterTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWaterTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingWaterTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWaterTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWaterTimeseriesFieldValue)
}

func (c *ClientFacingWaterTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWaterTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWaterTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWaterTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWaterTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWheelchairPushSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWheelchairPushSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWheelchairPushSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWheelchairPushSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWheelchairPushSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWheelchairPushSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWheelchairPushSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWheelchairPushSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWheelchairPushSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWheelchairPushSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWheelchairPushSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWheelchairPushSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWheelchairPushSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWheelchairPushSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWheelchairPushSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWheelchairPushSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWheelchairPushSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWheelchairPushSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWheelchairPushSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWheelchairPushSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWheelchairPushSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWheelchairPushSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWheelchairPushSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWheelchairPushSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWheelchairPushSampleFieldValue)
}

func (c *ClientFacingWheelchairPushSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWheelchairPushSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWheelchairPushSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWheelchairPushSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWheelchairPushSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWheelchairPushSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWorkoutDistanceSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWorkoutDistanceSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWorkoutDistanceSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWorkoutDistanceSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWorkoutDistanceSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWorkoutDistanceSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWorkoutDistanceSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWorkoutDistanceSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWorkoutDistanceSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWorkoutDistanceSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWorkoutDistanceSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWorkoutDistanceSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWorkoutDistanceSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWorkoutDistanceSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWorkoutDistanceSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWorkoutDistanceSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutDistanceSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDistanceSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWorkoutDistanceSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWorkoutDistanceSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWorkoutDistanceSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWorkoutDistanceSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWorkoutDistanceSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWorkoutDistanceSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWorkoutDistanceSampleFieldValue)
}

func (c *ClientFacingWorkoutDistanceSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutDistanceSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDistanceSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "m" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "m", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDistanceSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDistanceSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "m",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWorkoutDistanceSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWorkoutDurationSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWorkoutDurationSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWorkoutDurationSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWorkoutDurationSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWorkoutDurationSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWorkoutDurationSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWorkoutDurationSampleFieldValue          = big.NewInt(1 << 6)
	clientFacingWorkoutDurationSampleFieldIntensity      = big.NewInt(1 << 7)
)

type ClientFacingWorkoutDurationSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Workout intensity.  This enum is non-exhaustive.
	Intensity *ClientFacingWorkoutDurationSampleIntensity `json:"intensity,omitempty" url:"intensity,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWorkoutDurationSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWorkoutDurationSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWorkoutDurationSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWorkoutDurationSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWorkoutDurationSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWorkoutDurationSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWorkoutDurationSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWorkoutDurationSample) GetIntensity() *ClientFacingWorkoutDurationSampleIntensity {
	if c == nil {
		return nil
	}
	return c.Intensity
}

func (c *ClientFacingWorkoutDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDurationSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWorkoutDurationSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWorkoutDurationSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWorkoutDurationSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWorkoutDurationSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWorkoutDurationSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWorkoutDurationSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWorkoutDurationSampleFieldValue)
}

// SetIntensity sets the Intensity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetIntensity(intensity *ClientFacingWorkoutDurationSampleIntensity) {
	c.Intensity = intensity
	c.require(clientFacingWorkoutDurationSampleFieldIntensity)
}

func (c *ClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutDurationSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDurationSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDurationSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWorkoutDurationSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSampleIntensity string

const (
	ClientFacingWorkoutDurationSampleIntensityLow    ClientFacingWorkoutDurationSampleIntensity = "low"
	ClientFacingWorkoutDurationSampleIntensityMedium ClientFacingWorkoutDurationSampleIntensity = "medium"
	ClientFacingWorkoutDurationSampleIntensityHigh   ClientFacingWorkoutDurationSampleIntensity = "high"
)

func NewClientFacingWorkoutDurationSampleIntensityFromString(s string) (ClientFacingWorkoutDurationSampleIntensity, error) {
	switch s {
	case "low":
		return ClientFacingWorkoutDurationSampleIntensityLow, nil
	case "medium":
		return ClientFacingWorkoutDurationSampleIntensityMedium, nil
	case "high":
		return ClientFacingWorkoutDurationSampleIntensityHigh, nil
	}
	var t ClientFacingWorkoutDurationSampleIntensity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutDurationSampleIntensity) Ptr() *ClientFacingWorkoutDurationSampleIntensity {
	return &c
}

var (
	clientFacingWorkoutSwimmingStrokeSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWorkoutSwimmingStrokeSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWorkoutSwimmingStrokeSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWorkoutSwimmingStrokeSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWorkoutSwimmingStrokeSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWorkoutSwimmingStrokeSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWorkoutSwimmingStrokeSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWorkoutSwimmingStrokeSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldValue)
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutSwimmingStrokeSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutSwimmingStrokeSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutSwimmingStrokeSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	groupedAFibBurdenFieldSource = big.NewInt(1 << 0)
	groupedAFibBurdenFieldData   = big.NewInt(1 << 1)
)

type GroupedAFibBurden struct {
	Source *ClientFacingSource             `json:"source" url:"source"`
	Data   []*ClientFacingAFibBurdenSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedAFibBurden) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedAFibBurden) GetData() []*ClientFacingAFibBurdenSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedAFibBurden) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAFibBurden) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurden) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedAFibBurdenFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurden) SetData(data []*ClientFacingAFibBurdenSample) {
	g.Data = data
	g.require(groupedAFibBurdenFieldData)
}

func (g *GroupedAFibBurden) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAFibBurden
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAFibBurden(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAFibBurden) MarshalJSON() ([]byte, error) {
	type embed GroupedAFibBurden
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedAFibBurden) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedAFibBurdenResponseFieldGroups     = big.NewInt(1 << 0)
	groupedAFibBurdenResponseFieldNext       = big.NewInt(1 << 1)
	groupedAFibBurdenResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedAFibBurdenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedAFibBurden `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedAFibBurdenResponse) GetGroups() map[string][]*GroupedAFibBurden {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedAFibBurdenResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedAFibBurdenResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedAFibBurdenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAFibBurdenResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurdenResponse) SetGroups(groups map[string][]*GroupedAFibBurden) {
	g.Groups = groups
	g.require(groupedAFibBurdenResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurdenResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedAFibBurdenResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurdenResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedAFibBurdenResponseFieldNextCursor)
}

func (g *GroupedAFibBurdenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAFibBurdenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAFibBurdenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAFibBurdenResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedAFibBurdenResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedAFibBurdenResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBasalBodyTemperatureFieldSource = big.NewInt(1 << 0)
	groupedBasalBodyTemperatureFieldData   = big.NewInt(1 << 1)
)

type GroupedBasalBodyTemperature struct {
	Source *ClientFacingSource                       `json:"source" url:"source"`
	Data   []*ClientFacingBasalBodyTemperatureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBasalBodyTemperature) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBasalBodyTemperature) GetData() []*ClientFacingBasalBodyTemperatureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBasalBodyTemperature) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBasalBodyTemperature) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperature) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBasalBodyTemperatureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperature) SetData(data []*ClientFacingBasalBodyTemperatureSample) {
	g.Data = data
	g.require(groupedBasalBodyTemperatureFieldData)
}

func (g *GroupedBasalBodyTemperature) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBasalBodyTemperature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBasalBodyTemperature(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBasalBodyTemperature) MarshalJSON() ([]byte, error) {
	type embed GroupedBasalBodyTemperature
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBasalBodyTemperature) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBasalBodyTemperatureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBasalBodyTemperatureResponseFieldNext       = big.NewInt(1 << 1)
	groupedBasalBodyTemperatureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBasalBodyTemperatureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBasalBodyTemperature `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBasalBodyTemperatureResponse) GetGroups() map[string][]*GroupedBasalBodyTemperature {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBasalBodyTemperatureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBasalBodyTemperatureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBasalBodyTemperatureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBasalBodyTemperatureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperatureResponse) SetGroups(groups map[string][]*GroupedBasalBodyTemperature) {
	g.Groups = groups
	g.require(groupedBasalBodyTemperatureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperatureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBasalBodyTemperatureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperatureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBasalBodyTemperatureResponseFieldNextCursor)
}

func (g *GroupedBasalBodyTemperatureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBasalBodyTemperatureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBasalBodyTemperatureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBasalBodyTemperatureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBasalBodyTemperatureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBasalBodyTemperatureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodOxygenFieldSource = big.NewInt(1 << 0)
	groupedBloodOxygenFieldData   = big.NewInt(1 << 1)
)

type GroupedBloodOxygen struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingBloodOxygenTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodOxygen) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBloodOxygen) GetData() []*ClientFacingBloodOxygenTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBloodOxygen) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygen) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygen) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBloodOxygenFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygen) SetData(data []*ClientFacingBloodOxygenTimeseries) {
	g.Data = data
	g.require(groupedBloodOxygenFieldData)
}

func (g *GroupedBloodOxygen) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygen(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygen) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodOxygen
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodOxygen) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodOxygenResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBloodOxygenResponseFieldNext       = big.NewInt(1 << 1)
	groupedBloodOxygenResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBloodOxygenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodOxygen `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodOxygenResponse) GetGroups() map[string][]*GroupedBloodOxygen {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBloodOxygenResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBloodOxygenResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBloodOxygenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygenResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygenResponse) SetGroups(groups map[string][]*GroupedBloodOxygen) {
	g.Groups = groups
	g.require(groupedBloodOxygenResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygenResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBloodOxygenResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygenResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBloodOxygenResponseFieldNextCursor)
}

func (g *GroupedBloodOxygenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygenResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodOxygenResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodOxygenResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodPressureFieldSource = big.NewInt(1 << 0)
	groupedBloodPressureFieldData   = big.NewInt(1 << 1)
)

type GroupedBloodPressure struct {
	Source *ClientFacingSource                    `json:"source" url:"source"`
	Data   []*ClientFacingBloodPressureTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodPressure) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBloodPressure) GetData() []*ClientFacingBloodPressureTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBloodPressure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressure) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressure) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBloodPressureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressure) SetData(data []*ClientFacingBloodPressureTimeseries) {
	g.Data = data
	g.require(groupedBloodPressureFieldData)
}

func (g *GroupedBloodPressure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressure) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodPressure
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodPressure) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodPressureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBloodPressureResponseFieldNext       = big.NewInt(1 << 1)
	groupedBloodPressureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBloodPressureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodPressure `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodPressureResponse) GetGroups() map[string][]*GroupedBloodPressure {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBloodPressureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBloodPressureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBloodPressureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressureResponse) SetGroups(groups map[string][]*GroupedBloodPressure) {
	g.Groups = groups
	g.require(groupedBloodPressureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBloodPressureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBloodPressureResponseFieldNextCursor)
}

func (g *GroupedBloodPressureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodPressureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodPressureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyFatFieldSource = big.NewInt(1 << 0)
	groupedBodyFatFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyFat struct {
	Source *ClientFacingSource              `json:"source" url:"source"`
	Data   []*ClientFacingBodyFatTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyFat) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyFat) GetData() []*ClientFacingBodyFatTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyFat) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFat) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFat) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyFatFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFat) SetData(data []*ClientFacingBodyFatTimeseries) {
	g.Data = data
	g.require(groupedBodyFatFieldData)
}

func (g *GroupedBodyFat) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFat) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyFat
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyFat) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyFatResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyFatResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyFatResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyFatResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyFat `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyFatResponse) GetGroups() map[string][]*GroupedBodyFat {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyFatResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyFatResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyFatResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFatResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFatResponse) SetGroups(groups map[string][]*GroupedBodyFat) {
	g.Groups = groups
	g.require(groupedBodyFatResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFatResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyFatResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFatResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyFatResponseFieldNextCursor)
}

func (g *GroupedBodyFatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFatResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFatResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyFatResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyFatResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyMassIndexFieldSource = big.NewInt(1 << 0)
	groupedBodyMassIndexFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyMassIndex struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingBodyMassIndexSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyMassIndex) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyMassIndex) GetData() []*ClientFacingBodyMassIndexSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyMassIndex) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyMassIndex) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndex) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyMassIndexFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndex) SetData(data []*ClientFacingBodyMassIndexSample) {
	g.Data = data
	g.require(groupedBodyMassIndexFieldData)
}

func (g *GroupedBodyMassIndex) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyMassIndex
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyMassIndex(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyMassIndex) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyMassIndex
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyMassIndex) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyMassIndexResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyMassIndexResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyMassIndexResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyMassIndexResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyMassIndex `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyMassIndexResponse) GetGroups() map[string][]*GroupedBodyMassIndex {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyMassIndexResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyMassIndexResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyMassIndexResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyMassIndexResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndexResponse) SetGroups(groups map[string][]*GroupedBodyMassIndex) {
	g.Groups = groups
	g.require(groupedBodyMassIndexResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndexResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyMassIndexResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndexResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyMassIndexResponseFieldNextCursor)
}

func (g *GroupedBodyMassIndexResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyMassIndexResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyMassIndexResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyMassIndexResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyMassIndexResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyMassIndexResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureFieldSource = big.NewInt(1 << 0)
	groupedBodyTemperatureFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyTemperature struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingBodyTemperatureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperature) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyTemperature) GetData() []*ClientFacingBodyTemperatureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyTemperature) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperature) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperature) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyTemperatureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperature) SetData(data []*ClientFacingBodyTemperatureSample) {
	g.Data = data
	g.require(groupedBodyTemperatureFieldData)
}

func (g *GroupedBodyTemperature) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperature(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperature) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperature
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperature) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureDeltaFieldSource = big.NewInt(1 << 0)
	groupedBodyTemperatureDeltaFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyTemperatureDelta struct {
	Source *ClientFacingSource                       `json:"source" url:"source"`
	Data   []*ClientFacingBodyTemperatureDeltaSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperatureDelta) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyTemperatureDelta) GetData() []*ClientFacingBodyTemperatureDeltaSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyTemperatureDelta) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureDelta) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDelta) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyTemperatureDeltaFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDelta) SetData(data []*ClientFacingBodyTemperatureDeltaSample) {
	g.Data = data
	g.require(groupedBodyTemperatureDeltaFieldData)
}

func (g *GroupedBodyTemperatureDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureDelta) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperatureDelta
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperatureDelta) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureDeltaResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyTemperatureDeltaResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyTemperatureDeltaResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyTemperatureDeltaResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyTemperatureDelta `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperatureDeltaResponse) GetGroups() map[string][]*GroupedBodyTemperatureDelta {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyTemperatureDeltaResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyTemperatureDeltaResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyTemperatureDeltaResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureDeltaResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDeltaResponse) SetGroups(groups map[string][]*GroupedBodyTemperatureDelta) {
	g.Groups = groups
	g.require(groupedBodyTemperatureDeltaResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDeltaResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyTemperatureDeltaResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDeltaResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyTemperatureDeltaResponseFieldNextCursor)
}

func (g *GroupedBodyTemperatureDeltaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureDeltaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureDeltaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureDeltaResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperatureDeltaResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperatureDeltaResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyTemperatureResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyTemperatureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyTemperatureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyTemperature `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperatureResponse) GetGroups() map[string][]*GroupedBodyTemperature {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyTemperatureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyTemperatureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyTemperatureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureResponse) SetGroups(groups map[string][]*GroupedBodyTemperature) {
	g.Groups = groups
	g.require(groupedBodyTemperatureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyTemperatureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyTemperatureResponseFieldNextCursor)
}

func (g *GroupedBodyTemperatureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperatureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperatureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyWeightFieldSource = big.NewInt(1 << 0)
	groupedBodyWeightFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyWeight struct {
	Source *ClientFacingSource                 `json:"source" url:"source"`
	Data   []*ClientFacingBodyWeightTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyWeight) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyWeight) GetData() []*ClientFacingBodyWeightTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyWeight) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeight) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeight) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyWeightFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeight) SetData(data []*ClientFacingBodyWeightTimeseries) {
	g.Data = data
	g.require(groupedBodyWeightFieldData)
}

func (g *GroupedBodyWeight) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeight
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeight(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeight) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyWeight
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyWeight) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyWeightResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyWeightResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyWeightResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyWeightResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyWeight `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyWeightResponse) GetGroups() map[string][]*GroupedBodyWeight {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyWeightResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyWeightResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyWeightResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeightResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeightResponse) SetGroups(groups map[string][]*GroupedBodyWeight) {
	g.Groups = groups
	g.require(groupedBodyWeightResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeightResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyWeightResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeightResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyWeightResponseFieldNextCursor)
}

func (g *GroupedBodyWeightResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeightResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeightResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeightResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyWeightResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyWeightResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaffeineFieldSource = big.NewInt(1 << 0)
	groupedCaffeineFieldData   = big.NewInt(1 << 1)
)

type GroupedCaffeine struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingCaffeineTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaffeine) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCaffeine) GetData() []*ClientFacingCaffeineTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCaffeine) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeine) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeine) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCaffeineFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeine) SetData(data []*ClientFacingCaffeineTimeseries) {
	g.Data = data
	g.require(groupedCaffeineFieldData)
}

func (g *GroupedCaffeine) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeine(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeine) MarshalJSON() ([]byte, error) {
	type embed GroupedCaffeine
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaffeine) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaffeineResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCaffeineResponseFieldNext       = big.NewInt(1 << 1)
	groupedCaffeineResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCaffeineResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaffeine `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaffeineResponse) GetGroups() map[string][]*GroupedCaffeine {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCaffeineResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCaffeineResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCaffeineResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeineResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeineResponse) SetGroups(groups map[string][]*GroupedCaffeine) {
	g.Groups = groups
	g.require(groupedCaffeineResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeineResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCaffeineResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeineResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCaffeineResponseFieldNextCursor)
}

func (g *GroupedCaffeineResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeineResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeineResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeineResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCaffeineResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaffeineResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesActiveFieldSource = big.NewInt(1 << 0)
	groupedCaloriesActiveFieldData   = big.NewInt(1 << 1)
)

type GroupedCaloriesActive struct {
	Source *ClientFacingSource                     `json:"source" url:"source"`
	Data   []*ClientFacingCaloriesActiveTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesActive) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCaloriesActive) GetData() []*ClientFacingCaloriesActiveTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCaloriesActive) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActive) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActive) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCaloriesActiveFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActive) SetData(data []*ClientFacingCaloriesActiveTimeseries) {
	g.Data = data
	g.require(groupedCaloriesActiveFieldData)
}

func (g *GroupedCaloriesActive) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActive(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActive) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesActive
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesActive) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesActiveResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCaloriesActiveResponseFieldNext       = big.NewInt(1 << 1)
	groupedCaloriesActiveResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCaloriesActiveResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesActive `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesActiveResponse) GetGroups() map[string][]*GroupedCaloriesActive {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCaloriesActiveResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCaloriesActiveResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCaloriesActiveResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActiveResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActiveResponse) SetGroups(groups map[string][]*GroupedCaloriesActive) {
	g.Groups = groups
	g.require(groupedCaloriesActiveResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActiveResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCaloriesActiveResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActiveResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCaloriesActiveResponseFieldNextCursor)
}

func (g *GroupedCaloriesActiveResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActiveResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActiveResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActiveResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesActiveResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesActiveResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesBasalFieldSource = big.NewInt(1 << 0)
	groupedCaloriesBasalFieldData   = big.NewInt(1 << 1)
)

type GroupedCaloriesBasal struct {
	Source *ClientFacingSource                    `json:"source" url:"source"`
	Data   []*ClientFacingCaloriesBasalTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesBasal) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCaloriesBasal) GetData() []*ClientFacingCaloriesBasalTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCaloriesBasal) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasal) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasal) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCaloriesBasalFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasal) SetData(data []*ClientFacingCaloriesBasalTimeseries) {
	g.Data = data
	g.require(groupedCaloriesBasalFieldData)
}

func (g *GroupedCaloriesBasal) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasal) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesBasal
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesBasal) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesBasalResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCaloriesBasalResponseFieldNext       = big.NewInt(1 << 1)
	groupedCaloriesBasalResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCaloriesBasalResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesBasal `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesBasalResponse) GetGroups() map[string][]*GroupedCaloriesBasal {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCaloriesBasalResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCaloriesBasalResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCaloriesBasalResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasalResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasalResponse) SetGroups(groups map[string][]*GroupedCaloriesBasal) {
	g.Groups = groups
	g.require(groupedCaloriesBasalResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasalResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCaloriesBasalResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasalResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCaloriesBasalResponseFieldNextCursor)
}

func (g *GroupedCaloriesBasalResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasalResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasalResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasalResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesBasalResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesBasalResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCarbohydratesFieldSource = big.NewInt(1 << 0)
	groupedCarbohydratesFieldData   = big.NewInt(1 << 1)
)

type GroupedCarbohydrates struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingCarbohydratesSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCarbohydrates) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCarbohydrates) GetData() []*ClientFacingCarbohydratesSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCarbohydrates) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCarbohydrates) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydrates) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCarbohydratesFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydrates) SetData(data []*ClientFacingCarbohydratesSample) {
	g.Data = data
	g.require(groupedCarbohydratesFieldData)
}

func (g *GroupedCarbohydrates) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCarbohydrates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCarbohydrates(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCarbohydrates) MarshalJSON() ([]byte, error) {
	type embed GroupedCarbohydrates
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCarbohydrates) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCarbohydratesResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCarbohydratesResponseFieldNext       = big.NewInt(1 << 1)
	groupedCarbohydratesResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCarbohydratesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCarbohydrates `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCarbohydratesResponse) GetGroups() map[string][]*GroupedCarbohydrates {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCarbohydratesResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCarbohydratesResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCarbohydratesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCarbohydratesResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydratesResponse) SetGroups(groups map[string][]*GroupedCarbohydrates) {
	g.Groups = groups
	g.require(groupedCarbohydratesResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydratesResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCarbohydratesResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydratesResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCarbohydratesResponseFieldNextCursor)
}

func (g *GroupedCarbohydratesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCarbohydratesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCarbohydratesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCarbohydratesResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCarbohydratesResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCarbohydratesResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCholesterolFieldSource = big.NewInt(1 << 0)
	groupedCholesterolFieldData   = big.NewInt(1 << 1)
)

type GroupedCholesterol struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingCholesterolTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCholesterol) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCholesterol) GetData() []*ClientFacingCholesterolTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCholesterol) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterol) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterol) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCholesterolFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterol) SetData(data []*ClientFacingCholesterolTimeseries) {
	g.Data = data
	g.require(groupedCholesterolFieldData)
}

func (g *GroupedCholesterol) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterol
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterol(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterol) MarshalJSON() ([]byte, error) {
	type embed GroupedCholesterol
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCholesterol) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCholesterolResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCholesterolResponseFieldNext       = big.NewInt(1 << 1)
	groupedCholesterolResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCholesterolResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCholesterol `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCholesterolResponse) GetGroups() map[string][]*GroupedCholesterol {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCholesterolResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCholesterolResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCholesterolResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterolResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterolResponse) SetGroups(groups map[string][]*GroupedCholesterol) {
	g.Groups = groups
	g.require(groupedCholesterolResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterolResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCholesterolResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterolResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCholesterolResponseFieldNextCursor)
}

func (g *GroupedCholesterolResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterolResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterolResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterolResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCholesterolResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCholesterolResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDaylightExposureFieldSource = big.NewInt(1 << 0)
	groupedDaylightExposureFieldData   = big.NewInt(1 << 1)
)

type GroupedDaylightExposure struct {
	Source *ClientFacingSource                   `json:"source" url:"source"`
	Data   []*ClientFacingDaylightExposureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDaylightExposure) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedDaylightExposure) GetData() []*ClientFacingDaylightExposureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedDaylightExposure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDaylightExposure) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposure) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedDaylightExposureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposure) SetData(data []*ClientFacingDaylightExposureSample) {
	g.Data = data
	g.require(groupedDaylightExposureFieldData)
}

func (g *GroupedDaylightExposure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDaylightExposure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDaylightExposure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDaylightExposure) MarshalJSON() ([]byte, error) {
	type embed GroupedDaylightExposure
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDaylightExposure) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDaylightExposureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedDaylightExposureResponseFieldNext       = big.NewInt(1 << 1)
	groupedDaylightExposureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedDaylightExposureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedDaylightExposure `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDaylightExposureResponse) GetGroups() map[string][]*GroupedDaylightExposure {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedDaylightExposureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedDaylightExposureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedDaylightExposureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDaylightExposureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposureResponse) SetGroups(groups map[string][]*GroupedDaylightExposure) {
	g.Groups = groups
	g.require(groupedDaylightExposureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedDaylightExposureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedDaylightExposureResponseFieldNextCursor)
}

func (g *GroupedDaylightExposureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDaylightExposureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDaylightExposureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDaylightExposureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedDaylightExposureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDaylightExposureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDistanceFieldSource = big.NewInt(1 << 0)
	groupedDistanceFieldData   = big.NewInt(1 << 1)
)

type GroupedDistance struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingDistanceTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDistance) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedDistance) GetData() []*ClientFacingDistanceTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedDistance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistance) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistance) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedDistanceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistance) SetData(data []*ClientFacingDistanceTimeseries) {
	g.Data = data
	g.require(groupedDistanceFieldData)
}

func (g *GroupedDistance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistance) MarshalJSON() ([]byte, error) {
	type embed GroupedDistance
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDistance) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDistanceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedDistanceResponseFieldNext       = big.NewInt(1 << 1)
	groupedDistanceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedDistanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedDistance `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDistanceResponse) GetGroups() map[string][]*GroupedDistance {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedDistanceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedDistanceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedDistanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistanceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistanceResponse) SetGroups(groups map[string][]*GroupedDistance) {
	g.Groups = groups
	g.require(groupedDistanceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistanceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedDistanceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistanceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedDistanceResponseFieldNextCursor)
}

func (g *GroupedDistanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistanceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedDistanceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDistanceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedElectrocardiogramVoltageFieldSource = big.NewInt(1 << 0)
	groupedElectrocardiogramVoltageFieldData   = big.NewInt(1 << 1)
)

type GroupedElectrocardiogramVoltage struct {
	Source *ClientFacingSource                               `json:"source" url:"source"`
	Data   []*ClientFacingElectrocardiogramVoltageTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedElectrocardiogramVoltage) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedElectrocardiogramVoltage) GetData() []*ClientFacingElectrocardiogramVoltageTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedElectrocardiogramVoltage) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltage) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltage) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedElectrocardiogramVoltageFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltage) SetData(data []*ClientFacingElectrocardiogramVoltageTimeseries) {
	g.Data = data
	g.require(groupedElectrocardiogramVoltageFieldData)
}

func (g *GroupedElectrocardiogramVoltage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltage) MarshalJSON() ([]byte, error) {
	type embed GroupedElectrocardiogramVoltage
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedElectrocardiogramVoltage) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedElectrocardiogramVoltageResponseFieldGroups     = big.NewInt(1 << 0)
	groupedElectrocardiogramVoltageResponseFieldNext       = big.NewInt(1 << 1)
	groupedElectrocardiogramVoltageResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedElectrocardiogramVoltageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedElectrocardiogramVoltage `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedElectrocardiogramVoltageResponse) GetGroups() map[string][]*GroupedElectrocardiogramVoltage {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedElectrocardiogramVoltageResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedElectrocardiogramVoltageResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedElectrocardiogramVoltageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltageResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltageResponse) SetGroups(groups map[string][]*GroupedElectrocardiogramVoltage) {
	g.Groups = groups
	g.require(groupedElectrocardiogramVoltageResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltageResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedElectrocardiogramVoltageResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltageResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedElectrocardiogramVoltageResponseFieldNextCursor)
}

func (g *GroupedElectrocardiogramVoltageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltageResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedElectrocardiogramVoltageResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedElectrocardiogramVoltageResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFallFieldSource = big.NewInt(1 << 0)
	groupedFallFieldData   = big.NewInt(1 << 1)
)

type GroupedFall struct {
	Source *ClientFacingSource       `json:"source" url:"source"`
	Data   []*ClientFacingFallSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFall) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedFall) GetData() []*ClientFacingFallSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedFall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFall) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFall) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedFallFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFall) SetData(data []*ClientFacingFallSample) {
	g.Data = data
	g.require(groupedFallFieldData)
}

func (g *GroupedFall) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFall) MarshalJSON() ([]byte, error) {
	type embed GroupedFall
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFallResponseFieldGroups     = big.NewInt(1 << 0)
	groupedFallResponseFieldNext       = big.NewInt(1 << 1)
	groupedFallResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedFallResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedFall `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFallResponse) GetGroups() map[string][]*GroupedFall {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedFallResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedFallResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedFallResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFallResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFallResponse) SetGroups(groups map[string][]*GroupedFall) {
	g.Groups = groups
	g.require(groupedFallResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFallResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedFallResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFallResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedFallResponseFieldNextCursor)
}

func (g *GroupedFallResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFallResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFallResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFallResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedFallResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFallResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFloorsClimbedFieldSource = big.NewInt(1 << 0)
	groupedFloorsClimbedFieldData   = big.NewInt(1 << 1)
)

type GroupedFloorsClimbed struct {
	Source *ClientFacingSource                    `json:"source" url:"source"`
	Data   []*ClientFacingFloorsClimbedTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFloorsClimbed) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedFloorsClimbed) GetData() []*ClientFacingFloorsClimbedTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedFloorsClimbed) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbed) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbed) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedFloorsClimbedFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbed) SetData(data []*ClientFacingFloorsClimbedTimeseries) {
	g.Data = data
	g.require(groupedFloorsClimbedFieldData)
}

func (g *GroupedFloorsClimbed) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbed(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbed) MarshalJSON() ([]byte, error) {
	type embed GroupedFloorsClimbed
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFloorsClimbed) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFloorsClimbedResponseFieldGroups     = big.NewInt(1 << 0)
	groupedFloorsClimbedResponseFieldNext       = big.NewInt(1 << 1)
	groupedFloorsClimbedResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedFloorsClimbedResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedFloorsClimbed `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFloorsClimbedResponse) GetGroups() map[string][]*GroupedFloorsClimbed {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedFloorsClimbedResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedFloorsClimbedResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedFloorsClimbedResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbedResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbedResponse) SetGroups(groups map[string][]*GroupedFloorsClimbed) {
	g.Groups = groups
	g.require(groupedFloorsClimbedResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbedResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedFloorsClimbedResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbedResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedFloorsClimbedResponseFieldNextCursor)
}

func (g *GroupedFloorsClimbedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbedResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedFloorsClimbedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFloorsClimbedResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedExpiratoryVolume1FieldSource = big.NewInt(1 << 0)
	groupedForcedExpiratoryVolume1FieldData   = big.NewInt(1 << 1)
)

type GroupedForcedExpiratoryVolume1 struct {
	Source *ClientFacingSource                          `json:"source" url:"source"`
	Data   []*ClientFacingForcedExpiratoryVolume1Sample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedExpiratoryVolume1) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedForcedExpiratoryVolume1) GetData() []*ClientFacingForcedExpiratoryVolume1Sample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedForcedExpiratoryVolume1) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedExpiratoryVolume1) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedForcedExpiratoryVolume1FieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1) SetData(data []*ClientFacingForcedExpiratoryVolume1Sample) {
	g.Data = data
	g.require(groupedForcedExpiratoryVolume1FieldData)
}

func (g *GroupedForcedExpiratoryVolume1) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedExpiratoryVolume1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedExpiratoryVolume1(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedExpiratoryVolume1) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedExpiratoryVolume1
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedExpiratoryVolume1) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedExpiratoryVolume1ResponseFieldGroups     = big.NewInt(1 << 0)
	groupedForcedExpiratoryVolume1ResponseFieldNext       = big.NewInt(1 << 1)
	groupedForcedExpiratoryVolume1ResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedForcedExpiratoryVolume1Response struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedForcedExpiratoryVolume1 `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedExpiratoryVolume1Response) GetGroups() map[string][]*GroupedForcedExpiratoryVolume1 {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedForcedExpiratoryVolume1Response) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedForcedExpiratoryVolume1Response) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedForcedExpiratoryVolume1Response) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedExpiratoryVolume1Response) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1Response) SetGroups(groups map[string][]*GroupedForcedExpiratoryVolume1) {
	g.Groups = groups
	g.require(groupedForcedExpiratoryVolume1ResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1Response) SetNext(next *string) {
	g.Next = next
	g.require(groupedForcedExpiratoryVolume1ResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1Response) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedForcedExpiratoryVolume1ResponseFieldNextCursor)
}

func (g *GroupedForcedExpiratoryVolume1Response) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedExpiratoryVolume1Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedExpiratoryVolume1Response(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedExpiratoryVolume1Response) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedExpiratoryVolume1Response
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedExpiratoryVolume1Response) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedVitalCapacityFieldSource = big.NewInt(1 << 0)
	groupedForcedVitalCapacityFieldData   = big.NewInt(1 << 1)
)

type GroupedForcedVitalCapacity struct {
	Source *ClientFacingSource                      `json:"source" url:"source"`
	Data   []*ClientFacingForcedVitalCapacitySample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedVitalCapacity) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedForcedVitalCapacity) GetData() []*ClientFacingForcedVitalCapacitySample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedForcedVitalCapacity) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedVitalCapacity) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacity) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedForcedVitalCapacityFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacity) SetData(data []*ClientFacingForcedVitalCapacitySample) {
	g.Data = data
	g.require(groupedForcedVitalCapacityFieldData)
}

func (g *GroupedForcedVitalCapacity) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedVitalCapacity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedVitalCapacity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedVitalCapacity) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedVitalCapacity
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedVitalCapacity) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedVitalCapacityResponseFieldGroups     = big.NewInt(1 << 0)
	groupedForcedVitalCapacityResponseFieldNext       = big.NewInt(1 << 1)
	groupedForcedVitalCapacityResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedForcedVitalCapacityResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedForcedVitalCapacity `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedVitalCapacityResponse) GetGroups() map[string][]*GroupedForcedVitalCapacity {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedForcedVitalCapacityResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedForcedVitalCapacityResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedForcedVitalCapacityResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedVitalCapacityResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacityResponse) SetGroups(groups map[string][]*GroupedForcedVitalCapacity) {
	g.Groups = groups
	g.require(groupedForcedVitalCapacityResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacityResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedForcedVitalCapacityResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacityResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedForcedVitalCapacityResponseFieldNextCursor)
}

func (g *GroupedForcedVitalCapacityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedVitalCapacityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedVitalCapacityResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedVitalCapacityResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedVitalCapacityResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedVitalCapacityResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedGlucoseFieldSource = big.NewInt(1 << 0)
	groupedGlucoseFieldData   = big.NewInt(1 << 1)
)

type GroupedGlucose struct {
	Source *ClientFacingSource              `json:"source" url:"source"`
	Data   []*ClientFacingGlucoseTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedGlucose) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedGlucose) GetData() []*ClientFacingGlucoseTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedGlucose) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucose) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucose) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedGlucoseFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucose) SetData(data []*ClientFacingGlucoseTimeseries) {
	g.Data = data
	g.require(groupedGlucoseFieldData)
}

func (g *GroupedGlucose) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucose) MarshalJSON() ([]byte, error) {
	type embed GroupedGlucose
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedGlucose) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedGlucoseResponseFieldGroups     = big.NewInt(1 << 0)
	groupedGlucoseResponseFieldNext       = big.NewInt(1 << 1)
	groupedGlucoseResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedGlucoseResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedGlucose `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedGlucoseResponse) GetGroups() map[string][]*GroupedGlucose {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedGlucoseResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedGlucoseResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedGlucoseResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucoseResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucoseResponse) SetGroups(groups map[string][]*GroupedGlucose) {
	g.Groups = groups
	g.require(groupedGlucoseResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucoseResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedGlucoseResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucoseResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedGlucoseResponseFieldNextCursor)
}

func (g *GroupedGlucoseResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucoseResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucoseResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucoseResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedGlucoseResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedGlucoseResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHandwashingFieldSource = big.NewInt(1 << 0)
	groupedHandwashingFieldData   = big.NewInt(1 << 1)
)

type GroupedHandwashing struct {
	Source *ClientFacingSource              `json:"source" url:"source"`
	Data   []*ClientFacingHandwashingSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHandwashing) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHandwashing) GetData() []*ClientFacingHandwashingSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHandwashing) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHandwashing) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashing) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHandwashingFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashing) SetData(data []*ClientFacingHandwashingSample) {
	g.Data = data
	g.require(groupedHandwashingFieldData)
}

func (g *GroupedHandwashing) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHandwashing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHandwashing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHandwashing) MarshalJSON() ([]byte, error) {
	type embed GroupedHandwashing
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHandwashing) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHandwashingResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHandwashingResponseFieldNext       = big.NewInt(1 << 1)
	groupedHandwashingResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHandwashingResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHandwashing `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHandwashingResponse) GetGroups() map[string][]*GroupedHandwashing {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHandwashingResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHandwashingResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHandwashingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHandwashingResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashingResponse) SetGroups(groups map[string][]*GroupedHandwashing) {
	g.Groups = groups
	g.require(groupedHandwashingResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashingResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHandwashingResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashingResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHandwashingResponseFieldNextCursor)
}

func (g *GroupedHandwashingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHandwashingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHandwashingResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHandwashingResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHandwashingResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHandwashingResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateFieldSource = big.NewInt(1 << 0)
	groupedHeartRateFieldData   = big.NewInt(1 << 1)
)

type GroupedHeartRate struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingHeartRateTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRate) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHeartRate) GetData() []*ClientFacingHeartRateTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHeartRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRate) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRate) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHeartRateFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRate) SetData(data []*ClientFacingHeartRateTimeseries) {
	g.Data = data
	g.require(groupedHeartRateFieldData)
}

func (g *GroupedHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRate) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateAlertFieldSource = big.NewInt(1 << 0)
	groupedHeartRateAlertFieldData   = big.NewInt(1 << 1)
)

type GroupedHeartRateAlert struct {
	Source *ClientFacingSource                 `json:"source" url:"source"`
	Data   []*ClientFacingHeartRateAlertSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateAlert) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHeartRateAlert) GetData() []*ClientFacingHeartRateAlertSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHeartRateAlert) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateAlert) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlert) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHeartRateAlertFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlert) SetData(data []*ClientFacingHeartRateAlertSample) {
	g.Data = data
	g.require(groupedHeartRateAlertFieldData)
}

func (g *GroupedHeartRateAlert) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateAlert
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateAlert(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateAlert) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateAlert
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateAlert) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateAlertResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHeartRateAlertResponseFieldNext       = big.NewInt(1 << 1)
	groupedHeartRateAlertResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHeartRateAlertResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRateAlert `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateAlertResponse) GetGroups() map[string][]*GroupedHeartRateAlert {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHeartRateAlertResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHeartRateAlertResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHeartRateAlertResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateAlertResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlertResponse) SetGroups(groups map[string][]*GroupedHeartRateAlert) {
	g.Groups = groups
	g.require(groupedHeartRateAlertResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlertResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHeartRateAlertResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlertResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHeartRateAlertResponseFieldNextCursor)
}

func (g *GroupedHeartRateAlertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateAlertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateAlertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateAlertResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateAlertResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateAlertResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateRecoveryOneMinuteFieldSource = big.NewInt(1 << 0)
	groupedHeartRateRecoveryOneMinuteFieldData   = big.NewInt(1 << 1)
)

type GroupedHeartRateRecoveryOneMinute struct {
	Source *ClientFacingSource                             `json:"source" url:"source"`
	Data   []*ClientFacingHeartRateRecoveryOneMinuteSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateRecoveryOneMinute) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHeartRateRecoveryOneMinute) GetData() []*ClientFacingHeartRateRecoveryOneMinuteSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHeartRateRecoveryOneMinute) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateRecoveryOneMinute) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinute) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHeartRateRecoveryOneMinuteFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinute) SetData(data []*ClientFacingHeartRateRecoveryOneMinuteSample) {
	g.Data = data
	g.require(groupedHeartRateRecoveryOneMinuteFieldData)
}

func (g *GroupedHeartRateRecoveryOneMinute) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateRecoveryOneMinute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateRecoveryOneMinute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateRecoveryOneMinute) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateRecoveryOneMinute
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateRecoveryOneMinute) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateRecoveryOneMinuteResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHeartRateRecoveryOneMinuteResponseFieldNext       = big.NewInt(1 << 1)
	groupedHeartRateRecoveryOneMinuteResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHeartRateRecoveryOneMinuteResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRateRecoveryOneMinute `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetGroups() map[string][]*GroupedHeartRateRecoveryOneMinute {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinuteResponse) SetGroups(groups map[string][]*GroupedHeartRateRecoveryOneMinute) {
	g.Groups = groups
	g.require(groupedHeartRateRecoveryOneMinuteResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinuteResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHeartRateRecoveryOneMinuteResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinuteResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHeartRateRecoveryOneMinuteResponseFieldNextCursor)
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateRecoveryOneMinuteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateRecoveryOneMinuteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateRecoveryOneMinuteResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHeartRateResponseFieldNext       = big.NewInt(1 << 1)
	groupedHeartRateResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHeartRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRate `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateResponse) GetGroups() map[string][]*GroupedHeartRate {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHeartRateResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHeartRateResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHeartRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateResponse) SetGroups(groups map[string][]*GroupedHeartRate) {
	g.Groups = groups
	g.require(groupedHeartRateResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHeartRateResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHeartRateResponseFieldNextCursor)
}

func (g *GroupedHeartRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHrvFieldSource = big.NewInt(1 << 0)
	groupedHrvFieldData   = big.NewInt(1 << 1)
)

type GroupedHrv struct {
	Source *ClientFacingSource          `json:"source" url:"source"`
	Data   []*ClientFacingHrvTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHrv) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHrv) GetData() []*ClientFacingHrvTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHrv) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrv) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrv) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHrvFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrv) SetData(data []*ClientFacingHrvTimeseries) {
	g.Data = data
	g.require(groupedHrvFieldData)
}

func (g *GroupedHrv) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrv
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrv(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrv) MarshalJSON() ([]byte, error) {
	type embed GroupedHrv
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHrv) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHrvResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHrvResponseFieldNext       = big.NewInt(1 << 1)
	groupedHrvResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHrvResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHrv `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHrvResponse) GetGroups() map[string][]*GroupedHrv {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHrvResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHrvResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHrvResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrvResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrvResponse) SetGroups(groups map[string][]*GroupedHrv) {
	g.Groups = groups
	g.require(groupedHrvResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrvResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHrvResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrvResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHrvResponseFieldNextCursor)
}

func (g *GroupedHrvResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrvResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrvResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrvResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHrvResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHrvResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHypnogramFieldSource = big.NewInt(1 << 0)
	groupedHypnogramFieldData   = big.NewInt(1 << 1)
)

type GroupedHypnogram struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingHypnogramTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHypnogram) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHypnogram) GetData() []*ClientFacingHypnogramTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHypnogram) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogram) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogram) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHypnogramFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogram) SetData(data []*ClientFacingHypnogramTimeseries) {
	g.Data = data
	g.require(groupedHypnogramFieldData)
}

func (g *GroupedHypnogram) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogram(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogram) MarshalJSON() ([]byte, error) {
	type embed GroupedHypnogram
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHypnogram) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHypnogramResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHypnogramResponseFieldNext       = big.NewInt(1 << 1)
	groupedHypnogramResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHypnogramResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHypnogram `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHypnogramResponse) GetGroups() map[string][]*GroupedHypnogram {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHypnogramResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHypnogramResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHypnogramResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogramResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogramResponse) SetGroups(groups map[string][]*GroupedHypnogram) {
	g.Groups = groups
	g.require(groupedHypnogramResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogramResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHypnogramResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogramResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHypnogramResponseFieldNextCursor)
}

func (g *GroupedHypnogramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogramResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogramResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHypnogramResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHypnogramResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIgeFieldSource = big.NewInt(1 << 0)
	groupedIgeFieldData   = big.NewInt(1 << 1)
)

type GroupedIge struct {
	Source *ClientFacingSource          `json:"source" url:"source"`
	Data   []*ClientFacingIgeTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIge) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedIge) GetData() []*ClientFacingIgeTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedIge) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIge) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIge) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedIgeFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIge) SetData(data []*ClientFacingIgeTimeseries) {
	g.Data = data
	g.require(groupedIgeFieldData)
}

func (g *GroupedIge) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIge) MarshalJSON() ([]byte, error) {
	type embed GroupedIge
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIge) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIgeResponseFieldGroups     = big.NewInt(1 << 0)
	groupedIgeResponseFieldNext       = big.NewInt(1 << 1)
	groupedIgeResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedIgeResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIge `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIgeResponse) GetGroups() map[string][]*GroupedIge {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedIgeResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedIgeResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedIgeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgeResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgeResponse) SetGroups(groups map[string][]*GroupedIge) {
	g.Groups = groups
	g.require(groupedIgeResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgeResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedIgeResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgeResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedIgeResponseFieldNextCursor)
}

func (g *GroupedIgeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgeResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedIgeResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIgeResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIggFieldSource = big.NewInt(1 << 0)
	groupedIggFieldData   = big.NewInt(1 << 1)
)

type GroupedIgg struct {
	Source *ClientFacingSource          `json:"source" url:"source"`
	Data   []*ClientFacingIggTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIgg) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedIgg) GetData() []*ClientFacingIggTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedIgg) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgg) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgg) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedIggFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgg) SetData(data []*ClientFacingIggTimeseries) {
	g.Data = data
	g.require(groupedIggFieldData)
}

func (g *GroupedIgg) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgg(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgg) MarshalJSON() ([]byte, error) {
	type embed GroupedIgg
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIgg) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIggResponseFieldGroups     = big.NewInt(1 << 0)
	groupedIggResponseFieldNext       = big.NewInt(1 << 1)
	groupedIggResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedIggResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIgg `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIggResponse) GetGroups() map[string][]*GroupedIgg {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedIggResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedIggResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedIggResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIggResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIggResponse) SetGroups(groups map[string][]*GroupedIgg) {
	g.Groups = groups
	g.require(groupedIggResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIggResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedIggResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIggResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedIggResponseFieldNextCursor)
}

func (g *GroupedIggResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIggResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIggResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIggResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedIggResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIggResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInhalerUsageFieldSource = big.NewInt(1 << 0)
	groupedInhalerUsageFieldData   = big.NewInt(1 << 1)
)

type GroupedInhalerUsage struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingInhalerUsageSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInhalerUsage) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedInhalerUsage) GetData() []*ClientFacingInhalerUsageSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedInhalerUsage) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInhalerUsage) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsage) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedInhalerUsageFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsage) SetData(data []*ClientFacingInhalerUsageSample) {
	g.Data = data
	g.require(groupedInhalerUsageFieldData)
}

func (g *GroupedInhalerUsage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInhalerUsage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInhalerUsage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInhalerUsage) MarshalJSON() ([]byte, error) {
	type embed GroupedInhalerUsage
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInhalerUsage) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInhalerUsageResponseFieldGroups     = big.NewInt(1 << 0)
	groupedInhalerUsageResponseFieldNext       = big.NewInt(1 << 1)
	groupedInhalerUsageResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedInhalerUsageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedInhalerUsage `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInhalerUsageResponse) GetGroups() map[string][]*GroupedInhalerUsage {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedInhalerUsageResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedInhalerUsageResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedInhalerUsageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInhalerUsageResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsageResponse) SetGroups(groups map[string][]*GroupedInhalerUsage) {
	g.Groups = groups
	g.require(groupedInhalerUsageResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsageResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedInhalerUsageResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsageResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedInhalerUsageResponseFieldNextCursor)
}

func (g *GroupedInhalerUsageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInhalerUsageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInhalerUsageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInhalerUsageResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedInhalerUsageResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInhalerUsageResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInsulinInjectionFieldSource = big.NewInt(1 << 0)
	groupedInsulinInjectionFieldData   = big.NewInt(1 << 1)
)

type GroupedInsulinInjection struct {
	Source *ClientFacingSource                   `json:"source" url:"source"`
	Data   []*ClientFacingInsulinInjectionSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInsulinInjection) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedInsulinInjection) GetData() []*ClientFacingInsulinInjectionSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedInsulinInjection) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInsulinInjection) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjection) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedInsulinInjectionFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjection) SetData(data []*ClientFacingInsulinInjectionSample) {
	g.Data = data
	g.require(groupedInsulinInjectionFieldData)
}

func (g *GroupedInsulinInjection) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInsulinInjection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInsulinInjection(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInsulinInjection) MarshalJSON() ([]byte, error) {
	type embed GroupedInsulinInjection
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInsulinInjection) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInsulinInjectionResponseFieldGroups     = big.NewInt(1 << 0)
	groupedInsulinInjectionResponseFieldNext       = big.NewInt(1 << 1)
	groupedInsulinInjectionResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedInsulinInjectionResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedInsulinInjection `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInsulinInjectionResponse) GetGroups() map[string][]*GroupedInsulinInjection {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedInsulinInjectionResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedInsulinInjectionResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedInsulinInjectionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInsulinInjectionResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjectionResponse) SetGroups(groups map[string][]*GroupedInsulinInjection) {
	g.Groups = groups
	g.require(groupedInsulinInjectionResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjectionResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedInsulinInjectionResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjectionResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedInsulinInjectionResponseFieldNextCursor)
}

func (g *GroupedInsulinInjectionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInsulinInjectionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInsulinInjectionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInsulinInjectionResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedInsulinInjectionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInsulinInjectionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedLeanBodyMassFieldSource = big.NewInt(1 << 0)
	groupedLeanBodyMassFieldData   = big.NewInt(1 << 1)
)

type GroupedLeanBodyMass struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingLeanBodyMassSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedLeanBodyMass) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedLeanBodyMass) GetData() []*ClientFacingLeanBodyMassSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedLeanBodyMass) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedLeanBodyMass) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMass) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedLeanBodyMassFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMass) SetData(data []*ClientFacingLeanBodyMassSample) {
	g.Data = data
	g.require(groupedLeanBodyMassFieldData)
}

func (g *GroupedLeanBodyMass) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedLeanBodyMass
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedLeanBodyMass(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedLeanBodyMass) MarshalJSON() ([]byte, error) {
	type embed GroupedLeanBodyMass
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedLeanBodyMass) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedLeanBodyMassResponseFieldGroups     = big.NewInt(1 << 0)
	groupedLeanBodyMassResponseFieldNext       = big.NewInt(1 << 1)
	groupedLeanBodyMassResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedLeanBodyMassResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedLeanBodyMass `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedLeanBodyMassResponse) GetGroups() map[string][]*GroupedLeanBodyMass {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedLeanBodyMassResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedLeanBodyMassResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedLeanBodyMassResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedLeanBodyMassResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMassResponse) SetGroups(groups map[string][]*GroupedLeanBodyMass) {
	g.Groups = groups
	g.require(groupedLeanBodyMassResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMassResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedLeanBodyMassResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMassResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedLeanBodyMassResponseFieldNextCursor)
}

func (g *GroupedLeanBodyMassResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedLeanBodyMassResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedLeanBodyMassResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedLeanBodyMassResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedLeanBodyMassResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedLeanBodyMassResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedMindfulnessMinutesFieldSource = big.NewInt(1 << 0)
	groupedMindfulnessMinutesFieldData   = big.NewInt(1 << 1)
)

type GroupedMindfulnessMinutes struct {
	Source *ClientFacingSource                         `json:"source" url:"source"`
	Data   []*ClientFacingMindfulnessMinutesTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedMindfulnessMinutes) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedMindfulnessMinutes) GetData() []*ClientFacingMindfulnessMinutesTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedMindfulnessMinutes) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutes) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutes) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedMindfulnessMinutesFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutes) SetData(data []*ClientFacingMindfulnessMinutesTimeseries) {
	g.Data = data
	g.require(groupedMindfulnessMinutesFieldData)
}

func (g *GroupedMindfulnessMinutes) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutes) MarshalJSON() ([]byte, error) {
	type embed GroupedMindfulnessMinutes
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedMindfulnessMinutes) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedMindfulnessMinutesResponseFieldGroups     = big.NewInt(1 << 0)
	groupedMindfulnessMinutesResponseFieldNext       = big.NewInt(1 << 1)
	groupedMindfulnessMinutesResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedMindfulnessMinutesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedMindfulnessMinutes `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedMindfulnessMinutesResponse) GetGroups() map[string][]*GroupedMindfulnessMinutes {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedMindfulnessMinutesResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedMindfulnessMinutesResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedMindfulnessMinutesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutesResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutesResponse) SetGroups(groups map[string][]*GroupedMindfulnessMinutes) {
	g.Groups = groups
	g.require(groupedMindfulnessMinutesResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutesResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedMindfulnessMinutesResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutesResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedMindfulnessMinutesResponseFieldNextCursor)
}

func (g *GroupedMindfulnessMinutesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutesResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedMindfulnessMinutesResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedMindfulnessMinutesResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedNoteFieldSource = big.NewInt(1 << 0)
	groupedNoteFieldData   = big.NewInt(1 << 1)
)

type GroupedNote struct {
	Source *ClientFacingSource       `json:"source" url:"source"`
	Data   []*ClientFacingNoteSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedNote) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedNote) GetData() []*ClientFacingNoteSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedNote) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedNote) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNote) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedNoteFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNote) SetData(data []*ClientFacingNoteSample) {
	g.Data = data
	g.require(groupedNoteFieldData)
}

func (g *GroupedNote) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedNote
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedNote(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedNote) MarshalJSON() ([]byte, error) {
	type embed GroupedNote
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedNote) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedNoteResponseFieldGroups     = big.NewInt(1 << 0)
	groupedNoteResponseFieldNext       = big.NewInt(1 << 1)
	groupedNoteResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedNoteResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedNote `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedNoteResponse) GetGroups() map[string][]*GroupedNote {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedNoteResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedNoteResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedNoteResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedNoteResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNoteResponse) SetGroups(groups map[string][]*GroupedNote) {
	g.Groups = groups
	g.require(groupedNoteResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNoteResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedNoteResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNoteResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedNoteResponseFieldNextCursor)
}

func (g *GroupedNoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedNoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedNoteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedNoteResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedNoteResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedNoteResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedPeakExpiratoryFlowRateFieldSource = big.NewInt(1 << 0)
	groupedPeakExpiratoryFlowRateFieldData   = big.NewInt(1 << 1)
)

type GroupedPeakExpiratoryFlowRate struct {
	Source *ClientFacingSource                         `json:"source" url:"source"`
	Data   []*ClientFacingPeakExpiratoryFlowRateSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedPeakExpiratoryFlowRate) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedPeakExpiratoryFlowRate) GetData() []*ClientFacingPeakExpiratoryFlowRateSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedPeakExpiratoryFlowRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedPeakExpiratoryFlowRate) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRate) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedPeakExpiratoryFlowRateFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRate) SetData(data []*ClientFacingPeakExpiratoryFlowRateSample) {
	g.Data = data
	g.require(groupedPeakExpiratoryFlowRateFieldData)
}

func (g *GroupedPeakExpiratoryFlowRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedPeakExpiratoryFlowRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedPeakExpiratoryFlowRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedPeakExpiratoryFlowRate) MarshalJSON() ([]byte, error) {
	type embed GroupedPeakExpiratoryFlowRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedPeakExpiratoryFlowRate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedPeakExpiratoryFlowRateResponseFieldGroups     = big.NewInt(1 << 0)
	groupedPeakExpiratoryFlowRateResponseFieldNext       = big.NewInt(1 << 1)
	groupedPeakExpiratoryFlowRateResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedPeakExpiratoryFlowRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedPeakExpiratoryFlowRate `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetGroups() map[string][]*GroupedPeakExpiratoryFlowRate {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedPeakExpiratoryFlowRateResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRateResponse) SetGroups(groups map[string][]*GroupedPeakExpiratoryFlowRate) {
	g.Groups = groups
	g.require(groupedPeakExpiratoryFlowRateResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRateResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedPeakExpiratoryFlowRateResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRateResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedPeakExpiratoryFlowRateResponseFieldNextCursor)
}

func (g *GroupedPeakExpiratoryFlowRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedPeakExpiratoryFlowRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedPeakExpiratoryFlowRateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedPeakExpiratoryFlowRateResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedPeakExpiratoryFlowRateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedPeakExpiratoryFlowRateResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedRespiratoryRateFieldSource = big.NewInt(1 << 0)
	groupedRespiratoryRateFieldData   = big.NewInt(1 << 1)
)

type GroupedRespiratoryRate struct {
	Source *ClientFacingSource                      `json:"source" url:"source"`
	Data   []*ClientFacingRespiratoryRateTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedRespiratoryRate) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedRespiratoryRate) GetData() []*ClientFacingRespiratoryRateTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedRespiratoryRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRate) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRate) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedRespiratoryRateFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRate) SetData(data []*ClientFacingRespiratoryRateTimeseries) {
	g.Data = data
	g.require(groupedRespiratoryRateFieldData)
}

func (g *GroupedRespiratoryRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRate) MarshalJSON() ([]byte, error) {
	type embed GroupedRespiratoryRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedRespiratoryRate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedRespiratoryRateResponseFieldGroups     = big.NewInt(1 << 0)
	groupedRespiratoryRateResponseFieldNext       = big.NewInt(1 << 1)
	groupedRespiratoryRateResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedRespiratoryRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedRespiratoryRate `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedRespiratoryRateResponse) GetGroups() map[string][]*GroupedRespiratoryRate {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedRespiratoryRateResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedRespiratoryRateResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedRespiratoryRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRateResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRateResponse) SetGroups(groups map[string][]*GroupedRespiratoryRate) {
	g.Groups = groups
	g.require(groupedRespiratoryRateResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRateResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedRespiratoryRateResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRateResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedRespiratoryRateResponseFieldNextCursor)
}

func (g *GroupedRespiratoryRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRateResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedRespiratoryRateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedRespiratoryRateResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepApneaAlertFieldSource = big.NewInt(1 << 0)
	groupedSleepApneaAlertFieldData   = big.NewInt(1 << 1)
)

type GroupedSleepApneaAlert struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingSleepApneaAlertSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepApneaAlert) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedSleepApneaAlert) GetData() []*ClientFacingSleepApneaAlertSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedSleepApneaAlert) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepApneaAlert) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlert) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedSleepApneaAlertFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlert) SetData(data []*ClientFacingSleepApneaAlertSample) {
	g.Data = data
	g.require(groupedSleepApneaAlertFieldData)
}

func (g *GroupedSleepApneaAlert) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepApneaAlert
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepApneaAlert(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepApneaAlert) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepApneaAlert
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepApneaAlert) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepApneaAlertResponseFieldGroups     = big.NewInt(1 << 0)
	groupedSleepApneaAlertResponseFieldNext       = big.NewInt(1 << 1)
	groupedSleepApneaAlertResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedSleepApneaAlertResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSleepApneaAlert `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepApneaAlertResponse) GetGroups() map[string][]*GroupedSleepApneaAlert {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedSleepApneaAlertResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedSleepApneaAlertResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedSleepApneaAlertResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepApneaAlertResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlertResponse) SetGroups(groups map[string][]*GroupedSleepApneaAlert) {
	g.Groups = groups
	g.require(groupedSleepApneaAlertResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlertResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedSleepApneaAlertResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlertResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedSleepApneaAlertResponseFieldNextCursor)
}

func (g *GroupedSleepApneaAlertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepApneaAlertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepApneaAlertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepApneaAlertResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepApneaAlertResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepApneaAlertResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepBreathingDisturbanceFieldSource = big.NewInt(1 << 0)
	groupedSleepBreathingDisturbanceFieldData   = big.NewInt(1 << 1)
)

type GroupedSleepBreathingDisturbance struct {
	Source *ClientFacingSource                            `json:"source" url:"source"`
	Data   []*ClientFacingSleepBreathingDisturbanceSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepBreathingDisturbance) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedSleepBreathingDisturbance) GetData() []*ClientFacingSleepBreathingDisturbanceSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedSleepBreathingDisturbance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepBreathingDisturbance) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbance) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedSleepBreathingDisturbanceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbance) SetData(data []*ClientFacingSleepBreathingDisturbanceSample) {
	g.Data = data
	g.require(groupedSleepBreathingDisturbanceFieldData)
}

func (g *GroupedSleepBreathingDisturbance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepBreathingDisturbance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepBreathingDisturbance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepBreathingDisturbance) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepBreathingDisturbance
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepBreathingDisturbance) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepBreathingDisturbanceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedSleepBreathingDisturbanceResponseFieldNext       = big.NewInt(1 << 1)
	groupedSleepBreathingDisturbanceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedSleepBreathingDisturbanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSleepBreathingDisturbance `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetGroups() map[string][]*GroupedSleepBreathingDisturbance {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepBreathingDisturbanceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbanceResponse) SetGroups(groups map[string][]*GroupedSleepBreathingDisturbance) {
	g.Groups = groups
	g.require(groupedSleepBreathingDisturbanceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbanceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedSleepBreathingDisturbanceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbanceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedSleepBreathingDisturbanceResponseFieldNextCursor)
}

func (g *GroupedSleepBreathingDisturbanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepBreathingDisturbanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepBreathingDisturbanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepBreathingDisturbanceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepBreathingDisturbanceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepBreathingDisturbanceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandDurationFieldSource = big.NewInt(1 << 0)
	groupedStandDurationFieldData   = big.NewInt(1 << 1)
)

type GroupedStandDuration struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingStandDurationSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandDuration) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedStandDuration) GetData() []*ClientFacingStandDurationSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedStandDuration) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandDuration) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDuration) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStandDurationFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDuration) SetData(data []*ClientFacingStandDurationSample) {
	g.Data = data
	g.require(groupedStandDurationFieldData)
}

func (g *GroupedStandDuration) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandDuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandDuration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandDuration) MarshalJSON() ([]byte, error) {
	type embed GroupedStandDuration
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandDuration) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandDurationResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStandDurationResponseFieldNext       = big.NewInt(1 << 1)
	groupedStandDurationResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStandDurationResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStandDuration `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandDurationResponse) GetGroups() map[string][]*GroupedStandDuration {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStandDurationResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStandDurationResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStandDurationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandDurationResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDurationResponse) SetGroups(groups map[string][]*GroupedStandDuration) {
	g.Groups = groups
	g.require(groupedStandDurationResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDurationResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStandDurationResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDurationResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStandDurationResponseFieldNextCursor)
}

func (g *GroupedStandDurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandDurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandDurationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandDurationResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStandDurationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandDurationResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandHourFieldSource = big.NewInt(1 << 0)
	groupedStandHourFieldData   = big.NewInt(1 << 1)
)

type GroupedStandHour struct {
	Source *ClientFacingSource            `json:"source" url:"source"`
	Data   []*ClientFacingStandHourSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandHour) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedStandHour) GetData() []*ClientFacingStandHourSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedStandHour) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandHour) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHour) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStandHourFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHour) SetData(data []*ClientFacingStandHourSample) {
	g.Data = data
	g.require(groupedStandHourFieldData)
}

func (g *GroupedStandHour) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandHour
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandHour(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandHour) MarshalJSON() ([]byte, error) {
	type embed GroupedStandHour
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandHour) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandHourResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStandHourResponseFieldNext       = big.NewInt(1 << 1)
	groupedStandHourResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStandHourResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStandHour `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandHourResponse) GetGroups() map[string][]*GroupedStandHour {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStandHourResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStandHourResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStandHourResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandHourResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHourResponse) SetGroups(groups map[string][]*GroupedStandHour) {
	g.Groups = groups
	g.require(groupedStandHourResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHourResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStandHourResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHourResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStandHourResponseFieldNextCursor)
}

func (g *GroupedStandHourResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandHourResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandHourResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandHourResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStandHourResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandHourResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStepsFieldSource = big.NewInt(1 << 0)
	groupedStepsFieldData   = big.NewInt(1 << 1)
)

type GroupedSteps struct {
	Source *ClientFacingSource            `json:"source" url:"source"`
	Data   []*ClientFacingStepsTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSteps) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedSteps) GetData() []*ClientFacingStepsTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedSteps) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSteps) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSteps) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStepsFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSteps) SetData(data []*ClientFacingStepsTimeseries) {
	g.Data = data
	g.require(groupedStepsFieldData)
}

func (g *GroupedSteps) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSteps
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSteps(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSteps) MarshalJSON() ([]byte, error) {
	type embed GroupedSteps
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSteps) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStepsResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStepsResponseFieldNext       = big.NewInt(1 << 1)
	groupedStepsResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStepsResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSteps `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStepsResponse) GetGroups() map[string][]*GroupedSteps {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStepsResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStepsResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStepsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStepsResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStepsResponse) SetGroups(groups map[string][]*GroupedSteps) {
	g.Groups = groups
	g.require(groupedStepsResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStepsResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStepsResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStepsResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStepsResponseFieldNextCursor)
}

func (g *GroupedStepsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStepsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStepsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStepsResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStepsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStepsResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStressLevelFieldSource = big.NewInt(1 << 0)
	groupedStressLevelFieldData   = big.NewInt(1 << 1)
)

type GroupedStressLevel struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingStressLevelTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStressLevel) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedStressLevel) GetData() []*ClientFacingStressLevelTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedStressLevel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevel) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevel) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStressLevelFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevel) SetData(data []*ClientFacingStressLevelTimeseries) {
	g.Data = data
	g.require(groupedStressLevelFieldData)
}

func (g *GroupedStressLevel) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevel) MarshalJSON() ([]byte, error) {
	type embed GroupedStressLevel
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStressLevel) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStressLevelResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStressLevelResponseFieldNext       = big.NewInt(1 << 1)
	groupedStressLevelResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStressLevelResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStressLevel `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStressLevelResponse) GetGroups() map[string][]*GroupedStressLevel {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStressLevelResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStressLevelResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStressLevelResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevelResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevelResponse) SetGroups(groups map[string][]*GroupedStressLevel) {
	g.Groups = groups
	g.require(groupedStressLevelResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevelResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStressLevelResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevelResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStressLevelResponseFieldNextCursor)
}

func (g *GroupedStressLevelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevelResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevelResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStressLevelResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStressLevelResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedUvExposureFieldSource = big.NewInt(1 << 0)
	groupedUvExposureFieldData   = big.NewInt(1 << 1)
)

type GroupedUvExposure struct {
	Source *ClientFacingSource             `json:"source" url:"source"`
	Data   []*ClientFacingUvExposureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedUvExposure) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedUvExposure) GetData() []*ClientFacingUvExposureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedUvExposure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedUvExposure) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposure) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedUvExposureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposure) SetData(data []*ClientFacingUvExposureSample) {
	g.Data = data
	g.require(groupedUvExposureFieldData)
}

func (g *GroupedUvExposure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedUvExposure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedUvExposure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedUvExposure) MarshalJSON() ([]byte, error) {
	type embed GroupedUvExposure
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedUvExposure) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedUvExposureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedUvExposureResponseFieldNext       = big.NewInt(1 << 1)
	groupedUvExposureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedUvExposureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedUvExposure `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedUvExposureResponse) GetGroups() map[string][]*GroupedUvExposure {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedUvExposureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedUvExposureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedUvExposureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedUvExposureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposureResponse) SetGroups(groups map[string][]*GroupedUvExposure) {
	g.Groups = groups
	g.require(groupedUvExposureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedUvExposureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedUvExposureResponseFieldNextCursor)
}

func (g *GroupedUvExposureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedUvExposureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedUvExposureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedUvExposureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedUvExposureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedUvExposureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedVo2MaxFieldSource = big.NewInt(1 << 0)
	groupedVo2MaxFieldData   = big.NewInt(1 << 1)
)

type GroupedVo2Max struct {
	Source *ClientFacingSource             `json:"source" url:"source"`
	Data   []*ClientFacingVo2MaxTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedVo2Max) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedVo2Max) GetData() []*ClientFacingVo2MaxTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedVo2Max) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2Max) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2Max) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedVo2MaxFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2Max) SetData(data []*ClientFacingVo2MaxTimeseries) {
	g.Data = data
	g.require(groupedVo2MaxFieldData)
}

func (g *GroupedVo2Max) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2Max
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2Max(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2Max) MarshalJSON() ([]byte, error) {
	type embed GroupedVo2Max
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedVo2Max) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedVo2MaxResponseFieldGroups     = big.NewInt(1 << 0)
	groupedVo2MaxResponseFieldNext       = big.NewInt(1 << 1)
	groupedVo2MaxResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedVo2MaxResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedVo2Max `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedVo2MaxResponse) GetGroups() map[string][]*GroupedVo2Max {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedVo2MaxResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedVo2MaxResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedVo2MaxResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2MaxResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2MaxResponse) SetGroups(groups map[string][]*GroupedVo2Max) {
	g.Groups = groups
	g.require(groupedVo2MaxResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2MaxResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedVo2MaxResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2MaxResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedVo2MaxResponseFieldNextCursor)
}

func (g *GroupedVo2MaxResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2MaxResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2MaxResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2MaxResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedVo2MaxResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedVo2MaxResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaistCircumferenceFieldSource = big.NewInt(1 << 0)
	groupedWaistCircumferenceFieldData   = big.NewInt(1 << 1)
)

type GroupedWaistCircumference struct {
	Source *ClientFacingSource                     `json:"source" url:"source"`
	Data   []*ClientFacingWaistCircumferenceSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWaistCircumference) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWaistCircumference) GetData() []*ClientFacingWaistCircumferenceSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWaistCircumference) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaistCircumference) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumference) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWaistCircumferenceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumference) SetData(data []*ClientFacingWaistCircumferenceSample) {
	g.Data = data
	g.require(groupedWaistCircumferenceFieldData)
}

func (g *GroupedWaistCircumference) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaistCircumference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaistCircumference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaistCircumference) MarshalJSON() ([]byte, error) {
	type embed GroupedWaistCircumference
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWaistCircumference) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaistCircumferenceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWaistCircumferenceResponseFieldNext       = big.NewInt(1 << 1)
	groupedWaistCircumferenceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWaistCircumferenceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWaistCircumference `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWaistCircumferenceResponse) GetGroups() map[string][]*GroupedWaistCircumference {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWaistCircumferenceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWaistCircumferenceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWaistCircumferenceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaistCircumferenceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumferenceResponse) SetGroups(groups map[string][]*GroupedWaistCircumference) {
	g.Groups = groups
	g.require(groupedWaistCircumferenceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumferenceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWaistCircumferenceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumferenceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWaistCircumferenceResponseFieldNextCursor)
}

func (g *GroupedWaistCircumferenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaistCircumferenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaistCircumferenceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaistCircumferenceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWaistCircumferenceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWaistCircumferenceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaterFieldSource = big.NewInt(1 << 0)
	groupedWaterFieldData   = big.NewInt(1 << 1)
)

type GroupedWater struct {
	Source *ClientFacingSource            `json:"source" url:"source"`
	Data   []*ClientFacingWaterTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWater) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWater) GetData() []*ClientFacingWaterTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWater) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWater) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWater) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWaterFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWater) SetData(data []*ClientFacingWaterTimeseries) {
	g.Data = data
	g.require(groupedWaterFieldData)
}

func (g *GroupedWater) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWater
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWater(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWater) MarshalJSON() ([]byte, error) {
	type embed GroupedWater
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWater) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaterResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWaterResponseFieldNext       = big.NewInt(1 << 1)
	groupedWaterResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWaterResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWater `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWaterResponse) GetGroups() map[string][]*GroupedWater {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWaterResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWaterResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWaterResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaterResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaterResponse) SetGroups(groups map[string][]*GroupedWater) {
	g.Groups = groups
	g.require(groupedWaterResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaterResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWaterResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaterResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWaterResponseFieldNextCursor)
}

func (g *GroupedWaterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaterResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaterResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWaterResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWaterResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWheelchairPushFieldSource = big.NewInt(1 << 0)
	groupedWheelchairPushFieldData   = big.NewInt(1 << 1)
)

type GroupedWheelchairPush struct {
	Source *ClientFacingSource                 `json:"source" url:"source"`
	Data   []*ClientFacingWheelchairPushSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWheelchairPush) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWheelchairPush) GetData() []*ClientFacingWheelchairPushSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWheelchairPush) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWheelchairPush) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPush) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWheelchairPushFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPush) SetData(data []*ClientFacingWheelchairPushSample) {
	g.Data = data
	g.require(groupedWheelchairPushFieldData)
}

func (g *GroupedWheelchairPush) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWheelchairPush
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWheelchairPush(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWheelchairPush) MarshalJSON() ([]byte, error) {
	type embed GroupedWheelchairPush
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWheelchairPush) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWheelchairPushResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWheelchairPushResponseFieldNext       = big.NewInt(1 << 1)
	groupedWheelchairPushResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWheelchairPushResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWheelchairPush `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWheelchairPushResponse) GetGroups() map[string][]*GroupedWheelchairPush {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWheelchairPushResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWheelchairPushResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWheelchairPushResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWheelchairPushResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPushResponse) SetGroups(groups map[string][]*GroupedWheelchairPush) {
	g.Groups = groups
	g.require(groupedWheelchairPushResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPushResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWheelchairPushResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPushResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWheelchairPushResponseFieldNextCursor)
}

func (g *GroupedWheelchairPushResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWheelchairPushResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWheelchairPushResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWheelchairPushResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWheelchairPushResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWheelchairPushResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDistanceFieldSource = big.NewInt(1 << 0)
	groupedWorkoutDistanceFieldData   = big.NewInt(1 << 1)
)

type GroupedWorkoutDistance struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingWorkoutDistanceSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDistance) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWorkoutDistance) GetData() []*ClientFacingWorkoutDistanceSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWorkoutDistance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDistance) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistance) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWorkoutDistanceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistance) SetData(data []*ClientFacingWorkoutDistanceSample) {
	g.Data = data
	g.require(groupedWorkoutDistanceFieldData)
}

func (g *GroupedWorkoutDistance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDistance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDistance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDistance) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDistance
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDistance) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDistanceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWorkoutDistanceResponseFieldNext       = big.NewInt(1 << 1)
	groupedWorkoutDistanceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWorkoutDistanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWorkoutDistance `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDistanceResponse) GetGroups() map[string][]*GroupedWorkoutDistance {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWorkoutDistanceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWorkoutDistanceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWorkoutDistanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDistanceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistanceResponse) SetGroups(groups map[string][]*GroupedWorkoutDistance) {
	g.Groups = groups
	g.require(groupedWorkoutDistanceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistanceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWorkoutDistanceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistanceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWorkoutDistanceResponseFieldNextCursor)
}

func (g *GroupedWorkoutDistanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDistanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDistanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDistanceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDistanceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDistanceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDurationFieldSource = big.NewInt(1 << 0)
	groupedWorkoutDurationFieldData   = big.NewInt(1 << 1)
)

type GroupedWorkoutDuration struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingWorkoutDurationSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDuration) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWorkoutDuration) GetData() []*ClientFacingWorkoutDurationSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWorkoutDuration) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDuration) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDuration) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWorkoutDurationFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDuration) SetData(data []*ClientFacingWorkoutDurationSample) {
	g.Data = data
	g.require(groupedWorkoutDurationFieldData)
}

func (g *GroupedWorkoutDuration) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDuration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDuration) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDuration
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDuration) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDurationResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWorkoutDurationResponseFieldNext       = big.NewInt(1 << 1)
	groupedWorkoutDurationResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWorkoutDurationResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWorkoutDuration `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDurationResponse) GetGroups() map[string][]*GroupedWorkoutDuration {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWorkoutDurationResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWorkoutDurationResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWorkoutDurationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDurationResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDurationResponse) SetGroups(groups map[string][]*GroupedWorkoutDuration) {
	g.Groups = groups
	g.require(groupedWorkoutDurationResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDurationResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWorkoutDurationResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDurationResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWorkoutDurationResponseFieldNextCursor)
}

func (g *GroupedWorkoutDurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDurationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDurationResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDurationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDurationResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutSwimmingStrokeFieldSource = big.NewInt(1 << 0)
	groupedWorkoutSwimmingStrokeFieldData   = big.NewInt(1 << 1)
)

type GroupedWorkoutSwimmingStroke struct {
	Source *ClientFacingSource                        `json:"source" url:"source"`
	Data   []*ClientFacingWorkoutSwimmingStrokeSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutSwimmingStroke) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWorkoutSwimmingStroke) GetData() []*ClientFacingWorkoutSwimmingStrokeSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWorkoutSwimmingStroke) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutSwimmingStroke) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStroke) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWorkoutSwimmingStrokeFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStroke) SetData(data []*ClientFacingWorkoutSwimmingStrokeSample) {
	g.Data = data
	g.require(groupedWorkoutSwimmingStrokeFieldData)
}

func (g *GroupedWorkoutSwimmingStroke) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutSwimmingStroke
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutSwimmingStroke(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutSwimmingStroke) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutSwimmingStroke
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutSwimmingStroke) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutSwimmingStrokeResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWorkoutSwimmingStrokeResponseFieldNext       = big.NewInt(1 << 1)
	groupedWorkoutSwimmingStrokeResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWorkoutSwimmingStrokeResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWorkoutSwimmingStroke `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetGroups() map[string][]*GroupedWorkoutSwimmingStroke {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutSwimmingStrokeResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStrokeResponse) SetGroups(groups map[string][]*GroupedWorkoutSwimmingStroke) {
	g.Groups = groups
	g.require(groupedWorkoutSwimmingStrokeResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStrokeResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWorkoutSwimmingStrokeResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStrokeResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWorkoutSwimmingStrokeResponseFieldNextCursor)
}

func (g *GroupedWorkoutSwimmingStrokeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutSwimmingStrokeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutSwimmingStrokeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutSwimmingStrokeResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutSwimmingStrokeResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutSwimmingStrokeResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	uvExposureGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	uvExposureGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	uvExposureGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	uvExposureGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	uvExposureGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	uvExposureGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type UvExposureGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UvExposureGroupedVitalsRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UvExposureGroupedVitalsRequest) SetUserId(userId string) {
	u.UserId = userId
	u.require(uvExposureGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UvExposureGroupedVitalsRequest) SetCursor(cursor *string) {
	u.Cursor = cursor
	u.require(uvExposureGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UvExposureGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	u.NextCursor = nextCursor
	u.require(uvExposureGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UvExposureGroupedVitalsRequest) SetProvider(provider *string) {
	u.Provider = provider
	u.require(uvExposureGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UvExposureGroupedVitalsRequest) SetStartDate(startDate string) {
	u.StartDate = startDate
	u.require(uvExposureGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UvExposureGroupedVitalsRequest) SetEndDate(endDate *string) {
	u.EndDate = endDate
	u.require(uvExposureGroupedVitalsRequestFieldEndDate)
}

var (
	vo2MaxVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	vo2MaxVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	vo2MaxVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	vo2MaxVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type Vo2MaxVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *Vo2MaxVitalsRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxVitalsRequest) SetUserId(userId string) {
	v.UserId = userId
	v.require(vo2MaxVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxVitalsRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vo2MaxVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxVitalsRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vo2MaxVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxVitalsRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vo2MaxVitalsRequestFieldEndDate)
}

var (
	vo2MaxGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	vo2MaxGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	vo2MaxGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	vo2MaxGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	vo2MaxGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	vo2MaxGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type Vo2MaxGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *Vo2MaxGroupedVitalsRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxGroupedVitalsRequest) SetUserId(userId string) {
	v.UserId = userId
	v.require(vo2MaxGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxGroupedVitalsRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vo2MaxGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vo2MaxGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxGroupedVitalsRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vo2MaxGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxGroupedVitalsRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vo2MaxGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Vo2MaxGroupedVitalsRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vo2MaxGroupedVitalsRequestFieldEndDate)
}

var (
	waistCircumferenceGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	waistCircumferenceGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	waistCircumferenceGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	waistCircumferenceGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	waistCircumferenceGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	waistCircumferenceGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type WaistCircumferenceGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (w *WaistCircumferenceGroupedVitalsRequest) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaistCircumferenceGroupedVitalsRequest) SetUserId(userId string) {
	w.UserId = userId
	w.require(waistCircumferenceGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaistCircumferenceGroupedVitalsRequest) SetCursor(cursor *string) {
	w.Cursor = cursor
	w.require(waistCircumferenceGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaistCircumferenceGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	w.NextCursor = nextCursor
	w.require(waistCircumferenceGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaistCircumferenceGroupedVitalsRequest) SetProvider(provider *string) {
	w.Provider = provider
	w.require(waistCircumferenceGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaistCircumferenceGroupedVitalsRequest) SetStartDate(startDate string) {
	w.StartDate = startDate
	w.require(waistCircumferenceGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaistCircumferenceGroupedVitalsRequest) SetEndDate(endDate *string) {
	w.EndDate = endDate
	w.require(waistCircumferenceGroupedVitalsRequestFieldEndDate)
}

var (
	waterVitalsRequestFieldUserId    = big.NewInt(1 << 0)
	waterVitalsRequestFieldProvider  = big.NewInt(1 << 1)
	waterVitalsRequestFieldStartDate = big.NewInt(1 << 2)
	waterVitalsRequestFieldEndDate   = big.NewInt(1 << 3)
)

type WaterVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (w *WaterVitalsRequest) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterVitalsRequest) SetUserId(userId string) {
	w.UserId = userId
	w.require(waterVitalsRequestFieldUserId)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterVitalsRequest) SetProvider(provider *string) {
	w.Provider = provider
	w.require(waterVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterVitalsRequest) SetStartDate(startDate string) {
	w.StartDate = startDate
	w.require(waterVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterVitalsRequest) SetEndDate(endDate *string) {
	w.EndDate = endDate
	w.require(waterVitalsRequestFieldEndDate)
}

var (
	waterGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	waterGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	waterGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	waterGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	waterGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	waterGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type WaterGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (w *WaterGroupedVitalsRequest) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterGroupedVitalsRequest) SetUserId(userId string) {
	w.UserId = userId
	w.require(waterGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterGroupedVitalsRequest) SetCursor(cursor *string) {
	w.Cursor = cursor
	w.require(waterGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	w.NextCursor = nextCursor
	w.require(waterGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterGroupedVitalsRequest) SetProvider(provider *string) {
	w.Provider = provider
	w.require(waterGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterGroupedVitalsRequest) SetStartDate(startDate string) {
	w.StartDate = startDate
	w.require(waterGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WaterGroupedVitalsRequest) SetEndDate(endDate *string) {
	w.EndDate = endDate
	w.require(waterGroupedVitalsRequestFieldEndDate)
}

var (
	wheelchairPushGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	wheelchairPushGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	wheelchairPushGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	wheelchairPushGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	wheelchairPushGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	wheelchairPushGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type WheelchairPushGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (w *WheelchairPushGroupedVitalsRequest) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WheelchairPushGroupedVitalsRequest) SetUserId(userId string) {
	w.UserId = userId
	w.require(wheelchairPushGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WheelchairPushGroupedVitalsRequest) SetCursor(cursor *string) {
	w.Cursor = cursor
	w.require(wheelchairPushGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WheelchairPushGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	w.NextCursor = nextCursor
	w.require(wheelchairPushGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WheelchairPushGroupedVitalsRequest) SetProvider(provider *string) {
	w.Provider = provider
	w.require(wheelchairPushGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WheelchairPushGroupedVitalsRequest) SetStartDate(startDate string) {
	w.StartDate = startDate
	w.require(wheelchairPushGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WheelchairPushGroupedVitalsRequest) SetEndDate(endDate *string) {
	w.EndDate = endDate
	w.require(wheelchairPushGroupedVitalsRequestFieldEndDate)
}

var (
	workoutDistanceGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	workoutDistanceGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	workoutDistanceGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	workoutDistanceGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	workoutDistanceGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	workoutDistanceGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type WorkoutDistanceGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (w *WorkoutDistanceGroupedVitalsRequest) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDistanceGroupedVitalsRequest) SetUserId(userId string) {
	w.UserId = userId
	w.require(workoutDistanceGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDistanceGroupedVitalsRequest) SetCursor(cursor *string) {
	w.Cursor = cursor
	w.require(workoutDistanceGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDistanceGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	w.NextCursor = nextCursor
	w.require(workoutDistanceGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDistanceGroupedVitalsRequest) SetProvider(provider *string) {
	w.Provider = provider
	w.require(workoutDistanceGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDistanceGroupedVitalsRequest) SetStartDate(startDate string) {
	w.StartDate = startDate
	w.require(workoutDistanceGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDistanceGroupedVitalsRequest) SetEndDate(endDate *string) {
	w.EndDate = endDate
	w.require(workoutDistanceGroupedVitalsRequestFieldEndDate)
}

var (
	workoutDurationGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	workoutDurationGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	workoutDurationGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	workoutDurationGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	workoutDurationGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	workoutDurationGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type WorkoutDurationGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (w *WorkoutDurationGroupedVitalsRequest) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDurationGroupedVitalsRequest) SetUserId(userId string) {
	w.UserId = userId
	w.require(workoutDurationGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDurationGroupedVitalsRequest) SetCursor(cursor *string) {
	w.Cursor = cursor
	w.require(workoutDurationGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDurationGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	w.NextCursor = nextCursor
	w.require(workoutDurationGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDurationGroupedVitalsRequest) SetProvider(provider *string) {
	w.Provider = provider
	w.require(workoutDurationGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDurationGroupedVitalsRequest) SetStartDate(startDate string) {
	w.StartDate = startDate
	w.require(workoutDurationGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutDurationGroupedVitalsRequest) SetEndDate(endDate *string) {
	w.EndDate = endDate
	w.require(workoutDurationGroupedVitalsRequestFieldEndDate)
}

var (
	workoutSwimmingStrokeGroupedVitalsRequestFieldUserId     = big.NewInt(1 << 0)
	workoutSwimmingStrokeGroupedVitalsRequestFieldCursor     = big.NewInt(1 << 1)
	workoutSwimmingStrokeGroupedVitalsRequestFieldNextCursor = big.NewInt(1 << 2)
	workoutSwimmingStrokeGroupedVitalsRequestFieldProvider   = big.NewInt(1 << 3)
	workoutSwimmingStrokeGroupedVitalsRequestFieldStartDate  = big.NewInt(1 << 4)
	workoutSwimmingStrokeGroupedVitalsRequestFieldEndDate    = big.NewInt(1 << 5)
)

type WorkoutSwimmingStrokeGroupedVitalsRequest struct {
	UserId string `json:"-" url:"-"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (w *WorkoutSwimmingStrokeGroupedVitalsRequest) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutSwimmingStrokeGroupedVitalsRequest) SetUserId(userId string) {
	w.UserId = userId
	w.require(workoutSwimmingStrokeGroupedVitalsRequestFieldUserId)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutSwimmingStrokeGroupedVitalsRequest) SetCursor(cursor *string) {
	w.Cursor = cursor
	w.require(workoutSwimmingStrokeGroupedVitalsRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutSwimmingStrokeGroupedVitalsRequest) SetNextCursor(nextCursor *string) {
	w.NextCursor = nextCursor
	w.require(workoutSwimmingStrokeGroupedVitalsRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutSwimmingStrokeGroupedVitalsRequest) SetProvider(provider *string) {
	w.Provider = provider
	w.require(workoutSwimmingStrokeGroupedVitalsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutSwimmingStrokeGroupedVitalsRequest) SetStartDate(startDate string) {
	w.StartDate = startDate
	w.require(workoutSwimmingStrokeGroupedVitalsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WorkoutSwimmingStrokeGroupedVitalsRequest) SetEndDate(endDate *string) {
	w.EndDate = endDate
	w.require(workoutSwimmingStrokeGroupedVitalsRequestFieldEndDate)
}
