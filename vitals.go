// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tryVital/vital-go/internal"
	big "math/big"
	time "time"
)

var (
	vitalsAfibBurdenGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsAfibBurdenGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsAfibBurdenGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsAfibBurdenGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsAfibBurdenGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsAfibBurdenGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsAfibBurdenGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsAfibBurdenGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsAfibBurdenGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsAfibBurdenGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsAfibBurdenGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsAfibBurdenGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsAfibBurdenGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsAfibBurdenGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsAfibBurdenGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsAfibBurdenGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsAfibBurdenGroupedRequestFieldEndDate)
}

var (
	vitalsBasalBodyTemperatureGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBasalBodyTemperatureGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBasalBodyTemperatureGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBasalBodyTemperatureGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBasalBodyTemperatureGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBasalBodyTemperatureGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBasalBodyTemperatureGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBasalBodyTemperatureGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBasalBodyTemperatureGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBasalBodyTemperatureGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBasalBodyTemperatureGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBasalBodyTemperatureGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBasalBodyTemperatureGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBasalBodyTemperatureGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBasalBodyTemperatureGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBasalBodyTemperatureGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBasalBodyTemperatureGroupedRequestFieldEndDate)
}

var (
	vitalsBloodOxygenRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsBloodOxygenRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsBloodOxygenRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsBloodOxygenRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBloodOxygenRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBloodOxygenRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBloodOxygenRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBloodOxygenRequestFieldEndDate)
}

var (
	vitalsBloodOxygenGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBloodOxygenGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBloodOxygenGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBloodOxygenGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBloodOxygenGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBloodOxygenGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBloodOxygenGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBloodOxygenGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBloodOxygenGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBloodOxygenGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBloodOxygenGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodOxygenGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBloodOxygenGroupedRequestFieldEndDate)
}

var (
	vitalsBloodPressureRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsBloodPressureRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsBloodPressureRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsBloodPressureRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBloodPressureRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBloodPressureRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBloodPressureRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBloodPressureRequestFieldEndDate)
}

var (
	vitalsBloodPressureGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBloodPressureGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBloodPressureGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBloodPressureGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBloodPressureGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBloodPressureGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBloodPressureGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBloodPressureGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBloodPressureGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBloodPressureGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBloodPressureGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBloodPressureGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBloodPressureGroupedRequestFieldEndDate)
}

var (
	vitalsBodyFatRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsBodyFatRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsBodyFatRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsBodyFatRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBodyFatRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBodyFatRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBodyFatRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBodyFatRequestFieldEndDate)
}

var (
	vitalsBodyFatGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBodyFatGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBodyFatGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBodyFatGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBodyFatGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBodyFatGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBodyFatGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBodyFatGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBodyFatGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBodyFatGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBodyFatGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyFatGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBodyFatGroupedRequestFieldEndDate)
}

var (
	vitalsBodyMassIndexGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBodyMassIndexGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBodyMassIndexGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBodyMassIndexGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBodyMassIndexGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBodyMassIndexGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBodyMassIndexGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyMassIndexGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBodyMassIndexGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyMassIndexGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBodyMassIndexGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyMassIndexGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBodyMassIndexGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyMassIndexGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBodyMassIndexGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyMassIndexGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBodyMassIndexGroupedRequestFieldEndDate)
}

var (
	vitalsBodyTemperatureDeltaGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBodyTemperatureDeltaGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBodyTemperatureDeltaGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBodyTemperatureDeltaGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBodyTemperatureDeltaGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBodyTemperatureDeltaGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBodyTemperatureDeltaGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureDeltaGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBodyTemperatureDeltaGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureDeltaGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBodyTemperatureDeltaGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureDeltaGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBodyTemperatureDeltaGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureDeltaGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBodyTemperatureDeltaGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureDeltaGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBodyTemperatureDeltaGroupedRequestFieldEndDate)
}

var (
	vitalsBodyTemperatureGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBodyTemperatureGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBodyTemperatureGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBodyTemperatureGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBodyTemperatureGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBodyTemperatureGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBodyTemperatureGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBodyTemperatureGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBodyTemperatureGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBodyTemperatureGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBodyTemperatureGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyTemperatureGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBodyTemperatureGroupedRequestFieldEndDate)
}

var (
	vitalsBodyWeightRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsBodyWeightRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsBodyWeightRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsBodyWeightRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBodyWeightRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBodyWeightRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBodyWeightRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBodyWeightRequestFieldEndDate)
}

var (
	vitalsBodyWeightGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsBodyWeightGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsBodyWeightGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsBodyWeightGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsBodyWeightGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsBodyWeightGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsBodyWeightGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsBodyWeightGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsBodyWeightGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsBodyWeightGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsBodyWeightGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsBodyWeightGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsBodyWeightGroupedRequestFieldEndDate)
}

var (
	vitalsCaffeineRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCaffeineRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCaffeineRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCaffeineRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCaffeineRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCaffeineRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCaffeineRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCaffeineRequestFieldEndDate)
}

var (
	vitalsCaffeineGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsCaffeineGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsCaffeineGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsCaffeineGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsCaffeineGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsCaffeineGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCaffeineGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsCaffeineGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsCaffeineGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCaffeineGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCaffeineGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaffeineGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCaffeineGroupedRequestFieldEndDate)
}

var (
	vitalsCaloriesActiveRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCaloriesActiveRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCaloriesActiveRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCaloriesActiveRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCaloriesActiveRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCaloriesActiveRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCaloriesActiveRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCaloriesActiveRequestFieldEndDate)
}

var (
	vitalsCaloriesActiveGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsCaloriesActiveGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsCaloriesActiveGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsCaloriesActiveGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsCaloriesActiveGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsCaloriesActiveGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCaloriesActiveGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsCaloriesActiveGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsCaloriesActiveGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCaloriesActiveGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCaloriesActiveGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesActiveGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCaloriesActiveGroupedRequestFieldEndDate)
}

var (
	vitalsCaloriesBasalRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCaloriesBasalRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCaloriesBasalRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCaloriesBasalRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCaloriesBasalRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCaloriesBasalRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCaloriesBasalRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCaloriesBasalRequestFieldEndDate)
}

var (
	vitalsCaloriesBasalGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsCaloriesBasalGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsCaloriesBasalGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsCaloriesBasalGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsCaloriesBasalGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsCaloriesBasalGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCaloriesBasalGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsCaloriesBasalGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsCaloriesBasalGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCaloriesBasalGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCaloriesBasalGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCaloriesBasalGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCaloriesBasalGroupedRequestFieldEndDate)
}

var (
	vitalsCarbohydratesGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsCarbohydratesGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsCarbohydratesGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsCarbohydratesGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsCarbohydratesGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsCarbohydratesGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCarbohydratesGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCarbohydratesGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsCarbohydratesGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCarbohydratesGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsCarbohydratesGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCarbohydratesGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCarbohydratesGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCarbohydratesGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCarbohydratesGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCarbohydratesGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCarbohydratesGroupedRequestFieldEndDate)
}

var (
	vitalsCholesterolRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCholesterolRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCholesterolRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCholesterolRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCholesterolRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCholesterolRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCholesterolRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCholesterolRequestFieldEndDate)
}

var (
	vitalsCholesterolHdlRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCholesterolHdlRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCholesterolHdlRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCholesterolHdlRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCholesterolHdlRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolHdlRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCholesterolHdlRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolHdlRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCholesterolHdlRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolHdlRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCholesterolHdlRequestFieldEndDate)
}

var (
	vitalsCholesterolLdlRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCholesterolLdlRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCholesterolLdlRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCholesterolLdlRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCholesterolLdlRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolLdlRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCholesterolLdlRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolLdlRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCholesterolLdlRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolLdlRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCholesterolLdlRequestFieldEndDate)
}

var (
	vitalsCholesterolTotalRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCholesterolTotalRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCholesterolTotalRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCholesterolTotalRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCholesterolTotalRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolTotalRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCholesterolTotalRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolTotalRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCholesterolTotalRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolTotalRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCholesterolTotalRequestFieldEndDate)
}

var (
	vitalsCholesterolTriglyceridesRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsCholesterolTriglyceridesRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsCholesterolTriglyceridesRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsCholesterolTriglyceridesRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCholesterolTriglyceridesRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolTriglyceridesRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCholesterolTriglyceridesRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolTriglyceridesRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCholesterolTriglyceridesRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolTriglyceridesRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCholesterolTriglyceridesRequestFieldEndDate)
}

var (
	vitalsCholesterolGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsCholesterolGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsCholesterolGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsCholesterolGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsCholesterolGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsCholesterolGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsCholesterolGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsCholesterolGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsCholesterolGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsCholesterolGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsCholesterolGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsCholesterolGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsCholesterolGroupedRequestFieldEndDate)
}

var (
	vitalsDaylightExposureGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsDaylightExposureGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsDaylightExposureGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsDaylightExposureGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsDaylightExposureGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsDaylightExposureGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsDaylightExposureGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDaylightExposureGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsDaylightExposureGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDaylightExposureGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsDaylightExposureGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDaylightExposureGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsDaylightExposureGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDaylightExposureGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsDaylightExposureGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDaylightExposureGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsDaylightExposureGroupedRequestFieldEndDate)
}

var (
	vitalsDistanceRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsDistanceRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsDistanceRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsDistanceRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsDistanceRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsDistanceRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsDistanceRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsDistanceRequestFieldEndDate)
}

var (
	vitalsDistanceGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsDistanceGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsDistanceGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsDistanceGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsDistanceGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsDistanceGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsDistanceGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsDistanceGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsDistanceGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsDistanceGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsDistanceGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsDistanceGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsDistanceGroupedRequestFieldEndDate)
}

var (
	vitalsElectrocardiogramVoltageRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsElectrocardiogramVoltageRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsElectrocardiogramVoltageRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsElectrocardiogramVoltageRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsElectrocardiogramVoltageRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsElectrocardiogramVoltageRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsElectrocardiogramVoltageRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsElectrocardiogramVoltageRequestFieldEndDate)
}

var (
	vitalsElectrocardiogramVoltageGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsElectrocardiogramVoltageGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsElectrocardiogramVoltageGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsElectrocardiogramVoltageGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsElectrocardiogramVoltageGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsElectrocardiogramVoltageGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsElectrocardiogramVoltageGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsElectrocardiogramVoltageGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsElectrocardiogramVoltageGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsElectrocardiogramVoltageGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsElectrocardiogramVoltageGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsElectrocardiogramVoltageGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsElectrocardiogramVoltageGroupedRequestFieldEndDate)
}

var (
	vitalsFallGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsFallGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsFallGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsFallGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsFallGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsFallGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsFallGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFallGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsFallGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFallGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsFallGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFallGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsFallGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFallGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsFallGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFallGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsFallGroupedRequestFieldEndDate)
}

var (
	vitalsFloorsClimbedRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsFloorsClimbedRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsFloorsClimbedRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsFloorsClimbedRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsFloorsClimbedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsFloorsClimbedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsFloorsClimbedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsFloorsClimbedRequestFieldEndDate)
}

var (
	vitalsFloorsClimbedGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsFloorsClimbedGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsFloorsClimbedGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsFloorsClimbedGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsFloorsClimbedGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsFloorsClimbedGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsFloorsClimbedGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsFloorsClimbedGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsFloorsClimbedGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsFloorsClimbedGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsFloorsClimbedGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsFloorsClimbedGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsFloorsClimbedGroupedRequestFieldEndDate)
}

var (
	vitalsForcedExpiratoryVolume1GroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsForcedExpiratoryVolume1GroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsForcedExpiratoryVolume1GroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsForcedExpiratoryVolume1GroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsForcedExpiratoryVolume1GroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsForcedExpiratoryVolume1GroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsForcedExpiratoryVolume1GroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedExpiratoryVolume1GroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsForcedExpiratoryVolume1GroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedExpiratoryVolume1GroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsForcedExpiratoryVolume1GroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedExpiratoryVolume1GroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsForcedExpiratoryVolume1GroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedExpiratoryVolume1GroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsForcedExpiratoryVolume1GroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedExpiratoryVolume1GroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsForcedExpiratoryVolume1GroupedRequestFieldEndDate)
}

var (
	vitalsForcedVitalCapacityGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsForcedVitalCapacityGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsForcedVitalCapacityGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsForcedVitalCapacityGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsForcedVitalCapacityGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsForcedVitalCapacityGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsForcedVitalCapacityGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedVitalCapacityGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsForcedVitalCapacityGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedVitalCapacityGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsForcedVitalCapacityGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedVitalCapacityGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsForcedVitalCapacityGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedVitalCapacityGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsForcedVitalCapacityGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsForcedVitalCapacityGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsForcedVitalCapacityGroupedRequestFieldEndDate)
}

var (
	vitalsGlucoseRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsGlucoseRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsGlucoseRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsGlucoseRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsGlucoseRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsGlucoseRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsGlucoseRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsGlucoseRequestFieldEndDate)
}

var (
	vitalsGlucoseGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsGlucoseGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsGlucoseGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsGlucoseGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsGlucoseGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsGlucoseGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsGlucoseGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsGlucoseGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsGlucoseGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsGlucoseGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsGlucoseGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsGlucoseGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsGlucoseGroupedRequestFieldEndDate)
}

var (
	vitalsHandwashingGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsHandwashingGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsHandwashingGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsHandwashingGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsHandwashingGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsHandwashingGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHandwashingGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHandwashingGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsHandwashingGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHandwashingGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsHandwashingGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHandwashingGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHandwashingGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHandwashingGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHandwashingGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHandwashingGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHandwashingGroupedRequestFieldEndDate)
}

var (
	vitalsHeartRateAlertGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsHeartRateAlertGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsHeartRateAlertGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsHeartRateAlertGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsHeartRateAlertGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsHeartRateAlertGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHeartRateAlertGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateAlertGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsHeartRateAlertGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateAlertGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsHeartRateAlertGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateAlertGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHeartRateAlertGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateAlertGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHeartRateAlertGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateAlertGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHeartRateAlertGroupedRequestFieldEndDate)
}

var (
	vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsHeartRateRecoveryOneMinuteGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHeartRateRecoveryOneMinuteGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateRecoveryOneMinuteGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateRecoveryOneMinuteGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateRecoveryOneMinuteGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateRecoveryOneMinuteGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartRateRecoveryOneMinuteGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHeartRateRecoveryOneMinuteGroupedRequestFieldEndDate)
}

var (
	vitalsHeartrateRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsHeartrateRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsHeartrateRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsHeartrateRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHeartrateRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHeartrateRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHeartrateRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHeartrateRequestFieldEndDate)
}

var (
	vitalsHeartrateGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsHeartrateGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsHeartrateGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsHeartrateGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsHeartrateGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsHeartrateGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHeartrateGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsHeartrateGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsHeartrateGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHeartrateGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHeartrateGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHeartrateGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHeartrateGroupedRequestFieldEndDate)
}

var (
	vitalsHrvRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsHrvRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsHrvRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsHrvRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHrvRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHrvRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHrvRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHrvRequestFieldEndDate)
}

var (
	vitalsHrvGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsHrvGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsHrvGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsHrvGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsHrvGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsHrvGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHrvGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsHrvGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsHrvGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHrvGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHrvGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHrvGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHrvGroupedRequestFieldEndDate)
}

var (
	vitalsHypnogramRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsHypnogramRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsHypnogramRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsHypnogramRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHypnogramRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHypnogramRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHypnogramRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHypnogramRequestFieldEndDate)
}

var (
	vitalsHypnogramGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsHypnogramGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsHypnogramGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsHypnogramGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsHypnogramGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsHypnogramGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsHypnogramGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsHypnogramGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsHypnogramGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsHypnogramGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsHypnogramGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsHypnogramGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsHypnogramGroupedRequestFieldEndDate)
}

var (
	vitalsIgeRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsIgeRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsIgeRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsIgeRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsIgeRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsIgeRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsIgeRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsIgeRequestFieldEndDate)
}

var (
	vitalsIgeGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsIgeGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsIgeGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsIgeGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsIgeGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsIgeGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsIgeGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsIgeGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsIgeGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsIgeGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsIgeGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIgeGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsIgeGroupedRequestFieldEndDate)
}

var (
	vitalsIggRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsIggRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsIggRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsIggRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsIggRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsIggRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsIggRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsIggRequestFieldEndDate)
}

var (
	vitalsIggGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsIggGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsIggGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsIggGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsIggGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsIggGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsIggGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsIggGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsIggGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsIggGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsIggGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsIggGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsIggGroupedRequestFieldEndDate)
}

var (
	vitalsInhalerUsageGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsInhalerUsageGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsInhalerUsageGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsInhalerUsageGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsInhalerUsageGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsInhalerUsageGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsInhalerUsageGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInhalerUsageGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsInhalerUsageGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInhalerUsageGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsInhalerUsageGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInhalerUsageGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsInhalerUsageGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInhalerUsageGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsInhalerUsageGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInhalerUsageGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsInhalerUsageGroupedRequestFieldEndDate)
}

var (
	vitalsInsulinInjectionGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsInsulinInjectionGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsInsulinInjectionGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsInsulinInjectionGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsInsulinInjectionGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsInsulinInjectionGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsInsulinInjectionGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInsulinInjectionGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsInsulinInjectionGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInsulinInjectionGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsInsulinInjectionGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInsulinInjectionGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsInsulinInjectionGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInsulinInjectionGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsInsulinInjectionGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsInsulinInjectionGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsInsulinInjectionGroupedRequestFieldEndDate)
}

var (
	vitalsLeanBodyMassGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsLeanBodyMassGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsLeanBodyMassGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsLeanBodyMassGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsLeanBodyMassGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsLeanBodyMassGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsLeanBodyMassGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsLeanBodyMassGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsLeanBodyMassGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsLeanBodyMassGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsLeanBodyMassGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsLeanBodyMassGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsLeanBodyMassGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsLeanBodyMassGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsLeanBodyMassGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsLeanBodyMassGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsLeanBodyMassGroupedRequestFieldEndDate)
}

var (
	vitalsMindfulnessMinutesRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsMindfulnessMinutesRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsMindfulnessMinutesRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsMindfulnessMinutesRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsMindfulnessMinutesRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsMindfulnessMinutesRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsMindfulnessMinutesRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsMindfulnessMinutesRequestFieldEndDate)
}

var (
	vitalsMindfulnessMinutesGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsMindfulnessMinutesGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsMindfulnessMinutesGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsMindfulnessMinutesGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsMindfulnessMinutesGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsMindfulnessMinutesGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsMindfulnessMinutesGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsMindfulnessMinutesGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsMindfulnessMinutesGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsMindfulnessMinutesGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsMindfulnessMinutesGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsMindfulnessMinutesGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsMindfulnessMinutesGroupedRequestFieldEndDate)
}

var (
	vitalsNoteGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsNoteGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsNoteGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsNoteGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsNoteGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsNoteGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsNoteGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsNoteGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsNoteGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsNoteGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsNoteGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsNoteGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsNoteGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsNoteGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsNoteGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsNoteGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsNoteGroupedRequestFieldEndDate)
}

var (
	vitalsPeakExpiratoryFlowRateGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsPeakExpiratoryFlowRateGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsPeakExpiratoryFlowRateGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsPeakExpiratoryFlowRateGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsPeakExpiratoryFlowRateGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsPeakExpiratoryFlowRateGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsPeakExpiratoryFlowRateGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsPeakExpiratoryFlowRateGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsPeakExpiratoryFlowRateGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsPeakExpiratoryFlowRateGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsPeakExpiratoryFlowRateGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsPeakExpiratoryFlowRateGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsPeakExpiratoryFlowRateGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsPeakExpiratoryFlowRateGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsPeakExpiratoryFlowRateGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsPeakExpiratoryFlowRateGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsPeakExpiratoryFlowRateGroupedRequestFieldEndDate)
}

var (
	vitalsRespiratoryRateRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsRespiratoryRateRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsRespiratoryRateRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsRespiratoryRateRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsRespiratoryRateRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsRespiratoryRateRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsRespiratoryRateRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsRespiratoryRateRequestFieldEndDate)
}

var (
	vitalsRespiratoryRateGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsRespiratoryRateGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsRespiratoryRateGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsRespiratoryRateGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsRespiratoryRateGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsRespiratoryRateGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsRespiratoryRateGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsRespiratoryRateGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsRespiratoryRateGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsRespiratoryRateGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsRespiratoryRateGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsRespiratoryRateGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsRespiratoryRateGroupedRequestFieldEndDate)
}

var (
	vitalsSleepApneaAlertGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsSleepApneaAlertGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsSleepApneaAlertGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsSleepApneaAlertGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsSleepApneaAlertGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsSleepApneaAlertGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsSleepApneaAlertGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepApneaAlertGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsSleepApneaAlertGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepApneaAlertGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsSleepApneaAlertGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepApneaAlertGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsSleepApneaAlertGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepApneaAlertGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsSleepApneaAlertGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepApneaAlertGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsSleepApneaAlertGroupedRequestFieldEndDate)
}

var (
	vitalsSleepBreathingDisturbanceGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsSleepBreathingDisturbanceGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsSleepBreathingDisturbanceGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsSleepBreathingDisturbanceGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsSleepBreathingDisturbanceGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsSleepBreathingDisturbanceGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsSleepBreathingDisturbanceGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepBreathingDisturbanceGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsSleepBreathingDisturbanceGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepBreathingDisturbanceGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsSleepBreathingDisturbanceGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepBreathingDisturbanceGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsSleepBreathingDisturbanceGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepBreathingDisturbanceGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsSleepBreathingDisturbanceGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsSleepBreathingDisturbanceGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsSleepBreathingDisturbanceGroupedRequestFieldEndDate)
}

var (
	vitalsStandDurationGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsStandDurationGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsStandDurationGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsStandDurationGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsStandDurationGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsStandDurationGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsStandDurationGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandDurationGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsStandDurationGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandDurationGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsStandDurationGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandDurationGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsStandDurationGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandDurationGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsStandDurationGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandDurationGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsStandDurationGroupedRequestFieldEndDate)
}

var (
	vitalsStandHourGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsStandHourGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsStandHourGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsStandHourGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsStandHourGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsStandHourGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsStandHourGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandHourGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsStandHourGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandHourGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsStandHourGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandHourGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsStandHourGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandHourGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsStandHourGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStandHourGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsStandHourGroupedRequestFieldEndDate)
}

var (
	vitalsStepsRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsStepsRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsStepsRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsStepsRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsStepsRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsStepsRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsStepsRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsStepsRequestFieldEndDate)
}

var (
	vitalsStepsGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsStepsGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsStepsGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsStepsGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsStepsGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsStepsGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsStepsGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsStepsGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsStepsGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsStepsGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsStepsGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStepsGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsStepsGroupedRequestFieldEndDate)
}

var (
	vitalsStressLevelRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsStressLevelRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsStressLevelRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsStressLevelRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsStressLevelRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsStressLevelRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsStressLevelRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsStressLevelRequestFieldEndDate)
}

var (
	vitalsStressLevelGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsStressLevelGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsStressLevelGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsStressLevelGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsStressLevelGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsStressLevelGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsStressLevelGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsStressLevelGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsStressLevelGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsStressLevelGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsStressLevelGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsStressLevelGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsStressLevelGroupedRequestFieldEndDate)
}

var (
	clientFacingAFibBurdenSampleFieldId             = big.NewInt(1 << 0)
	clientFacingAFibBurdenSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingAFibBurdenSampleFieldType           = big.NewInt(1 << 2)
	clientFacingAFibBurdenSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingAFibBurdenSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingAFibBurdenSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingAFibBurdenSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingAFibBurdenSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingAFibBurdenSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingAFibBurdenSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingAFibBurdenSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingAFibBurdenSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingAFibBurdenSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingAFibBurdenSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingAFibBurdenSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingAFibBurdenSample) Unit() string {
	return c.unit
}

func (c *ClientFacingAFibBurdenSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingAFibBurdenSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingAFibBurdenSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingAFibBurdenSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingAFibBurdenSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingAFibBurdenSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingAFibBurdenSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingAFibBurdenSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingAFibBurdenSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingAFibBurdenSampleFieldValue)
}

func (c *ClientFacingAFibBurdenSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingAFibBurdenSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingAFibBurdenSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "%" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "%", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingAFibBurdenSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingAFibBurdenSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "%",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingAFibBurdenSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBasalBodyTemperatureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBasalBodyTemperatureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBasalBodyTemperatureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBasalBodyTemperatureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBasalBodyTemperatureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBasalBodyTemperatureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBasalBodyTemperatureSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingBasalBodyTemperatureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBasalBodyTemperatureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBasalBodyTemperatureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBasalBodyTemperatureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBasalBodyTemperatureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBasalBodyTemperatureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBasalBodyTemperatureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBasalBodyTemperatureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBasalBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBasalBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBasalBodyTemperatureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBasalBodyTemperatureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBasalBodyTemperatureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBasalBodyTemperatureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBasalBodyTemperatureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBasalBodyTemperatureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBasalBodyTemperatureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBasalBodyTemperatureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBasalBodyTemperatureSampleFieldValue)
}

func (c *ClientFacingBasalBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBasalBodyTemperatureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBasalBodyTemperatureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBasalBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBasalBodyTemperatureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "C",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBasalBodyTemperatureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBloodOxygenTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBloodOxygenTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBloodOxygenTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBloodOxygenTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBloodOxygenTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingBloodOxygenTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingBloodOxygenTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (spo2).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBloodOxygenTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBloodOxygenTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBloodOxygenTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBloodOxygenTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBloodOxygenTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBloodOxygenTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBloodOxygenTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodOxygenTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBloodOxygenTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBloodOxygenTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBloodOxygenTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBloodOxygenTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBloodOxygenTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodOxygenTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBloodOxygenTimeseriesFieldValue)
}

func (c *ClientFacingBloodOxygenTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodOxygenTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodOxygenTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodOxygenTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodOxygenTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBloodOxygenTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBloodPressureTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBloodPressureTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBloodPressureTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBloodPressureTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBloodPressureTimeseriesFieldGrouping       = big.NewInt(1 << 4)
	clientFacingBloodPressureTimeseriesFieldTimestamp      = big.NewInt(1 << 5)
	clientFacingBloodPressureTimeseriesFieldSystolic       = big.NewInt(1 << 6)
	clientFacingBloodPressureTimeseriesFieldDiastolic      = big.NewInt(1 << 7)
)

type ClientFacingBloodPressureTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unit of the value. We use SI units where possible, e.g. mmol/L for glucose/cholesterol, bpm for heart rate, etc.
	Unit      string                          `json:"unit" url:"unit"`
	Grouping  *ClientFacingSampleGroupingKeys `json:"grouping,omitempty" url:"grouping,omitempty"`
	Timestamp time.Time                       `json:"timestamp" url:"timestamp"`
	Systolic  float64                         `json:"systolic" url:"systolic"`
	Diastolic float64                         `json:"diastolic" url:"diastolic"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBloodPressureTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBloodPressureTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBloodPressureTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBloodPressureTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBloodPressureTimeseries) GetGrouping() *ClientFacingSampleGroupingKeys {
	if c == nil {
		return nil
	}
	return c.Grouping
}

func (c *ClientFacingBloodPressureTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBloodPressureTimeseries) GetSystolic() float64 {
	if c == nil {
		return 0
	}
	return c.Systolic
}

func (c *ClientFacingBloodPressureTimeseries) GetDiastolic() float64 {
	if c == nil {
		return 0
	}
	return c.Diastolic
}

func (c *ClientFacingBloodPressureTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBloodPressureTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBloodPressureTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBloodPressureTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBloodPressureTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBloodPressureTimeseriesFieldUnit)
}

// SetGrouping sets the Grouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetGrouping(grouping *ClientFacingSampleGroupingKeys) {
	c.Grouping = grouping
	c.require(clientFacingBloodPressureTimeseriesFieldGrouping)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBloodPressureTimeseriesFieldTimestamp)
}

// SetSystolic sets the Systolic field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetSystolic(systolic float64) {
	c.Systolic = systolic
	c.require(clientFacingBloodPressureTimeseriesFieldSystolic)
}

// SetDiastolic sets the Diastolic field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBloodPressureTimeseries) SetDiastolic(diastolic float64) {
	c.Diastolic = diastolic
	c.require(clientFacingBloodPressureTimeseriesFieldDiastolic)
}

func (c *ClientFacingBloodPressureTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBloodPressureTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBloodPressureTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBloodPressureTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBloodPressureTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBloodPressureTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBodyFatTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBodyFatTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyFatTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBodyFatTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBodyFatTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingBodyFatTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingBodyFatTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyFatTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyFatTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyFatTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyFatTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBodyFatTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyFatTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyFatTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyFatTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyFatTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyFatTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyFatTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBodyFatTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyFatTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyFatTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyFatTimeseriesFieldValue)
}

func (c *ClientFacingBodyFatTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyFatTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyFatTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyFatTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyFatTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyFatTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBodyMassIndexSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBodyMassIndexSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyMassIndexSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBodyMassIndexSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBodyMassIndexSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBodyMassIndexSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBodyMassIndexSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingBodyMassIndexSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyMassIndexSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyMassIndexSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyMassIndexSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyMassIndexSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyMassIndexSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBodyMassIndexSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBodyMassIndexSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyMassIndexSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyMassIndexSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyMassIndexSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyMassIndexSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyMassIndexSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyMassIndexSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyMassIndexSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBodyMassIndexSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBodyMassIndexSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyMassIndexSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyMassIndexSampleFieldValue)
}

func (c *ClientFacingBodyMassIndexSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyMassIndexSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyMassIndexSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "index" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "index", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyMassIndexSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyMassIndexSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "index",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyMassIndexSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingBodyTemperatureDeltaSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBodyTemperatureDeltaSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyTemperatureDeltaSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBodyTemperatureDeltaSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBodyTemperatureDeltaSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBodyTemperatureDeltaSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBodyTemperatureDeltaSampleFieldValue          = big.NewInt(1 << 6)
	clientFacingBodyTemperatureDeltaSampleFieldSensorLocation = big.NewInt(1 << 7)
)

type ClientFacingBodyTemperatureDeltaSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.  This enum is non-exhaustive.
	SensorLocation *ClientFacingBodyTemperatureDeltaSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetSensorLocation() *ClientFacingBodyTemperatureDeltaSampleSensorLocation {
	if c == nil {
		return nil
	}
	return c.SensorLocation
}

func (c *ClientFacingBodyTemperatureDeltaSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureDeltaSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureDeltaSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyTemperatureDeltaSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyTemperatureDeltaSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyTemperatureDeltaSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyTemperatureDeltaSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBodyTemperatureDeltaSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBodyTemperatureDeltaSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyTemperatureDeltaSampleFieldValue)
}

// SetSensorLocation sets the SensorLocation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureDeltaSample) SetSensorLocation(sensorLocation *ClientFacingBodyTemperatureDeltaSampleSensorLocation) {
	c.SensorLocation = sensorLocation
	c.require(clientFacingBodyTemperatureDeltaSampleFieldSensorLocation)
}

func (c *ClientFacingBodyTemperatureDeltaSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureDeltaSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureDeltaSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureDeltaSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureDeltaSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "C",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyTemperatureDeltaSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureDeltaSampleSensorLocation string

const (
	ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationBody             ClientFacingBodyTemperatureDeltaSampleSensorLocation = "body"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEar              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureDeltaSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum           ClientFacingBodyTemperatureDeltaSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationToe              ClientFacingBodyTemperatureDeltaSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum          ClientFacingBodyTemperatureDeltaSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureDeltaSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead         ClientFacingBodyTemperatureDeltaSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist            ClientFacingBodyTemperatureDeltaSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureDeltaSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureDeltaSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureDeltaSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureDeltaSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureDeltaSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureDeltaSampleSensorLocation {
	return &c
}

var (
	clientFacingBodyTemperatureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingBodyTemperatureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyTemperatureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingBodyTemperatureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingBodyTemperatureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingBodyTemperatureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingBodyTemperatureSampleFieldValue          = big.NewInt(1 << 6)
	clientFacingBodyTemperatureSampleFieldSensorLocation = big.NewInt(1 << 7)
)

type ClientFacingBodyTemperatureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Location of the temperature sensor.  This enum is non-exhaustive.
	SensorLocation *ClientFacingBodyTemperatureSampleSensorLocation `json:"sensor_location,omitempty" url:"sensor_location,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyTemperatureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyTemperatureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyTemperatureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyTemperatureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyTemperatureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingBodyTemperatureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingBodyTemperatureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyTemperatureSample) GetSensorLocation() *ClientFacingBodyTemperatureSampleSensorLocation {
	if c == nil {
		return nil
	}
	return c.SensorLocation
}

func (c *ClientFacingBodyTemperatureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingBodyTemperatureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyTemperatureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyTemperatureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyTemperatureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyTemperatureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyTemperatureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingBodyTemperatureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingBodyTemperatureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyTemperatureSampleFieldValue)
}

// SetSensorLocation sets the SensorLocation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyTemperatureSample) SetSensorLocation(sensorLocation *ClientFacingBodyTemperatureSampleSensorLocation) {
	c.SensorLocation = sensorLocation
	c.require(clientFacingBodyTemperatureSampleFieldSensorLocation)
}

func (c *ClientFacingBodyTemperatureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyTemperatureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyTemperatureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "C" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "C", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyTemperatureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyTemperatureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "C",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyTemperatureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingBodyTemperatureSampleSensorLocation string

const (
	ClientFacingBodyTemperatureSampleSensorLocationArmpit           ClientFacingBodyTemperatureSampleSensorLocation = "armpit"
	ClientFacingBodyTemperatureSampleSensorLocationBody             ClientFacingBodyTemperatureSampleSensorLocation = "body"
	ClientFacingBodyTemperatureSampleSensorLocationEar              ClientFacingBodyTemperatureSampleSensorLocation = "ear"
	ClientFacingBodyTemperatureSampleSensorLocationFinger           ClientFacingBodyTemperatureSampleSensorLocation = "finger"
	ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal ClientFacingBodyTemperatureSampleSensorLocation = "gastrointestinal"
	ClientFacingBodyTemperatureSampleSensorLocationMouth            ClientFacingBodyTemperatureSampleSensorLocation = "mouth"
	ClientFacingBodyTemperatureSampleSensorLocationRectum           ClientFacingBodyTemperatureSampleSensorLocation = "rectum"
	ClientFacingBodyTemperatureSampleSensorLocationToe              ClientFacingBodyTemperatureSampleSensorLocation = "toe"
	ClientFacingBodyTemperatureSampleSensorLocationEardrum          ClientFacingBodyTemperatureSampleSensorLocation = "eardrum"
	ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery   ClientFacingBodyTemperatureSampleSensorLocation = "temporal_artery"
	ClientFacingBodyTemperatureSampleSensorLocationForehead         ClientFacingBodyTemperatureSampleSensorLocation = "forehead"
	ClientFacingBodyTemperatureSampleSensorLocationWrist            ClientFacingBodyTemperatureSampleSensorLocation = "wrist"
)

func NewClientFacingBodyTemperatureSampleSensorLocationFromString(s string) (ClientFacingBodyTemperatureSampleSensorLocation, error) {
	switch s {
	case "armpit":
		return ClientFacingBodyTemperatureSampleSensorLocationArmpit, nil
	case "body":
		return ClientFacingBodyTemperatureSampleSensorLocationBody, nil
	case "ear":
		return ClientFacingBodyTemperatureSampleSensorLocationEar, nil
	case "finger":
		return ClientFacingBodyTemperatureSampleSensorLocationFinger, nil
	case "gastrointestinal":
		return ClientFacingBodyTemperatureSampleSensorLocationGastrointestinal, nil
	case "mouth":
		return ClientFacingBodyTemperatureSampleSensorLocationMouth, nil
	case "rectum":
		return ClientFacingBodyTemperatureSampleSensorLocationRectum, nil
	case "toe":
		return ClientFacingBodyTemperatureSampleSensorLocationToe, nil
	case "eardrum":
		return ClientFacingBodyTemperatureSampleSensorLocationEardrum, nil
	case "temporal_artery":
		return ClientFacingBodyTemperatureSampleSensorLocationTemporalArtery, nil
	case "forehead":
		return ClientFacingBodyTemperatureSampleSensorLocationForehead, nil
	case "wrist":
		return ClientFacingBodyTemperatureSampleSensorLocationWrist, nil
	}
	var t ClientFacingBodyTemperatureSampleSensorLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingBodyTemperatureSampleSensorLocation) Ptr() *ClientFacingBodyTemperatureSampleSensorLocation {
	return &c
}

var (
	clientFacingBodyWeightTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingBodyWeightTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingBodyWeightTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingBodyWeightTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingBodyWeightTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingBodyWeightTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingBodyWeightTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilograms (kg).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingBodyWeightTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingBodyWeightTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingBodyWeightTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingBodyWeightTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingBodyWeightTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingBodyWeightTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingBodyWeightTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingBodyWeightTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingBodyWeightTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingBodyWeightTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingBodyWeightTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingBodyWeightTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingBodyWeightTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingBodyWeightTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingBodyWeightTimeseriesFieldValue)
}

func (c *ClientFacingBodyWeightTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingBodyWeightTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingBodyWeightTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingBodyWeightTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingBodyWeightTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingBodyWeightTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCaffeineTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCaffeineTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCaffeineTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCaffeineTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingCaffeineTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingCaffeineTimeseriesFieldStart          = big.NewInt(1 << 5)
	clientFacingCaffeineTimeseriesFieldEnd            = big.NewInt(1 << 6)
	clientFacingCaffeineTimeseriesFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingCaffeineTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Quantity of caffeine consumed during the time period.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCaffeineTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCaffeineTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCaffeineTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCaffeineTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingCaffeineTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCaffeineTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingCaffeineTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingCaffeineTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCaffeineTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaffeineTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCaffeineTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCaffeineTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCaffeineTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingCaffeineTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCaffeineTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingCaffeineTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingCaffeineTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaffeineTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCaffeineTimeseriesFieldValue)
}

func (c *ClientFacingCaffeineTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaffeineTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaffeineTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaffeineTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaffeineTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCaffeineTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCaloriesActiveTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCaloriesActiveTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCaloriesActiveTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCaloriesActiveTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingCaloriesActiveTimeseriesFieldStart          = big.NewInt(1 << 4)
	clientFacingCaloriesActiveTimeseriesFieldEnd            = big.NewInt(1 << 5)
	clientFacingCaloriesActiveTimeseriesFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingCaloriesActiveTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Energy consumption caused by the physical activity at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCaloriesActiveTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCaloriesActiveTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCaloriesActiveTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCaloriesActiveTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCaloriesActiveTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingCaloriesActiveTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingCaloriesActiveTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCaloriesActiveTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesActiveTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesActiveTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCaloriesActiveTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCaloriesActiveTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCaloriesActiveTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCaloriesActiveTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingCaloriesActiveTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingCaloriesActiveTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesActiveTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCaloriesActiveTimeseriesFieldValue)
}

func (c *ClientFacingCaloriesActiveTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesActiveTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesActiveTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesActiveTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesActiveTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "kcal",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCaloriesActiveTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCaloriesBasalTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCaloriesBasalTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCaloriesBasalTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCaloriesBasalTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingCaloriesBasalTimeseriesFieldValue          = big.NewInt(1 << 4)
)

type ClientFacingCaloriesBasalTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in kilocalories (kcal)
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Basal Metabolic Rate at the time or interval::kilocalories
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCaloriesBasalTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCaloriesBasalTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCaloriesBasalTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCaloriesBasalTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCaloriesBasalTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCaloriesBasalTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingCaloriesBasalTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCaloriesBasalTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCaloriesBasalTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCaloriesBasalTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCaloriesBasalTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCaloriesBasalTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCaloriesBasalTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCaloriesBasalTimeseriesFieldValue)
}

func (c *ClientFacingCaloriesBasalTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCaloriesBasalTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCaloriesBasalTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	if unmarshaler.Unit != "kcal" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kcal", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCaloriesBasalTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCaloriesBasalTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Unit:      "kcal",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCaloriesBasalTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCarbohydratesSampleFieldId             = big.NewInt(1 << 0)
	clientFacingCarbohydratesSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCarbohydratesSampleFieldType           = big.NewInt(1 << 2)
	clientFacingCarbohydratesSampleFieldUnit           = big.NewInt(1 << 3)
	clientFacingCarbohydratesSampleFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingCarbohydratesSampleFieldStart          = big.NewInt(1 << 5)
	clientFacingCarbohydratesSampleFieldEnd            = big.NewInt(1 << 6)
	clientFacingCarbohydratesSampleFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingCarbohydratesSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in grams.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCarbohydratesSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCarbohydratesSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCarbohydratesSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingCarbohydratesSample) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingCarbohydratesSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCarbohydratesSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingCarbohydratesSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingCarbohydratesSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCarbohydratesSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCarbohydratesSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCarbohydratesSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCarbohydratesSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingCarbohydratesSampleFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingCarbohydratesSampleFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCarbohydratesSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingCarbohydratesSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingCarbohydratesSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCarbohydratesSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCarbohydratesSampleFieldValue)
}

func (c *ClientFacingCarbohydratesSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCarbohydratesSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCarbohydratesSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCarbohydratesSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCarbohydratesSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCarbohydratesSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingCholesterolTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingCholesterolTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingCholesterolTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingCholesterolTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingCholesterolTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingCholesterolTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingCholesterolTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in mmol/L.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingCholesterolTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingCholesterolTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingCholesterolTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingCholesterolTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingCholesterolTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingCholesterolTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingCholesterolTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingCholesterolTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingCholesterolTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingCholesterolTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingCholesterolTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingCholesterolTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingCholesterolTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingCholesterolTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingCholesterolTimeseriesFieldValue)
}

func (c *ClientFacingCholesterolTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingCholesterolTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingCholesterolTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingCholesterolTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingCholesterolTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingCholesterolTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingDaylightExposureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingDaylightExposureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingDaylightExposureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingDaylightExposureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingDaylightExposureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingDaylightExposureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingDaylightExposureSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingDaylightExposureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingDaylightExposureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingDaylightExposureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingDaylightExposureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingDaylightExposureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingDaylightExposureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingDaylightExposureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingDaylightExposureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingDaylightExposureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingDaylightExposureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDaylightExposureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingDaylightExposureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingDaylightExposureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingDaylightExposureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingDaylightExposureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingDaylightExposureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingDaylightExposureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDaylightExposureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingDaylightExposureSampleFieldValue)
}

func (c *ClientFacingDaylightExposureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDaylightExposureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDaylightExposureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDaylightExposureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDaylightExposureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingDaylightExposureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingDistanceTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingDistanceTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingDistanceTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingDistanceTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingDistanceTimeseriesFieldStart          = big.NewInt(1 << 4)
	clientFacingDistanceTimeseriesFieldEnd            = big.NewInt(1 << 5)
	clientFacingDistanceTimeseriesFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingDistanceTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in meters (m)
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Distance traveled during activities at the time or interval::steps
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingDistanceTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingDistanceTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingDistanceTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingDistanceTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingDistanceTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingDistanceTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingDistanceTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingDistanceTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingDistanceTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingDistanceTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingDistanceTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingDistanceTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingDistanceTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingDistanceTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingDistanceTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingDistanceTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingDistanceTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingDistanceTimeseriesFieldValue)
}

func (c *ClientFacingDistanceTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingDistanceTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingDistanceTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "m" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "m", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingDistanceTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingDistanceTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "m",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingDistanceTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingElectrocardiogramVoltageTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingElectrocardiogramVoltageTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingElectrocardiogramVoltageTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingElectrocardiogramVoltageTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingElectrocardiogramVoltageTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingElectrocardiogramVoltageTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingElectrocardiogramVoltageTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The lead of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in mV.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingElectrocardiogramVoltageTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingElectrocardiogramVoltageTimeseriesFieldValue)
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingElectrocardiogramVoltageTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingElectrocardiogramVoltageTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingElectrocardiogramVoltageTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingElectrocardiogramVoltageTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingFallSampleFieldId             = big.NewInt(1 << 0)
	clientFacingFallSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingFallSampleFieldType           = big.NewInt(1 << 2)
	clientFacingFallSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingFallSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingFallSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingFallSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingFallSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingFallSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingFallSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingFallSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingFallSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingFallSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingFallSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingFallSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingFallSample) Unit() string {
	return c.unit
}

func (c *ClientFacingFallSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFallSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingFallSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingFallSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingFallSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingFallSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingFallSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingFallSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFallSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingFallSampleFieldValue)
}

func (c *ClientFacingFallSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFallSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFallSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFallSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFallSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingFallSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingFloorsClimbedTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingFloorsClimbedTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingFloorsClimbedTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingFloorsClimbedTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingFloorsClimbedTimeseriesFieldValue          = big.NewInt(1 << 4)
)

type ClientFacingFloorsClimbedTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Number of floors climbed at the time or interval::count
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingFloorsClimbedTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingFloorsClimbedTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingFloorsClimbedTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingFloorsClimbedTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingFloorsClimbedTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingFloorsClimbedTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingFloorsClimbedTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingFloorsClimbedTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingFloorsClimbedTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingFloorsClimbedTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingFloorsClimbedTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingFloorsClimbedTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingFloorsClimbedTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingFloorsClimbedTimeseriesFieldValue)
}

func (c *ClientFacingFloorsClimbedTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingFloorsClimbedTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingFloorsClimbedTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingFloorsClimbedTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingFloorsClimbedTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingFloorsClimbedTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingForcedExpiratoryVolume1SampleFieldId             = big.NewInt(1 << 0)
	clientFacingForcedExpiratoryVolume1SampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingForcedExpiratoryVolume1SampleFieldType           = big.NewInt(1 << 2)
	clientFacingForcedExpiratoryVolume1SampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingForcedExpiratoryVolume1SampleFieldStart          = big.NewInt(1 << 4)
	clientFacingForcedExpiratoryVolume1SampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingForcedExpiratoryVolume1SampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingForcedExpiratoryVolume1Sample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) Unit() string {
	return c.unit
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedExpiratoryVolume1Sample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingForcedExpiratoryVolume1SampleFieldValue)
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedExpiratoryVolume1Sample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedExpiratoryVolume1Sample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedExpiratoryVolume1Sample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "L",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingForcedExpiratoryVolume1Sample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingForcedVitalCapacitySampleFieldId             = big.NewInt(1 << 0)
	clientFacingForcedVitalCapacitySampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingForcedVitalCapacitySampleFieldType           = big.NewInt(1 << 2)
	clientFacingForcedVitalCapacitySampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingForcedVitalCapacitySampleFieldStart          = big.NewInt(1 << 4)
	clientFacingForcedVitalCapacitySampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingForcedVitalCapacitySampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingForcedVitalCapacitySample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingForcedVitalCapacitySample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingForcedVitalCapacitySample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingForcedVitalCapacitySample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingForcedVitalCapacitySample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingForcedVitalCapacitySample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingForcedVitalCapacitySample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingForcedVitalCapacitySample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingForcedVitalCapacitySample) Unit() string {
	return c.unit
}

func (c *ClientFacingForcedVitalCapacitySample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingForcedVitalCapacitySample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingForcedVitalCapacitySampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingForcedVitalCapacitySampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingForcedVitalCapacitySampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingForcedVitalCapacitySampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingForcedVitalCapacitySampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingForcedVitalCapacitySampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingForcedVitalCapacitySample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingForcedVitalCapacitySampleFieldValue)
}

func (c *ClientFacingForcedVitalCapacitySample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingForcedVitalCapacitySample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingForcedVitalCapacitySample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingForcedVitalCapacitySample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingForcedVitalCapacitySample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "L",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingForcedVitalCapacitySample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingGlucoseTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingGlucoseTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingGlucoseTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingGlucoseTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingGlucoseTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingGlucoseTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingGlucoseTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mmol/L.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingGlucoseTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingGlucoseTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingGlucoseTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingGlucoseTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingGlucoseTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingGlucoseTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingGlucoseTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingGlucoseTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingGlucoseTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingGlucoseTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingGlucoseTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingGlucoseTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingGlucoseTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingGlucoseTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingGlucoseTimeseriesFieldValue)
}

func (c *ClientFacingGlucoseTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingGlucoseTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingGlucoseTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingGlucoseTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingGlucoseTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingGlucoseTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingHandwashingSampleFieldId             = big.NewInt(1 << 0)
	clientFacingHandwashingSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingHandwashingSampleFieldType           = big.NewInt(1 << 2)
	clientFacingHandwashingSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingHandwashingSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingHandwashingSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingHandwashingSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingHandwashingSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingHandwashingSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingHandwashingSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingHandwashingSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingHandwashingSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingHandwashingSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingHandwashingSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingHandwashingSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingHandwashingSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHandwashingSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHandwashingSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingHandwashingSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingHandwashingSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingHandwashingSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingHandwashingSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingHandwashingSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingHandwashingSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHandwashingSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingHandwashingSampleFieldValue)
}

func (c *ClientFacingHandwashingSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHandwashingSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHandwashingSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHandwashingSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHandwashingSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingHandwashingSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingHeartRateAlertSampleFieldId             = big.NewInt(1 << 0)
	clientFacingHeartRateAlertSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingHeartRateAlertSampleFieldType           = big.NewInt(1 << 2)
	clientFacingHeartRateAlertSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingHeartRateAlertSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingHeartRateAlertSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingHeartRateAlertSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingHeartRateAlertSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of heart rate alert.  This enum is non-exhaustive.
	Type ClientFacingHeartRateAlertSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End   time.Time `json:"end" url:"end"`
	Value int       `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingHeartRateAlertSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingHeartRateAlertSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingHeartRateAlertSample) GetType() ClientFacingHeartRateAlertSampleType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingHeartRateAlertSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingHeartRateAlertSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingHeartRateAlertSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingHeartRateAlertSample) GetValue() int {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingHeartRateAlertSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHeartRateAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateAlertSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingHeartRateAlertSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingHeartRateAlertSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetType(type_ ClientFacingHeartRateAlertSampleType) {
	c.Type = type_
	c.require(clientFacingHeartRateAlertSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingHeartRateAlertSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingHeartRateAlertSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingHeartRateAlertSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateAlertSample) SetValue(value int) {
	c.Value = value
	c.require(clientFacingHeartRateAlertSampleFieldValue)
}

func (c *ClientFacingHeartRateAlertSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateAlertSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateAlertSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateAlertSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateAlertSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingHeartRateAlertSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of heart rate alert.  This enum is non-exhaustive.
type ClientFacingHeartRateAlertSampleType string

const (
	ClientFacingHeartRateAlertSampleTypeLowHeartRate    ClientFacingHeartRateAlertSampleType = "low_heart_rate"
	ClientFacingHeartRateAlertSampleTypeHighHeartRate   ClientFacingHeartRateAlertSampleType = "high_heart_rate"
	ClientFacingHeartRateAlertSampleTypeIrregularRhythm ClientFacingHeartRateAlertSampleType = "irregular_rhythm"
)

func NewClientFacingHeartRateAlertSampleTypeFromString(s string) (ClientFacingHeartRateAlertSampleType, error) {
	switch s {
	case "low_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeLowHeartRate, nil
	case "high_heart_rate":
		return ClientFacingHeartRateAlertSampleTypeHighHeartRate, nil
	case "irregular_rhythm":
		return ClientFacingHeartRateAlertSampleTypeIrregularRhythm, nil
	}
	var t ClientFacingHeartRateAlertSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingHeartRateAlertSampleType) Ptr() *ClientFacingHeartRateAlertSampleType {
	return &c
}

var (
	clientFacingHeartRateRecoveryOneMinuteSampleFieldId             = big.NewInt(1 << 0)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldType           = big.NewInt(1 << 2)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingHeartRateRecoveryOneMinuteSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingHeartRateRecoveryOneMinuteSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) Unit() string {
	return c.unit
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingHeartRateRecoveryOneMinuteSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingHeartRateRecoveryOneMinuteSampleFieldValue)
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingHeartRateRecoveryOneMinuteSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingHeartRateRecoveryOneMinuteSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingHeartRateRecoveryOneMinuteSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingHeartRateRecoveryOneMinuteSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingIgeTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingIgeTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingIgeTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingIgeTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingIgeTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingIgeTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingIgeTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in FSU.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingIgeTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingIgeTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingIgeTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingIgeTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingIgeTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingIgeTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingIgeTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIgeTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingIgeTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingIgeTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingIgeTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingIgeTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingIgeTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIgeTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingIgeTimeseriesFieldValue)
}

func (c *ClientFacingIgeTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIgeTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIgeTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIgeTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIgeTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingIgeTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingIggTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingIggTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingIggTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingIggTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingIggTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingIggTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingIggTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The reading type of the measurement.
	Type string `json:"type" url:"type"`
	// Measured in FSU.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The value of the measurement.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingIggTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingIggTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingIggTimeseries) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingIggTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingIggTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingIggTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingIggTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingIggTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingIggTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingIggTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetType(type_ string) {
	c.Type = type_
	c.require(clientFacingIggTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingIggTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingIggTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingIggTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingIggTimeseriesFieldValue)
}

func (c *ClientFacingIggTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingIggTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingIggTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingIggTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingIggTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingIggTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingInhalerUsageSampleFieldId             = big.NewInt(1 << 0)
	clientFacingInhalerUsageSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingInhalerUsageSampleFieldType           = big.NewInt(1 << 2)
	clientFacingInhalerUsageSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingInhalerUsageSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingInhalerUsageSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingInhalerUsageSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingInhalerUsageSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingInhalerUsageSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingInhalerUsageSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingInhalerUsageSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingInhalerUsageSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingInhalerUsageSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingInhalerUsageSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingInhalerUsageSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingInhalerUsageSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInhalerUsageSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInhalerUsageSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingInhalerUsageSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingInhalerUsageSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingInhalerUsageSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingInhalerUsageSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingInhalerUsageSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingInhalerUsageSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInhalerUsageSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingInhalerUsageSampleFieldValue)
}

func (c *ClientFacingInhalerUsageSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInhalerUsageSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInhalerUsageSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInhalerUsageSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInhalerUsageSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingInhalerUsageSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingInsulinInjectionSampleFieldId             = big.NewInt(1 << 0)
	clientFacingInsulinInjectionSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingInsulinInjectionSampleFieldType           = big.NewInt(1 << 2)
	clientFacingInsulinInjectionSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingInsulinInjectionSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingInsulinInjectionSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingInsulinInjectionSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingInsulinInjectionSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of insulin injection.  This enum is non-exhaustive.
	Type ClientFacingInsulinInjectionSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingInsulinInjectionSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingInsulinInjectionSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingInsulinInjectionSample) GetType() ClientFacingInsulinInjectionSampleType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingInsulinInjectionSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingInsulinInjectionSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingInsulinInjectionSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingInsulinInjectionSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingInsulinInjectionSample) Unit() string {
	return c.unit
}

func (c *ClientFacingInsulinInjectionSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingInsulinInjectionSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingInsulinInjectionSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingInsulinInjectionSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetType(type_ ClientFacingInsulinInjectionSampleType) {
	c.Type = type_
	c.require(clientFacingInsulinInjectionSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingInsulinInjectionSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingInsulinInjectionSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingInsulinInjectionSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingInsulinInjectionSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingInsulinInjectionSampleFieldValue)
}

func (c *ClientFacingInsulinInjectionSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingInsulinInjectionSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingInsulinInjectionSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "unit" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "unit", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingInsulinInjectionSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingInsulinInjectionSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "unit",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingInsulinInjectionSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of insulin injection.  This enum is non-exhaustive.
type ClientFacingInsulinInjectionSampleType string

const (
	ClientFacingInsulinInjectionSampleTypeRapidActing ClientFacingInsulinInjectionSampleType = "rapid_acting"
	ClientFacingInsulinInjectionSampleTypeLongActing  ClientFacingInsulinInjectionSampleType = "long_acting"
)

func NewClientFacingInsulinInjectionSampleTypeFromString(s string) (ClientFacingInsulinInjectionSampleType, error) {
	switch s {
	case "rapid_acting":
		return ClientFacingInsulinInjectionSampleTypeRapidActing, nil
	case "long_acting":
		return ClientFacingInsulinInjectionSampleTypeLongActing, nil
	}
	var t ClientFacingInsulinInjectionSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingInsulinInjectionSampleType) Ptr() *ClientFacingInsulinInjectionSampleType {
	return &c
}

var (
	clientFacingLeanBodyMassSampleFieldId             = big.NewInt(1 << 0)
	clientFacingLeanBodyMassSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingLeanBodyMassSampleFieldType           = big.NewInt(1 << 2)
	clientFacingLeanBodyMassSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingLeanBodyMassSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingLeanBodyMassSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingLeanBodyMassSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingLeanBodyMassSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingLeanBodyMassSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingLeanBodyMassSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingLeanBodyMassSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingLeanBodyMassSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingLeanBodyMassSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingLeanBodyMassSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingLeanBodyMassSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingLeanBodyMassSample) Unit() string {
	return c.unit
}

func (c *ClientFacingLeanBodyMassSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingLeanBodyMassSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingLeanBodyMassSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingLeanBodyMassSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingLeanBodyMassSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingLeanBodyMassSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingLeanBodyMassSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingLeanBodyMassSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingLeanBodyMassSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingLeanBodyMassSampleFieldValue)
}

func (c *ClientFacingLeanBodyMassSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingLeanBodyMassSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingLeanBodyMassSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "kg" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "kg", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingLeanBodyMassSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingLeanBodyMassSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "kg",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingLeanBodyMassSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingMindfulnessMinutesTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingMindfulnessMinutesTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingMindfulnessMinutesTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingMindfulnessMinutesTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingMindfulnessMinutesTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingMindfulnessMinutesTimeseriesFieldStart          = big.NewInt(1 << 5)
	clientFacingMindfulnessMinutesTimeseriesFieldEnd            = big.NewInt(1 << 6)
	clientFacingMindfulnessMinutesTimeseriesFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingMindfulnessMinutesTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in minutes.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// Number of minutes spent in a mindful state.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingMindfulnessMinutesTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingMindfulnessMinutesTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingMindfulnessMinutesTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingMindfulnessMinutesTimeseriesFieldValue)
}

func (c *ClientFacingMindfulnessMinutesTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingMindfulnessMinutesTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingMindfulnessMinutesTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingMindfulnessMinutesTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingMindfulnessMinutesTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingMindfulnessMinutesTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingNoteSampleFieldId             = big.NewInt(1 << 0)
	clientFacingNoteSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingNoteSampleFieldType           = big.NewInt(1 << 2)
	clientFacingNoteSampleFieldUnit           = big.NewInt(1 << 3)
	clientFacingNoteSampleFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingNoteSampleFieldStart          = big.NewInt(1 << 5)
	clientFacingNoteSampleFieldEnd            = big.NewInt(1 << 6)
	clientFacingNoteSampleFieldValue          = big.NewInt(1 << 7)
	clientFacingNoteSampleFieldTags           = big.NewInt(1 << 8)
)

type ClientFacingNoteSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// User notes as text.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value string `json:"value" url:"value"`
	// What the note refers to.
	Tags []ClientFacingNoteSampleTagsItem `json:"tags,omitempty" url:"tags,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingNoteSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingNoteSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingNoteSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingNoteSample) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingNoteSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingNoteSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingNoteSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingNoteSample) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *ClientFacingNoteSample) GetTags() []ClientFacingNoteSampleTagsItem {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ClientFacingNoteSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingNoteSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingNoteSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingNoteSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingNoteSampleFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingNoteSampleFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingNoteSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingNoteSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingNoteSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetValue(value string) {
	c.Value = value
	c.require(clientFacingNoteSampleFieldValue)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingNoteSample) SetTags(tags []ClientFacingNoteSampleTagsItem) {
	c.Tags = tags
	c.require(clientFacingNoteSampleFieldTags)
}

func (c *ClientFacingNoteSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingNoteSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingNoteSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingNoteSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingNoteSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingNoteSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingNoteSampleTagsItem string

const (
	ClientFacingNoteSampleTagsItemFood             ClientFacingNoteSampleTagsItem = "food"
	ClientFacingNoteSampleTagsItemExercise         ClientFacingNoteSampleTagsItem = "exercise"
	ClientFacingNoteSampleTagsItemInsulinInjection ClientFacingNoteSampleTagsItem = "insulin_injection"
	ClientFacingNoteSampleTagsItemUnspecified      ClientFacingNoteSampleTagsItem = "unspecified"
)

func NewClientFacingNoteSampleTagsItemFromString(s string) (ClientFacingNoteSampleTagsItem, error) {
	switch s {
	case "food":
		return ClientFacingNoteSampleTagsItemFood, nil
	case "exercise":
		return ClientFacingNoteSampleTagsItemExercise, nil
	case "insulin_injection":
		return ClientFacingNoteSampleTagsItemInsulinInjection, nil
	case "unspecified":
		return ClientFacingNoteSampleTagsItemUnspecified, nil
	}
	var t ClientFacingNoteSampleTagsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingNoteSampleTagsItem) Ptr() *ClientFacingNoteSampleTagsItem {
	return &c
}

var (
	clientFacingPeakExpiratoryFlowRateSampleFieldId             = big.NewInt(1 << 0)
	clientFacingPeakExpiratoryFlowRateSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingPeakExpiratoryFlowRateSampleFieldType           = big.NewInt(1 << 2)
	clientFacingPeakExpiratoryFlowRateSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingPeakExpiratoryFlowRateSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingPeakExpiratoryFlowRateSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingPeakExpiratoryFlowRateSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingPeakExpiratoryFlowRateSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) Unit() string {
	return c.unit
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingPeakExpiratoryFlowRateSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingPeakExpiratoryFlowRateSampleFieldValue)
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingPeakExpiratoryFlowRateSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingPeakExpiratoryFlowRateSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "L/min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "L/min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingPeakExpiratoryFlowRateSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "L/min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingPeakExpiratoryFlowRateSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSampleGroupingKeys = []interface{}

var (
	clientFacingSleepApneaAlertSampleFieldId             = big.NewInt(1 << 0)
	clientFacingSleepApneaAlertSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingSleepApneaAlertSampleFieldType           = big.NewInt(1 << 2)
	clientFacingSleepApneaAlertSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingSleepApneaAlertSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingSleepApneaAlertSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingSleepApneaAlertSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingSleepApneaAlertSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingSleepApneaAlertSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingSleepApneaAlertSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingSleepApneaAlertSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingSleepApneaAlertSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingSleepApneaAlertSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingSleepApneaAlertSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingSleepApneaAlertSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingSleepApneaAlertSample) Unit() string {
	return c.unit
}

func (c *ClientFacingSleepApneaAlertSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepApneaAlertSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingSleepApneaAlertSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingSleepApneaAlertSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingSleepApneaAlertSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingSleepApneaAlertSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingSleepApneaAlertSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingSleepApneaAlertSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepApneaAlertSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingSleepApneaAlertSampleFieldValue)
}

func (c *ClientFacingSleepApneaAlertSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepApneaAlertSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepApneaAlertSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepApneaAlertSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepApneaAlertSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingSleepApneaAlertSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingSleepBreathingDisturbanceSampleFieldId             = big.NewInt(1 << 0)
	clientFacingSleepBreathingDisturbanceSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingSleepBreathingDisturbanceSampleFieldType           = big.NewInt(1 << 2)
	clientFacingSleepBreathingDisturbanceSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingSleepBreathingDisturbanceSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingSleepBreathingDisturbanceSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingSleepBreathingDisturbanceSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingSleepBreathingDisturbanceSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of sleep breathing disturbance.  This enum is non-exhaustive.
	Type *ClientFacingSleepBreathingDisturbanceSampleType `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetType() *ClientFacingSleepBreathingDisturbanceSampleType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingSleepBreathingDisturbanceSample) Unit() string {
	return c.unit
}

func (c *ClientFacingSleepBreathingDisturbanceSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingSleepBreathingDisturbanceSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetType(type_ *ClientFacingSleepBreathingDisturbanceSampleType) {
	c.Type = type_
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingSleepBreathingDisturbanceSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingSleepBreathingDisturbanceSampleFieldValue)
}

func (c *ClientFacingSleepBreathingDisturbanceSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingSleepBreathingDisturbanceSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingSleepBreathingDisturbanceSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingSleepBreathingDisturbanceSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingSleepBreathingDisturbanceSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingSleepBreathingDisturbanceSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingSleepBreathingDisturbanceSampleType string

const (
	ClientFacingSleepBreathingDisturbanceSampleTypeElevated    ClientFacingSleepBreathingDisturbanceSampleType = "elevated"
	ClientFacingSleepBreathingDisturbanceSampleTypeNotElevated ClientFacingSleepBreathingDisturbanceSampleType = "not_elevated"
)

func NewClientFacingSleepBreathingDisturbanceSampleTypeFromString(s string) (ClientFacingSleepBreathingDisturbanceSampleType, error) {
	switch s {
	case "elevated":
		return ClientFacingSleepBreathingDisturbanceSampleTypeElevated, nil
	case "not_elevated":
		return ClientFacingSleepBreathingDisturbanceSampleTypeNotElevated, nil
	}
	var t ClientFacingSleepBreathingDisturbanceSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingSleepBreathingDisturbanceSampleType) Ptr() *ClientFacingSleepBreathingDisturbanceSampleType {
	return &c
}

var (
	clientFacingStandDurationSampleFieldId             = big.NewInt(1 << 0)
	clientFacingStandDurationSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStandDurationSampleFieldType           = big.NewInt(1 << 2)
	clientFacingStandDurationSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingStandDurationSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingStandDurationSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingStandDurationSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingStandDurationSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStandDurationSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStandDurationSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStandDurationSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingStandDurationSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStandDurationSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingStandDurationSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingStandDurationSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStandDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingStandDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandDurationSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStandDurationSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStandDurationSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingStandDurationSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStandDurationSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingStandDurationSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingStandDurationSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandDurationSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStandDurationSampleFieldValue)
}

func (c *ClientFacingStandDurationSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandDurationSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandDurationSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandDurationSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStandDurationSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingStandHourSampleFieldId             = big.NewInt(1 << 0)
	clientFacingStandHourSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStandHourSampleFieldType           = big.NewInt(1 << 2)
	clientFacingStandHourSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingStandHourSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingStandHourSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingStandHourSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingStandHourSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The type of stand hour.  This enum is non-exhaustive.
	Type ClientFacingStandHourSampleType `json:"type" url:"type"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStandHourSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStandHourSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStandHourSample) GetType() ClientFacingStandHourSampleType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ClientFacingStandHourSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStandHourSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingStandHourSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingStandHourSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStandHourSample) Unit() string {
	return c.unit
}

func (c *ClientFacingStandHourSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStandHourSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStandHourSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStandHourSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetType(type_ ClientFacingStandHourSampleType) {
	c.Type = type_
	c.require(clientFacingStandHourSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStandHourSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingStandHourSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingStandHourSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStandHourSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStandHourSampleFieldValue)
}

func (c *ClientFacingStandHourSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStandHourSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStandHourSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStandHourSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStandHourSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStandHourSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of stand hour.  This enum is non-exhaustive.
type ClientFacingStandHourSampleType string

const (
	ClientFacingStandHourSampleTypeStood ClientFacingStandHourSampleType = "stood"
	ClientFacingStandHourSampleTypeIdle  ClientFacingStandHourSampleType = "idle"
)

func NewClientFacingStandHourSampleTypeFromString(s string) (ClientFacingStandHourSampleType, error) {
	switch s {
	case "stood":
		return ClientFacingStandHourSampleTypeStood, nil
	case "idle":
		return ClientFacingStandHourSampleTypeIdle, nil
	}
	var t ClientFacingStandHourSampleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingStandHourSampleType) Ptr() *ClientFacingStandHourSampleType {
	return &c
}

var (
	clientFacingStepsTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingStepsTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStepsTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingStepsTimeseriesFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingStepsTimeseriesFieldStart          = big.NewInt(1 << 4)
	clientFacingStepsTimeseriesFieldEnd            = big.NewInt(1 << 5)
	clientFacingStepsTimeseriesFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingStepsTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in counts
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The number of steps sampled at the time or interval::count
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStepsTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStepsTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStepsTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingStepsTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStepsTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingStepsTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingStepsTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStepsTimeseries) Unit() string {
	return c.unit
}

func (c *ClientFacingStepsTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStepsTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStepsTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStepsTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingStepsTimeseriesFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStepsTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingStepsTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingStepsTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStepsTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStepsTimeseriesFieldValue)
}

func (c *ClientFacingStepsTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStepsTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStepsTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStepsTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStepsTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStepsTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingStressLevelTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingStressLevelTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingStressLevelTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingStressLevelTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingStressLevelTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingStressLevelTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingStressLevelTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in percentage (0-100).
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	Value     float64   `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingStressLevelTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingStressLevelTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingStressLevelTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingStressLevelTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingStressLevelTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingStressLevelTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingStressLevelTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingStressLevelTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingStressLevelTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingStressLevelTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingStressLevelTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingStressLevelTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingStressLevelTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingStressLevelTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingStressLevelTimeseriesFieldValue)
}

func (c *ClientFacingStressLevelTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingStressLevelTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingStressLevelTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingStressLevelTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingStressLevelTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingStressLevelTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingUvExposureSampleFieldId             = big.NewInt(1 << 0)
	clientFacingUvExposureSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingUvExposureSampleFieldType           = big.NewInt(1 << 2)
	clientFacingUvExposureSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingUvExposureSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingUvExposureSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingUvExposureSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingUvExposureSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingUvExposureSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingUvExposureSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingUvExposureSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingUvExposureSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingUvExposureSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingUvExposureSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingUvExposureSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingUvExposureSample) Unit() string {
	return c.unit
}

func (c *ClientFacingUvExposureSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingUvExposureSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingUvExposureSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingUvExposureSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingUvExposureSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingUvExposureSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingUvExposureSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingUvExposureSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingUvExposureSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingUvExposureSampleFieldValue)
}

func (c *ClientFacingUvExposureSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingUvExposureSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingUvExposureSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "index" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "index", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingUvExposureSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingUvExposureSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "index",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingUvExposureSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingVo2MaxTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingVo2MaxTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingVo2MaxTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingVo2MaxTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingVo2MaxTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingVo2MaxTimeseriesFieldStart          = big.NewInt(1 << 5)
	clientFacingVo2MaxTimeseriesFieldEnd            = big.NewInt(1 << 6)
	clientFacingVo2MaxTimeseriesFieldValue          = big.NewInt(1 << 7)
)

type ClientFacingVo2MaxTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in mL/kg/min.
	Unit string `json:"unit" url:"unit"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingVo2MaxTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingVo2MaxTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingVo2MaxTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingVo2MaxTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingVo2MaxTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingVo2MaxTimeseries) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingVo2MaxTimeseries) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingVo2MaxTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingVo2MaxTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingVo2MaxTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingVo2MaxTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingVo2MaxTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingVo2MaxTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingVo2MaxTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingVo2MaxTimeseriesFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingVo2MaxTimeseriesFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingVo2MaxTimeseriesFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingVo2MaxTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingVo2MaxTimeseriesFieldValue)
}

func (c *ClientFacingVo2MaxTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingVo2MaxTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingVo2MaxTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingVo2MaxTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingVo2MaxTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingVo2MaxTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWaistCircumferenceSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWaistCircumferenceSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWaistCircumferenceSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWaistCircumferenceSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWaistCircumferenceSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWaistCircumferenceSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWaistCircumferenceSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWaistCircumferenceSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWaistCircumferenceSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWaistCircumferenceSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWaistCircumferenceSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWaistCircumferenceSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWaistCircumferenceSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWaistCircumferenceSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWaistCircumferenceSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWaistCircumferenceSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWaistCircumferenceSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaistCircumferenceSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWaistCircumferenceSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWaistCircumferenceSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWaistCircumferenceSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWaistCircumferenceSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWaistCircumferenceSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWaistCircumferenceSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaistCircumferenceSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWaistCircumferenceSampleFieldValue)
}

func (c *ClientFacingWaistCircumferenceSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWaistCircumferenceSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWaistCircumferenceSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "cm" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "cm", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaistCircumferenceSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWaistCircumferenceSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "cm",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWaistCircumferenceSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWaterTimeseriesFieldId             = big.NewInt(1 << 0)
	clientFacingWaterTimeseriesFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWaterTimeseriesFieldType           = big.NewInt(1 << 2)
	clientFacingWaterTimeseriesFieldUnit           = big.NewInt(1 << 3)
	clientFacingWaterTimeseriesFieldTimestamp      = big.NewInt(1 << 4)
	clientFacingWaterTimeseriesFieldValue          = big.NewInt(1 << 5)
)

type ClientFacingWaterTimeseries struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Measured in milliters.
	Unit string `json:"unit" url:"unit"`
	// The timestamp of the measurement.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// Quantity of water drank during the time period.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWaterTimeseries) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWaterTimeseries) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWaterTimeseries) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWaterTimeseries) GetUnit() string {
	if c == nil {
		return ""
	}
	return c.Unit
}

func (c *ClientFacingWaterTimeseries) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWaterTimeseries) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWaterTimeseries) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWaterTimeseries) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWaterTimeseriesFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWaterTimeseriesFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWaterTimeseriesFieldType)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetUnit(unit string) {
	c.Unit = unit
	c.require(clientFacingWaterTimeseriesFieldUnit)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWaterTimeseriesFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWaterTimeseries) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWaterTimeseriesFieldValue)
}

func (c *ClientFacingWaterTimeseries) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWaterTimeseries
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWaterTimeseries(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWaterTimeseries) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWaterTimeseries
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWaterTimeseries) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWheelchairPushSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWheelchairPushSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWheelchairPushSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWheelchairPushSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWheelchairPushSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWheelchairPushSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWheelchairPushSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWheelchairPushSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWheelchairPushSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWheelchairPushSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWheelchairPushSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWheelchairPushSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWheelchairPushSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWheelchairPushSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWheelchairPushSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWheelchairPushSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWheelchairPushSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWheelchairPushSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWheelchairPushSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWheelchairPushSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWheelchairPushSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWheelchairPushSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWheelchairPushSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWheelchairPushSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWheelchairPushSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWheelchairPushSampleFieldValue)
}

func (c *ClientFacingWheelchairPushSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWheelchairPushSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWheelchairPushSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWheelchairPushSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWheelchairPushSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWheelchairPushSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWorkoutDistanceSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWorkoutDistanceSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWorkoutDistanceSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWorkoutDistanceSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWorkoutDistanceSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWorkoutDistanceSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWorkoutDistanceSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWorkoutDistanceSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWorkoutDistanceSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWorkoutDistanceSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWorkoutDistanceSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWorkoutDistanceSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWorkoutDistanceSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWorkoutDistanceSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWorkoutDistanceSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWorkoutDistanceSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutDistanceSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDistanceSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWorkoutDistanceSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWorkoutDistanceSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWorkoutDistanceSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWorkoutDistanceSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWorkoutDistanceSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWorkoutDistanceSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDistanceSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWorkoutDistanceSampleFieldValue)
}

func (c *ClientFacingWorkoutDistanceSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutDistanceSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDistanceSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "m" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "m", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDistanceSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDistanceSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "m",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWorkoutDistanceSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	clientFacingWorkoutDurationSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWorkoutDurationSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWorkoutDurationSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWorkoutDurationSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWorkoutDurationSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWorkoutDurationSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWorkoutDurationSampleFieldValue          = big.NewInt(1 << 6)
	clientFacingWorkoutDurationSampleFieldIntensity      = big.NewInt(1 << 7)
)

type ClientFacingWorkoutDurationSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`
	// Workout intensity.  This enum is non-exhaustive.
	Intensity *ClientFacingWorkoutDurationSampleIntensity `json:"intensity,omitempty" url:"intensity,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWorkoutDurationSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWorkoutDurationSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWorkoutDurationSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWorkoutDurationSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWorkoutDurationSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWorkoutDurationSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWorkoutDurationSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWorkoutDurationSample) GetIntensity() *ClientFacingWorkoutDurationSampleIntensity {
	if c == nil {
		return nil
	}
	return c.Intensity
}

func (c *ClientFacingWorkoutDurationSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutDurationSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutDurationSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWorkoutDurationSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWorkoutDurationSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWorkoutDurationSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWorkoutDurationSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWorkoutDurationSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWorkoutDurationSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWorkoutDurationSampleFieldValue)
}

// SetIntensity sets the Intensity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutDurationSample) SetIntensity(intensity *ClientFacingWorkoutDurationSampleIntensity) {
	c.Intensity = intensity
	c.require(clientFacingWorkoutDurationSampleFieldIntensity)
}

func (c *ClientFacingWorkoutDurationSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutDurationSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutDurationSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "min" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "min", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutDurationSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutDurationSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "min",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWorkoutDurationSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientFacingWorkoutDurationSampleIntensity string

const (
	ClientFacingWorkoutDurationSampleIntensityLow    ClientFacingWorkoutDurationSampleIntensity = "low"
	ClientFacingWorkoutDurationSampleIntensityMedium ClientFacingWorkoutDurationSampleIntensity = "medium"
	ClientFacingWorkoutDurationSampleIntensityHigh   ClientFacingWorkoutDurationSampleIntensity = "high"
)

func NewClientFacingWorkoutDurationSampleIntensityFromString(s string) (ClientFacingWorkoutDurationSampleIntensity, error) {
	switch s {
	case "low":
		return ClientFacingWorkoutDurationSampleIntensityLow, nil
	case "medium":
		return ClientFacingWorkoutDurationSampleIntensityMedium, nil
	case "high":
		return ClientFacingWorkoutDurationSampleIntensityHigh, nil
	}
	var t ClientFacingWorkoutDurationSampleIntensity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClientFacingWorkoutDurationSampleIntensity) Ptr() *ClientFacingWorkoutDurationSampleIntensity {
	return &c
}

var (
	clientFacingWorkoutSwimmingStrokeSampleFieldId             = big.NewInt(1 << 0)
	clientFacingWorkoutSwimmingStrokeSampleFieldTimezoneOffset = big.NewInt(1 << 1)
	clientFacingWorkoutSwimmingStrokeSampleFieldType           = big.NewInt(1 << 2)
	clientFacingWorkoutSwimmingStrokeSampleFieldTimestamp      = big.NewInt(1 << 3)
	clientFacingWorkoutSwimmingStrokeSampleFieldStart          = big.NewInt(1 << 4)
	clientFacingWorkoutSwimmingStrokeSampleFieldEnd            = big.NewInt(1 << 5)
	clientFacingWorkoutSwimmingStrokeSampleFieldValue          = big.NewInt(1 << 6)
)

type ClientFacingWorkoutSwimmingStrokeSample struct {
	// Deprecated
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// Time zone UTC offset in seconds. Positive offset indicates east of UTC; negative offset indicates west of UTC; and null indicates the time zone information is unavailable at source.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// Type is always null for this resource.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Depracated. The start time (inclusive) of the interval.
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The start time (inclusive) of the interval.
	Start time.Time `json:"start" url:"start"`
	// The end time (exclusive) of the interval.
	End time.Time `json:"end" url:"end"`
	// The recorded value for the interval.
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	unit           string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetId() *int {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetTimezoneOffset() *int {
	if c == nil {
		return nil
	}
	return c.TimezoneOffset
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetStart() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Start
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetEnd() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.End
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) Unit() string {
	return c.unit
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetId(id *int) {
	c.Id = id
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldId)
}

// SetTimezoneOffset sets the TimezoneOffset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetTimezoneOffset(timezoneOffset *int) {
	c.TimezoneOffset = timezoneOffset
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldTimezoneOffset)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetType(type_ *string) {
	c.Type = type_
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldType)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldTimestamp)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetStart(start time.Time) {
	c.Start = start
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetEnd(end time.Time) {
	c.End = end
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldEnd)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ClientFacingWorkoutSwimmingStrokeSample) SetValue(value float64) {
	c.Value = value
	c.require(clientFacingWorkoutSwimmingStrokeSampleFieldValue)
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) UnmarshalJSON(data []byte) error {
	type embed ClientFacingWorkoutSwimmingStrokeSample
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ClientFacingWorkoutSwimmingStrokeSample(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.Start = unmarshaler.Start.Time()
	c.End = unmarshaler.End.Time()
	if unmarshaler.Unit != "count" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "count", unmarshaler.Unit)
	}
	c.unit = unmarshaler.Unit
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "unit")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) MarshalJSON() ([]byte, error) {
	type embed ClientFacingWorkoutSwimmingStrokeSample
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		Start     *internal.DateTime `json:"start"`
		End       *internal.DateTime `json:"end"`
		Unit      string             `json:"unit"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		Start:     internal.NewDateTime(c.Start),
		End:       internal.NewDateTime(c.End),
		Unit:      "count",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ClientFacingWorkoutSwimmingStrokeSample) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	groupedAFibBurdenFieldSource = big.NewInt(1 << 0)
	groupedAFibBurdenFieldData   = big.NewInt(1 << 1)
)

type GroupedAFibBurden struct {
	Source *ClientFacingSource             `json:"source" url:"source"`
	Data   []*ClientFacingAFibBurdenSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedAFibBurden) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedAFibBurden) GetData() []*ClientFacingAFibBurdenSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedAFibBurden) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAFibBurden) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurden) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedAFibBurdenFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurden) SetData(data []*ClientFacingAFibBurdenSample) {
	g.Data = data
	g.require(groupedAFibBurdenFieldData)
}

func (g *GroupedAFibBurden) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAFibBurden
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAFibBurden(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAFibBurden) MarshalJSON() ([]byte, error) {
	type embed GroupedAFibBurden
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedAFibBurden) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedAFibBurdenResponseFieldGroups     = big.NewInt(1 << 0)
	groupedAFibBurdenResponseFieldNext       = big.NewInt(1 << 1)
	groupedAFibBurdenResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedAFibBurdenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedAFibBurden `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedAFibBurdenResponse) GetGroups() map[string][]*GroupedAFibBurden {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedAFibBurdenResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedAFibBurdenResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedAFibBurdenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedAFibBurdenResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurdenResponse) SetGroups(groups map[string][]*GroupedAFibBurden) {
	g.Groups = groups
	g.require(groupedAFibBurdenResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurdenResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedAFibBurdenResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedAFibBurdenResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedAFibBurdenResponseFieldNextCursor)
}

func (g *GroupedAFibBurdenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedAFibBurdenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedAFibBurdenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedAFibBurdenResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedAFibBurdenResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedAFibBurdenResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBasalBodyTemperatureFieldSource = big.NewInt(1 << 0)
	groupedBasalBodyTemperatureFieldData   = big.NewInt(1 << 1)
)

type GroupedBasalBodyTemperature struct {
	Source *ClientFacingSource                       `json:"source" url:"source"`
	Data   []*ClientFacingBasalBodyTemperatureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBasalBodyTemperature) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBasalBodyTemperature) GetData() []*ClientFacingBasalBodyTemperatureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBasalBodyTemperature) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBasalBodyTemperature) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperature) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBasalBodyTemperatureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperature) SetData(data []*ClientFacingBasalBodyTemperatureSample) {
	g.Data = data
	g.require(groupedBasalBodyTemperatureFieldData)
}

func (g *GroupedBasalBodyTemperature) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBasalBodyTemperature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBasalBodyTemperature(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBasalBodyTemperature) MarshalJSON() ([]byte, error) {
	type embed GroupedBasalBodyTemperature
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBasalBodyTemperature) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBasalBodyTemperatureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBasalBodyTemperatureResponseFieldNext       = big.NewInt(1 << 1)
	groupedBasalBodyTemperatureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBasalBodyTemperatureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBasalBodyTemperature `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBasalBodyTemperatureResponse) GetGroups() map[string][]*GroupedBasalBodyTemperature {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBasalBodyTemperatureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBasalBodyTemperatureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBasalBodyTemperatureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBasalBodyTemperatureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperatureResponse) SetGroups(groups map[string][]*GroupedBasalBodyTemperature) {
	g.Groups = groups
	g.require(groupedBasalBodyTemperatureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperatureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBasalBodyTemperatureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBasalBodyTemperatureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBasalBodyTemperatureResponseFieldNextCursor)
}

func (g *GroupedBasalBodyTemperatureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBasalBodyTemperatureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBasalBodyTemperatureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBasalBodyTemperatureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBasalBodyTemperatureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBasalBodyTemperatureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodOxygenFieldSource = big.NewInt(1 << 0)
	groupedBloodOxygenFieldData   = big.NewInt(1 << 1)
)

type GroupedBloodOxygen struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingBloodOxygenTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodOxygen) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBloodOxygen) GetData() []*ClientFacingBloodOxygenTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBloodOxygen) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygen) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygen) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBloodOxygenFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygen) SetData(data []*ClientFacingBloodOxygenTimeseries) {
	g.Data = data
	g.require(groupedBloodOxygenFieldData)
}

func (g *GroupedBloodOxygen) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygen(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygen) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodOxygen
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodOxygen) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodOxygenResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBloodOxygenResponseFieldNext       = big.NewInt(1 << 1)
	groupedBloodOxygenResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBloodOxygenResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodOxygen `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodOxygenResponse) GetGroups() map[string][]*GroupedBloodOxygen {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBloodOxygenResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBloodOxygenResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBloodOxygenResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodOxygenResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygenResponse) SetGroups(groups map[string][]*GroupedBloodOxygen) {
	g.Groups = groups
	g.require(groupedBloodOxygenResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygenResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBloodOxygenResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodOxygenResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBloodOxygenResponseFieldNextCursor)
}

func (g *GroupedBloodOxygenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodOxygenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodOxygenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodOxygenResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodOxygenResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodOxygenResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodPressureFieldSource = big.NewInt(1 << 0)
	groupedBloodPressureFieldData   = big.NewInt(1 << 1)
)

type GroupedBloodPressure struct {
	Source *ClientFacingSource                    `json:"source" url:"source"`
	Data   []*ClientFacingBloodPressureTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodPressure) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBloodPressure) GetData() []*ClientFacingBloodPressureTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBloodPressure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressure) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressure) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBloodPressureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressure) SetData(data []*ClientFacingBloodPressureTimeseries) {
	g.Data = data
	g.require(groupedBloodPressureFieldData)
}

func (g *GroupedBloodPressure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressure) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodPressure
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodPressure) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBloodPressureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBloodPressureResponseFieldNext       = big.NewInt(1 << 1)
	groupedBloodPressureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBloodPressureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBloodPressure `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBloodPressureResponse) GetGroups() map[string][]*GroupedBloodPressure {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBloodPressureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBloodPressureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBloodPressureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBloodPressureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressureResponse) SetGroups(groups map[string][]*GroupedBloodPressure) {
	g.Groups = groups
	g.require(groupedBloodPressureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBloodPressureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBloodPressureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBloodPressureResponseFieldNextCursor)
}

func (g *GroupedBloodPressureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBloodPressureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBloodPressureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBloodPressureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBloodPressureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBloodPressureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyFatFieldSource = big.NewInt(1 << 0)
	groupedBodyFatFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyFat struct {
	Source *ClientFacingSource              `json:"source" url:"source"`
	Data   []*ClientFacingBodyFatTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyFat) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyFat) GetData() []*ClientFacingBodyFatTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyFat) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFat) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFat) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyFatFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFat) SetData(data []*ClientFacingBodyFatTimeseries) {
	g.Data = data
	g.require(groupedBodyFatFieldData)
}

func (g *GroupedBodyFat) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFat) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyFat
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyFat) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyFatResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyFatResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyFatResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyFatResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyFat `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyFatResponse) GetGroups() map[string][]*GroupedBodyFat {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyFatResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyFatResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyFatResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyFatResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFatResponse) SetGroups(groups map[string][]*GroupedBodyFat) {
	g.Groups = groups
	g.require(groupedBodyFatResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFatResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyFatResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyFatResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyFatResponseFieldNextCursor)
}

func (g *GroupedBodyFatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyFatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyFatResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyFatResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyFatResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyFatResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyMassIndexFieldSource = big.NewInt(1 << 0)
	groupedBodyMassIndexFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyMassIndex struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingBodyMassIndexSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyMassIndex) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyMassIndex) GetData() []*ClientFacingBodyMassIndexSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyMassIndex) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyMassIndex) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndex) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyMassIndexFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndex) SetData(data []*ClientFacingBodyMassIndexSample) {
	g.Data = data
	g.require(groupedBodyMassIndexFieldData)
}

func (g *GroupedBodyMassIndex) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyMassIndex
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyMassIndex(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyMassIndex) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyMassIndex
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyMassIndex) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyMassIndexResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyMassIndexResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyMassIndexResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyMassIndexResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyMassIndex `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyMassIndexResponse) GetGroups() map[string][]*GroupedBodyMassIndex {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyMassIndexResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyMassIndexResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyMassIndexResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyMassIndexResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndexResponse) SetGroups(groups map[string][]*GroupedBodyMassIndex) {
	g.Groups = groups
	g.require(groupedBodyMassIndexResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndexResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyMassIndexResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyMassIndexResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyMassIndexResponseFieldNextCursor)
}

func (g *GroupedBodyMassIndexResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyMassIndexResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyMassIndexResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyMassIndexResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyMassIndexResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyMassIndexResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureFieldSource = big.NewInt(1 << 0)
	groupedBodyTemperatureFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyTemperature struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingBodyTemperatureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperature) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyTemperature) GetData() []*ClientFacingBodyTemperatureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyTemperature) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperature) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperature) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyTemperatureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperature) SetData(data []*ClientFacingBodyTemperatureSample) {
	g.Data = data
	g.require(groupedBodyTemperatureFieldData)
}

func (g *GroupedBodyTemperature) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperature(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperature) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperature
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperature) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureDeltaFieldSource = big.NewInt(1 << 0)
	groupedBodyTemperatureDeltaFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyTemperatureDelta struct {
	Source *ClientFacingSource                       `json:"source" url:"source"`
	Data   []*ClientFacingBodyTemperatureDeltaSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperatureDelta) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyTemperatureDelta) GetData() []*ClientFacingBodyTemperatureDeltaSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyTemperatureDelta) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureDelta) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDelta) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyTemperatureDeltaFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDelta) SetData(data []*ClientFacingBodyTemperatureDeltaSample) {
	g.Data = data
	g.require(groupedBodyTemperatureDeltaFieldData)
}

func (g *GroupedBodyTemperatureDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureDelta) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperatureDelta
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperatureDelta) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureDeltaResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyTemperatureDeltaResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyTemperatureDeltaResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyTemperatureDeltaResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyTemperatureDelta `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperatureDeltaResponse) GetGroups() map[string][]*GroupedBodyTemperatureDelta {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyTemperatureDeltaResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyTemperatureDeltaResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyTemperatureDeltaResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureDeltaResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDeltaResponse) SetGroups(groups map[string][]*GroupedBodyTemperatureDelta) {
	g.Groups = groups
	g.require(groupedBodyTemperatureDeltaResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDeltaResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyTemperatureDeltaResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureDeltaResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyTemperatureDeltaResponseFieldNextCursor)
}

func (g *GroupedBodyTemperatureDeltaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureDeltaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureDeltaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureDeltaResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperatureDeltaResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperatureDeltaResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyTemperatureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyTemperatureResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyTemperatureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyTemperatureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyTemperature `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyTemperatureResponse) GetGroups() map[string][]*GroupedBodyTemperature {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyTemperatureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyTemperatureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyTemperatureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyTemperatureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureResponse) SetGroups(groups map[string][]*GroupedBodyTemperature) {
	g.Groups = groups
	g.require(groupedBodyTemperatureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyTemperatureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyTemperatureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyTemperatureResponseFieldNextCursor)
}

func (g *GroupedBodyTemperatureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyTemperatureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyTemperatureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyTemperatureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyTemperatureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyTemperatureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyWeightFieldSource = big.NewInt(1 << 0)
	groupedBodyWeightFieldData   = big.NewInt(1 << 1)
)

type GroupedBodyWeight struct {
	Source *ClientFacingSource                 `json:"source" url:"source"`
	Data   []*ClientFacingBodyWeightTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyWeight) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedBodyWeight) GetData() []*ClientFacingBodyWeightTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedBodyWeight) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeight) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeight) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedBodyWeightFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeight) SetData(data []*ClientFacingBodyWeightTimeseries) {
	g.Data = data
	g.require(groupedBodyWeightFieldData)
}

func (g *GroupedBodyWeight) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeight
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeight(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeight) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyWeight
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyWeight) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedBodyWeightResponseFieldGroups     = big.NewInt(1 << 0)
	groupedBodyWeightResponseFieldNext       = big.NewInt(1 << 1)
	groupedBodyWeightResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedBodyWeightResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedBodyWeight `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedBodyWeightResponse) GetGroups() map[string][]*GroupedBodyWeight {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedBodyWeightResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedBodyWeightResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedBodyWeightResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedBodyWeightResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeightResponse) SetGroups(groups map[string][]*GroupedBodyWeight) {
	g.Groups = groups
	g.require(groupedBodyWeightResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeightResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedBodyWeightResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedBodyWeightResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedBodyWeightResponseFieldNextCursor)
}

func (g *GroupedBodyWeightResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedBodyWeightResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedBodyWeightResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedBodyWeightResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedBodyWeightResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedBodyWeightResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaffeineFieldSource = big.NewInt(1 << 0)
	groupedCaffeineFieldData   = big.NewInt(1 << 1)
)

type GroupedCaffeine struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingCaffeineTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaffeine) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCaffeine) GetData() []*ClientFacingCaffeineTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCaffeine) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeine) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeine) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCaffeineFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeine) SetData(data []*ClientFacingCaffeineTimeseries) {
	g.Data = data
	g.require(groupedCaffeineFieldData)
}

func (g *GroupedCaffeine) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeine(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeine) MarshalJSON() ([]byte, error) {
	type embed GroupedCaffeine
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaffeine) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaffeineResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCaffeineResponseFieldNext       = big.NewInt(1 << 1)
	groupedCaffeineResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCaffeineResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaffeine `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaffeineResponse) GetGroups() map[string][]*GroupedCaffeine {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCaffeineResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCaffeineResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCaffeineResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaffeineResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeineResponse) SetGroups(groups map[string][]*GroupedCaffeine) {
	g.Groups = groups
	g.require(groupedCaffeineResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeineResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCaffeineResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaffeineResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCaffeineResponseFieldNextCursor)
}

func (g *GroupedCaffeineResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaffeineResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaffeineResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaffeineResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCaffeineResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaffeineResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesActiveFieldSource = big.NewInt(1 << 0)
	groupedCaloriesActiveFieldData   = big.NewInt(1 << 1)
)

type GroupedCaloriesActive struct {
	Source *ClientFacingSource                     `json:"source" url:"source"`
	Data   []*ClientFacingCaloriesActiveTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesActive) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCaloriesActive) GetData() []*ClientFacingCaloriesActiveTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCaloriesActive) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActive) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActive) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCaloriesActiveFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActive) SetData(data []*ClientFacingCaloriesActiveTimeseries) {
	g.Data = data
	g.require(groupedCaloriesActiveFieldData)
}

func (g *GroupedCaloriesActive) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActive(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActive) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesActive
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesActive) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesActiveResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCaloriesActiveResponseFieldNext       = big.NewInt(1 << 1)
	groupedCaloriesActiveResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCaloriesActiveResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesActive `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesActiveResponse) GetGroups() map[string][]*GroupedCaloriesActive {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCaloriesActiveResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCaloriesActiveResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCaloriesActiveResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesActiveResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActiveResponse) SetGroups(groups map[string][]*GroupedCaloriesActive) {
	g.Groups = groups
	g.require(groupedCaloriesActiveResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActiveResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCaloriesActiveResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesActiveResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCaloriesActiveResponseFieldNextCursor)
}

func (g *GroupedCaloriesActiveResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesActiveResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesActiveResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesActiveResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesActiveResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesActiveResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesBasalFieldSource = big.NewInt(1 << 0)
	groupedCaloriesBasalFieldData   = big.NewInt(1 << 1)
)

type GroupedCaloriesBasal struct {
	Source *ClientFacingSource                    `json:"source" url:"source"`
	Data   []*ClientFacingCaloriesBasalTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesBasal) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCaloriesBasal) GetData() []*ClientFacingCaloriesBasalTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCaloriesBasal) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasal) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasal) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCaloriesBasalFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasal) SetData(data []*ClientFacingCaloriesBasalTimeseries) {
	g.Data = data
	g.require(groupedCaloriesBasalFieldData)
}

func (g *GroupedCaloriesBasal) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasal) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesBasal
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesBasal) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCaloriesBasalResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCaloriesBasalResponseFieldNext       = big.NewInt(1 << 1)
	groupedCaloriesBasalResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCaloriesBasalResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCaloriesBasal `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCaloriesBasalResponse) GetGroups() map[string][]*GroupedCaloriesBasal {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCaloriesBasalResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCaloriesBasalResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCaloriesBasalResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCaloriesBasalResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasalResponse) SetGroups(groups map[string][]*GroupedCaloriesBasal) {
	g.Groups = groups
	g.require(groupedCaloriesBasalResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasalResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCaloriesBasalResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCaloriesBasalResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCaloriesBasalResponseFieldNextCursor)
}

func (g *GroupedCaloriesBasalResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCaloriesBasalResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCaloriesBasalResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCaloriesBasalResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCaloriesBasalResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCaloriesBasalResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCarbohydratesFieldSource = big.NewInt(1 << 0)
	groupedCarbohydratesFieldData   = big.NewInt(1 << 1)
)

type GroupedCarbohydrates struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingCarbohydratesSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCarbohydrates) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCarbohydrates) GetData() []*ClientFacingCarbohydratesSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCarbohydrates) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCarbohydrates) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydrates) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCarbohydratesFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydrates) SetData(data []*ClientFacingCarbohydratesSample) {
	g.Data = data
	g.require(groupedCarbohydratesFieldData)
}

func (g *GroupedCarbohydrates) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCarbohydrates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCarbohydrates(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCarbohydrates) MarshalJSON() ([]byte, error) {
	type embed GroupedCarbohydrates
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCarbohydrates) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCarbohydratesResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCarbohydratesResponseFieldNext       = big.NewInt(1 << 1)
	groupedCarbohydratesResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCarbohydratesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCarbohydrates `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCarbohydratesResponse) GetGroups() map[string][]*GroupedCarbohydrates {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCarbohydratesResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCarbohydratesResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCarbohydratesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCarbohydratesResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydratesResponse) SetGroups(groups map[string][]*GroupedCarbohydrates) {
	g.Groups = groups
	g.require(groupedCarbohydratesResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydratesResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCarbohydratesResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCarbohydratesResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCarbohydratesResponseFieldNextCursor)
}

func (g *GroupedCarbohydratesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCarbohydratesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCarbohydratesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCarbohydratesResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCarbohydratesResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCarbohydratesResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCholesterolFieldSource = big.NewInt(1 << 0)
	groupedCholesterolFieldData   = big.NewInt(1 << 1)
)

type GroupedCholesterol struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingCholesterolTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCholesterol) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedCholesterol) GetData() []*ClientFacingCholesterolTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedCholesterol) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterol) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterol) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedCholesterolFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterol) SetData(data []*ClientFacingCholesterolTimeseries) {
	g.Data = data
	g.require(groupedCholesterolFieldData)
}

func (g *GroupedCholesterol) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterol
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterol(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterol) MarshalJSON() ([]byte, error) {
	type embed GroupedCholesterol
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCholesterol) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedCholesterolResponseFieldGroups     = big.NewInt(1 << 0)
	groupedCholesterolResponseFieldNext       = big.NewInt(1 << 1)
	groupedCholesterolResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedCholesterolResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedCholesterol `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedCholesterolResponse) GetGroups() map[string][]*GroupedCholesterol {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedCholesterolResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedCholesterolResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedCholesterolResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedCholesterolResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterolResponse) SetGroups(groups map[string][]*GroupedCholesterol) {
	g.Groups = groups
	g.require(groupedCholesterolResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterolResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedCholesterolResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedCholesterolResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedCholesterolResponseFieldNextCursor)
}

func (g *GroupedCholesterolResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedCholesterolResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedCholesterolResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedCholesterolResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedCholesterolResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedCholesterolResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDaylightExposureFieldSource = big.NewInt(1 << 0)
	groupedDaylightExposureFieldData   = big.NewInt(1 << 1)
)

type GroupedDaylightExposure struct {
	Source *ClientFacingSource                   `json:"source" url:"source"`
	Data   []*ClientFacingDaylightExposureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDaylightExposure) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedDaylightExposure) GetData() []*ClientFacingDaylightExposureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedDaylightExposure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDaylightExposure) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposure) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedDaylightExposureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposure) SetData(data []*ClientFacingDaylightExposureSample) {
	g.Data = data
	g.require(groupedDaylightExposureFieldData)
}

func (g *GroupedDaylightExposure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDaylightExposure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDaylightExposure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDaylightExposure) MarshalJSON() ([]byte, error) {
	type embed GroupedDaylightExposure
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDaylightExposure) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDaylightExposureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedDaylightExposureResponseFieldNext       = big.NewInt(1 << 1)
	groupedDaylightExposureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedDaylightExposureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedDaylightExposure `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDaylightExposureResponse) GetGroups() map[string][]*GroupedDaylightExposure {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedDaylightExposureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedDaylightExposureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedDaylightExposureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDaylightExposureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposureResponse) SetGroups(groups map[string][]*GroupedDaylightExposure) {
	g.Groups = groups
	g.require(groupedDaylightExposureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedDaylightExposureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDaylightExposureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedDaylightExposureResponseFieldNextCursor)
}

func (g *GroupedDaylightExposureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDaylightExposureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDaylightExposureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDaylightExposureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedDaylightExposureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDaylightExposureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDistanceFieldSource = big.NewInt(1 << 0)
	groupedDistanceFieldData   = big.NewInt(1 << 1)
)

type GroupedDistance struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingDistanceTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDistance) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedDistance) GetData() []*ClientFacingDistanceTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedDistance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistance) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistance) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedDistanceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistance) SetData(data []*ClientFacingDistanceTimeseries) {
	g.Data = data
	g.require(groupedDistanceFieldData)
}

func (g *GroupedDistance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistance) MarshalJSON() ([]byte, error) {
	type embed GroupedDistance
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDistance) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedDistanceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedDistanceResponseFieldNext       = big.NewInt(1 << 1)
	groupedDistanceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedDistanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedDistance `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedDistanceResponse) GetGroups() map[string][]*GroupedDistance {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedDistanceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedDistanceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedDistanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedDistanceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistanceResponse) SetGroups(groups map[string][]*GroupedDistance) {
	g.Groups = groups
	g.require(groupedDistanceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistanceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedDistanceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedDistanceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedDistanceResponseFieldNextCursor)
}

func (g *GroupedDistanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedDistanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedDistanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedDistanceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedDistanceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedDistanceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedElectrocardiogramVoltageFieldSource = big.NewInt(1 << 0)
	groupedElectrocardiogramVoltageFieldData   = big.NewInt(1 << 1)
)

type GroupedElectrocardiogramVoltage struct {
	Source *ClientFacingSource                               `json:"source" url:"source"`
	Data   []*ClientFacingElectrocardiogramVoltageTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedElectrocardiogramVoltage) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedElectrocardiogramVoltage) GetData() []*ClientFacingElectrocardiogramVoltageTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedElectrocardiogramVoltage) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltage) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltage) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedElectrocardiogramVoltageFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltage) SetData(data []*ClientFacingElectrocardiogramVoltageTimeseries) {
	g.Data = data
	g.require(groupedElectrocardiogramVoltageFieldData)
}

func (g *GroupedElectrocardiogramVoltage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltage) MarshalJSON() ([]byte, error) {
	type embed GroupedElectrocardiogramVoltage
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedElectrocardiogramVoltage) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedElectrocardiogramVoltageResponseFieldGroups     = big.NewInt(1 << 0)
	groupedElectrocardiogramVoltageResponseFieldNext       = big.NewInt(1 << 1)
	groupedElectrocardiogramVoltageResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedElectrocardiogramVoltageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedElectrocardiogramVoltage `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedElectrocardiogramVoltageResponse) GetGroups() map[string][]*GroupedElectrocardiogramVoltage {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedElectrocardiogramVoltageResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedElectrocardiogramVoltageResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedElectrocardiogramVoltageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedElectrocardiogramVoltageResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltageResponse) SetGroups(groups map[string][]*GroupedElectrocardiogramVoltage) {
	g.Groups = groups
	g.require(groupedElectrocardiogramVoltageResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltageResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedElectrocardiogramVoltageResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedElectrocardiogramVoltageResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedElectrocardiogramVoltageResponseFieldNextCursor)
}

func (g *GroupedElectrocardiogramVoltageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedElectrocardiogramVoltageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedElectrocardiogramVoltageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedElectrocardiogramVoltageResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedElectrocardiogramVoltageResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedElectrocardiogramVoltageResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFallFieldSource = big.NewInt(1 << 0)
	groupedFallFieldData   = big.NewInt(1 << 1)
)

type GroupedFall struct {
	Source *ClientFacingSource       `json:"source" url:"source"`
	Data   []*ClientFacingFallSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFall) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedFall) GetData() []*ClientFacingFallSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedFall) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFall) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFall) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedFallFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFall) SetData(data []*ClientFacingFallSample) {
	g.Data = data
	g.require(groupedFallFieldData)
}

func (g *GroupedFall) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFall(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFall) MarshalJSON() ([]byte, error) {
	type embed GroupedFall
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFall) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFallResponseFieldGroups     = big.NewInt(1 << 0)
	groupedFallResponseFieldNext       = big.NewInt(1 << 1)
	groupedFallResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedFallResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedFall `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFallResponse) GetGroups() map[string][]*GroupedFall {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedFallResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedFallResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedFallResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFallResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFallResponse) SetGroups(groups map[string][]*GroupedFall) {
	g.Groups = groups
	g.require(groupedFallResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFallResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedFallResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFallResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedFallResponseFieldNextCursor)
}

func (g *GroupedFallResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFallResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFallResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFallResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedFallResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFallResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFloorsClimbedFieldSource = big.NewInt(1 << 0)
	groupedFloorsClimbedFieldData   = big.NewInt(1 << 1)
)

type GroupedFloorsClimbed struct {
	Source *ClientFacingSource                    `json:"source" url:"source"`
	Data   []*ClientFacingFloorsClimbedTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFloorsClimbed) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedFloorsClimbed) GetData() []*ClientFacingFloorsClimbedTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedFloorsClimbed) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbed) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbed) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedFloorsClimbedFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbed) SetData(data []*ClientFacingFloorsClimbedTimeseries) {
	g.Data = data
	g.require(groupedFloorsClimbedFieldData)
}

func (g *GroupedFloorsClimbed) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbed(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbed) MarshalJSON() ([]byte, error) {
	type embed GroupedFloorsClimbed
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFloorsClimbed) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedFloorsClimbedResponseFieldGroups     = big.NewInt(1 << 0)
	groupedFloorsClimbedResponseFieldNext       = big.NewInt(1 << 1)
	groupedFloorsClimbedResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedFloorsClimbedResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedFloorsClimbed `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedFloorsClimbedResponse) GetGroups() map[string][]*GroupedFloorsClimbed {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedFloorsClimbedResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedFloorsClimbedResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedFloorsClimbedResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedFloorsClimbedResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbedResponse) SetGroups(groups map[string][]*GroupedFloorsClimbed) {
	g.Groups = groups
	g.require(groupedFloorsClimbedResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbedResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedFloorsClimbedResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedFloorsClimbedResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedFloorsClimbedResponseFieldNextCursor)
}

func (g *GroupedFloorsClimbedResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedFloorsClimbedResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedFloorsClimbedResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedFloorsClimbedResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedFloorsClimbedResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedFloorsClimbedResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedExpiratoryVolume1FieldSource = big.NewInt(1 << 0)
	groupedForcedExpiratoryVolume1FieldData   = big.NewInt(1 << 1)
)

type GroupedForcedExpiratoryVolume1 struct {
	Source *ClientFacingSource                          `json:"source" url:"source"`
	Data   []*ClientFacingForcedExpiratoryVolume1Sample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedExpiratoryVolume1) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedForcedExpiratoryVolume1) GetData() []*ClientFacingForcedExpiratoryVolume1Sample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedForcedExpiratoryVolume1) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedExpiratoryVolume1) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedForcedExpiratoryVolume1FieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1) SetData(data []*ClientFacingForcedExpiratoryVolume1Sample) {
	g.Data = data
	g.require(groupedForcedExpiratoryVolume1FieldData)
}

func (g *GroupedForcedExpiratoryVolume1) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedExpiratoryVolume1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedExpiratoryVolume1(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedExpiratoryVolume1) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedExpiratoryVolume1
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedExpiratoryVolume1) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedExpiratoryVolume1ResponseFieldGroups     = big.NewInt(1 << 0)
	groupedForcedExpiratoryVolume1ResponseFieldNext       = big.NewInt(1 << 1)
	groupedForcedExpiratoryVolume1ResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedForcedExpiratoryVolume1Response struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedForcedExpiratoryVolume1 `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedExpiratoryVolume1Response) GetGroups() map[string][]*GroupedForcedExpiratoryVolume1 {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedForcedExpiratoryVolume1Response) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedForcedExpiratoryVolume1Response) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedForcedExpiratoryVolume1Response) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedExpiratoryVolume1Response) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1Response) SetGroups(groups map[string][]*GroupedForcedExpiratoryVolume1) {
	g.Groups = groups
	g.require(groupedForcedExpiratoryVolume1ResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1Response) SetNext(next *string) {
	g.Next = next
	g.require(groupedForcedExpiratoryVolume1ResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedExpiratoryVolume1Response) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedForcedExpiratoryVolume1ResponseFieldNextCursor)
}

func (g *GroupedForcedExpiratoryVolume1Response) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedExpiratoryVolume1Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedExpiratoryVolume1Response(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedExpiratoryVolume1Response) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedExpiratoryVolume1Response
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedExpiratoryVolume1Response) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedVitalCapacityFieldSource = big.NewInt(1 << 0)
	groupedForcedVitalCapacityFieldData   = big.NewInt(1 << 1)
)

type GroupedForcedVitalCapacity struct {
	Source *ClientFacingSource                      `json:"source" url:"source"`
	Data   []*ClientFacingForcedVitalCapacitySample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedVitalCapacity) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedForcedVitalCapacity) GetData() []*ClientFacingForcedVitalCapacitySample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedForcedVitalCapacity) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedVitalCapacity) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacity) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedForcedVitalCapacityFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacity) SetData(data []*ClientFacingForcedVitalCapacitySample) {
	g.Data = data
	g.require(groupedForcedVitalCapacityFieldData)
}

func (g *GroupedForcedVitalCapacity) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedVitalCapacity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedVitalCapacity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedVitalCapacity) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedVitalCapacity
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedVitalCapacity) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedForcedVitalCapacityResponseFieldGroups     = big.NewInt(1 << 0)
	groupedForcedVitalCapacityResponseFieldNext       = big.NewInt(1 << 1)
	groupedForcedVitalCapacityResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedForcedVitalCapacityResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedForcedVitalCapacity `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedForcedVitalCapacityResponse) GetGroups() map[string][]*GroupedForcedVitalCapacity {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedForcedVitalCapacityResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedForcedVitalCapacityResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedForcedVitalCapacityResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedForcedVitalCapacityResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacityResponse) SetGroups(groups map[string][]*GroupedForcedVitalCapacity) {
	g.Groups = groups
	g.require(groupedForcedVitalCapacityResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacityResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedForcedVitalCapacityResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedForcedVitalCapacityResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedForcedVitalCapacityResponseFieldNextCursor)
}

func (g *GroupedForcedVitalCapacityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedForcedVitalCapacityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedForcedVitalCapacityResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedForcedVitalCapacityResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedForcedVitalCapacityResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedForcedVitalCapacityResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedGlucoseFieldSource = big.NewInt(1 << 0)
	groupedGlucoseFieldData   = big.NewInt(1 << 1)
)

type GroupedGlucose struct {
	Source *ClientFacingSource              `json:"source" url:"source"`
	Data   []*ClientFacingGlucoseTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedGlucose) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedGlucose) GetData() []*ClientFacingGlucoseTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedGlucose) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucose) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucose) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedGlucoseFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucose) SetData(data []*ClientFacingGlucoseTimeseries) {
	g.Data = data
	g.require(groupedGlucoseFieldData)
}

func (g *GroupedGlucose) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucose) MarshalJSON() ([]byte, error) {
	type embed GroupedGlucose
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedGlucose) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedGlucoseResponseFieldGroups     = big.NewInt(1 << 0)
	groupedGlucoseResponseFieldNext       = big.NewInt(1 << 1)
	groupedGlucoseResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedGlucoseResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedGlucose `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedGlucoseResponse) GetGroups() map[string][]*GroupedGlucose {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedGlucoseResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedGlucoseResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedGlucoseResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedGlucoseResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucoseResponse) SetGroups(groups map[string][]*GroupedGlucose) {
	g.Groups = groups
	g.require(groupedGlucoseResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucoseResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedGlucoseResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedGlucoseResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedGlucoseResponseFieldNextCursor)
}

func (g *GroupedGlucoseResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedGlucoseResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedGlucoseResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedGlucoseResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedGlucoseResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedGlucoseResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHandwashingFieldSource = big.NewInt(1 << 0)
	groupedHandwashingFieldData   = big.NewInt(1 << 1)
)

type GroupedHandwashing struct {
	Source *ClientFacingSource              `json:"source" url:"source"`
	Data   []*ClientFacingHandwashingSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHandwashing) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHandwashing) GetData() []*ClientFacingHandwashingSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHandwashing) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHandwashing) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashing) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHandwashingFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashing) SetData(data []*ClientFacingHandwashingSample) {
	g.Data = data
	g.require(groupedHandwashingFieldData)
}

func (g *GroupedHandwashing) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHandwashing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHandwashing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHandwashing) MarshalJSON() ([]byte, error) {
	type embed GroupedHandwashing
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHandwashing) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHandwashingResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHandwashingResponseFieldNext       = big.NewInt(1 << 1)
	groupedHandwashingResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHandwashingResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHandwashing `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHandwashingResponse) GetGroups() map[string][]*GroupedHandwashing {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHandwashingResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHandwashingResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHandwashingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHandwashingResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashingResponse) SetGroups(groups map[string][]*GroupedHandwashing) {
	g.Groups = groups
	g.require(groupedHandwashingResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashingResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHandwashingResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHandwashingResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHandwashingResponseFieldNextCursor)
}

func (g *GroupedHandwashingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHandwashingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHandwashingResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHandwashingResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHandwashingResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHandwashingResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateFieldSource = big.NewInt(1 << 0)
	groupedHeartRateFieldData   = big.NewInt(1 << 1)
)

type GroupedHeartRate struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingHeartRateTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRate) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHeartRate) GetData() []*ClientFacingHeartRateTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHeartRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRate) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRate) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHeartRateFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRate) SetData(data []*ClientFacingHeartRateTimeseries) {
	g.Data = data
	g.require(groupedHeartRateFieldData)
}

func (g *GroupedHeartRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRate) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateAlertFieldSource = big.NewInt(1 << 0)
	groupedHeartRateAlertFieldData   = big.NewInt(1 << 1)
)

type GroupedHeartRateAlert struct {
	Source *ClientFacingSource                 `json:"source" url:"source"`
	Data   []*ClientFacingHeartRateAlertSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateAlert) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHeartRateAlert) GetData() []*ClientFacingHeartRateAlertSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHeartRateAlert) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateAlert) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlert) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHeartRateAlertFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlert) SetData(data []*ClientFacingHeartRateAlertSample) {
	g.Data = data
	g.require(groupedHeartRateAlertFieldData)
}

func (g *GroupedHeartRateAlert) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateAlert
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateAlert(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateAlert) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateAlert
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateAlert) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateAlertResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHeartRateAlertResponseFieldNext       = big.NewInt(1 << 1)
	groupedHeartRateAlertResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHeartRateAlertResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRateAlert `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateAlertResponse) GetGroups() map[string][]*GroupedHeartRateAlert {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHeartRateAlertResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHeartRateAlertResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHeartRateAlertResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateAlertResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlertResponse) SetGroups(groups map[string][]*GroupedHeartRateAlert) {
	g.Groups = groups
	g.require(groupedHeartRateAlertResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlertResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHeartRateAlertResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateAlertResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHeartRateAlertResponseFieldNextCursor)
}

func (g *GroupedHeartRateAlertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateAlertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateAlertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateAlertResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateAlertResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateAlertResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateRecoveryOneMinuteFieldSource = big.NewInt(1 << 0)
	groupedHeartRateRecoveryOneMinuteFieldData   = big.NewInt(1 << 1)
)

type GroupedHeartRateRecoveryOneMinute struct {
	Source *ClientFacingSource                             `json:"source" url:"source"`
	Data   []*ClientFacingHeartRateRecoveryOneMinuteSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateRecoveryOneMinute) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHeartRateRecoveryOneMinute) GetData() []*ClientFacingHeartRateRecoveryOneMinuteSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHeartRateRecoveryOneMinute) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateRecoveryOneMinute) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinute) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHeartRateRecoveryOneMinuteFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinute) SetData(data []*ClientFacingHeartRateRecoveryOneMinuteSample) {
	g.Data = data
	g.require(groupedHeartRateRecoveryOneMinuteFieldData)
}

func (g *GroupedHeartRateRecoveryOneMinute) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateRecoveryOneMinute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateRecoveryOneMinute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateRecoveryOneMinute) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateRecoveryOneMinute
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateRecoveryOneMinute) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateRecoveryOneMinuteResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHeartRateRecoveryOneMinuteResponseFieldNext       = big.NewInt(1 << 1)
	groupedHeartRateRecoveryOneMinuteResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHeartRateRecoveryOneMinuteResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRateRecoveryOneMinute `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetGroups() map[string][]*GroupedHeartRateRecoveryOneMinute {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinuteResponse) SetGroups(groups map[string][]*GroupedHeartRateRecoveryOneMinute) {
	g.Groups = groups
	g.require(groupedHeartRateRecoveryOneMinuteResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinuteResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHeartRateRecoveryOneMinuteResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateRecoveryOneMinuteResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHeartRateRecoveryOneMinuteResponseFieldNextCursor)
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateRecoveryOneMinuteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateRecoveryOneMinuteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateRecoveryOneMinuteResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateRecoveryOneMinuteResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHeartRateResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHeartRateResponseFieldNext       = big.NewInt(1 << 1)
	groupedHeartRateResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHeartRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHeartRate `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHeartRateResponse) GetGroups() map[string][]*GroupedHeartRate {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHeartRateResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHeartRateResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHeartRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHeartRateResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateResponse) SetGroups(groups map[string][]*GroupedHeartRate) {
	g.Groups = groups
	g.require(groupedHeartRateResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHeartRateResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHeartRateResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHeartRateResponseFieldNextCursor)
}

func (g *GroupedHeartRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHeartRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHeartRateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHeartRateResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHeartRateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHeartRateResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHrvFieldSource = big.NewInt(1 << 0)
	groupedHrvFieldData   = big.NewInt(1 << 1)
)

type GroupedHrv struct {
	Source *ClientFacingSource          `json:"source" url:"source"`
	Data   []*ClientFacingHrvTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHrv) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHrv) GetData() []*ClientFacingHrvTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHrv) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrv) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrv) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHrvFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrv) SetData(data []*ClientFacingHrvTimeseries) {
	g.Data = data
	g.require(groupedHrvFieldData)
}

func (g *GroupedHrv) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrv
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrv(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrv) MarshalJSON() ([]byte, error) {
	type embed GroupedHrv
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHrv) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHrvResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHrvResponseFieldNext       = big.NewInt(1 << 1)
	groupedHrvResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHrvResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHrv `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHrvResponse) GetGroups() map[string][]*GroupedHrv {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHrvResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHrvResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHrvResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHrvResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrvResponse) SetGroups(groups map[string][]*GroupedHrv) {
	g.Groups = groups
	g.require(groupedHrvResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrvResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHrvResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHrvResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHrvResponseFieldNextCursor)
}

func (g *GroupedHrvResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHrvResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHrvResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHrvResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHrvResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHrvResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHypnogramFieldSource = big.NewInt(1 << 0)
	groupedHypnogramFieldData   = big.NewInt(1 << 1)
)

type GroupedHypnogram struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingHypnogramTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHypnogram) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedHypnogram) GetData() []*ClientFacingHypnogramTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedHypnogram) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogram) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogram) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedHypnogramFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogram) SetData(data []*ClientFacingHypnogramTimeseries) {
	g.Data = data
	g.require(groupedHypnogramFieldData)
}

func (g *GroupedHypnogram) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogram(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogram) MarshalJSON() ([]byte, error) {
	type embed GroupedHypnogram
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHypnogram) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedHypnogramResponseFieldGroups     = big.NewInt(1 << 0)
	groupedHypnogramResponseFieldNext       = big.NewInt(1 << 1)
	groupedHypnogramResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedHypnogramResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedHypnogram `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedHypnogramResponse) GetGroups() map[string][]*GroupedHypnogram {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedHypnogramResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedHypnogramResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedHypnogramResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedHypnogramResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogramResponse) SetGroups(groups map[string][]*GroupedHypnogram) {
	g.Groups = groups
	g.require(groupedHypnogramResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogramResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedHypnogramResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedHypnogramResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedHypnogramResponseFieldNextCursor)
}

func (g *GroupedHypnogramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedHypnogramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedHypnogramResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedHypnogramResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedHypnogramResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedHypnogramResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIgeFieldSource = big.NewInt(1 << 0)
	groupedIgeFieldData   = big.NewInt(1 << 1)
)

type GroupedIge struct {
	Source *ClientFacingSource          `json:"source" url:"source"`
	Data   []*ClientFacingIgeTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIge) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedIge) GetData() []*ClientFacingIgeTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedIge) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIge) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIge) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedIgeFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIge) SetData(data []*ClientFacingIgeTimeseries) {
	g.Data = data
	g.require(groupedIgeFieldData)
}

func (g *GroupedIge) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIge) MarshalJSON() ([]byte, error) {
	type embed GroupedIge
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIge) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIgeResponseFieldGroups     = big.NewInt(1 << 0)
	groupedIgeResponseFieldNext       = big.NewInt(1 << 1)
	groupedIgeResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedIgeResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIge `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIgeResponse) GetGroups() map[string][]*GroupedIge {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedIgeResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedIgeResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedIgeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgeResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgeResponse) SetGroups(groups map[string][]*GroupedIge) {
	g.Groups = groups
	g.require(groupedIgeResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgeResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedIgeResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgeResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedIgeResponseFieldNextCursor)
}

func (g *GroupedIgeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgeResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedIgeResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIgeResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIggFieldSource = big.NewInt(1 << 0)
	groupedIggFieldData   = big.NewInt(1 << 1)
)

type GroupedIgg struct {
	Source *ClientFacingSource          `json:"source" url:"source"`
	Data   []*ClientFacingIggTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIgg) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedIgg) GetData() []*ClientFacingIggTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedIgg) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIgg) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgg) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedIggFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIgg) SetData(data []*ClientFacingIggTimeseries) {
	g.Data = data
	g.require(groupedIggFieldData)
}

func (g *GroupedIgg) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIgg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIgg(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIgg) MarshalJSON() ([]byte, error) {
	type embed GroupedIgg
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIgg) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedIggResponseFieldGroups     = big.NewInt(1 << 0)
	groupedIggResponseFieldNext       = big.NewInt(1 << 1)
	groupedIggResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedIggResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedIgg `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedIggResponse) GetGroups() map[string][]*GroupedIgg {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedIggResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedIggResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedIggResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedIggResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIggResponse) SetGroups(groups map[string][]*GroupedIgg) {
	g.Groups = groups
	g.require(groupedIggResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIggResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedIggResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedIggResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedIggResponseFieldNextCursor)
}

func (g *GroupedIggResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedIggResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedIggResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedIggResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedIggResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedIggResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInhalerUsageFieldSource = big.NewInt(1 << 0)
	groupedInhalerUsageFieldData   = big.NewInt(1 << 1)
)

type GroupedInhalerUsage struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingInhalerUsageSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInhalerUsage) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedInhalerUsage) GetData() []*ClientFacingInhalerUsageSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedInhalerUsage) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInhalerUsage) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsage) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedInhalerUsageFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsage) SetData(data []*ClientFacingInhalerUsageSample) {
	g.Data = data
	g.require(groupedInhalerUsageFieldData)
}

func (g *GroupedInhalerUsage) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInhalerUsage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInhalerUsage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInhalerUsage) MarshalJSON() ([]byte, error) {
	type embed GroupedInhalerUsage
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInhalerUsage) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInhalerUsageResponseFieldGroups     = big.NewInt(1 << 0)
	groupedInhalerUsageResponseFieldNext       = big.NewInt(1 << 1)
	groupedInhalerUsageResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedInhalerUsageResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedInhalerUsage `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInhalerUsageResponse) GetGroups() map[string][]*GroupedInhalerUsage {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedInhalerUsageResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedInhalerUsageResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedInhalerUsageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInhalerUsageResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsageResponse) SetGroups(groups map[string][]*GroupedInhalerUsage) {
	g.Groups = groups
	g.require(groupedInhalerUsageResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsageResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedInhalerUsageResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInhalerUsageResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedInhalerUsageResponseFieldNextCursor)
}

func (g *GroupedInhalerUsageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInhalerUsageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInhalerUsageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInhalerUsageResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedInhalerUsageResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInhalerUsageResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInsulinInjectionFieldSource = big.NewInt(1 << 0)
	groupedInsulinInjectionFieldData   = big.NewInt(1 << 1)
)

type GroupedInsulinInjection struct {
	Source *ClientFacingSource                   `json:"source" url:"source"`
	Data   []*ClientFacingInsulinInjectionSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInsulinInjection) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedInsulinInjection) GetData() []*ClientFacingInsulinInjectionSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedInsulinInjection) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInsulinInjection) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjection) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedInsulinInjectionFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjection) SetData(data []*ClientFacingInsulinInjectionSample) {
	g.Data = data
	g.require(groupedInsulinInjectionFieldData)
}

func (g *GroupedInsulinInjection) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInsulinInjection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInsulinInjection(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInsulinInjection) MarshalJSON() ([]byte, error) {
	type embed GroupedInsulinInjection
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInsulinInjection) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedInsulinInjectionResponseFieldGroups     = big.NewInt(1 << 0)
	groupedInsulinInjectionResponseFieldNext       = big.NewInt(1 << 1)
	groupedInsulinInjectionResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedInsulinInjectionResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedInsulinInjection `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedInsulinInjectionResponse) GetGroups() map[string][]*GroupedInsulinInjection {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedInsulinInjectionResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedInsulinInjectionResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedInsulinInjectionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedInsulinInjectionResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjectionResponse) SetGroups(groups map[string][]*GroupedInsulinInjection) {
	g.Groups = groups
	g.require(groupedInsulinInjectionResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjectionResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedInsulinInjectionResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedInsulinInjectionResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedInsulinInjectionResponseFieldNextCursor)
}

func (g *GroupedInsulinInjectionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedInsulinInjectionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedInsulinInjectionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedInsulinInjectionResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedInsulinInjectionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedInsulinInjectionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedLeanBodyMassFieldSource = big.NewInt(1 << 0)
	groupedLeanBodyMassFieldData   = big.NewInt(1 << 1)
)

type GroupedLeanBodyMass struct {
	Source *ClientFacingSource               `json:"source" url:"source"`
	Data   []*ClientFacingLeanBodyMassSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedLeanBodyMass) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedLeanBodyMass) GetData() []*ClientFacingLeanBodyMassSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedLeanBodyMass) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedLeanBodyMass) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMass) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedLeanBodyMassFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMass) SetData(data []*ClientFacingLeanBodyMassSample) {
	g.Data = data
	g.require(groupedLeanBodyMassFieldData)
}

func (g *GroupedLeanBodyMass) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedLeanBodyMass
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedLeanBodyMass(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedLeanBodyMass) MarshalJSON() ([]byte, error) {
	type embed GroupedLeanBodyMass
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedLeanBodyMass) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedLeanBodyMassResponseFieldGroups     = big.NewInt(1 << 0)
	groupedLeanBodyMassResponseFieldNext       = big.NewInt(1 << 1)
	groupedLeanBodyMassResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedLeanBodyMassResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedLeanBodyMass `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedLeanBodyMassResponse) GetGroups() map[string][]*GroupedLeanBodyMass {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedLeanBodyMassResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedLeanBodyMassResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedLeanBodyMassResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedLeanBodyMassResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMassResponse) SetGroups(groups map[string][]*GroupedLeanBodyMass) {
	g.Groups = groups
	g.require(groupedLeanBodyMassResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMassResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedLeanBodyMassResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedLeanBodyMassResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedLeanBodyMassResponseFieldNextCursor)
}

func (g *GroupedLeanBodyMassResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedLeanBodyMassResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedLeanBodyMassResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedLeanBodyMassResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedLeanBodyMassResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedLeanBodyMassResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedMindfulnessMinutesFieldSource = big.NewInt(1 << 0)
	groupedMindfulnessMinutesFieldData   = big.NewInt(1 << 1)
)

type GroupedMindfulnessMinutes struct {
	Source *ClientFacingSource                         `json:"source" url:"source"`
	Data   []*ClientFacingMindfulnessMinutesTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedMindfulnessMinutes) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedMindfulnessMinutes) GetData() []*ClientFacingMindfulnessMinutesTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedMindfulnessMinutes) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutes) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutes) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedMindfulnessMinutesFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutes) SetData(data []*ClientFacingMindfulnessMinutesTimeseries) {
	g.Data = data
	g.require(groupedMindfulnessMinutesFieldData)
}

func (g *GroupedMindfulnessMinutes) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutes) MarshalJSON() ([]byte, error) {
	type embed GroupedMindfulnessMinutes
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedMindfulnessMinutes) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedMindfulnessMinutesResponseFieldGroups     = big.NewInt(1 << 0)
	groupedMindfulnessMinutesResponseFieldNext       = big.NewInt(1 << 1)
	groupedMindfulnessMinutesResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedMindfulnessMinutesResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedMindfulnessMinutes `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedMindfulnessMinutesResponse) GetGroups() map[string][]*GroupedMindfulnessMinutes {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedMindfulnessMinutesResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedMindfulnessMinutesResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedMindfulnessMinutesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedMindfulnessMinutesResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutesResponse) SetGroups(groups map[string][]*GroupedMindfulnessMinutes) {
	g.Groups = groups
	g.require(groupedMindfulnessMinutesResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutesResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedMindfulnessMinutesResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedMindfulnessMinutesResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedMindfulnessMinutesResponseFieldNextCursor)
}

func (g *GroupedMindfulnessMinutesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedMindfulnessMinutesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedMindfulnessMinutesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedMindfulnessMinutesResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedMindfulnessMinutesResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedMindfulnessMinutesResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedNoteFieldSource = big.NewInt(1 << 0)
	groupedNoteFieldData   = big.NewInt(1 << 1)
)

type GroupedNote struct {
	Source *ClientFacingSource       `json:"source" url:"source"`
	Data   []*ClientFacingNoteSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedNote) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedNote) GetData() []*ClientFacingNoteSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedNote) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedNote) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNote) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedNoteFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNote) SetData(data []*ClientFacingNoteSample) {
	g.Data = data
	g.require(groupedNoteFieldData)
}

func (g *GroupedNote) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedNote
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedNote(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedNote) MarshalJSON() ([]byte, error) {
	type embed GroupedNote
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedNote) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedNoteResponseFieldGroups     = big.NewInt(1 << 0)
	groupedNoteResponseFieldNext       = big.NewInt(1 << 1)
	groupedNoteResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedNoteResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedNote `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedNoteResponse) GetGroups() map[string][]*GroupedNote {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedNoteResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedNoteResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedNoteResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedNoteResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNoteResponse) SetGroups(groups map[string][]*GroupedNote) {
	g.Groups = groups
	g.require(groupedNoteResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNoteResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedNoteResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedNoteResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedNoteResponseFieldNextCursor)
}

func (g *GroupedNoteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedNoteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedNoteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedNoteResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedNoteResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedNoteResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedPeakExpiratoryFlowRateFieldSource = big.NewInt(1 << 0)
	groupedPeakExpiratoryFlowRateFieldData   = big.NewInt(1 << 1)
)

type GroupedPeakExpiratoryFlowRate struct {
	Source *ClientFacingSource                         `json:"source" url:"source"`
	Data   []*ClientFacingPeakExpiratoryFlowRateSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedPeakExpiratoryFlowRate) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedPeakExpiratoryFlowRate) GetData() []*ClientFacingPeakExpiratoryFlowRateSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedPeakExpiratoryFlowRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedPeakExpiratoryFlowRate) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRate) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedPeakExpiratoryFlowRateFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRate) SetData(data []*ClientFacingPeakExpiratoryFlowRateSample) {
	g.Data = data
	g.require(groupedPeakExpiratoryFlowRateFieldData)
}

func (g *GroupedPeakExpiratoryFlowRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedPeakExpiratoryFlowRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedPeakExpiratoryFlowRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedPeakExpiratoryFlowRate) MarshalJSON() ([]byte, error) {
	type embed GroupedPeakExpiratoryFlowRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedPeakExpiratoryFlowRate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedPeakExpiratoryFlowRateResponseFieldGroups     = big.NewInt(1 << 0)
	groupedPeakExpiratoryFlowRateResponseFieldNext       = big.NewInt(1 << 1)
	groupedPeakExpiratoryFlowRateResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedPeakExpiratoryFlowRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedPeakExpiratoryFlowRate `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetGroups() map[string][]*GroupedPeakExpiratoryFlowRate {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedPeakExpiratoryFlowRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedPeakExpiratoryFlowRateResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRateResponse) SetGroups(groups map[string][]*GroupedPeakExpiratoryFlowRate) {
	g.Groups = groups
	g.require(groupedPeakExpiratoryFlowRateResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRateResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedPeakExpiratoryFlowRateResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedPeakExpiratoryFlowRateResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedPeakExpiratoryFlowRateResponseFieldNextCursor)
}

func (g *GroupedPeakExpiratoryFlowRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedPeakExpiratoryFlowRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedPeakExpiratoryFlowRateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedPeakExpiratoryFlowRateResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedPeakExpiratoryFlowRateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedPeakExpiratoryFlowRateResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedRespiratoryRateFieldSource = big.NewInt(1 << 0)
	groupedRespiratoryRateFieldData   = big.NewInt(1 << 1)
)

type GroupedRespiratoryRate struct {
	Source *ClientFacingSource                      `json:"source" url:"source"`
	Data   []*ClientFacingRespiratoryRateTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedRespiratoryRate) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedRespiratoryRate) GetData() []*ClientFacingRespiratoryRateTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedRespiratoryRate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRate) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRate) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedRespiratoryRateFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRate) SetData(data []*ClientFacingRespiratoryRateTimeseries) {
	g.Data = data
	g.require(groupedRespiratoryRateFieldData)
}

func (g *GroupedRespiratoryRate) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRate) MarshalJSON() ([]byte, error) {
	type embed GroupedRespiratoryRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedRespiratoryRate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedRespiratoryRateResponseFieldGroups     = big.NewInt(1 << 0)
	groupedRespiratoryRateResponseFieldNext       = big.NewInt(1 << 1)
	groupedRespiratoryRateResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedRespiratoryRateResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedRespiratoryRate `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedRespiratoryRateResponse) GetGroups() map[string][]*GroupedRespiratoryRate {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedRespiratoryRateResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedRespiratoryRateResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedRespiratoryRateResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedRespiratoryRateResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRateResponse) SetGroups(groups map[string][]*GroupedRespiratoryRate) {
	g.Groups = groups
	g.require(groupedRespiratoryRateResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRateResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedRespiratoryRateResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedRespiratoryRateResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedRespiratoryRateResponseFieldNextCursor)
}

func (g *GroupedRespiratoryRateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedRespiratoryRateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedRespiratoryRateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedRespiratoryRateResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedRespiratoryRateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedRespiratoryRateResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepApneaAlertFieldSource = big.NewInt(1 << 0)
	groupedSleepApneaAlertFieldData   = big.NewInt(1 << 1)
)

type GroupedSleepApneaAlert struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingSleepApneaAlertSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepApneaAlert) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedSleepApneaAlert) GetData() []*ClientFacingSleepApneaAlertSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedSleepApneaAlert) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepApneaAlert) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlert) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedSleepApneaAlertFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlert) SetData(data []*ClientFacingSleepApneaAlertSample) {
	g.Data = data
	g.require(groupedSleepApneaAlertFieldData)
}

func (g *GroupedSleepApneaAlert) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepApneaAlert
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepApneaAlert(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepApneaAlert) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepApneaAlert
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepApneaAlert) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepApneaAlertResponseFieldGroups     = big.NewInt(1 << 0)
	groupedSleepApneaAlertResponseFieldNext       = big.NewInt(1 << 1)
	groupedSleepApneaAlertResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedSleepApneaAlertResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSleepApneaAlert `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepApneaAlertResponse) GetGroups() map[string][]*GroupedSleepApneaAlert {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedSleepApneaAlertResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedSleepApneaAlertResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedSleepApneaAlertResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepApneaAlertResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlertResponse) SetGroups(groups map[string][]*GroupedSleepApneaAlert) {
	g.Groups = groups
	g.require(groupedSleepApneaAlertResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlertResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedSleepApneaAlertResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepApneaAlertResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedSleepApneaAlertResponseFieldNextCursor)
}

func (g *GroupedSleepApneaAlertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepApneaAlertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepApneaAlertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepApneaAlertResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepApneaAlertResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepApneaAlertResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepBreathingDisturbanceFieldSource = big.NewInt(1 << 0)
	groupedSleepBreathingDisturbanceFieldData   = big.NewInt(1 << 1)
)

type GroupedSleepBreathingDisturbance struct {
	Source *ClientFacingSource                            `json:"source" url:"source"`
	Data   []*ClientFacingSleepBreathingDisturbanceSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepBreathingDisturbance) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedSleepBreathingDisturbance) GetData() []*ClientFacingSleepBreathingDisturbanceSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedSleepBreathingDisturbance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepBreathingDisturbance) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbance) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedSleepBreathingDisturbanceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbance) SetData(data []*ClientFacingSleepBreathingDisturbanceSample) {
	g.Data = data
	g.require(groupedSleepBreathingDisturbanceFieldData)
}

func (g *GroupedSleepBreathingDisturbance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepBreathingDisturbance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepBreathingDisturbance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepBreathingDisturbance) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepBreathingDisturbance
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepBreathingDisturbance) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedSleepBreathingDisturbanceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedSleepBreathingDisturbanceResponseFieldNext       = big.NewInt(1 << 1)
	groupedSleepBreathingDisturbanceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedSleepBreathingDisturbanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSleepBreathingDisturbance `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetGroups() map[string][]*GroupedSleepBreathingDisturbance {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedSleepBreathingDisturbanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSleepBreathingDisturbanceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbanceResponse) SetGroups(groups map[string][]*GroupedSleepBreathingDisturbance) {
	g.Groups = groups
	g.require(groupedSleepBreathingDisturbanceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbanceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedSleepBreathingDisturbanceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSleepBreathingDisturbanceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedSleepBreathingDisturbanceResponseFieldNextCursor)
}

func (g *GroupedSleepBreathingDisturbanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSleepBreathingDisturbanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSleepBreathingDisturbanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSleepBreathingDisturbanceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedSleepBreathingDisturbanceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSleepBreathingDisturbanceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandDurationFieldSource = big.NewInt(1 << 0)
	groupedStandDurationFieldData   = big.NewInt(1 << 1)
)

type GroupedStandDuration struct {
	Source *ClientFacingSource                `json:"source" url:"source"`
	Data   []*ClientFacingStandDurationSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandDuration) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedStandDuration) GetData() []*ClientFacingStandDurationSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedStandDuration) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandDuration) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDuration) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStandDurationFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDuration) SetData(data []*ClientFacingStandDurationSample) {
	g.Data = data
	g.require(groupedStandDurationFieldData)
}

func (g *GroupedStandDuration) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandDuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandDuration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandDuration) MarshalJSON() ([]byte, error) {
	type embed GroupedStandDuration
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandDuration) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandDurationResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStandDurationResponseFieldNext       = big.NewInt(1 << 1)
	groupedStandDurationResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStandDurationResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStandDuration `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandDurationResponse) GetGroups() map[string][]*GroupedStandDuration {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStandDurationResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStandDurationResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStandDurationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandDurationResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDurationResponse) SetGroups(groups map[string][]*GroupedStandDuration) {
	g.Groups = groups
	g.require(groupedStandDurationResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDurationResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStandDurationResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandDurationResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStandDurationResponseFieldNextCursor)
}

func (g *GroupedStandDurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandDurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandDurationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandDurationResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStandDurationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandDurationResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandHourFieldSource = big.NewInt(1 << 0)
	groupedStandHourFieldData   = big.NewInt(1 << 1)
)

type GroupedStandHour struct {
	Source *ClientFacingSource            `json:"source" url:"source"`
	Data   []*ClientFacingStandHourSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandHour) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedStandHour) GetData() []*ClientFacingStandHourSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedStandHour) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandHour) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHour) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStandHourFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHour) SetData(data []*ClientFacingStandHourSample) {
	g.Data = data
	g.require(groupedStandHourFieldData)
}

func (g *GroupedStandHour) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandHour
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandHour(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandHour) MarshalJSON() ([]byte, error) {
	type embed GroupedStandHour
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandHour) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStandHourResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStandHourResponseFieldNext       = big.NewInt(1 << 1)
	groupedStandHourResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStandHourResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStandHour `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStandHourResponse) GetGroups() map[string][]*GroupedStandHour {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStandHourResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStandHourResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStandHourResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStandHourResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHourResponse) SetGroups(groups map[string][]*GroupedStandHour) {
	g.Groups = groups
	g.require(groupedStandHourResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHourResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStandHourResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStandHourResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStandHourResponseFieldNextCursor)
}

func (g *GroupedStandHourResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStandHourResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStandHourResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStandHourResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStandHourResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStandHourResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStepsFieldSource = big.NewInt(1 << 0)
	groupedStepsFieldData   = big.NewInt(1 << 1)
)

type GroupedSteps struct {
	Source *ClientFacingSource            `json:"source" url:"source"`
	Data   []*ClientFacingStepsTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedSteps) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedSteps) GetData() []*ClientFacingStepsTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedSteps) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedSteps) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSteps) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStepsFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedSteps) SetData(data []*ClientFacingStepsTimeseries) {
	g.Data = data
	g.require(groupedStepsFieldData)
}

func (g *GroupedSteps) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedSteps
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedSteps(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedSteps) MarshalJSON() ([]byte, error) {
	type embed GroupedSteps
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedSteps) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStepsResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStepsResponseFieldNext       = big.NewInt(1 << 1)
	groupedStepsResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStepsResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedSteps `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStepsResponse) GetGroups() map[string][]*GroupedSteps {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStepsResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStepsResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStepsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStepsResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStepsResponse) SetGroups(groups map[string][]*GroupedSteps) {
	g.Groups = groups
	g.require(groupedStepsResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStepsResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStepsResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStepsResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStepsResponseFieldNextCursor)
}

func (g *GroupedStepsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStepsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStepsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStepsResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStepsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStepsResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStressLevelFieldSource = big.NewInt(1 << 0)
	groupedStressLevelFieldData   = big.NewInt(1 << 1)
)

type GroupedStressLevel struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingStressLevelTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStressLevel) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedStressLevel) GetData() []*ClientFacingStressLevelTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedStressLevel) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevel) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevel) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedStressLevelFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevel) SetData(data []*ClientFacingStressLevelTimeseries) {
	g.Data = data
	g.require(groupedStressLevelFieldData)
}

func (g *GroupedStressLevel) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevel) MarshalJSON() ([]byte, error) {
	type embed GroupedStressLevel
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStressLevel) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedStressLevelResponseFieldGroups     = big.NewInt(1 << 0)
	groupedStressLevelResponseFieldNext       = big.NewInt(1 << 1)
	groupedStressLevelResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedStressLevelResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedStressLevel `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedStressLevelResponse) GetGroups() map[string][]*GroupedStressLevel {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedStressLevelResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedStressLevelResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedStressLevelResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedStressLevelResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevelResponse) SetGroups(groups map[string][]*GroupedStressLevel) {
	g.Groups = groups
	g.require(groupedStressLevelResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevelResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedStressLevelResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedStressLevelResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedStressLevelResponseFieldNextCursor)
}

func (g *GroupedStressLevelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedStressLevelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedStressLevelResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedStressLevelResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedStressLevelResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedStressLevelResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedUvExposureFieldSource = big.NewInt(1 << 0)
	groupedUvExposureFieldData   = big.NewInt(1 << 1)
)

type GroupedUvExposure struct {
	Source *ClientFacingSource             `json:"source" url:"source"`
	Data   []*ClientFacingUvExposureSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedUvExposure) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedUvExposure) GetData() []*ClientFacingUvExposureSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedUvExposure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedUvExposure) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposure) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedUvExposureFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposure) SetData(data []*ClientFacingUvExposureSample) {
	g.Data = data
	g.require(groupedUvExposureFieldData)
}

func (g *GroupedUvExposure) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedUvExposure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedUvExposure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedUvExposure) MarshalJSON() ([]byte, error) {
	type embed GroupedUvExposure
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedUvExposure) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedUvExposureResponseFieldGroups     = big.NewInt(1 << 0)
	groupedUvExposureResponseFieldNext       = big.NewInt(1 << 1)
	groupedUvExposureResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedUvExposureResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedUvExposure `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedUvExposureResponse) GetGroups() map[string][]*GroupedUvExposure {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedUvExposureResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedUvExposureResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedUvExposureResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedUvExposureResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposureResponse) SetGroups(groups map[string][]*GroupedUvExposure) {
	g.Groups = groups
	g.require(groupedUvExposureResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposureResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedUvExposureResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedUvExposureResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedUvExposureResponseFieldNextCursor)
}

func (g *GroupedUvExposureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedUvExposureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedUvExposureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedUvExposureResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedUvExposureResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedUvExposureResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedVo2MaxFieldSource = big.NewInt(1 << 0)
	groupedVo2MaxFieldData   = big.NewInt(1 << 1)
)

type GroupedVo2Max struct {
	Source *ClientFacingSource             `json:"source" url:"source"`
	Data   []*ClientFacingVo2MaxTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedVo2Max) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedVo2Max) GetData() []*ClientFacingVo2MaxTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedVo2Max) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2Max) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2Max) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedVo2MaxFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2Max) SetData(data []*ClientFacingVo2MaxTimeseries) {
	g.Data = data
	g.require(groupedVo2MaxFieldData)
}

func (g *GroupedVo2Max) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2Max
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2Max(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2Max) MarshalJSON() ([]byte, error) {
	type embed GroupedVo2Max
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedVo2Max) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedVo2MaxResponseFieldGroups     = big.NewInt(1 << 0)
	groupedVo2MaxResponseFieldNext       = big.NewInt(1 << 1)
	groupedVo2MaxResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedVo2MaxResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedVo2Max `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedVo2MaxResponse) GetGroups() map[string][]*GroupedVo2Max {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedVo2MaxResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedVo2MaxResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedVo2MaxResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedVo2MaxResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2MaxResponse) SetGroups(groups map[string][]*GroupedVo2Max) {
	g.Groups = groups
	g.require(groupedVo2MaxResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2MaxResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedVo2MaxResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedVo2MaxResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedVo2MaxResponseFieldNextCursor)
}

func (g *GroupedVo2MaxResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedVo2MaxResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedVo2MaxResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedVo2MaxResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedVo2MaxResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedVo2MaxResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaistCircumferenceFieldSource = big.NewInt(1 << 0)
	groupedWaistCircumferenceFieldData   = big.NewInt(1 << 1)
)

type GroupedWaistCircumference struct {
	Source *ClientFacingSource                     `json:"source" url:"source"`
	Data   []*ClientFacingWaistCircumferenceSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWaistCircumference) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWaistCircumference) GetData() []*ClientFacingWaistCircumferenceSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWaistCircumference) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaistCircumference) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumference) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWaistCircumferenceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumference) SetData(data []*ClientFacingWaistCircumferenceSample) {
	g.Data = data
	g.require(groupedWaistCircumferenceFieldData)
}

func (g *GroupedWaistCircumference) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaistCircumference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaistCircumference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaistCircumference) MarshalJSON() ([]byte, error) {
	type embed GroupedWaistCircumference
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWaistCircumference) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaistCircumferenceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWaistCircumferenceResponseFieldNext       = big.NewInt(1 << 1)
	groupedWaistCircumferenceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWaistCircumferenceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWaistCircumference `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWaistCircumferenceResponse) GetGroups() map[string][]*GroupedWaistCircumference {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWaistCircumferenceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWaistCircumferenceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWaistCircumferenceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaistCircumferenceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumferenceResponse) SetGroups(groups map[string][]*GroupedWaistCircumference) {
	g.Groups = groups
	g.require(groupedWaistCircumferenceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumferenceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWaistCircumferenceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaistCircumferenceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWaistCircumferenceResponseFieldNextCursor)
}

func (g *GroupedWaistCircumferenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaistCircumferenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaistCircumferenceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaistCircumferenceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWaistCircumferenceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWaistCircumferenceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaterFieldSource = big.NewInt(1 << 0)
	groupedWaterFieldData   = big.NewInt(1 << 1)
)

type GroupedWater struct {
	Source *ClientFacingSource            `json:"source" url:"source"`
	Data   []*ClientFacingWaterTimeseries `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWater) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWater) GetData() []*ClientFacingWaterTimeseries {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWater) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWater) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWater) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWaterFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWater) SetData(data []*ClientFacingWaterTimeseries) {
	g.Data = data
	g.require(groupedWaterFieldData)
}

func (g *GroupedWater) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWater
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWater(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWater) MarshalJSON() ([]byte, error) {
	type embed GroupedWater
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWater) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWaterResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWaterResponseFieldNext       = big.NewInt(1 << 1)
	groupedWaterResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWaterResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWater `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWaterResponse) GetGroups() map[string][]*GroupedWater {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWaterResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWaterResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWaterResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWaterResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaterResponse) SetGroups(groups map[string][]*GroupedWater) {
	g.Groups = groups
	g.require(groupedWaterResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaterResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWaterResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWaterResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWaterResponseFieldNextCursor)
}

func (g *GroupedWaterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWaterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWaterResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWaterResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWaterResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWaterResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWheelchairPushFieldSource = big.NewInt(1 << 0)
	groupedWheelchairPushFieldData   = big.NewInt(1 << 1)
)

type GroupedWheelchairPush struct {
	Source *ClientFacingSource                 `json:"source" url:"source"`
	Data   []*ClientFacingWheelchairPushSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWheelchairPush) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWheelchairPush) GetData() []*ClientFacingWheelchairPushSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWheelchairPush) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWheelchairPush) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPush) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWheelchairPushFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPush) SetData(data []*ClientFacingWheelchairPushSample) {
	g.Data = data
	g.require(groupedWheelchairPushFieldData)
}

func (g *GroupedWheelchairPush) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWheelchairPush
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWheelchairPush(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWheelchairPush) MarshalJSON() ([]byte, error) {
	type embed GroupedWheelchairPush
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWheelchairPush) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWheelchairPushResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWheelchairPushResponseFieldNext       = big.NewInt(1 << 1)
	groupedWheelchairPushResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWheelchairPushResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWheelchairPush `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWheelchairPushResponse) GetGroups() map[string][]*GroupedWheelchairPush {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWheelchairPushResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWheelchairPushResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWheelchairPushResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWheelchairPushResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPushResponse) SetGroups(groups map[string][]*GroupedWheelchairPush) {
	g.Groups = groups
	g.require(groupedWheelchairPushResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPushResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWheelchairPushResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWheelchairPushResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWheelchairPushResponseFieldNextCursor)
}

func (g *GroupedWheelchairPushResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWheelchairPushResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWheelchairPushResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWheelchairPushResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWheelchairPushResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWheelchairPushResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDistanceFieldSource = big.NewInt(1 << 0)
	groupedWorkoutDistanceFieldData   = big.NewInt(1 << 1)
)

type GroupedWorkoutDistance struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingWorkoutDistanceSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDistance) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWorkoutDistance) GetData() []*ClientFacingWorkoutDistanceSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWorkoutDistance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDistance) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistance) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWorkoutDistanceFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistance) SetData(data []*ClientFacingWorkoutDistanceSample) {
	g.Data = data
	g.require(groupedWorkoutDistanceFieldData)
}

func (g *GroupedWorkoutDistance) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDistance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDistance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDistance) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDistance
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDistance) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDistanceResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWorkoutDistanceResponseFieldNext       = big.NewInt(1 << 1)
	groupedWorkoutDistanceResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWorkoutDistanceResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWorkoutDistance `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDistanceResponse) GetGroups() map[string][]*GroupedWorkoutDistance {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWorkoutDistanceResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWorkoutDistanceResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWorkoutDistanceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDistanceResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistanceResponse) SetGroups(groups map[string][]*GroupedWorkoutDistance) {
	g.Groups = groups
	g.require(groupedWorkoutDistanceResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistanceResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWorkoutDistanceResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDistanceResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWorkoutDistanceResponseFieldNextCursor)
}

func (g *GroupedWorkoutDistanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDistanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDistanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDistanceResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDistanceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDistanceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDurationFieldSource = big.NewInt(1 << 0)
	groupedWorkoutDurationFieldData   = big.NewInt(1 << 1)
)

type GroupedWorkoutDuration struct {
	Source *ClientFacingSource                  `json:"source" url:"source"`
	Data   []*ClientFacingWorkoutDurationSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDuration) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWorkoutDuration) GetData() []*ClientFacingWorkoutDurationSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWorkoutDuration) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDuration) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDuration) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWorkoutDurationFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDuration) SetData(data []*ClientFacingWorkoutDurationSample) {
	g.Data = data
	g.require(groupedWorkoutDurationFieldData)
}

func (g *GroupedWorkoutDuration) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDuration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDuration) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDuration
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDuration) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutDurationResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWorkoutDurationResponseFieldNext       = big.NewInt(1 << 1)
	groupedWorkoutDurationResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWorkoutDurationResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWorkoutDuration `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutDurationResponse) GetGroups() map[string][]*GroupedWorkoutDuration {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWorkoutDurationResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWorkoutDurationResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWorkoutDurationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutDurationResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDurationResponse) SetGroups(groups map[string][]*GroupedWorkoutDuration) {
	g.Groups = groups
	g.require(groupedWorkoutDurationResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDurationResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWorkoutDurationResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutDurationResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWorkoutDurationResponseFieldNextCursor)
}

func (g *GroupedWorkoutDurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutDurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutDurationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutDurationResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutDurationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutDurationResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutSwimmingStrokeFieldSource = big.NewInt(1 << 0)
	groupedWorkoutSwimmingStrokeFieldData   = big.NewInt(1 << 1)
)

type GroupedWorkoutSwimmingStroke struct {
	Source *ClientFacingSource                        `json:"source" url:"source"`
	Data   []*ClientFacingWorkoutSwimmingStrokeSample `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutSwimmingStroke) GetSource() *ClientFacingSource {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GroupedWorkoutSwimmingStroke) GetData() []*ClientFacingWorkoutSwimmingStrokeSample {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GroupedWorkoutSwimmingStroke) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutSwimmingStroke) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStroke) SetSource(source *ClientFacingSource) {
	g.Source = source
	g.require(groupedWorkoutSwimmingStrokeFieldSource)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStroke) SetData(data []*ClientFacingWorkoutSwimmingStrokeSample) {
	g.Data = data
	g.require(groupedWorkoutSwimmingStrokeFieldData)
}

func (g *GroupedWorkoutSwimmingStroke) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutSwimmingStroke
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutSwimmingStroke(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutSwimmingStroke) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutSwimmingStroke
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutSwimmingStroke) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	groupedWorkoutSwimmingStrokeResponseFieldGroups     = big.NewInt(1 << 0)
	groupedWorkoutSwimmingStrokeResponseFieldNext       = big.NewInt(1 << 1)
	groupedWorkoutSwimmingStrokeResponseFieldNextCursor = big.NewInt(1 << 2)
)

type GroupedWorkoutSwimmingStrokeResponse struct {
	// For each matching provider or lab, a list of grouped timeseries values.
	Groups map[string][]*GroupedWorkoutSwimmingStroke `json:"groups" url:"groups"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	Next *string `json:"next,omitempty" url:"next,omitempty"`
	// The cursor for fetching the next page, or `null` if there is no more data.
	NextCursor *string `json:"next_cursor,omitempty" url:"next_cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetGroups() map[string][]*GroupedWorkoutSwimmingStroke {
	if g == nil {
		return nil
	}
	return g.Groups
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetNext() *string {
	if g == nil {
		return nil
	}
	return g.Next
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetNextCursor() *string {
	if g == nil {
		return nil
	}
	return g.NextCursor
}

func (g *GroupedWorkoutSwimmingStrokeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupedWorkoutSwimmingStrokeResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetGroups sets the Groups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStrokeResponse) SetGroups(groups map[string][]*GroupedWorkoutSwimmingStroke) {
	g.Groups = groups
	g.require(groupedWorkoutSwimmingStrokeResponseFieldGroups)
}

// SetNext sets the Next field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStrokeResponse) SetNext(next *string) {
	g.Next = next
	g.require(groupedWorkoutSwimmingStrokeResponseFieldNext)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupedWorkoutSwimmingStrokeResponse) SetNextCursor(nextCursor *string) {
	g.NextCursor = nextCursor
	g.require(groupedWorkoutSwimmingStrokeResponseFieldNextCursor)
}

func (g *GroupedWorkoutSwimmingStrokeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupedWorkoutSwimmingStrokeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupedWorkoutSwimmingStrokeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupedWorkoutSwimmingStrokeResponse) MarshalJSON() ([]byte, error) {
	type embed GroupedWorkoutSwimmingStrokeResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupedWorkoutSwimmingStrokeResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	vitalsUvExposureGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsUvExposureGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsUvExposureGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsUvExposureGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsUvExposureGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsUvExposureGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsUvExposureGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsUvExposureGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsUvExposureGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsUvExposureGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsUvExposureGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsUvExposureGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsUvExposureGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsUvExposureGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsUvExposureGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsUvExposureGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsUvExposureGroupedRequestFieldEndDate)
}

var (
	vitalsVo2MaxRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsVo2MaxRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsVo2MaxRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsVo2MaxRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsVo2MaxRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsVo2MaxRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsVo2MaxRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsVo2MaxRequestFieldEndDate)
}

var (
	vitalsVo2MaxGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsVo2MaxGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsVo2MaxGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsVo2MaxGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsVo2MaxGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsVo2MaxGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsVo2MaxGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsVo2MaxGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsVo2MaxGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsVo2MaxGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsVo2MaxGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsVo2MaxGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsVo2MaxGroupedRequestFieldEndDate)
}

var (
	vitalsWaistCircumferenceGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsWaistCircumferenceGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsWaistCircumferenceGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsWaistCircumferenceGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsWaistCircumferenceGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsWaistCircumferenceGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsWaistCircumferenceGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaistCircumferenceGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsWaistCircumferenceGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaistCircumferenceGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsWaistCircumferenceGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaistCircumferenceGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsWaistCircumferenceGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaistCircumferenceGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsWaistCircumferenceGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaistCircumferenceGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsWaistCircumferenceGroupedRequestFieldEndDate)
}

var (
	vitalsWaterRequestFieldProvider  = big.NewInt(1 << 0)
	vitalsWaterRequestFieldStartDate = big.NewInt(1 << 1)
	vitalsWaterRequestFieldEndDate   = big.NewInt(1 << 2)
)

type VitalsWaterRequest struct {
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsWaterRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsWaterRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsWaterRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsWaterRequestFieldEndDate)
}

var (
	vitalsWaterGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsWaterGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsWaterGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsWaterGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsWaterGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsWaterGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsWaterGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsWaterGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsWaterGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsWaterGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsWaterGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWaterGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsWaterGroupedRequestFieldEndDate)
}

var (
	vitalsWheelchairPushGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsWheelchairPushGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsWheelchairPushGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsWheelchairPushGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsWheelchairPushGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsWheelchairPushGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsWheelchairPushGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWheelchairPushGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsWheelchairPushGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWheelchairPushGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsWheelchairPushGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWheelchairPushGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsWheelchairPushGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWheelchairPushGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsWheelchairPushGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWheelchairPushGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsWheelchairPushGroupedRequestFieldEndDate)
}

var (
	vitalsWorkoutDistanceGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsWorkoutDistanceGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsWorkoutDistanceGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsWorkoutDistanceGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsWorkoutDistanceGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsWorkoutDistanceGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsWorkoutDistanceGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDistanceGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsWorkoutDistanceGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDistanceGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsWorkoutDistanceGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDistanceGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsWorkoutDistanceGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDistanceGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsWorkoutDistanceGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDistanceGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsWorkoutDistanceGroupedRequestFieldEndDate)
}

var (
	vitalsWorkoutDurationGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsWorkoutDurationGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsWorkoutDurationGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsWorkoutDurationGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsWorkoutDurationGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsWorkoutDurationGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsWorkoutDurationGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDurationGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsWorkoutDurationGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDurationGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsWorkoutDurationGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDurationGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsWorkoutDurationGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDurationGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsWorkoutDurationGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutDurationGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsWorkoutDurationGroupedRequestFieldEndDate)
}

var (
	vitalsWorkoutSwimmingStrokeGroupedRequestFieldCursor     = big.NewInt(1 << 0)
	vitalsWorkoutSwimmingStrokeGroupedRequestFieldNextCursor = big.NewInt(1 << 1)
	vitalsWorkoutSwimmingStrokeGroupedRequestFieldProvider   = big.NewInt(1 << 2)
	vitalsWorkoutSwimmingStrokeGroupedRequestFieldStartDate  = big.NewInt(1 << 3)
	vitalsWorkoutSwimmingStrokeGroupedRequestFieldEndDate    = big.NewInt(1 << 4)
)

type VitalsWorkoutSwimmingStrokeGroupedRequest struct {
	// The cursor for fetching the next page, or `null` to fetch the first page.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The cursor for fetching the next page, or `null` to fetch the first page.
	NextCursor *string `json:"-" url:"next_cursor,omitempty"`
	// Provider oura/strava etc
	Provider *string `json:"-" url:"provider,omitempty"`
	// Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00
	StartDate string `json:"-" url:"start_date"`
	// Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59
	EndDate *string `json:"-" url:"end_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (v *VitalsWorkoutSwimmingStrokeGroupedRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutSwimmingStrokeGroupedRequest) SetCursor(cursor *string) {
	v.Cursor = cursor
	v.require(vitalsWorkoutSwimmingStrokeGroupedRequestFieldCursor)
}

// SetNextCursor sets the NextCursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutSwimmingStrokeGroupedRequest) SetNextCursor(nextCursor *string) {
	v.NextCursor = nextCursor
	v.require(vitalsWorkoutSwimmingStrokeGroupedRequestFieldNextCursor)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutSwimmingStrokeGroupedRequest) SetProvider(provider *string) {
	v.Provider = provider
	v.require(vitalsWorkoutSwimmingStrokeGroupedRequestFieldProvider)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutSwimmingStrokeGroupedRequest) SetStartDate(startDate string) {
	v.StartDate = startDate
	v.require(vitalsWorkoutSwimmingStrokeGroupedRequestFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VitalsWorkoutSwimmingStrokeGroupedRequest) SetEndDate(endDate *string) {
	v.EndDate = endDate
	v.require(vitalsWorkoutSwimmingStrokeGroupedRequestFieldEndDate)
}
